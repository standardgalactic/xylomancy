Okay, we want to see who is going to start you.
Okay, we have written some questions for you.
My first question is, we don't see Chuck much online, and I'm very interested in what he's doing now and is he still working on and with Ford?
Yes, of course.
Can you hear me?
Yes.
Yes.
Okay.
I have a wonderful version of Color Force, which I use almost every day.
I'm not doing anything impressive with it, just messing around with computers.
Basically I'm retired.
I spend a lot of time exercising, trying to stay alive.
It's a very pleasant, very pleasant life.
And I certainly don't want to be under any kind of pressure to produce things.
So I'm basically not.
I have a number of applications in Color Force that I enjoy.
They are emphatically not portable.
Forced to me, I agree with Ulrich is a personal language, and I'm doing it my way.
And I would be happy to share ideas.
But no one would be interested in my fourth code.
I think we all interested in everyone's ideas and especially in yours.
I would love to see it.
Sometimes maybe I can show it to you, but I'm not set up to do that. No.
What's the computer are you doing at the moment?
Sorry.
Are you doing it on the GA 144?
Another computer, a special computer maybe.
It's on a PC.
I've got a 4k display.
And it's all tuned to 4k.
Although I have it parameterized, so I could display it on 2k.
It doesn't work very well.
That means it's small screen.
Okay.
55 inch.
Big screen.
Okay, 55 inch 4k display.
It's a PCL television.
It works just fine.
You only do force on it?
So other things.
I browse web and YouTube.
Okay.
That is my fourth display.
It's very nice to meet you.
We have got an old club here.
From 1979 or about.
Okay.
We are rather active still with a few members, maybe 13 members are active.
And more than 100 members are there, but not here normally.
And we're all very happy to use force because it's very flexible.
And it's very basic. You can do very smart things with a few,
just a little bit of code.
It's always been my favorite language.
I'm impressed.
I'm very happy with it.
I'm impressed with how many people are interested.
I gave up long ago.
Trying to promote force.
It's, it's a hard sell.
And I would just rather use it myself.
I can understand that it's really a hard sell.
Beautiful code with it's most people only do a segment of relations.
And that doesn't help.
Beautiful code is right.
It's.
Back in the back in the old days.
I thought that people would write their own programs.
And it forced to be a great vehicle for doing that.
And it would appear that a thousand people.
Out of eight billion.
Are willing to write their own programs.
Yes.
Most of the people like to copy and paste only.
Question for check more.
I really wonder what your most used application does.
The application I use.
The application you mostly use.
It's a clock.
I have a, I have a screen full of numbers.
I have a date and time.
Julian day.
Moonrise.
Moonset.
A number of days till things like they like savings time.
All of the.
Time questions that I asked myself.
Have got the answers.
That sounds nice.
Thank you.
One thing I have done.
Recently.
Is a new character set.
You may be aware that I've done many, many different character sets.
This one is the prettiest.
And the simplest.
And it has a unique property.
And normally what I have been doing.
With me, I would generate.
A character.
As a raster.
Library.
I would have what 48.
Symbols representing the characters.
Stored.
In rain Ram.
It finally occurred to me that.
Computers are much faster than they need to be.
So instead of storing the characters,
I store the code that generates the characters.
And when I want to display one, I compute it.
Computers are pretty fast to do that.
With those perceptible delay.
And it stays memory.
It adds flexibility. You can edit your characters on the fly.
And you can invest.
A fair amount of work in calculating a character,
because it doesn't matter.
So I've got pretty characters.
Available on demand.
I encourage people to design their own characters.
It's fun.
It's easy.
It gives you another customizable.
Aspect of force.
Yeah.
Very, very nice.
So there's something that is called display post script on,
on, on Mac OS 10, for example, or I don't know whether it's called
like this.
So this is something like display force.
So a force program runs when you display text.
Because it draws the characters.
Yep.
I like that.
I'll show you the characters sometime when I can.
They're very pretty in 4k.
I can draw very large characters.
They're all scalable.
And some curves.
Chuck, this is Don.
You gave a talk, I think it was last fourth day where you were
writing directly to the memory buffer.
That's what this system you're describing as you're writing
directly to the memory buffer.
Oh, yes.
You have to have a kind of speed.
If you go through the windows.
Interface.
It's much too slow.
Hi, Chuck.
This is us.
Hi,
from the interplanetary networking special interest group.
I know you have been for many years interested in a space and
space exploration.
Have you been working at some point about the delay,
delayed and networking and interfacing with force?
What is called DTM
I don't understand.
DTD is a protocol.
That you send by the protocol and capsulate DCP
with the space it's used in the International Space Station and also in Mars rovers.
And I've been looking to different languages to interface with DTM.
We are working with PintoxSurf in this project about interplanetary internet.
And I would like to know if you have been interested at some point in this kind of communication.
I'm indeed interested, but I've done nothing in that direction.
In fact, I haven't even been able to get onto the internet or the tools that Windows provides are opaque to me.
And I've just been forced to deal with things locally.
Thank you.
My name is Bob Flanders. It's a pleasure to meet you, sir.
Yeah, somebody just brought up the original listings.
Nice, nice to meet you. Nice to see you in the group.
Nice to meet you too, Peter. It's been a long time coming.
There's kind of an interesting little story about what's on the screen on 2011 or thereabouts.
I got in touch with Chuck to ask if he had any old code for the IBM 1130, which was the first computer he wrote fourth of fully working forth on this.
I understand it. In fact, the name of, of fourth would have been fo uRTH had it not been for the 1130s limited file system, which only allows five characters.
So it had to be named foRTH to be a file on the 1130, just kind of fun and has led to the idea of it being something that we go forth.
So anyway, in 2011, I sent a message to him asking if he had any old code for the, for the 1130 and he said, yeah, I'll run it around and, and he'll take a look and see what he has and he found this.
And he sent it to me, but I missed the message or something.
Well, a few years later, I guess it was 2017 or so.
Carl Clanch, who is a fellow IBM 1130 enthusiast, sent me a message that he had spoken with Chuck.
And Chuck had said, I think I send it to the Sky Flanders and but I've he'd since gotten rid of the papers and so I rummaged around in my Gmail and I found it.
And it turns out it's either a free version one or pretty close to version one copy of the code and the basic kernel, the, you know, the assemble level words and then the additional words on top of it.
And I've had a tiny amount of contribution to helping Carl get it working on the on an IBM 1130 emulator.
And Carl actually has a working IBM 1130.
And he's, he's gotten a working there was one critical word that we probably all be completely lost without had it not had that wasn't there in this version which was period.
And I figured out the top of the stack. I think that the top of the stack may have only been shown in the indicator on the on the 1130 for the for the accumulator.
And it was a very interesting, very interesting bit of work to to put it together and get it running. There were there are some typos or some not typos, but some some handwritten notes on the code and notice some things that needed to be a just a little bit
and he's also we made typos, putting it in. And there is, there's actually floating about out there a version one fourth of the IBM 1130.
The way I became interested in fourth personally was I was hired by MCI telecommunications.
In 1986 or thereabouts.
And I had no fourth experience but a friend recommended me. And I came in and the guy said well listen let's let's give you a try. First thing I want you to do is write a word that shows a timestamp.
So I fumbled around and wrote a timestamp then the next thing he said is I want you to implement drivers for a multi port serial card.
And then he said okay you got the job. And I ended up working for eight years using LMI fourth under some DOS extender to implement a system that ran on.
And I think it was nearly 1000 of what were called site controllers, and they were put in, they were co located at the various MCI facilities and talk to digital cross connects and extended extended subframe monitoring units and would send all the
information back to a central computer, which would then use its interface the fourth to do things like, you know, a customer call up say hey I need a circuit from Washington DC to Los Angeles and they would go into the digital
cross connects hook up the hook up the key one get roll running and then, you know, go out and get it delivered to the customer there and points to whatever provisions were necessary.
And it was very cool and interesting system I haven't done much with fourth sense.
But I'm always like, I'm always looking backwards like oh I want to do this I want to work on, like, I'm writing 1130 emulating and things like that so it's always an interest me to do things with older code, not necessarily New York.
But I program and C sharp and for us.
Let's do a lot of SQL stuff on you know it.
Anyway, pleasure to meet sir thank you so much for this is brilliant. It was brilliant that is brilliant and shall continue to be better.
I can, I can add a little bit to the 1130 story.
It isn't as if I was sitting in an office working with the 1130.
The 1130 was on the abandoned production floor of a textile mill.
There's a huge room about 200 feet long 100 feet wide.
And the exact center of it was this 1130 which had been delivered by IBM.
And nobody knew what to do with it, except me.
And so that was the environment in which forth was invented.
It was challenging in many ways.
Yeah.
It was the 1130 if they hadn't been 1130 my high school. This was about 1972, and I started using one.
And I that time I had no understanding of what I was doing, then meant for the 1130 probably would never have gotten into computing.
That started my career.
First mini computer.
Yeah, yeah. I call it my first personal computer.
Hi Chuck.
Hey.
We met a couple of times, and many of us here will remember the August 1980 edition of bites where you introduced the language to a much wider audience.
And that was the time that you felt that the software had been done, and you are now looking towards the hardware. Could you.
Could you tell us a bit about how you made that transition from software to hardware and, and, and you, you move towards the, the Novics.
What was your experience of, of force history.
Yes, I did feel the software had been perfected in the, in the context of fourth.
What I was doing at the time was putting off putting forth on many different computers and interfacing it with many different devices.
And this of course is very easy to do. That's why forth exists.
But the interfacing with many different devices got very frustrating because these devices were badly designed.
The interface I had to go through was bizarre.
People wrote.
And I got kind of tired of doing that.
And I said well I could design a better interface.
I can design a better computer.
Now, people didn't do that at the time.
This was the business of someone else.
I took really a leap of a leap of faith to abandon software for hardware.
I actually didn't because I had to develop the software to design the hardware.
But thereafter my software efforts went in the hardware direction and simulators and layout tools.
It was very rewarding. My, my hardware worked.
And it worked much better than anyone expected, or even would admit.
And I'm still doing that in the sense of the greener rays, multi processor chips.
They're incredibly simple, incredibly effective, and totally unpopular.
So forth hardware is just as unacceptable as for software.
Yep. And that's, that's absolutely fine.
And I think that's why I like forth, like everybody here would imagine other people don't understand.
Hi, it's Howard Oakford here. We've met a couple of times too. I'd just like to say, thank you. You've made my career in programming much more fun than it would ever have been otherwise.
Thank you.
G'day Chuck.
I met you once back in 88 back in the Australian symposium here.
And, but, and I've been using forth since the early 80s, you know, I started the big project with that, and I've been using it ever since.
And yes, you know, a lot of people won't admit that it works so well.
You know, that's true. It was a hardware and software, and it also makes the hardware a lot simpler.
We don't have to use any complicated hardware.
And, you know, that was my original forthboard I did up, you know, with a Rockwell chips, etc.
And then, you know, I ended to a module, you know, a little credit card size module, but this is mid 80s.
And, and that was a paper mid 80s.
And now I use the PT multi core processor with 64 smart pins, etc.
And, and so, and so you do a lot of better control.
But this is, this is a question I really wanted to wanted to ask you, you just mentioned the greener rates.
It's got all these processes on there.
I've got the the propeller parallax propeller processor.
We've got eight cogs, well eight cores.
It has hard ram so it shares everything and every, every one of those cores can access all the IO equally.
But when I look at the greener rays, I can't figure out how I can use it.
You're saying it's an effective processor.
What has it proved to be effective in, you know, really.
How can I use it for general embedded control and smart stuff.
That's a good question.
It has 144 computers.
Exactly cores, they're independent computers.
They communicate with one another.
And the ones around the edge communicate with pins.
So if you want to control a pin.
You have to use the computer, which is attached to it.
And that computer pretty much can't do anything except run that pin and communicate with his neighbors.
So you end up building a little network of computers.
Not 144 but maybe half a dozen that all cooperate and communicate in running the protocol on that pin.
It's a, it's a fun thing to do.
It's totally different than any other computer where you would just run a serial processor.
Your, your whole attention is in coordinating the efforts of as many independent computers as you want.
I don't think I've done an application with more than about a few dozen computers.
So, so Chuck, so in talking about applications, what, what do you, what, if you had to showcase an application, say, look, you know, look how well it does this.
And, and I'm, I'm, I'm bearing in mind to that.
Well, what you said already, there's a bit of work setting it all up for those cores to communicate with one another, or, you know, those little C for years to communicate with one another.
I'm familiar with the whole architecture.
And what would you say, which, you know, you could tell off an application and say, man, you know, this doesn't so well.
Well, one of his applications room fourth to, you can use some of the, some of the computers to drive a display.
You can use some of the computers to read a keyboard.
You can use them together to run forth.
I haven't done that. I've never got around to doing that, although I got close.
We've got each computer has 64 words of realm.
And one of the computers interfaces with a flash memory.
Infinite, infinite amounts of data available.
Another set of three computers can commute with communicate with DRAM.
So what you want to do is set up a system whereby you read code from flash you store the DRAM.
And you read it back from DRAM and do whatever you want to do.
So I'm wondering why you haven't done a PC with it yet. Come on, you know, you can do it.
But the thing is, okay, so I use chips, you know, so that one's got 512k of RAM and plus all the 4k RAM on each CPU, et cetera.
And so it's really easy to make it work. And if, and I've talked to an IO and I can even instruct the IO to do something by itself.
It's a smart IO. It has everything built into it.
I, you know, I keep racking my brains looking at the green arrays.
And I can't think, you know, like, even if I could get it to do something, boy, it'll be a lot of work.
You know, it'll be fun, but it'll be a lot of work to do it.
And you mentioned memory displays. For instance, well, there were a lot of more effective ways of doing displays, but I can do a VGA or even a HD display from the RAM on this one.
But I have to add bolt on all that RAM onto the green arrays.
You know, I'd really love to see a green arrays one that was had less CPUs, had a bit more memory on each one and more access to the IO.
And it was like, that would be really great. You know, you know, 64 CPUs.
We get about 144. Give me 64 and, you know, as you said, you don't need to use many.
We'd love to do that. We've had plans to doing that, but we've never been able to make such a chip.
Right.
We'd have to integrate someone else's memory onto our chip, but that isn't easy to do.
Yeah, well, you know, I appreciate it. I just wanted to ask you that question because it's like, it's the one thing that bugs me.
It's like, these fourth chips are going right from the early days on OVIX and all that, and they're all really great.
And, and, and then, you know, like, I've got 21, I've got the, the, the, and everything like that, but I can't figure out how to use a green array.
So I'd really love to see some application.
I'll even forget about application notes, but just by showcase something to showcase that particular chip power was used really well.
Well, the biggest advantage of the 144 is it doesn't use any energy.
Somebody put a lot of energy in to make it work though. That's the trouble.
Yeah.
Yeah. Well, thanks, Chuck. Yeah. No, appreciate it. Well, very much all your work.
We, you know, when we, we, we love for the other question, can I, I just wanted to ask you nothing to do with technical things, but we often talk about how,
how is it that we can really promote fourth, you know, it's just that mindset, you know, you've, you've had way more experience with encountering their opposition and with people accepting fourth.
And it's like, well, this before I had fourth built into the chip and silicon on this particular P2 chip.
And that was a hard task to get that done at the time.
And, but fourth is a dirty word, you know, people just don't like companies don't like mentioning it.
You see anything that would help break down that barrier.
A killer app.
We've been looking for a killer app for 50 years and haven't found one.
Well, after PC's, you know, I think, I think most of the fourth use, you know, I've always used fourth on micros embedded.
And so it's built into airports and roadways and all kinds of vending machines, anything, you know, and so they're all out there.
People just don't see it, but it keeps going 24 seven and it's also my prototype language that I use.
You probably want to prototype this, you know, people are used to using breadboards or fourth, you can move stuff around like that.
You can fritz all your life with fourth and it's very quick.
So, you know, I have a project now where they are saying, hey, you know, do it with Arduino, you know, see and everything else like this.
And I'm thinking they can ask me, but I'm still doing it my way because you know, I can get it done.
But yeah, but it's just that opposition to it.
And I don't know if there's anything we often talk about it on our group on fourth 2020, how we can get young people interested.
It's not going to be a killer app.
I think it's going to be the easy use.
How they're using it make it's how to make it use fourth, you know, can use fourth easily straight away.
I have a question for Chuck.
Chuck, was the sun force in bios or open force open.
How was the name open OS.
Open boot.
Yes, exactly open boot.
Was this not the fourth killer app because this was installed in so many computers, and also on the one laptop per child I know this was a really big, a really big installation of force.
Yes, that's true but bios is such a obscure application that it didn't attract any, any, any, any attention.
It was a technical triumph.
The attention that open boot attracted was attempts to replace it with conventional software.
That didn't work. Fourth didn't work to because there was not an industry behind it.
That's always been a problem.
We lack large scale support.
Intel came along and killed open firmware open, not open boot open firmware.
And yeah, Intel was responsible for UEFI.
And that killed open firmware.
But fourth really doesn't need corporate support to prosper.
It's an individual thing rather than a collective.
As you did check with your inner race talk on, you did a discussion of that video, how you got the 144 trips to drive the video.
I'm very impressed that you don't have generic video hardware driving the video in your demonstration. You had the green erase chips, each programming, the timing.
And that was significant of how you got the green erase chip to do video that wouldn't be normally required.
You had to produce an output for people to see in applications which don't really need consoles. If you manipulating data, you work the data and you produce the storage of the other output for the for later display for people to see.
And that display was just just a really fantastic ability that the trip array could actually program and the speed.
I think was absolutely significant was the power savings that your trip said that nobody else could do.
It was a lot of fun to program that DGA. And it was, it wasn't easy timing was a big problem. And just fun.
I would say so too.
I think that you've got this hardware, and you interfacing the green erase into that hardware. So there's another incredible example of what the green erase trip set can do.
I don't think anything. It's got it's got the speed.
And this is with a obsolete geometry, 180 nanometers. This is this is abandoned.
Competitive with with the 10 nanometer geometries.
Quite the green erase chip set to be a risk processor where everybody's going to assist processes with multi with multi instructions.
What you can do on a risk processor like the green erase.
It's so much quicker. It may need a little bit of effort to do the stuff that needs to be done. But clearly, the number of instructions to do the work supersedes the performance that any of the standard processes can work with.
And at the cost of power, which was so much cheaper on.
I've got to jump in here a little bit about programming these machines Chuck's machines.
I was one of the first Novix programmers, and one of the early green erase series of processors.
Jeff Fox and I, at the beginning, we're doing our darndest to pack as much code as we could into those 64 words or Ram.
Over years. Now we found that the smaller amount of code the smallest amount that you can put into a node.
We use the least power, because each node is cooperating sending messages between them.
And when it isn't running, it isn't. It's only got leakage power going.
Look at for the earlier speaker about getting into a green erase programming mind mode.
Look at the examples that are on the green erase website.
You'll get a lot of that.
One of the things that I did sort of is a skunk works program with a good friend of mine, Bill Minch who was also an early programmer for the.
I think it was the 24 processor chip was to implement a virtual machine to execute E fourth.
We put bills, Bill was the originator of E fourth and Ting is taking it taken off with it in assembly language we did it all in high level.
And we built a virtual machine using, I think it was three or four of the nodes to execute E fourth op codes eight bit op codes directly.
That has facilitated actually.
It's been moved and Greg Bailey's version of poly forth for things code is now running virtually on the novice on the green erase chip.
And all the development that's happening currently is being done in standard fourth.
You do not need to know the details, just like every other processor.
So, take a look at those application write ups on the green erase website.
For example, if I may 10 words of code forms and ethernet Manchester decoder and receiver converting the weekly signals on the twisted pairs into bits going to the next node.
Wow.
I listened to all this and I think this is there to stuff you guys are doing her credible little chunks right.
And then there's a question.
I could something like forth and take how do we take forth to the next level how do we get it to, you know, push it into the future.
I'll tell you something, you know, I've watched this one guy on YouTube his name is Jeff yearly, and he's trying to deal with taking a video card and getting it to run in a PCI E single lane on some of the new Raspberry Pi compute boards.
If you could do something like build a fourth driven video card with an open interface that could be, you know, could be added to drivers and such to be added to that would have some kind of a standard interface that's like you know we'll work with open GL or I don't know what the current
the modern of the current video standards are.
If you could build something like that, that would then sit in like a PCI E one.
The main PCI E slot is sell a billion of those because they repeat the very, the CM for Raspberry Pi CM forced things are taking are becoming incredibly popular little small on like you know systems with all with a bunch of
lots of them and stuff like that for multiple safety news, and then having a, you know, a PCI E card or something like that sitting in there to show have a video.
It seems like busy building.
Track is busy building a thing called HD fourth from his last this from his last discussion.
And that seems so significant what he's working with on an HDMI interface. I'll be interesting to see further development that he's working on on his HD fourth.
HD fourth has evolved into what I call you HD fourth, you even better for the 4k display.
Wow.
It's running on a PC.
It's unique characteristic is that a lot of the code is an assembler. Well, is in machine language.
And there's no assembler.
There are hex op codes for the x86 instructions.
I had to memorize those up codes.
But it was as easy to memorize the up codes as it was to memorize the assembly code.
And it gives you beautiful versatility and efficiency.
Completely unportable.
That's what I use. I call it color fourth, but that's that's versions I'm using now.
And it is the nicest fourth I've ever had, because it gives me the closest interface with the hardware.
On the other hand, in the old days.
You wanted to interface to a chip or board that chip or board was documented.
And you could really download the spec sheet and and work with it.
Nowadays, there's no documentation.
The best I have found is in windows.
Windows is incredibly complex, incredibly obscure, badly designed.
Almost impossible to work with. And I work with it when I must.
But it has turned me off trying to interface with the larger world.
And therefore I've never been able to figure out how to get on the internet.
The world has changed.
And I'm afraid it's changed in such a way as to disadvantage us.
The calls hackers.
You're supposed to sign on to the corporate vision of computers.
And if you don't, or can't do that, you're being left behind.
Perhaps some of you know,
Werner Vinge's
science fiction novels.
He has one cold.
Oh, fire in the sky, something like that.
In which the problem of
buggy enormous software was mentioned.
The spaceships of that era were programmed in some obscure language that nobody could really master.
And it was determined that you should improve rewrite the software.
So that that was simple, clean, bug free.
And entire planets.
Attempted to do so.
They could not reproduce all of the obscure bugs in the existing software so it was not useful on existing spaceships.
And the whole project led to
enormous costs, effort and failure.
That would equate in today's view with trying to reprogram windows, say, or Linux.
In force.
It probably can't be done.
It certainly is not.
It sounds like much fun.
Because you have to reproduce the bugs.
Who wants to reduce banks.
You want to get the bags out.
For instance, what you really need is just an IP stack and internet or Wi-Fi interface.
And once you have those, you're pretty much good to go.
Sorry.
The hard part is the Wi-Fi interface due to proprietary firmware though.
Yes, exactly.
That that's why I went to 144 rather than try to interface with the existing world.
I wanted to try something different, something standalone.
Or could drive a GPU.
I don't know how to do that.
I don't even know how to find out how to do that.
If it could be done.
If it can be done, of course, but whether you can figure out how is a completely different question.
And I've given up on that.
Chuck, here's a challenge.
If you were to develop the 144 to do bit corning, everybody will stop using the GPU processes.
And the sales of the 144 would go through the roof.
You'd be making money over money because the people out there wouldn't realize just how fast these 144s could process the hash tables.
Quite right.
But among other things that takes money to develop such an application.
And we don't have any money.
I have an open question for you, Chuck, if I may, first of all, let me say that I'm feel very honored to speak to you today.
And fourth for me was a fantastic concept since the 80s when I was a student so definitely it's a wonderful experience to speak to you now for the question is related to IOT.
Since fourth is by design very, very efficient in terms of power consumption in terms of processing efficiency. I'm surprised that I you fourth is not more commonly used for all developments based on it is where of course energy consumption and responsiveness and real time aspects
absolutely critical what do you think about this.
It's an absolutely wonderful application area.
And greener raises projects which are trying to address that.
In fact, we use very little energy.
It's an old brainer.
But we haven't found the killer app.
Well, next week I have to go and explain to a professor at University of Wyoming.
Why the fact that we don't run standard high level languages in a pair of streaming glasses is not a killer of our technology.
The reason why people don't use our chips is that we don't have these giant fat libraries of crappy code, which they can glue together which is all they know how to do.
They don't know how to write code. They don't know how to program in the story.
No, that's the first I've got a question for Chuck give I may.
Please go ahead, Ken.
It's a historical question, Chuck.
When you made the transition from software to hardware.
In the very early 1980s, did you prototype any of the early fourth hardware using, I guess, TTL at that time.
Before you before you move to the, the, the gate array of the, of the Novix.
Did you prototype any of that stuff.
Yes, I, I did.
I did build a prototype of a fourth computer in TTL or CMOS chips, which was part of a proof of principle.
I moved to simulating the data array.
As a more helpful design tool in fourth.
Fourth hardware prototype didn't really wasn't really helpful didn't go anywhere. It only helped to convince some other people to support the gate array.
Okay, thanks. That's, that's quite fascinating. So I guess you were on the transition between building prototypes and hardware to simulating them.
By 1981, 82, I guess we had 16 bit PCs and and simulation became a reality. Yeah.
I see Jared. Yeah, that's right.
Yeah. Hello everybody.
Now you're muted. Now you are muted.
So, we just had a couple of words and then your mic went off.
No, no, no, no, no sound.
We can't hear you.
Yeah.
Now comes the mic.
No sound. Can you hear me? Yeah, yeah.
Yes.
That's good.
No, no, no, no, no, no.
Not now.
That's strange. It was just a, again, just a word.
Maybe we'll log off and log back in the zoom.
Like, if you're having problems with the audio, sometimes that fixes it.
Yeah.
You may get a message or reinstall the software like it happened to me.
Reinstall windows.
I want to come back and I put on the chat.
There's something that Chuck will love to see.
I will put this on the chat.
Probably you have seen some of you.
I am watching, I started watching yesterday on Netflix.
The billion dollar code battle of over Google Earth and a German
company called television. It's absolute amazing, a fantastic film.
And this has to do with this killer app we were speaking before.
This is very, this is very interesting to watch.
Thank you.
Okay.
I've got a question for Chuck.
Yeah, I just, I'm just curious about the changes in forth from the sort of the
classic forth from the early 80s through to California and some of your
observations and reasons for the kinds of the sign, the way forth has gone from
the classic forth to the fourth you're using now.
What was some of the reasons that drove some of those design decisions in the
more recent versions that you're using now?
Wow.
Fourth was originally an interpreter.
And I had to learn how to make it into a compiler.
And that was largely a question of confidence.
The model I used was a bell go.
Developed at Stanford.
And I was a graduate student at Stanford.
And there's this team of half a dozen people who wrote a bell go compiler.
And I said, well, if they can do it, I can do it.
And so I wrote standalone forth.
That was the first one.
The criteria was to make it simple because I couldn't do anything complicated.
And I think all of my later developments of forth implementations were to try to
make it simpler.
Originally, forth had a threaded dictionary.
And that hung on for a long time.
Perhaps until UHD forth.
Now I don't have a threaded dictionary.
I have dictionary broken into pieces.
Each piece.
There's the each array.
One array contains the words.
Another array contains parameters.
Another array contains the code address.
This, this, this lets me search.
The name array.
With this hardware instruction.
But really nothing has changed.
I'm amazed that the original
concept structure of forth with this dictionary and stack
has remained for 50 years without significant
alteration.
At the moment, I don't know how to make it any simpler.
And of course, the hardware has changed.
It was originally memory constrained and now it's not.
It's an amount of memory.
Fourth doesn't know how to use infinite amounts of memory.
It's just not necessary.
So I don't know where to go from here.
I have a question which is not about technology only.
I mean, and as Christian said, I mean, you are free mind, right?
What, what is the topic?
I mean, considering the news, considering the way the world is
going at the moment, what is the topic that makes you passionate
about at the moment?
Could be forth, could be AI or could be something not about technology.
AI goes back to my early days at the, what they call them.
The early neural nets.
I, I'm of two minds.
You can see this played out in the full, full self driving cars.
Do you use artificial intelligence or do you use pre-programmed
decision making?
I'm a pre-programmed decision maker.
I don't know who I, that that's the way I do things.
If AI becomes magic, as it has in the case of go and chess,
I'll be disturbed because we can't understand how it does it.
If we get AI in the form of a mobile robot or a main frame in the
cloud, that we don't know how it works.
I don't know that we've accomplished anything.
If you've got the oracles of ancient Greece,
who could answer your questions?
How is that different if an AI is answering your questions?
But I don't know what side to come down on.
I think I will stick with my deterministic clock and perhaps try to
get precision time protocol implemented or something like that.
Chuck, this is Don.
We're working on this FPGA base fourth.
I'm very curious about your comments on the dictionary because we
haven't implemented the outer interpreter in the dictionary quite
yet, the compiler part.
You said that you have three arrays.
You have the CFAs, you have the strings, the word strings,
the name of the words, and then you have the data.
What's the data?
Because the data is usually on the stack, right?
In the case of a constant, it would be the value of the constant.
Oh, okay.
It's a constant array.
Well, it's an array of you can put anything in it you want the address
of a variable, the value of a constant.
I think those are the only two I actually use.
Okay, have a data field.
In the case of a code reference, the data field
merely indicates that it is a code reference.
What's the most efficient implementation of all these things that I've ever had?
I have a second question.
You know I'm in the space business now.
I'm working on space robotics.
The fourth has a very rich history in space.
Your RTX especially.
I know that talking with Dr. Ting in 2010,
the Goddard space laboratory had him do some work
on implementing fourth for one of their missions.
Can you talk a little bit about the history of fourth in space?
I programmed reconnaissance satellite once.
But I had very little to do with it because the NC 4000
was the prototype of the RTX.
And yet I had no contact with it at all. Nobody ever asked me a question.
Nobody ever paid me money to do anything.
The whole space application went on without my participation.
So most of the space stuff was done by fourth Inc.
And Elizabeth Rathers people.
They were kind of the central focus.
John Hayes and Hopkins University.
John Hopkins University crew.
They were good people.
Proves that fourth was a provable language.
Which was an issue at the time.
But I don't know why that is interesting because it's pretty obvious it's correct.
What's very interesting right now that I found being in the space business is
FPGAs are naturally radiation immune.
So they're very much favored in space because the geometry is much larger
than the modern microprocessors.
So a radiation hit is not going to impact an FPG.
And I think this is a huge opportunity for fourth.
If you can imagine 100 robots working out in Pluto assembling something
and you have this low speed data link and you're going to send a C binary blob
up there every time you want to change code.
You know fourth is interactive.
You just make your core words deferred words and you update as necessary using text.
I think it's the same thing applies to only over the year updates that Tesla uses.
I don't know how they do it, but I doubt they use a fourth model.
Okay, we have a queue of people that raise their hands to ask questions.
So Dimitri is next as far as I know.
Yeah, put my hand up after after dawn.
My question for Chuck is, okay, I've got a few finite list.
What would you say are the most important things about fourth that someone learning the language needs to know I'm interested in those who are learning it today.
I myself am quite young I've learned fourth in the past couple years.
I don't know what you what your thoughts on this.
The first thing you have to learn is how to handle the stack of conventional programmers.
Don't think in stack terms.
The transition that takes, oh, maybe a couple years before you really know what to put on the stack, what not to put on the stack, and how to keep the stack clean.
The, the, the processor used in greener rays chips as a circular stack.
So you can put things on it, leave it there, and it will be forgotten in an optimal way. You don't ever have to keep the stack clean.
And that's what I do in UHD fourth also have a circular stack, a little more expensive.
But it's a hard lot, a lot easier.
Beyond that, you've got to learn to factor.
The problem, break it into pieces, give names to each line of code, so that you can combine them into a higher level structure.
That's,
that's not unique to fourth.
That's a term that's a kind of good programmer practice that no one uses.
It's either conventional to use very large subroutines, lots of parameters.
And fourth has very small subroutines with almost no parameters.
You have to make that mental transition.
Thanks to your recommend, leaving on the stack at a time like how many things in the stack should a word consume is there any rough guide on that.
One or two, one or two. Yeah, the, the,
the GA 144 has eight deep stacks.
It doesn't have 16 deep stacks, whatever, but my UHD fourth has eight deep stacks. That's all you need.
On the FPGA process I'm working on with Don, yeah, we've implemented a circular stacks and I think, I think it's 32 at the moment, but I thought 16 might be a reasonable depth for, for fourth programming so that's reassuring to know.
I guess others have their hand up I asked my next question, which is, what was it like working with fourth compared to a Fortran or our goal.
What was it about Fortran or our goal that made you think my, I need to develop the language fourth.
Interactivity.
As others have said, in Fortran, you have to recompile the entire application.
I worked in Fortran. In fact, an early version of fourth was coded in Fortran.
And it was a pain to have to recompile the whole thing it took half an hour maybe.
And I wanted something that was easier to, to patch.
Now, there are two flavors of fourth that I've seen.
One is where you have a large body, a large dictionary with many things in it, and different vocabularies.
The other is which you don't know vocabularies, and you recompile apps on top of each other.
That's the way my UHD fourth works. One of the most common apps I use is the editor.
It overlays whatever other app might be active, because clearly it isn't interesting any longer.
And it compiles a new version of a block.
And then I can recompile the recompile that block to make the new app.
So my compile times are zero edit times are trivial.
And the application is tiny.
So I have a lot of tiny apps instead of one huge one.
Wow, so that really, that really is fascinating and I've tried out using blocks I think is implemented in the ESP 32 fourth and I found it very, very handy.
And my final question which follows on from the previous one is, do you think that fourth still has these advantages that you method that you mentioned.
Do you think it still has these advantages over languages today like see Java and Python.
Absolutely. I haven't seen any progress in the conventional language world.
So,
before trend, all these languages are in fixed notation.
They are not interactive.
They are huge.
If nothing has changed in the last 50 years.
What would you say is wrong with infix notation.
It's
it's a perversion of notation and concept and implementation.
In high school.
People have taught infix notation as algebra.
And it is a pain, because it is unnatural.
HP calculators are much more efficient.
That in keystrokes than an infix calculator.
It's just a path that society has taken that.
Think is suboptimal.
Yeah, I would, I would agree with you.
And that concludes my questions by the way yeah I would agree because I had a bug recently at work, which was caused by an infix operator that I got the precedence for it wrong.
It was evaluating it completely incorrectly and I was thinking, if I was using forth this would not happen.
And it's amazing how, how often people run into these things to see problems on Facebook sometimes where someone says, solve this math equation.
And it's because it's confusing these rules are confusing. They're good for mathematics, but they're not actually as intuitive as people think they are the only intuitive because we're taught them.
Yeah, that's it for me. Thank you for answering my questions, Chuck, and I will continue learning.
Yeah, thanks. So next with the right hand is James Norris.
Please go ahead.
We can't hear you, James.
Can you hear me? Yeah, no.
I was wondering about the x86 hand coding that you're doing. Would you consider using a similar or why don't you do it.
A similar is just another layer of software that gets in your way.
What I have is the hex op codes with subscripts.
Which I will put a number on the stack.
And the subscript indicates how many bytes that will take in the object code.
And stringing these numbers together gives you a program.
Now this is totally inappropriate for large programs. This is insane.
But for a one line fourth definition, it's trivial.
Would you be interested? I wrote a fourth base x86 assembler if you ever want to do anything bigger.
My second question is, what about using forth as a, right now they're coming out with rust trying to do this, they figured out that a lot of program languages have problems, like C++ has memory management problems and things like that.
And it causes all these expensive bugs for like Microsoft and stuff and they spend millions of dollars trying to fix bugs in their operating system caused by the programming language.
So I'm trying to come up with rust as a magic solution. What about for fun, you could take for that's really simple. You could put in all that error checking that doesn't have. What do you think about that.
Yes, we certainly could.
Fourth doesn't have to be a standalone language. It can be a module in an operating system.
It just doesn't seem to strike people's fancy.
That was all my questions.
Okay, thank you. So Gerald's next try.
Okay, next try. Can you hear me now. Yeah.
I'm very sorry about the blur before.
So Chuck, I wanted to ask just because you also mentioned before that not a lot has changed in force.
Regarding to the basic structure of having a directory and having a stack.
I really recall having a discussion with you where you mentioned investigating multiple stacks and using locals even did you have. Did you do any further research, or is this just been a short excursion for you.
No, that doesn't lead anywhere useful.
I've done in new HD forth.
I've taken advantage of all the registers that the x86 has.
And you could almost say that you could make a fourth register based instead of stack based.
And I explored that a bit.
And abandoned it.
And why is that the stack is absolutely essential.
You might not use it all the time. You might take advantage of the registers.
If you don't have a stack on which you can pass parameters.
You're crippled.
And why did you give up on having even more stacks.
I don't use floating point arithmetic so there's no, no reason to have a floating point stack.
No, I have never found the use for any other kind of stack.
Okay, thank you.
Right, thanks. So our next question come from Greg.
Yeah.
Hello Chuck.
Pleasure to meet you.
Actually, I was curious about something that was said earlier you mentioned as a, as a general rule.
I would like to limit the number of things on the stack to maybe just two.
And so just as a, as a possible example, if I were to develop a word that is to draw a rectangle, and it, it takes two points, you know, top left, bottom right, let's say, as parameters that would, that would be for arguments on the stack.
I might think, well, maybe I should start thinking about structures so maybe I'll create a structure that's a point object.
And so I could put two points on the stack and, you know, that's only a couple of things placed on the stack but now I have a structure that structure would be, I think in fourth would be typically global, which some people might look a scan set and say it's a global variable.
And I think of it in terms of, well, maybe I could create an object called a rectangle and the rectangle might have methods to set its points and to display itself or whatever I decide make make sense.
And I think fits well with the noun verb, you know, structure that forth, I think encourages, you know, objects, you know, action type of thing, you know, machine on machine off sort of thing.
So I guess as to what your thoughts, you know, would be on how you might structure and your thoughts, some problem like that. And, and, you know, what are your thoughts on structures and objects and that level of abstraction.
You know, in addition to just the basics of what gives you.
That's one way of doing things.
And what I do is I have a word at that sets the cursor takes two parameters and specifies the location on the screen.
And then I have another word called rectangle has the dimensions of the rectangle that I'm going to draw at the cursor.
I can, it into two pieces instead of having one large piece.
And I can use the word at for triangles as well, or for circles.
Now in the case of the triangle.
It's a problem because you've got three points.
You've got a structure for that.
A circle only has one parameter, the radius.
So it's on stack.
So to generalize and say everything should be structures is not right.
And everything should be in a stack is not right either you have to be flexible.
So what are your thoughts on objects, having, you know, a variety.
I created an object and forth.
Called the month.
And this object had starting point in the year and the number of days or something like that.
This was back back very early.
And the least object I've ever.
I've never done.
And it was useless. I have much better ways of doing months now.
So I think object or in programming is the mistake.
There are not enough instances.
Of the object to make worth the generalization.
Thank you for your thoughts on that.
Appreciate it.
That's why they call it oops.
Nice.
Okay, Francis, please ask your questions.
Hi Chuck.
Can you hear me?
Yes.
Okay.
Thank you.
It's an honor to speak with you.
Following following for a while.
And I just wanted to thank you for this gift to us.
I was wondering if you could speak a little bit about the motivations for the
circuit simulation software you wrote its performance and its current status.
Say again.
So I was wondering if you could speak a little bit about your motivations for the
circuit simulation software you wrote.
So I think that's one of the things that I've spent most of my time on.
For simulations, it's performance and its current status.
Yeah.
That is my.
That is one of my favorite applications.
It's one of the things that I've spent most time on.
And I think I've done the best job.
Um,
There's two aspects to it.
One is the circuit.
Logic die logic description.
And the other is a layout.
If you are laying out a circuit board.
Or whether you're laying out a chip.
Basically the same problem with different geometries.
And what I have learned to do is in both cases.
I do the layout.
And from the layout.
I derive the circuit.
An array of transistors and interconnects.
Okay.
It's extremely efficient.
Extremely intuitive.
Pretty simple to implement.
But it is.
Wonderfully complete.
Results.
I've done a lot of circuit boards.
But I've done even more chips.
And the chip layout.
Well, conventionally one has a logic description of gates that are
connected and then you, that you derive the.
The layout.
And I do it the other way. The layout is predominant.
And the functional layout is determined.
From it.
Yeah.
This is, this is a strange.
Side effect.
There is no need to do a validation.
Proving that the layout accurately.
Reflects the circuit.
The layout is the circuit.
And is by definition correct.
Amazing.
And it's a lot of fun.
I enjoy working with rectangles and layouts.
Yeah.
Unfortunately.
Again, just like the world doesn't let you interface with.
Chips or boards or GPUs.
The world doesn't let you interface with chips any longer.
You have to give it a.
GDS approved layout.
Which they will validate.
Before they.
Construct a layout.
Which vaguely resembles the one that you worked from.
To frustrating technological development.
I love to have a.
Chip making machine.
Something that will generate a prototype ship.
In a desktop environment.
But the world.
The world prefers to have.
Billion dollar fabs.
Yep.
Yep.
Just to just.
Yeah, I asked that because I was in my daily job.
I do this as a maker and a hobbyist on the side of my daily job.
I do chip design and process development for.
Some of the one of the big semiconductor companies.
And this is a cool interest of mine.
I thought I would ask about that.
Just another question.
What are the most interesting one or two applications you've seen in
forth from others that you didn't see coming.
The applications and forth think does.
And you can go to their website for a list.
But they've done the.
Communication networks.
Device handlers.
I did a.
Hollywood robot ones.
Robot camera.
Cement making plants.
I'd love to see it.
Full self driving car.
And forth.
That's a, that's a heavy thing though.
As soon as you get into applications that.
Risk human lives.
It's a whole new game.
And I've never done one of those.
And just a, just a, just a last question.
In hindsight, has anything sort of done differently with regards to
forth and.
Setting it up developing it all that.
Looking back after all these.
No.
In hindsight.
I don't know that I've done particularly well.
But I don't know that there's anything I would have or could have
done differently.
In back in what 19.
70 or so.
Fourth.
In a sense was competing with.
Microsoft.
Not directly, but conceptually.
If.
If we at four think.
Had developed an operating system.
We could have competed with.
Microsoft.
But we didn't.
We couldn't.
And.
I'm perhaps glad we didn't.
I'm much happier with where we are now than where with Microsoft is now.
Microsoft has to be compatible.
With the exception maybe of windows 11.
With everything they have ever done before.
Yeah.
And that is a horrible burden to bear.
Forth.
As it stands.
Fourth is free to reinvent the wheel.
And I think that is a marvelous concept.
No one should ever be afraid to reinvent the wheel.
And we do it every day.
Thank you.
Thank you.
Yeah, thanks.
And Howard.
Your turn.
And please open the mic.
Hi, Chuck.
I've already had a turn at chatting to you, but one more question.
About ones compliment.
The whole.
It used to be very popular a long time ago.
The IP internet protocol.
Users of ones compliment checksum.
And it has some interesting properties.
I have a feeling that it's a really good way to go.
And I observed that you, you use ones compliment in the, in color fourth.
And I just wanted to hear your opinion.
Do you think that the world went wrong when it moved over to.
Two's compliment.
No, I.
I'm worried about this.
One of the main frames I programmed early on was ones compliment arithmetic.
But.
Who's as much more convenient.
And it doesn't cost anything in hardware.
So who's compliment is definitely the way to go.
Yeah, I can, I can understand that.
That point of view. The thing,
the thing I like about ones compliment is that you've got this extra.
State in the system and normal, normal.
Two's conference, you've got zero and you've got everything else.
And in ones compliment, you've got plus zero and minus zero.
And it strikes me that it's very useful to have this extra.
State that can be used so you can have a value is either zero,
not zero or not set or some such.
And I think this, this whole idea of having three states in a,
in a value rather than two,
it brings it closer to the optimal number of symbols required to transmit
the data, which I believe is E somebody proves a long time ago.
So it's closer to three than two.
Anyway, it's just.
I think it's a good idea.
You talk about having code.
Yeah, yeah.
The introduction on computer file about that two days ago,
but having codes and the transition of following the edges of the,
of the square to get to that.
Okay, thanks for the link.
I'll look into that.
Okay, thanks, Chuck.
Okay.
Right.
So you will raise your hand.
Okay.
Okay, I have a few one thing I'm wondering when I heard you,
you programmed a mainframe that was one's compliment.
What mainframe was that you remember.
That's why I didn't name it.
Was it in a spare Univac?
No, it might have been the.
Don't use this.
Was it when you did that at the regs.
The first super computer, right? I can't come up with the name of it.
Right.
Right.
Right.
Right.
You have to create or maybe one of its.
Input terminal something like that.
Oh, cool.
Second question.
You mentioned compatibility, you know,
and how Microsoft has maintained compatibility.
And then of course you have just mentioned mainframes.
I was thinking.
ZVM, which is the current version of.
ZVM, which is OS MBT, which is.
OS 360 has maintained compatibility across since the 1960s.
When it first started and evidently you can compile the program today.
On CVM.
It's not a Z, ZOS,
rather I'm sorry, ZOS mainframe.
In a run.
I mean, just, you know, it was interesting that you'd mentioned compatibility.
IBM has had to maintain that for all these years.
Compatibility guarantees there won't be any progress.
Yes.
What is the smallest fourth you've, you've run across what's the, you know,
the minimum.
Like, if you could,
I don't know exactly how you quantify it, but like the smallest amount of memory,
smallest amount of experience.
What is, what is that?
What would that be?
The smallest one I've done was called CM fourth.
For the Novics, I think it was.
I think we had.
Micro fourth and mini fourth,
which explored the range of having a small kernel and everything else compiled.
He forced those out, I believe.
I've, I've heard references to these some micro computer.
Fourth, that had very small kernels.
I would say a kernel should not be more than 4k.
If you get it down to 1k, that would be nice.
Okay.
You mentioned in talking, I forget who it was, but you mentioned that the
two parameters stack, but you mentioned the stack that's on the feet.
Is that for like,
as many levels as deep as you go, or is it.
I've never thought he was also small.
I would think in terms of the circular stack with eight elements.
So that you could put as many things on the stack as you want, but you only have access to eight of them.
For the nice circuit.
Tracing algorithms.
I've needed to stack thousands deep.
Because as you trace a circuit, you're recursing and recursing and recursing.
And that's a whole different concept that I would have a software stack for.
The hardware stack can be very small for is too small.
Eight is small 16 is plenty.
Okay, cool.
Two more one is, did you know that the current dot net implementation of languages for do something called I L and I L is a fourth light stack language.
So they actually you compile C into a fourth language.
I don't know if you've done that.
I would say no, because I haven't understood what you said.
Okay, well, us that net is the kind of like, I'm sorry, Microsoft's answer to Java C sharp is Microsoft's answer to Java.
And that's become very popular. It's actually very nice language. If you're writing that kind of software.
But when it compiles, it compiles down into something called intermediate language, which is actually a very forth like language.
It's a stack based language.
I thought that was, I thought that was interesting. I didn't know if you'd heard of that.
All infects languages have to compile into a stack.
So yeah,
but if the interesting thing is this.
It doesn't compile.
It doesn't compile to a native, it compiles I L I L gets compiled to native.
An intermediate language.
Yeah, yes.
That is a
that is grossly inefficient.
Why not write intermediate language.
And on last thing is that you, you've talked about assembler and you don't even know the x86 op codes and such like that.
In the 1130 assembler, you wrote an assembler.
I mean, in 1134, you wrote an assembler so you could write 1130 instructions in a fourth like notation.
I mean, there's a right there right at the beginning is very cool.
Not only 1130 all of my, all of my computers have assembly words.
And I now think that that was a waste of time.
It was hard to figure out how to construct the words.
It was hard to remember how they were constructed. It was inefficient to implement the, the X op codes are on any computer are far the simplest way of implementing it.
It was, it was, it's interesting you saying that because it was just like, that was when we were looking at the code. That was one of the most intense parts of the journey.
What are you doing here.
And then like saying, wow, no, we thought we thought really.
So it was fun.
It was, it was a clever.
But it was at least as difficult as it has codes.
Yeah.
Okay, that's it. I'm out of here. I'm, at least I'm going to you.
Thank you for your time.
Okay, thanks Bob.
Our next questions come from Jan Bramkamp or Jen Brankamp, I don't know.
If my microphone is working.
Yes.
So my question is, you've already rented about infix notation and how it doesn't compose.
And what do you think about a prefix notation like list.
I'm sorry, I lost my earpiece.
Sorry, let me repeat that.
You've already given us your opinion on infix notation and how bad it composes.
Your opinion on prefix notation languages like list.
Um,
they made an unfortunate choice.
I believe the human brain works on post fix.
You, you, you accept data.
You store it in your short term stack.
Right on it.
You don't prefix things.
Okay, short answer.
Are you satisfied with it?
Yes, I got my answer.
Okay, thanks, Jan.
The next is Anton Airtel.
Anton, please go ahead.
Oh, maybe your mic volume has been turned down.
So that's what happened to Jared.
So we can't hear you.
My selection answer.
No, no, no.
No, no, no.
No, and now not again. So, yeah, yeah.
Go ahead.
All right. So, um, the question is, um, what is your take on state smart words?
I think you had them in your early fourth systems and then you eliminated them.
And I'm not sure if you have them in the reason systems. I don't think so.
But can you talk a little bit about them?
And yeah.
Yeah, I think maybe that's an area in which forth has made some progress,
or at least my fourth.
And you HD fourth is basically colored force.
And different words have different colors.
The state smart words would have different colors for different states.
For instance, the color white means executed immediately.
The color green means compile.
And those are only only two states that I need.
But I do have to be aware.
In programming.
For instance, a conditional word like if.
Or them.
It means an immediate word and must be in white.
If I have an if in green, it means compile a reference to if for future use.
And that's basically what the state state smart words did.
You didn't have to be aware that they were.
Which state they were in.
But now I must be aware.
To distinguish green from white.
And that is a programming challenge.
Sometimes I get it wrong.
Thank you.
Yep.
Yeah, interesting.
Yeah, don't please.
Thank you.
Thank you.
Thank you.
Chuck again.
How many items or how deep do you think we should build the return
stack in our FPJ fourth.
32 bit fourth.
That doesn't matter.
I would go with eight.
Okay.
I think the return stack.
And the data stack.
Need not be the same length.
But by default, I would make them the same length.
Until experience proved otherwise.
The next thing is that you're talking about.
It doesn't matter.
Okay.
We actually implemented circular stacks.
So that was Dr. Ting.
We shared the code with him.
He said, use circular stacks.
Okay.
So we did that.
Dmitry implemented that.
It costs nothing and hardware.
My next question to you is.
Yep.
Why don't you utilize FPJs?
Because that is your desktop chip making.
And it's going to be in system bar log.
And it's, it's very beautiful code right now.
It's like two pages of code.
To implement.
A fourth processor.
Basic.
Why, why haven't you used FPJ for development?
I don't know.
I don't know.
I don't know.
I don't know.
I don't know.
I don't know.
I don't know.
I don't know.
Why, why haven't you used FPJ for development?
Because they wouldn't let me program them and forth.
There you go.
That's great.
Yeah.
Literally the reason and the only reason I would love to use an
FPGA, but they won't let me.
I have, I'd have to learn someone else's ugly language.
Remember that's only maybe five years that there are open source
tool chains for, for FPGA programming.
Thanks, Chuck.
Okay.
Oh, not you're raising your hand and you're putting it down and
raising it.
Maybe you have a question.
I actually wasn't putting it down, but.
Sorry.
Yeah, I have a question.
I think like fourth is like, you know, perceived as a runtime
language, right?
But it could be like a meta language.
It could be like incredibly like expressive and like, you know,
what are your thoughts about that?
And also, yeah, I can, I can ask the next question.
So what exactly was your question?
Oh, sorry.
So the question is, um, we're thinking about stacks and what
stack to use and like, you know, what kind of stack size to use
because like that's a runtime for it, right?
That's the fourth where it's like, um, you know, we execute a
like a stack based, we have a stack based runtime, right?
And that has like a certain costs in terms of like, you know,
um, like third performance costs.
And it doesn't actually map to architectures like GPUs, for
example, because there is not even like a concept of stacks.
It's just like, I mean, you could have like a memory stack on the
GPUs.
Sure.
But it's got to work on like, you know, uh, I think, I think
I think fourth can be an amazing, uh, like compiler, you know,
like it's, it's, it's, I'm sorry.
Yeah, I can be, I'm super excited.
So I am somewhat in our particulates and can be harsh.
Sorry.
Well, let me, let me try to address that.
Yes.
Thank you.
The stack is nearly a tool that forth uses to express
things compactly.
And certainly forth has applications.
Far beyond.
Stack oriented things.
And yes, fourth would make an excellent compiler.
Fourth would make a good language translator.
Fourth would make a good, um, artificial intelligence effect.
Uh,
and yes, I kind of agree.
Fourth is a metal language.
It lets you define an application language suitable for your
environment.
Yes.
Yes. Thank you. I mean, um, also that's brings to the second
question, which is like, I also think like having the, like,
you know, the hundred forty four chip, uh, the, how, like, in
terms of like the simplicity, uh, that's, that's the way to
actually reach like the energy, uh, like consumption, uh, to the
minimum, right?
Yep.
And, um, yeah, we think there could be other constructs other
than the stack to like, you know, or like it could be like, I
don't know.
Um, I was thinking maybe it could be like a hardware definition
or a language where we define those kinds of constructs for
whatever problem at hand.
So the hardware could morph depending on like what kind of
application is what we redefine the hardware sort of.
You don't like need to be, you don't want to think restricted to
a stack.
You don't have to use a stack for everything.
As I said earlier, you can have, you can have structures which
relieve the depth of the stack.
And, um, but the stack I think is in this, at least the small
stack is absolutely essential for passing parameters.
Yes.
I think I also come to that conclusion because like it's super
simple to pass parameters.
And yet I think like, you know, at some level, it's, it's, it's
all like, it's, it's, it could be even like, you know, that we
implement the whole compiler in assembly and like, like use the,
I, I, sorry, I can, I can, I can grab.
Also, I just want to say like I, I thank you for, for all the
inspiration and like for everything.
I mean, I am, I'm so, so happy that I briefly got to the
introduce you to some of the work that I've been doing.
Okay.
Thank you very much.
I think we follow up on that later.
Dimitri, another one.
Oh, it's a very short question.
It was, it was based on, um, Don's question on the return stack.
And, um, in the, in the chat and Peter Jackie was saying, well,
you know, wouldn't the return stack need to be deeper if you're
going to factor your codes heavily?
Um, so Chuck, how could we have a return stack or say eight steep
and still factor our fourth code?
Oh, no, it's a question, it's a question of complexity.
If you, if you have to deep a call sequence,
this calls that calls that calls that it gets complicated and you
lose track of what's going on.
I rarely have more than two or three levels of nested calls,
which is what the return stack is for.
You see, okay, so it's quite flat to yes, because you can still,
you can still factor your application into lots of short words,
but they're just not words that call one another one another in a
chain.
You'll kind of stay at the same level.
That's right.
The return stack is to hold.
Although that's not the only way of doing it.
So you want to consider how many nested loops you have,
as well as how many nested calls.
Okay, that makes sense to me now. Thank you.
Okay, great.
Thanks so young for another question.
Yes, this time my question is regarding state smart words.
I found them a pain in the posterior to work with.
And wouldn't it be possibly easier to have an always compiling
forth where interactive code is compiled into an anonymous
function and executed afterward just to be immediately
deallocated.
Is there a downside to setting up a fourth system like this that
it's always in compile mode and.
The defining a word would only move the compile location from the
scratch pad to the dictionary.
Yeah, I'm, I'm a little bit out of my depth,
because I don't know how state smart words are done.
Conventionally.
But I do, I do agree there needs to be two distinct behaviors.
One in which you're interpreting and one in which you're compiling.
Why do I need the interpreting state at all.
Couldn't this be solved by compiling into a temporary scratch pad
area.
So I'm going to call it a line of code or two,
then calling this code and we using the scratch pad for the next
interactive input. So always being in compile mode.
Yes, you could do that. I think I did that once upon a time.
What is the downside.
It's no less clumsy. You still have to be aware of what you're doing.
It's just a different way.
What say there's three ways of doing it. One, you can have a state flag.
To you can have different colors.
Or three, you could have this.
Compile scratch and execute.
There's three ways of doing the same thing.
I think the color way is, is latest.
So what I went into this G fourth or Mac crisps still errors.
Yes, there's a state verbal.
And some words respond to it. And as soon as you want to do heavy
meta programming, and you need one of those state smart.
What's in another state smart word, they don't nest.
That's right.
And.
If you're scratching your head and some for systems work around it by
providing non state smart versions and suddenly you have.
Two or three times the number of words.
For those words.
It's got the special treatment.
That's.
That's bad.
Yes.
I would rethink the problem.
Which is why I asked.
I have a state smart.
State, state smart question for Chuck. So, you know,
what I was thinking is you have a 32 bit wide fourth computer in an
FPGA, but make the inside data bus.
34 bits wide and then use the top four bits for your state.
Or whether it's an immediate word or.
You know, compile, I guess it's compiling an immediate is that the
two, two things you need to figure out.
I, I have done that.
One of the early computers that I.
Had fabricated at 21 bit words.
Or as the memory was only 20 bits.
And that extra bit was used as a flag for various things.
It was not good.
It was, it was as awkward and confusing and difficult as anything else.
Okay.
Maybe I have a follow up question and another one on that.
You once talked about the ice principle.
Interpreter compile execute.
And so if we.
Enroll everything into just compile.
Don't we lose the interpretation capability.
To calculate things up front before we compile.
We need interpret compile execute the ice principle.
Um,
you're exactly right. We do need the ability to calculate things.
And that's why in color fourth,
compiling green words,
I can interpret interpolate white words to do the calculation.
So, so we, we don't want to lose this or maybe on this also answers a little bit of that.
We don't want to lose the capability to do execution while we compile and calculate things and generate code or whatever.
I didn't propose to eliminate immediate words.
Anyway,
my second question.
I was talking about the map is not the territory.
And I would like to hear your current opinion on on the statement and how you think about abstraction.
So,
the map, the map is not the territory.
Currently, I prefer to work in the territory.
No, that's not it. That's inaccurate either.
In the case of drawing characters.
You draw the character, or you can describe the character.
And
long time ago, I would draw the characters.
And that became a pain because I would somehow move a pixel the wrong place.
Now I describe the character.
And I've come up with, I think a very compact way of describing characters.
So,
I go back and forth between the map and the territory.
I see.
Yeah, thank you. Thank you very much and thank you very much for influencing my life over the last 40 years.
Sure.
Yeah, maybe without knowing it, but you did the responsibility.
Right.
Next question come from Travis.
And you have to unmute so that we can hear you.
I have a question about HD return stacks.
I found a number of different uses for return stacks, like, for instance, I'll make a word, I have a word that out that a lot space in the dictionary, and then deal lots afterwards.
I'll use the return stack as scratch space for storing the top of the here pointer for an afterwards so I can restore it and return it.
Including if an exception occurs.
I'll catch the exception, restore the step with the dictionary, then rethrow the exception.
So, in my fourth, I have to deal with exception frames, which go on this return stack.
And furthermore, there can be nested exception frames, where one exception is within another.
So, all the pop, and furthermore, the multi tasking uses the return stack.
So to store registers and all that. So, in essence, I need far more than eight cells on the return stack store all the possible states.
Even if my code itself does that go that deep.
So what are your thoughts on this.
I understand you can have a larger, you can have a large multi purpose return stack certainly.
My concern is that it's getting complicated.
And I tend not to like it being complicated.
I would observe that in the case of circular stacks.
When you get an exception.
You don't need to do anything to the stacks, you just leave them where they are and get on your business, because you don't need to keep them clean.
Yeah.
I think the simple solution is to have a small return stack.
But I understand the convenience of having a large return stack.
Thank you.
Okay, we have two other guys that want to ask questions john Hardy please.
And I was just, I mean, it's return stacks, an interesting topic because it is necessary to discuss also the different aspects of fourth, because, because the return stack is so critical to the virtual machine.
I'm interested in the changes that happened in colorful.
Some of them have to do with your use of tail call optimization.
It's a way of reducing. So, you know, it's optimizing away calls.
So they become jumps, which means that they use less stack space.
So, I can see that would reduce the size of a return stack.
But one thing that seemed to get thrown away from my understanding of classic fourth is that you use.
The tail call optimization is a looping mechanism.
And that you when you do when you in classic fourth when you redefine a word, or when you define a word you don't have access to that word it's hidden until you're finished defining it.
Whereas in color fourth I believe the word is is visible so that you can call it so you can be called by itself.
So, can you talk a little bit about that change in the language.
And, you know, like, what are your thoughts about the way you're ditching the idea of the original fourth and going forward in this way.
Yeah.
The original way would be my preference that you rarely reference a word within itself.
More likely you want to redefine the word add some functionality to its previous definition.
But that was complicated and awkward.
And the fourth I just threw it away and said okay I'll have to live with the fact that if I want to redefine the name of the word.
I'll have to say word colon word.
Word zero word word zero stuff stuff stuff.
That's awkward, but it doesn't happen very often.
Yeah.
Actually, I found that in my fort that doing it the way that you did it before.
It's simply a matter of linking the word that you're compiling into dictionary after you hit the semi colon at the end.
And it works.
It's really like how it was where you, if you redefine a word you refer to its old meeting from within the new word without any work at all.
Yes, that is, that is exactly right.
Um, but in my current fourth semi colon does not indicate end of word.
It merely indicates return from word return. Yeah.
I have no word that identify the end of the word.
Okay.
John.
Another question or.
No, that's it.
You're done. Thank you very much.
Satisfied.
Okay.
The last question for today comes from James Norris.
I was wondering what the most fun thing you ever worked on was.
Most fun thing.
A fun thing is something that gives you frequent positive feedback.
I have to say my chip layout and simulation.
It took years, five years.
But I was immediately doing good work after one week.
So I got this positive feedback, which continued and continued and continued.
The hard part of that was when you submit a chip for, for fabrication.
And you have to wait three months before you know whether it worked or not.
And what do you do during those three months.
I have to say that was a lot of fun for a lot of years.
This is great.
Asking another question.
The trip simulation is fantastic.
I think one of your very first projects to give a work on was the,
the telescopic pointing and the data analysis you did interactively.
In that on the system with all the other astronomers watching the work output.
Because that is, that is quite significant to use something as large as a radio telescope to capture the data live and to manipulate the data to generate those graphs that I think are to be significant.
Because at the time, there was this, this millimeter radio telescope was being used to discover interstellar molecule molecules.
Wow.
And you would, you would, you would collect data and display it. And if there was a peak where you're expected to peak you discovered a molecule.
And the immediate feedback was very useful for the astronomers.
But they still required that I record the raw data.
So they could take it home and repeat the analysis.
Even though that was completely unnecessary.
Brilliant.
You've done the processing already.
I mean, you probably do it probably not as well because I had good statistics.
Life statistics forget about post statistics.
Well, guys, I see, and we had a fantastic meeting today.
We need to thanks 1000 times to Chuck.
But there are people in the meeting.
I see Rob Jude from Australia.
Do you want to say hello and anything to Chuck, not not questions, but only hi.
Or do you have questions, sorry.
No questions.
Okay, who else I see Ray Gardner also from Australia very late in the night.
Ray.
Ray showed us in the group in the Facebook group, fantastic pictures of his boards with the RTX 2000.
And image vision in Australia for machines for different machines. So he's the, he's a wonderful for their incredible incredible stuff.
I see in the meeting Ashley Faniello wanted to show us the wonderful technician. Do you want to say anything.
Ashley, something to Chuck.
Hello, Chuck. We met once in 2013 at the strange loop conference.
But it's great to see you again. It's always great to hear what you have to say.
Who else. I see that as a foremost cow. He's chatting but he does not like to talk what happens either too much vodka today.
Hello to Chuck. Okay. Okay, I'm here but I'm afraid with my new microphone.
It's, it will be not possible to hear me.
Very good. It's very good. I just want to say hello.
No more. What else.
What else.
And wish everyone to be healthy.
Thank you. Thank you to you to 330 in the morning in Australia.
Indeed, this is a word by word translation of Russian hello be healthy.
Wonderful. Thank you, Ilya. I see also Jonas Carlson. Where are you in the world Jonas. Do you want to say hello to Chuck.
Oh, yeah, one moment. Yes. So yeah, I'm in Bangkok at the moment. And well, at the moment you're all stuck where we are right so it's two years.
So I had time to play with a lot of things and the last thing I played a few months ago was a 6502 fourth.
And I was reading in parallel a lot of things about color for him. And, and I found similarities when I was basically creating a system with an online editor running on a 6502 where each page 256 bite
maybe it was buffer size basically. And, and this fourth was a byte coded for actually is alphabetical byte coded for so I use D for do and I use s for swap and so on and of course the arithmetic operations are plus.
And I remember reading when I was working on this that you actually liked the idea of a byte coded for.
But you never really went to do that. Do you have any comments about that and especially about the code bloat today. We have so big systems and they're compiled to yield hundreds of bytes.
Yeah, so that's my my general question.
If shock is there.
I thought about like coding.
Other people have also.
It's a good strategy.
The closest I've come to it is the, the.
The 144 instruction codes.
They are five bits.
So effectively done by coding on the hardware.
Arm microcontrollers with on the seven M have the B H and T H H instruction which are basically what you're asking for bite code, the jump tables in mass manufactured CPUs, which can be used.
Yeah, but at fourth with a very tiny interpreter.
Yeah, I'm finally building my my so called alphabetical fourth, which is supposedly half readable kind of bite code with letters and symbols.
And I'm writing a very tiny C compiler that compile C to this fourth and I have it kind of working for functional C.
So we have no variables and the yes to the other day I added variables. So, soon I will be able to compile C to fourth and the rationale for this is ESP 32, which I calculated that yes it's a very powerful thing but one line of C code usually ends up being about 80 bytes.
So, Jonas, we are saying bye bye bye bye bye.
We are finishing. Bye bye.
Thank you.
Another, another one here.
Holy Neppu. Holy Neppu. Is this correct?
Holy. Yeah, from time.
Holy. How are you.
Yeah, I want to invite us to join this in.
Actually, I want to say that I have developed the close compiler for different Microsoft MC use.
And the close compiler includes assembler disassembler and compiler and close compiler.
And one special trick is that once the assembler is generated, the disassembler automatically generated.
And the assembly that I designed is based on algebraic assembler.
So, every microcontroller can be seen the same because we use, I use the same, same instruction like register and immediate word.
You can see that the all microcontroller can be seen as a false chip.
Not the really false chip, but actually we, if we say it is for chip and it contains only register and immediate word.
So that way, based on these two words, two characters, I can design the assembler based on these two.
So every microcontroller seems the same.
The assembler has, I can design the assembler in different way.
Fantastic. This is, this is great news. So we, we love to hear from you. And we send all our regards to the fantastic thick Taiwan and all the great members you have.
Also, in, in the name of the team who is here and he wanted to show, to show something but we will do this in the next meeting because we are out of time. Thank you.
Looking forward to hearing more about that later time.
Another friend here is Igor Mats from Estonia. Is this correct the name Igor.
Only to say hello to Chuck and wish, wish him well and etc.
Do you hear me, yes.
Yeah, but the mic is not making noise, but it will do.
Hello Chuck, thank you very much for your creation.
For the first time in my school and it made a big movement in my development as progress. Thank you very much for one more time and be healthy in this time and I wish you money years and a lot of implement your plans.
Thank you Igor.
Karsten, do you want to say hi to Chuck and bye bye. Where are you from Karsten from Germany.
I cannot.
Carson yeah.
Your microphone.
I cannot.
You have to put on the volume, increase the volume, Karsten.
Okay.
Waving wave into the camera next time. So customers from Hamburg actually across the city.
Yeah, thank you very much Karsten for participating next next time we we talk with you.
Also from Germany do you want to say bye bye to check and thanks etc.
I have a microphone who else I am.
You're muted.
Check, I want to say hello from Germany, benefit.
And I was motivated to write my own force, my own tiny force, because everybody should write his own tiny for before using a professional force, I think, and I learned it from you.
And also Thomas Gweppel from Germany, he helped us putting the link in the hackaday so I thank you very much to Thomas, and he's also a great participant here in our meetings.
No sound Thomas.
Hello.
Thank you then, if you have no sound thank you, thank you again.
Who else.
Atle from Norway, do you want to say bye bye and thank you to Charles.
I'm a relative newbie in short, and I just want to say thank you and I find it brilliant.
Thank you.
Anthony for a lot. Do you want to say bye bye and thanks to Chuck.
Yes, I say hello to say hello to Chuck and thank you so much for all the difficult nights I have to work through to find books in my programs for me later.
And still today, two months ago, I started a new project with forth, so it is still very alive for me. Thank you.
Well, who else. George from Brazil, George is an item. Do you want to say.
Oh, hi, I release me.
Yes.
Hello, I'm Georgia night from from Brazil, I'd like to say thank you everyone, especially Peter for organizing the seven to Chuck for discovered, discovered like he says that this incredible language it's amazing.
It's more than a language it's a philosophy.
I don't know what to say to think I don't know I really love this is it's a it's a pleasure to, to, to talk about it for feel with people who likes for feet.
Thanks. Thanks. Thanks, Peter.
Dr. Ting.
Everyone, everyone. It's really, really, really nice to to stay with them today. Thank you for your loving in the language, Georgia, you are a great father. I have also he had Thomas from current Thomas.
Thank you. Thank you. Can you hear me. Thank you, Chuck. Thank you everybody for this very marvelous meeting. And I was using force of being in, I think, 85 to 87 brought my PhD. No, my thesis in physics was a great time.
So, thank you all and have a good time.
See you soon.
Bye bye.
Thank you, Thomas. Pablo, the Argentina Pablo Reda.
Hi, I like to say thank you to Chuck Moore.
I am a color for fun.
I'm learning for reading the color for the source.
And I changed my life with this marvelous language. Thank you.
Thank you, Pablo. Who is somebody else. And then we close, Cecil Bayona. I don't know, Philip.
Yes.
So Chuck, again, many thanks for the inspiration. You gave me during those years when I was a student and still now and and clearly you are a wonderful person. So thank you for everything.
Fantastic.
Thanks again, Chuck, for being here.
I've been following force for many, many, many years.
And in my youth, when I first heard about force, I was so excited.
Somebody who wanted to keep things simple rather than the abortions we had for programming at the time.
So thanks again for your great idea.
And what can I say.
Thank you again.
Well, guys, this was fantastic. I don't know if Chuck agrees to that and we do all these meetings, thinking and thanking everybody in the force community.
All people from SVFIG also who helped us every meeting.
And from all the communities in the world.
How do you have a race, race in hand.
Yeah. Chuck, is there any chance I could get my hands on your clock code.
I'd like to put it in as an app and color forth.
You do have any plans to post it anywhere.
Hey,
I don't have a vehicle for posting things.
Anything about email.
I can send screen captures maybe I'll keep it in mind.
Okay, I'd also like to see the source for your character generator code that interests me.
That I would have would gladly publish.
Again, if I had some way of doing it, I used to have a website.
I was thinking, maybe I should reactivate the website.
But I haven't yet.
Okay, if you come up with any way of transferring it can help in any way let me know and I'll help you gladly.
Okay, I want to thank you all for inviting me. It's been fun.
And it's gratifying to see so many interested fourth people.
I wish you all will in your endeavors.
Thank you.
Thank you.
Thank you very much.
Thank you very much for joining us.
Thank you.
Thank you.
Thank you everybody.
Thank you.
Thank you.
