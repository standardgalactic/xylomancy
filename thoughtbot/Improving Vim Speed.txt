Hello, and welcome to the Weekly Iteration.
Today, we are going to be talking about one of my
favorite topics, which is how to get faster in Vim.
Joe and I are here to drop some knowledge bombs on you.
Take shelter.
So the first thing we're knowing is that if you are
not a Vim user, if you are a beginner, you
don't need to be scared.
Vim has this really intense mythology around it where
people think that learning it is incredibly hard.
Which, to be fair, certain Vim users help to propagate.
True.
There's a little bit of an elite
attitude there, probably, which is like, well, you're not
quite ready for Vim.
The truth is it's not that hard.
It's not that scary.
There's a tool to get started.
This is how I recommend you start.
Go to your terminal, type VimTutor.
It's a 15-minute thing that walks you through the most
basic Vim commands and gets you going.
And honestly, after 15, 20 minutes of that, you are
ready to start editing text.
You can actually start getting stuff done.
Within a couple days, you're going to be basically
productive.
In a few weeks, I think you'll pass your old editor speed.
It's just not that bad.
So don't be afraid.
That's the most important thing to keep in mind.
Right.
And VimTutor is totally accessible and approachable.
It's interactive, so it's not like, oh, I'll read a book on
it, and I'll be super bored while I read it.
And then maybe I can use Vim.
Right.
Like VimTutor, it really is a 15-minute thing, and it
actually has you do the stuff you're learning how to do.
And I agree that it's so easy to get better than your
editor with Vim, because most editors just
don't do anything.
People spend so much time making them look pretty, and
maybe have better syntax.
But the actual editing part of it is just like, you have
arrow keys, and you can insert stuff.
Maybe you have copy-paste, maybe some snippets.
It gets a little more advanced than that, but you just, I
haven't seen anything that comes close.
Like Sublime, no, TextMate, no, you just
are not getting there.
Vim or Emacs are pretty much, you need to get to that level
to have serious efficiency from an editor.
Right.
So once you figure out the basic insert mode, your old
editor is already eclipsed.
So don't be scared.
Get started.
Try it out.
I'll help you if you get stuck.
Let me know.
Beyond that, let's say you're an intermediate.
You've done some of this stuff.
You're getting reasonably proficient with Vim.
How do you get up towards the advanced side and keep
chipping away at that task, getting faster?
Here are a handful of advices.
Nuggets.
Nuggets.
Recommendations.
Number one, stay out of insert mode.
There's a mode called normal mode.
It's called normal mode because you should normally be in
normal mode.
Normal mode is where what you type doesn't happen on the
screen.
It moves the cursor around.
Stay in normal mode.
Like you should think of insert mode as like a place you
go for as minimal time as possible.
It's like a lousy vacation spot.
You want to get in, do what you have to do, and then get out.
Get back to normal mode as quickly as you can.
There are a few settings in Vim you can enable that make
insert mode unbearable.
So you can make it so you're not allowed to backspace over
where you started.
So a lot of people when they're new to Vim think, oh, I
want to delete all these characters.
I will go into insert mode after them and hold backspace.
It's really tempting to do that kind of things when you're
used to a normal editor.
Or like, oh, I'm in insert mode and I want to insert
something somewhere else.
I will use the arrow keys.
So you can disable those.
Basically, taking away all the things you use from insert
mode besides just typing stuff, at least for a while, will
make you way more efficient.
Yeah, and we have a couple other ideas of things to take
away that will help you go in the right direction.
First of which is the arrow keys.
It's very tempting in the beginning to not want to
learn the HDKL movements and to instead move your hand over
to those arrow keys.
Don't do that.
It's very easy to disable those arrow keys and bind them to
no ops instead.
And I recommend you totally do that so that you learn the
HDKL movements.
And why?
Because it keeps you in the home row.
It keeps your fingers right where they should be in the
right spot on the keyboard and not all the way over here, not
wasting this time traversing this distance trying to get
over to the arrow keys.
And all that sounds trivial.
Like if you want to move around, like, oh, I only need to
move my hand like five inches.
Why do I care?
Once you get to the point where you use those keys for all
of your different motion combinations, like deleting text
and denting text combination with different numbers, it's so
much faster to be able to just hit a button than it is to
move and hit a button.
Like you will use those for everything.
We're learning.
And the crazy thing is, once you get off the arrow keys and
start using HDKL, you know what you should do next is stop
using HDKL.
Right.
So HDKL are fine-grained motions.
They move you up one line or character, left and right.
And what you actually want to be doing is moving a little bit
more efficiently than that.
So the next thing I would say is learn, make sure you learn
really well the different movement characters.
W for word moves you forward by words, so much better than
moving by just holding L. I would consider, basically, any
time you hold down a character to be a smell.
Or press it more than once.
Or press it more than once, exactly.
So if I'm moving over, I want to move by at least words by
typing W, or back with B. E moves me through the ends of
words every time.
GE moves me backwards to the ends of words.
You can see that Vim considers a lot of punctuation words,
which is good and bad.
But you'll basically never see me do this.
Hold and scroll, hold and scroll.
Oh, I need to get over here.
Let me just do this huge anti-pattern.
Don't do that.
Instead, use the word things.
You can also use F and T, I think, are two of my favorite
motions.
So if I know I want to change something over on that hash, I
can say F for find and then curly brace.
And it will jump me to that.
So F will take me all the way over there.
If I wanted to change something up until that hash, I could
use the T motion.
T will move me all the way except one space away.
So I could say C, T, open, curly.
You can see it doesn't include that.
If I'd done C, F, open, curly, it includes it.
Really worth knowing.
And one of the really big advantages of that, a lot of
people think that this is just really low-level
optimization and it's obnoxious.
You're just trying to squeeze a few milliseconds.
Instead of holding down L or scrolling over, you
jump over, like, so what?
But one of the great things about the modal editing in FIM
is that anything you can do as a single thing, like go to
this character or change until this character, you can also
repeat and reuse.
And so if you have a few lines that you want to delete up
until the curly brace, you could hold down
delete three times.
But you could also just do the first one, delete until the
curly brace, go down and say, do that again, do that again.
And that starts to have massive consequences at scale.
Maybe holding over to get to one line isn't such a big
deal, but it becomes a point where, OK, if you frequently
do that in a few lines at once and you do that all day
because it's your job, you start saving an hour a day,
just doing stupid typing.
Yeah, I can actually show you a sample of that real quick.
So let's say we want to remove, like, we've stopped using
name here before these splits.
Like, we've moved these methods into a name class, for
example, and we want to move name dot on both of these.
I can do df dot for delete, find, period, and then just
move down to here and do it, hit dot, and do it again.
Repeat that same thing.
Because I've referred to what I want to do in a sort of
abstract way, I can repeat it in different places with that
dot command.
Whereas if I had done xxxxx, delete this thing, and then I
can't just hit dot, I've worked a
two fine-grained a level.
Right, and so not only did you make it faster, but then you
made it to the second time, it cost basically nothing.
Yep, absolutely.
Another thing along those lines is relative number, which
I'm a huge fan of.
So you'll notice as I move my cursor around, my cursor is
always on line zero.
And now zero moves around my cursor.
And the reason I like this is because it makes it easier to
refer to distances or sort of ranges of lines.
So if I wanted to get rid of both these methods, I could,
of course, hold dd, hit dd a bunch of times, but again,
repeated things are a smell.
So what I would do instead is say, OK, I'm on line zero,
seven lines away is the bottom of the other method.
So seven dd, and they're gone.
Or d7j.
Sure, exactly, d7, delete seven down, which actually gives me
one extra line.
Right, and that's where hjk all get really powerful, like
pressing them repeatedly inefficient, but combining them
with other motions actually makes them really powerful,
especially with something like relative number.
You can see how many lines you want, and you can say indent
10 lines down, or copy 10 lines down, or delete 10 lines
down, or anything.
Yep, absolutely.
Yeah, I use that a lot now.
I really like a relative number, very recommended.
Also, it's useful for things like, if I wanted to copy a
method from above to below, like for instance, I want to
move first name to where I am, I can say minus 16 to minus
14, copy to here, and then I get that method copied down.
Now, in a big file, you can still do that with absolute
line numbers, but in a big file, that might be line 152 to
line 158, and it's just more typing.
Never more than 16 or 20 characters or lines away.
And we try to keep our files small, but even so, like
relative number, you'll almost always be working with single
digits, and even in a small file, you're almost always
working with double digits.
So it's generally, again, even if you keep 20 line files.
Totally.
Just want to cover a couple more long distance moving
commands, because I think these are really useful to know,
and are better alternatives to holding J and K. One is high,
middle, low, I think of it.
Capital H, capital M, capital L. High, medium, low.
High, middle, low.
Really handy.
I like that for getting roughly where you want to go,
because I realize that most of my time in Vim is editing
existing things that are there.
And so a huge portion of the time is get your cursor to
where it's supposed to be, then perform a small edit.
And so when you can do a big jump, say I want to change
the method that we call an OAuth access token down at the
bottom, if I can get down to there in one line, now I'm
pretty close.
And I can say ff to get to for user, change to open paren,
and I've just gotten there and not a lot of keystrokes, which
is nice.
So high, middle, low, or nice.
Another way I might do that is by searching.
Like that.
That worked out nicely in this case, because there's only
one instance of that.
It's less effective when you have a less unique token.
You sort of develop an instinct for that over time.
Like you learn to scan forward and search to figure out
whether you should use ft, go down, and whatever.
But I think the most important part is actually just the
mindset of moving in an efficient way.
Like seek and destroy.
Right, exactly.
Don't scan and destroy type thing.
So there's a great plug-in that I can recommend that will
help encourage you to use these better motions called hard
mode.
It disables the arrow keys, hjkl, page up, page down, and
things that encourage you to rely on
character-wise navigation.
And I think this is actually a really good idea after you've
gotten past that beginner phase, like what's going on?
You sort of have a rough idea of what's happening, but you
want to be more efficient.
This is worth trying out.
Another thing I recommend to people when they're first
starting, and this is very annoying eventually, but you
can just go into your keyboard settings and disable key
repeat.
Not only can you make it slow, you can just turn it off.
And so if you find yourself holding down or holding k, you
can just disable that.
So you hold k, and it just goes down one line.
And you're like, oh, I better figure something out.
And if you just enable that for a week by the end of the
week, suddenly you know all of the good navigation commands.
I think that's worth doing too.
So that's some good sort of high-level advice and
specific commands.
I do want to recommend a couple plugins before we go,
because I think there are a couple plugins that are really
worth having that can really improve your Vim quality of
life.
One is some type of fuzzy finder.
There are a couple that I like.
I use command t, you use control p.
People have different preferences, but the basic
idea is something that lets you type roughly most of a file
name and get what you want.
Rather than having to type out app models user, I can start
typing user.
I just type us, and then I'm on the right file.
Just shortens how many things you have to type to get where
you want.
And most graphical editors have something like this now.
And so people are probably used to this style of editing.
Unlike most graphical editors, I think, though, there are a
lot of navigation commands built into a lot of these
fuzzy finders.
So in control p, for example, you can open a file, but
also do it in a new tab.
Or open it and do it in a vertical split.
And they're also like, they have a very powerful fuzzy
finding, so you could say, I only want to find directories.
Or I only want to find things that aren't in my getignore.
And lots of neat little options like that that take your
fuzzy finding to the next level and make it clearer.
Yes, exactly.
So that's definitely some sort of fuzzy finder worth
having for sure.
I consider that basically an essential to Vim.
Similarly, Rails Vim, if you're working in Rails apps.
Rails.Vim is a plugin by Tim Pope.
That's you do handy things like move to, I'm in a model, and
I can type colon r, and it knows that it'll take me right
to the schema entry for that model.
I could have it, if you do colon a, it will take you to the
test.
You can do certain splitting, like you split vertically and
go to the model.
And just sort of gives you these intelligent pair-wise
movements between different types of Rails files
worth having for sure.
And then finally, in my essential plugins list is
surround.vim.
This is another one that feels like it should be built in.
We have Curly surrounding this line.
If I wanted to change them, I could of course manually go
between the two, or I could just say change surrounding
Curly braces to Perence.
A really neat thing about that is that it takes a little
while to get intuitive, but it makes a difference between
left and right.
So one of them means include a space around it, and the other
one means don't.
So you can, for example, say like, oh, I have parentheses
with space, but I don't want the space, and actually delete
the extra space.
Or you have, like, tight parentheses, and you want to
change them to Curly braces with a space.
It can do that.
Yep, exactly.
Useful for things like this, like, oh, now our style guide
says we're using double-quoted strings to single-quoted,
change surrounding single-quotes to double-quotes.
It gets very easy.
And also it works very, does some very intelligent stuff
with HTML tags.
And it's kind of the only way I like to work with HTML.
Every time I do it without surround,
Vim, it's miserable.
Right.
It can also add quotes around something, which is cool.
So if you have, like, two words, you can say, like, add
quotes around these two words.
Which is pretty powerful.
Yep, why ask two words with quotes?
It takes motions, which is pretty awesome.
So you can say, you know, surround up until the comma at
the end of this line with a paran, things like that.
Right.
Super useful, one of my favorite things.
So that's it.
Those were some high-level advice, some specific motions,
and a couple of plugins to check out.
Hope that was useful.
I'd love to hear your Vim tips or your experiences learning
the editor on the forum, and we'll talk to you soon.
