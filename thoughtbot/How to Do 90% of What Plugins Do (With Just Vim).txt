Hi. I'm Max. You might remember me from such classics as the General Assembly Web Development
Immersive Program, their SQL boot camp. I'm a tech industry wanderer. I've done a little
bit of everything. I've been programming for countless millennia, around 20 years I think.
I have gone from writing code for Fortune 500s and independent game developers to more recently
education, classroom teaching, project management. I love them. It's not easy to use. I love
them anyway. I wanted to put together this talk because, well here, the goals of this talk are
not to hate on plugins or get people to stop using them. The goals of this talk are to increase
the understanding of them and to offer options. Because if you don't know something's out there,
then how do you know if you should even look into it? I firmly believe that understanding
our tools is one of the most important and overlooked priorities for a lot of technology,
not just development, but life in general. Understanding the thing that you're working with,
it does a lot. I think that especially nowadays with the emphasis on these fast boot camps that
get you into the world in like three months or two weeks, it can be really easy to lose track of
what it is you're actually trying to do and figure out. I think that if you find a balance between
sure, get a plugin going, let it do stuff for you, don't worry about it, and take a little while to
dive in to your tool that you already have, which is Vim, and look around and figure out what's
going on. That's where you really get into powerful programming and incredibly fast and
efficient work, and that's good for everybody. Here's what we're going to go through. Just one
more note before I dive in on how to follow along. This is a terminal screen, which will remain on
screen for hopefully the entire talk. I'm using a little terminal window manager sort of thing called
Tmux. What you're seeing down here, you can just think of this as like a tab list. If this one's
dark, that means I'm on this tab. If this one's dark, that means I'm in the tab where I've configured
my Vim especially. Here's where I have a vanilla Vim. I'm going to be switching back and forth a lot,
and the reason I'll be, I'm going to show how to configure Vim to do the stuff that plugins can do,
what it looks like when you haven't done that, and what it looks like once you have configured it.
I have also built these slides out of a Vim.rc file. I've never presented this way before,
but it seemed kind of cool. If we're lucky, it'll completely fall apart, and you'll get to see me
wing it. Okay. Yes. Good looking out. First, I'm going to be talking about fuzzy file search.
This is a really cool one that requires very little configuration and lets you go really,
really fast. There are several plugins for this like command T, command P, fuzzy find.
They all do pretty similar stuff, but you can get a surprising amount of mileage out of just Vim.
After that, I'll do tag jumping. Tags, if you're not familiar with the concept, is like anything
that's important to your programming language. If you make a class called abstract, then abstract
is a tag. If you use it someplace else, you might want to be able to jump to it really quickly
without having to dive down and figure out exactly what file it's in. There are plugins for this too.
I forget all of their names, but Vim can do it out of the box. Almost. Next, autocomplete,
everyone's favorites. There are plenty of options for autocomplete in Vim. In many of these situations,
I actually have come to use plugins instead. Let's see. For file browsing, even I use a nerd
tree now, and I don't use a lot of plugins, but autocomplete is one of those things where I see
a ton of plugins for. It just surprises me because Vim can do so much just by itself. That'll be a
really fun one. After that, I will do file browsing with Vim's cantankerous, but functional built-in
file browser called NetRW. We'll go into snippets, which will be a pretty quick one. Finally, if we
have some time, I'll talk about build integration, which is when you want to run your tests and get
immediate output or be able to jump between all the errors that happen, Vim can do that too. It's
quite cool. Okay, so before I get started, does anyone have any questions about anything on the
list? Anything super surprising to you? Cool. I always like to check.
So this is, again, in the form of a VMRC file. In practice, you can go to the GitHub repo and
just copy-paste the lines that you're interested in to yours. These are the only global configuration
changes necessary to make this stuff work. No compatible. Just tells Vim to not bother pretending
to be its predecessor, Vi V. I don't know how you're supposed to pronounce the one without the M,
but Vi's super old and by default, Vim tries to act like it because it assumes that you've been
doing this for 50 years and you fear change. Sorry if I just offended anybody. Sorry, not sorry.
So after that, just syntax, enable to allow some nice colors on the screen for us. And finally,
file type plugging on, kind of cheating a little bit. The feature that's built into Vim that uses
for file browsing, technically, it's a plug-in, but it comes with Vim, so I kind of don't think of
it as one. You could probably have a really long debate on that, but I'm not going to do that.
So first, let's talk about finding files.
Now, the interesting thing about this is there is no Vim feature that's called like
fuzzy file finder. It's kind of just this accident of various other features that it has
bumping into each other in just the right ways that you can do all the things that I'm about to do.
And it all starts with this one humble option. If you're not familiar with Vim configuration
syntax or Vim in general, I'm just going to do a really quick like one sentence pitch on it.
Set is a command that changes a built-in configuration variable such as path,
and plus equals means append it to the existing value of path because there's a default.
And two stars means something very important. Now, one of the things I'm going to be doing
occasionally in this talk is jumping to the Vim help system, which is actually one of the most
complex, but really thorough and nicely built help systems that I think exists.
You can read pretty much anything by, you can figure out pretty much anything by reading
through these, and a lot of the stuff that I'm going to show today are things that I found just
by stumbling on them in the documentation. I mean, it's kind of a shame that you have to
read the documentation for fun to figure some of this stuff out, but hey, that's why I'm giving the
talk. So this is a list of directories which will be searched when using any of these commands.
So these are all file-related commands. And down deep in the depths of this documentation,
they actually explain what star-star does, but I'm having trouble remembering where it is,
so I'm just going to tell you what it does. Star-star tells it to, when you look for a file,
search through every subdirectory, and search through every subdirectory of every subdirectory.
And so this is what my folder structure looks like right now.
So this is a project that I have had in the back burner for a while. It's a little
a text-based game, the server side. And I have this deeply nested file here, like tcp.rb.
And I'm going to be running Vim in this folder. There are a lot of tips and tricks and tweaks that
suggest adding something to your configuration so that your current folder follows whichever
file you're looking at. Like, if you're looking at tcp.rb, then Vim's folder gets switched here.
But I never do that because if you leave your Vim's active directory at the root of your project,
then it can do these special recursive searches, such as with the star-star on your path,
and it can reach into all different files and folders that you have. So I'm going to show
you what that looks like. First, if I go to my vanilla Vim instance, and I try to find that
file, say find tcp.rb. Oh, I guess I loaded in the real one, sorry. There we go.
Oh, that's not how you do it anymore. Okay, screw the vanilla one. So you'll have to trust that
that doesn't work if you don't set the path. But I'm going to do a little sanity check and
make sure that the variable looks the way I expect. So we can see here are all the defaults.
Mysteriously, someone added nothing a couple times, but here's the two asterisks that I put in.
Ah, software. So here's the thing. Not only can I find tcp.rb,
can I please just, like, get it to do the thing? There we go. Find tcp.rb. So I just jumped
immediately to that file, even though it was not in my current working directory.
What's great about this as well is if I say find tcp and tab, it will complete that for me.
So once again, that's tcp tab. It found it way down in the folder structure. You can also use
basic pattern recognition like star cp. I think this should work. There you go. So if you want
to make it fuzzy, you just put a star. You can put at the beginning or the end and you're good to
go. So hopefully this is a nice start to sort of the big splash of using Vim without plugins.
This does, I'm not crazy, right? Like this is like most of what a lot of fuzzy finders do, right?
Okay. I think it's really cool that Vim can just do that. It's sort of a shame that it's, I mean,
I don't understand really why that's not default behavior because that's really useful, but who
knows? The other thing I changed was this thing called wild menu. And basically, when you look
for a file and it has several, there's several different things that could match. Like let's say
I just want to look for all the RB files. So I'm going to say find star.rb. Now when I hit tab,
it's actually going to put all of the possible RB files it can find. And I can just sort through
them with shift tab and tab. And I can just pick the one that I want. So you can configure this
wild menu thing a number of different ways. But just by activating it by default, you get that
neat little menu thing here. And that gives you just pretty much like a biggest bang for your
buck, I think, in terms of fuzzy file finding compared to those plugins. One other thing to
consider, if you already have a file open, and that means essentially in Vim, if you've ever
opened the file, you can type this command ls, and it will give you a list of what Vim calls
buffers, which are basically just files it's holding in memory that you may or may not be
currently looking at. So if I open up another file, for example, what's a what's a good file?
I'll open up world.rb. That sounds pretty interesting. So I have these two files open now. And if I
type ls, here they both are. The important thing about this is that if you already have a file
open like this, you can jump to it just by typing colon b space, and typing in a unique subset of
its file name. So I can just say btcp. I don't have to hit tab. I don't have to do anything.
But if you give the b command a what's the what's the programmary term a substring
that is unique to one of the files you have open, it'll just jump to it right away.
And if it's not unique, it'll tell you more than one match.
And in that case, you can just do the tab complete thing, and it will scroll through
suggestions for you. So between find and the buffer command, b is short for buffer,
you can do a whole lot with navigation without really needing any other dependencies.
And that's super cool. Any questions about this one? Yeah?
So the question was, is there a way to ignore certain files or file types?
That's a great question. Off the top of my head, I don't know.
I bet that somewhere in the bowels of the find man page, it might explain. Good question, though.
Any others before I move on? Yeah? And then you?
Is the tab always showing you a cool recursive search? Or is it so that when you tap through that?
I'm not sure what you're asking just yet. To open the file, opening the file is all the
recursive if you get the star star? Yes. So the question was, is the find always recursive?
And the star star is in the actual path variable. So like, I don't have to type it in again ever.
The only time I might type an asterisk is going to be if I want to find
some file that I have open, or some file that I haven't opened yet, based on part of its name.
So like, if I wanted to open up a spec, then I might say star spec. But this asterisk and
these two asterisks are doing very different things. This one is very specific to like this
one search that I'm running right now. I'm saying find any file that ends with spec.
And hitting tab there, that'll scroll through. And this search is always recursive
because of those two asterisks. Yeah. So the path command configures how all the file-based
commands work. There's no way to limit it down to a specific folder? There is. But you'd have to
probably mess with the path variable, or you would have to specifically type it into your search.
So I might say find, let's see, what folder was that in? I might say find lib tella
star.rb. And so now I've explicitly told this search to say only show me things in that folder.
Does that answer your question? Yes. Awesome. And I think there was one more.
Yeah, that partially addressed it, but just to confirm, so the star star means you're only going too deep.
The, like, too many folders deep? Yeah. Yeah. If you do have a ton of folders, then
you might find this flow down. But I think you'd have to, you'd probably have to have quite a few.
Because I've used this on some pretty hairy projects, and it's only the like
20 year olds, 20 million line code base situations where it actually starts to chug.
So it's pretty impressively fast in my experience. Is that what you were thinking about? Yeah.
Okay. I think I saw some other questions possibly, but I do want to keep moving along.
If we have time at the end, I'll be happy to cover some more, though.
Okay. Oh, that's not where I have my slides.
So next up is tag jumping. This one requires an extra tool called C tags.
So once again, a tag is any interesting word or collection of alpha numerics that you might want
to navigate to or find quickly. If I'm moving through my code base like this, and let's see,
what's a good tag that I defined myself?
Oh, this is all deep stuff that has no dependency that I made. All right, here we go.
So let's say I'm looking through my code base and I see this thing called exit,
and I want to know what that is. Where is it defined? What does it do? What's the source code?
If you are unable to jump and navigate by tags, then there isn't really an easy way of doing this,
besides like changing over to your terminal and grepping for it or using some kind of IDE feature.
The tool that I'm going to be using is called C tags. It, I think, exists by default on every
modern GNU Linux system. You have to brew install it or find it some other way on OSX.
If anyone is unfamiliar with brew or home brew, just let me know afterwards and I'll help you get
set up. The exclamation point causes this to run as a shell command. So I'm asking them,
when I type in make tags, just pretend I type this into the console. So for the sake of simplicity,
I'm going to type it into the console myself. So C tags dash capital R, which means recursive.
This is effectively the C tags version of that star star. It just means drill down into all
possible folders and dot. And in classic Unixy style, no news means good news. If I look at LS
now, I have a file that was not there before called tags. And it is a super fugly confusing
list of stuff that it found. But here's what it lets you do. Now that there's a file called tags
in the current directory, Vim is configured to automatically look at that specific file name.
At least I think that's the default. Okay, so this is its list of places to look for tags.
Basically, it wants to be able to track down your source code or any reference that you use
anywhere. But the one that we're interested in now is dot tags, because that's for the current
code base. And what I'm going to do now is hit control right square bracket. And it jumped
immediately. You know, I used to have a thing, well, that's right, I emptied out the RC file.
So now it's not displaying the name of the file at the bottom. That kind of sucks.
Let's cheat. And I think this is how you get the current file name. Yes, I can't believe I got
that in the first try. I'm so happy. I always have to look up what expands does. So now we're
in world.rb. Where were we a second ago? I don't know. Okay, so we didn't jump to a different
file. Not that exciting. But it did automatically bring us to the definition of that tag. And
you I'm sure can trust that it would do that if I, you know, type that on something a different
file. The other interesting thing is, if you have an ambiguous tag, a tag that's defined in more
than one place, them still has your back, you can prepend that command with G. G is like the
weird filler prefix, all the commands that do something slightly different. Have a G in front
of them. It's really weird. But if I say, so if I do a control right bracket, it brings me to
this exact line, you can see my cursor jump. And it's kind of saying, okay, if you want to find
initialize, it's right there. But if I prepend that key press with G, I get a list of every
instance of initialize being defined in my entire code base, which is super cool.
That's a good global thing. Yes. Yeah. And you can configure this to look just at the code base
I'm using now across my entire computer. If you're truly devoted, I haven't stayed up late enough
to do this yet. But you could conceivably configure it to know exactly which version of Ruby you're
using and which bundle you're using and how to look at exactly the docs for the gem that you want.
Man, that'd be cool. Someone please write a plug in for that.
So yeah, in this case, I can just pick one of the numbers and say, oh, this one's in.
They're all in the world. My code base is very boring. There we go. I want to jump to the TCP
server so I can just say seven. Can I just say seven? There we go. Type number. And now I'm at
the initialize method way over in my TCP file. So super cool. Not a lot of configuration required.
Chances are C tags will be a little ornery depending on how your system is set up.
I think that sometime in the distant past, I set some kind of RC file that made it easy to run
and just use that one flag. But hopefully it'll work out of the box for you too. It's a pretty
neat program. And Vim just knows how to read those files. So you can do quite a lot. The only
thing to cover on this is that you can actually jump back through the tags. So if you go on a
if you go on a hunt, if you're drilling down layer by layer and trying to figure out exactly
what's going on. So let me give you an example here. So tell it at RB. If I say, okay, I guess I
want to start with this world file. And then I'm going to go down and I'm learning about the code
base. And you know, I don't know what exit is. So I'm going to go check that out. And then I don't
know what a destination is. So I'm going to see if that was defined anywhere. Okay, it wasn't.
But if you do this, you can actually hit control T. And every time you press it,
it will jump back by one more tag. And it looks like it discarded my first jump, which is unfortunate
at the bottom of tag step. But if you have any experience at all with like big, big code bases
that have like millions of dependencies deep, the control T features are really nice one,
because you can start someplace, drill down and figure out what code is doing the thing that
you want to understand. And then just hammer on control T until you get back to where you started.
Very, very convenient. Okay, any questions about this one? Yeah.
That's a great question. I don't have the top of my head. I bet it does by now. I bet someone's
written some like C tags, CSS plugin, that one actually might be easy to figure out. I think
you can just say C tags list languages. So it's in there somewhere. I bet someone out there has
done it, though. If they haven't, someone probably should. That sounds really convenient.
Any other questions about? What are we on tag jumping? Yeah.
I have a very unscientific method for that, which is I just leave it until I try to jump
to a tag and it goes someplace I didn't expect. And I go back and rebuild the tags, which actually
isn't so bad because it will see tags actually knows how to progressively update a file. And it
will go through and remove non existent tags and add new ones without you having to mess around with
it. So it's actually a surprisingly doable approach. The other way I've seen is to just
bind it to your right command. So every time you save a file, it just updates the tags and then
saves the file. But that I don't know. For some reason, I've just never felt good about that one.
Just my just just my spidey sense tingling. I have no idea if it's actually onto something.
Good question, though. Other questions before we move on?
Cool. All right. Let's see. Where are we in our sequence here? Okay, so let's do
let's do auto complete. And then we can take a break for pizza and hanging out and then we'll
finish out the rest of the night. If that sounds good to everybody. Whoops. I disrupted the
delicate balance of movement commands and scroll control. Pay no attention to the margin behind
the curtain. Okay, so auto complete. This is another one with possibly over 600
scrillion plugins devoted to it. Some of them are very, very cool. The key commands for some of
these things are a little weird, but you can also get a lot of functionality out of it.
So auto complete at this point is already configured. It automatically reads from your tags
file if one exists. And even if it doesn't, it will automatically check out the file that you're in,
and it has some language specific configuration that allows it to follow dependency chains. So
when Vim is looking at a Ruby file, someone actually sat down and wrote code so that it reads
the requires at the top, and it'll try and find those files. So the auto complete functionality
in Vim without any special configuration at all is already pretty nice. And it's extremely configurable
if you decide to start using it that way. Very simplest by default is just control n.
So if I'm typing something here and I want to do something with the contents variable,
I can say at con and hit control n, and it's going to automatically look through. And so here are
all the things that are happening inside this file. If it finds something outside the file,
tell me which file it comes from. This menu, I think this is pretty close to what it looks like
out of the box. You might have to tweak it to make the font a little more legible,
something like that. But this menu is something that you can pretty much just start using right
away. And the only hot key you need to use that is just control n. And to go backwards, you can
use control P. So this one is very convenient. Control P is previous in the list. So
control n and control P to go back. Oh, yeah. Oh, cool. Yeah. Oh, that's really interesting. It
reverses the order. That's neat. I like that. TIL. So there are a couple of other ways to autocomplete
all of the default bindings begin with control x. I have no idea why. But some of them are pretty
cool. You can restrict it to this specific file only by using control x, control n.
So if I say con, control x, control n, now you can see I only have those three options from
this file. And if you look at the help for this, there is a smorgasbord of different ways you can
mess with this stuff. You can complete keywords in the current file, the dictionary, the source,
keywords in the current included files, tags, filings, anything you could possibly want.
I don't remember even half of these. The coolest ones I think are these four, control n, which is
the default. It just sucks in everything according to the complete option, which is very nice and
configurable. And you should totally take a look and tweak it. The other one being control n for
just this file. And two of the other very specific ones are file names, which is a total lifesaver
sometimes. So I can say lib, tele, control x, control f. Now I can just insert the name of the
file from that folder. All I had to do was type the folder. Because remember, I know Vim is in my
project root. So Vim is here. So if I say lib slash tele, then Vim knows it's supposed to look
inside that folder. So this is a very straightforward way of working with files. This has saved me so
much time and command tabbing and copy pasting and how do I get the stupid file name? Because Vim
has its own little file finder right in the insert mode. Very, very cool.
Could you put in an absolute path? I bet, yeah. I don't think I've actually tried that one, but
let's just do a slash and see what happens. There you go. Yeah, so you could do this.
Right, and you can just keep saying control x, control f until you find something. So yeah, wow.
Oh, so there's probably a better way of doing this, but the way that I end up doing it all the
time is lib, control x, control f. And then when I find the one I want, I just hit control x,
control f again. Yeah, I have to imagine there's a better way of doing that, but I've just never
had the like five minutes where I was like, I feel like looking up that particular piece of
information right now. So yeah, that one's awesome. And finally, of course, there's a tag only
completion. So I can start with control capital R and say control x, control right bracket,
which is the same thing that you hit to jump to tags. So that's actually kind of a
mercifully consistent interface. But that'll complete room there, you know, I can say
co and if I say control x, control right bracket, it's only going to complete to connect because
that's the only tag in the entire code base that it found that started with those letters. So
very configurable and handy completion options and VIM. This is another one where there are
so many plugins and I'm just like, I don't, I can't figure out what it does that VIM can't do.
But you know, the price is kind of high, you I had to read a lot of documentation to figure
this stuff out. Hopefully, this is making it a bit easier and accessible for everyone here,
because it's a shame to have missed out on a feature like that. Okay, before we jump into
our mid talk break, does anyone have questions about auto completion or lingering questions
about previous topics? Yeah, it totally depends on how
much Monster Energy drink the node guys have had recently. Yeah, like if someone happens to have
made that work in the past, yeah. I don't do enough node to know off the top of my head,
but like, I bet by now it probably does. Or there's like someone's random GitHub repo where
it'll probably make it work, you know. All right, other questions? Yeah.
You know, I think I think the only way that I know how to do that is to just keep hammering
until you get back to the original escape. Does escape work? No, wait, yes. Okay, escape does work.
Yeah, it did.
Sucks. Wait, can I do can I do control C maybe?
I think if you start, that always gets me every time I, like,
yeah. That's a, oh yeah, so yeah, here's the extra credit bonus for the day. If someone can
find in the docs how to get out of it without exiting insert mode. Yeah, that's surprising
that that's not more widely known. I'm surprised I didn't know that actually. That's a great question.
If you'd enter, it just goes to the next line, I think. Control P and you go back to, like,
yeah. Well, it selects it and then puts an enter in. Can you type in, like, after I find something?
Like, oh, oh, then, actually, that does get you out of it. So if I'm, but like, you can't bail on
it entirely because it'll just leave you with whatever you had. So if I just hit space here,
like, yeah, which is nice when you, you know, want that one. All right, good question. I think
there was one there. Yeah. I don't know off the top of my head. I know that it supports the,
what's that weird term? The bash globbing with the asterisks? That's what that's called, right?
Globbing with the, yeah, okay. I don't know if it does reg Xs though. There is a way to plug
VIMS file find into the Unix find and grep commands, which is beyond the scope of this because I
haven't done it recently, but I don't know if find does it out of the box. Good question, though.
Anyone else? Cool. Let's take a short, I don't know, 15, 20 minute break and then we'll dive back into it.
That's so cool. I'm really, I'm just, I just love that. Look at that. That's awesome.
Okay. So, sorry, we just had to take a minute and find a new toy to play with.
Look how, look how cool that is. That's great. I'm going to do that. I'm going to try to do that
instead of gesturing. I find it much less gratifying than gesturing, but, but it's probably easier for
anyone who watches the video. So, if anyone's curious, that is the command forward slash find
the cursor feature on iterm. I often lose mine. Welcome back, everyone. I hope the pizza is
sitting well for you. I enjoyed mine. Let's dive right back in to file browsing. So, this one's
kind of cheating because technically NetRW, which is the file browser that I'm going to use,
is a plugin, but it comes with VIM by default. So, I'm just going to pretend that I'm not
telling you how to do things that other plugins do with this plugin.
So, the thing is NetRW is, it's effectively built in, right? Like you get it for free. That's kind
of the point. It's not super configurable. It's not super intuitive, but you get it for free,
and that's great. So, these are some, excuse me, these are some options that I have personally
ended up using over time. They're not necessary for using NetRW, except for this one which hides the
horrendous banner that takes up half the screen. Once you have done this, though, you can simply
say edit and provide the name of a folder. So, I'm going to say edit dot, and now I have a file
browser, and I can expand and contract folders. It even has some nifty stuff like different colors
for folders and executable files. You can do all kinds of crazy stuff in here, and I actually
have not explored many of the features of NetRW. You can do things like attach to a remote file
system through SSH. You can mark files the same way you would by like control clicking
and finder, but I'm not going to show you to do either of those things because I have no idea how
to do it. I just know that you can. All I really do is just use it to browse through file hierarchies
visually, and you can open up things in a visual split. You can open things, that's with v. You
can open things in a tab with t. It does all the basic things you would generally expect a file
browser to do. You just don't have to configure it that much or install anything to do it. It's
very, very nice. I'm not even sure if I had other detailed notes on this because it's kind of
straightforward once you know that it's there. Yes, so you can look at the help file NetRW
Browse Maps, and that will show you a list of all the different things that are mapped by default,
which as you can see is kind of a lot. So you can do things like moving around. You can navigate
up a directory. You can hide specific things. You can create directories. It's actually pretty
full featured. This is the one where I have never, ever blamed someone for using a plugin to do this
kind of thing because NetRW is cool. It does a lot of these things, but I have just never really
figured out how you're supposed to remember the commands and how they fit together. So I recommend
playing with this just in case your file navigation needs are simple and you just don't need another
plugin anymore. But be aware that if this is just too ridiculous where it's just like, look at all
the things it does. How do you do them in a sane, efficient way? I don't know. I'll figure it out.
There's value in good documentation, and most of them have it. NetRW doesn't as much. Sorry if
the NetRW documenter ever watches this video. Don't mean to throw any shade. Please write
better documentation. It's my second sorry not sorry of the talk. So this is pretty cool. I'm
not going to spend too much time messing with it because there's just so much else to talk about,
and let's face it, once you've seen a file browser, you've kind of seen all of them,
except that 3D1 from Jurassic Park. That was cool. Any questions about this one?
All right. Thank God. I'm not sure if I that looks like I have the right size. Yeah, cool.
Okay. This next one's also somewhat straightforward. This requires no outside tools whatsoever.
Let's say I want to make an empty HTML document. I'm going to show you how this one works before
I explain why it works. Let's close all this nonsense here.
Now, suppose I'm going to add a template to this file and say
some template equals stabby thing HTML. HTML will end here. Now I want an empty HTML template in here.
What's a developer to do? Standard solutions would be plug-in managers or snippet managers. I might
write it by hand, which I did for about five years until I just couldn't take it anymore.
You could copy paste from something, but so what I do is this. I say comma. Can I do that thing where
it shows the command I'm typing show command? Yes. So you can see what I'm typing down there. I know
it's kind of fast and not super useful, but it's better than nothing. I'm going to say comma HTML,
and on the L it's going to just blast this basic HTML template in there,
and it's actually going to position my cursor in the title fields too. Super convenient. How did I
do this? It is a total mess, but it works really well. Let's look at vissa here, vim command.
So just a moment ago, I was telling you don't necessarily bother with NRW. It's
like really big and complex and hard to figure out. This is also complex, apparently far more
than it needs to be probably, but I actually do recommend figuring this part out and using this
because this is so much easier and straightforward compared to snippet managers once you know what
the hell is going on. And so that's why I'm going to take a moment to explain this as carefully and
kindly as I can, both for you and me, because I wrote this and I'm not exactly proud of it,
but I also kind of am. So let's look at what it does. So this part here is just the basic mapping.
The no remap part is telling vim, don't let any of these commands invoke themselves. So if I use,
if I map something that's like j, using no remap will make sure that it doesn't clobber or
re-invoke the original use of j. It's pretty much just used for paranoia here. I very much
doubt there's ever going to be a built-in feature that is called comma HTML. Comma HTML, comma is
really an arbitrary character that I picked to prefix this weird normal mode command. By the way,
that's what the n at the very beginning of this means. Ooh, single character highlight. That
n stands for normal, because this is a mapping which will apply only in normal mode. But what
this means is when I type comma HTML, some people use backslash. This is often referred to as a
leader character. After this comes the effect of the mapping. And just as a small foundation
explanation, if you haven't written your own mapping before, if you've never seen this kind of thing,
you can change any key in vim to do anything you want. It's wonderful. It's horrible. You never
know if you sit down on someone else's vim what's going to happen when you hit any key. Any key could
do literally anything. Yeah, if that doesn't just fill your heart with a thrill and terror, then don't
use vim. But so what this is doing here is this is saying remap. And map is just the term for
this thing should be connected to this thing. So this series of keystrokes should result in this
being automatically typed. And so what this means is when I type comma HTML, it will be as if I was
sitting at the keyboard myself and typing this long string of nonsense in. And what does this mean?
Well, it is a invocation of the read command. And the read command does thankfully what it sounds
like it just reads from a file into the current vim buffer. And I'm going to really slowly show
that in action because it's important to understand the difference between the read command and how
we usually use vim. So what I'm going to do is go to my vim window here. And let's see. I want to
look at a list of current files. I just want to I just want to read from some file to prove this
works. So let's read from the tags file. And I'm literally just going to say colon read tags.
I'm going to tab complete. I always do this just out of paranoia in case, you know, I'm typoing
something or there's not a file where I expected it to be. When I do this, it's just going to take
the contents of the tag file and blast it into the middle of this file. So read is a very straightforward
but powerful command. It just means take whatever I put on the side of this and yank it into the
file that I'm working with right now. The negative one changes the line by one. So if I didn't have
that, the cursor would move when I enter the snippet. So notice I'm on this line here and when I say
comma HTML, there are no extra lines added except this one at the very bottom, which I think is
actually part of the template for some reason. But that's just a little tiny tweak. And this is the
important part. So in my home directory, I have a vim folder of course. And inside there, I have
this file called dot skeleton dot HTML. And I'm going to use the gf command, which opens a file
under the cursor to jump to that. So this is it. This is the exact contents that I just pulled in
by typing the snippet. So we're looking at three different files now. I have my skeleton HTML file,
which is deep within my dot files. We're looking at the actual vim configuration file. This is what
you would put into your actual vmrc. And we're looking at the file that I have been working with,
where I can now say comma HTML and pull the thing in there. The gibberish at the end,
excuse me, the complex and carefully designed string of characters.
So here's the thing to know about vim mappings. I'm going to do my absolute best to explain
why this works. Because if I can explain it right, and if you can carry it with you,
you can just have superpowers in vim. Because this is so cool. If you can get it to work.
When I put this colon in the mapping, what I'm doing is I'm essentially telling it to change
modes. So this is a normal mode mapping, right? In normal mode, if I hit control n, or sorry,
control f, I'm going to go back and forth. If I hit i, I'm going to enter insert mode.
When I hit colon, I've actually changed modes. I'm no longer in normal mode. I'm in command mode.
And vim keeps really careful track of this. Because the keys have to do something different,
right? In command mode, if I type i, I don't want to enter insert mode, which is what would
happen if I was in normal mode. I want to type an i. So the colon is actually like enter command
mode. That's what that means. And the cr here, this is the special vim specific key code for the
enter key. Also known as return. The cr is short for, I think, carriage return. Which,
believe it or not, is a holdover from typewriters, I'm pretty sure. As well as the QWERTY layout
itself. Ah, technology. It moves so fast sometimes. But so what the cr in this mapping will do is
it literally will type. And in fact, here's, I'm just going to do this. I'm going to remove this
for a moment. And I'm going to reload my vim. So I'm going to run that again. But remember,
what I did here is I took away everything from the end of the HTML file and beyond. So I took away
the cr. So now when I type comma HTML, look what happens. It just leaves it there as if I had typed
it into command mode. So what that means is the cr is the mapping way of doing this. Which is pretty
neat. Once you hit enter in command mode, you're back in normal mode. Which means I can type normal
mode commands into the mapping again. What does 3JWF write bracket A do? Well, let's do it ourselves.
3J, what the hell was the next thing? WF open bracket A. It positions the cursor exactly in
the middle of the title brackets. Just for convenience, you know. So clearly, you don't have to do that
part if you're making your own snippets. This is really the important part here. Being able to
just type in something short and instantly get the contents of a file back into whatever you're
working with. And this is really nice because you can just have an entire folder of snippets. And what
are they? They're plain text files. You can refer to them by name. You could also modify something
like this to figure out what the file name and directory is based on the name. I might even
do that when I get home because I just thought of that now. Why don't I do that yet?
So the interface of a snippet manager, I think, is probably the most important part. Which is why,
again, like, I'm not saying replace your snippet manager with this. But just knowing that this
is out there is probably a nice way to keep in mind all the different things you can do
if the snippet manager that you are using or that you're thinking about using just doesn't do one
thing that you were hoping for. This is a very, right, it's like one line of code. You create
the file separately. You keep track of them however you want. And you essentially can just
have a folder of snippets that are usable whenever. And I think that's pretty rad. Also,
hopefully this was a useful overview of how to do some cool mapping stuff. I have never, I think,
written a mapping correctly on the first try. I think maybe it's like hard coded. Where just
every mapping will fail the first time you write it. I can't figure it out. I always have to do
trial and error. So, like, don't feel bad if this doesn't make sense or if you sit down and try this
and it doesn't work. Because that's, it'd be weird if it worked on the first try for you. That's
what I'm trying to say. These things are, this part, I think, is a real premature optimization
in a sense. But, like, this stuff's cool. If you can figure out the whole colon goes into command
mode, CR sends the command automatically, then you're rolling and you can pretty much automate
whatever you'd like. So, this is a very nice thing to have in your pocket, as you can see. Now,
we can take over the world with much fewer keystrokes. Because that's always super important.
Yes?
Yeah, probably. Yeah. Yeah, so that, if anyone didn't hear that question,
just have done a forward slash search, probably. For some reason, I just like using the word
commands. I don't know. They feel really cool to me. It's like five words. That's awesome.
How can a computer know what a word is? That's great. I don't know. It blows my mind.
Sometimes, usually. Oh, I guess, was, were there any questions about this first? Yeah?
Yeah. A lot of the snippet managers, they do, I guess, there's kind of how it comes out of,
like, say, I type D in Ruby, I type D, yeah. And, you know, it's like, I hit, like, control
key, then gives me a template for a method definition. Yes.
Can you, is this, like, can you leverage this to accomplish that?
So, great question. So, that question was, certain snippet managers, or even just editors,
will set you up to type in an entire method, as soon as you say DEF? And the answer is absolutely
yes. There is actually, I think it's called abbreviations, possibly, is the name of the
feature, where it can pay attention to the stuff you're typing in insert mode. And when it sees
you type a certain pattern, then it can run a command. So, I think that, I think it's like,
it can do exactly that. It's just that it's Vim. So, it doesn't do all that out of the box. You
have to, you know, open up your Vim RC and figure out, you know, exactly what it looks like and
how you want it to work, unless you get lucky and someone else happens to have it in theirs.
I think, actually, in my Vim RC is something like that for Python, where it takes, essentially,
all of the names of the variables that you pass into the initializer and turns them into the,
like, at manager equals manager, at this equals whatever, because I hate typing those things out.
No, because it's just my little janky Vim RC script.
But, you know, I have affection for it as a result. So, good question. Any other questions on
snippets, if you can call these that? Can I do? All right, awesome. Okay, so, this last one is
probably one of the more interesting ones. It's, I think that the build integration plugins today
are very strong, and you should use them instead of this, because the support for this ebbs and
flows, I think, with, like, the time of day recently. But I'm going to show it to you anyway,
because it's really cool, and I am selfishly hoping that someone will sit down and reteach Vim
how to work with this stuff, or actually, in this case, reteach RSpec how to output in a Vim
readable format. It used to be able to do that, and it doesn't anymore, I guess, because
same as all the rest of this stuff, people just kind of forget that Vim does that. So,
what I'm going to do here is a three-step process, because I have this window running
here where I can say bundle exec, RSpec, and when I do that, I'm going to have my documentation
style output in this particular carefully curated series of tests. I have two that are currently
failing, but Vim can't read this. We need to add something that will allow Vim to do that,
and through some careful googling, I stumbled on a blog post from one Philip Bradley, who
has a simple Ruby class called Quick Fix Formatter, which you can pass to RSpec,
and it will change the way that RSpec outputs errors. So, when I run RSpec, I can say format
documentation, which is what gives us the stuff we just saw. I can do the classic progress,
which shows you the dots, which have been scrolled off, I think. Yeah, so you can do the dot approach,
or I can pass it this special Quick Fix Formatter, and the exact way that I plugged this into RSpec
is that I literally just copy pasted it from that guy's blog post into my spechelper.rb. I think the
ethical way of doing this would be to give it its own file and include that, but you know, whatever.
I just wanted to get it done. I don't have time to make things work better. I got work to do.
So, if I do this, it just outputs the errors, and it uses this sort of three-part format where
it's like, here's the file, and here is the line number on which the error happened, and here's
the actual error message itself. This is the classic Vim Quick Fix format, which came from,
I think, the way that the original C compiler allowed output for some of its own error messages.
The thing is, when I do this, if I have it set up this way, I can mess with this weird
secret option. It's not really secret, but I've never seen it used anywhere called Make Perg,
which I am hoping is short for Make Program, and I can do this strangely necessary backslash
escape thing on the spaces. Don't ask me why it needs that on this one option. I have no idea,
but I can essentially just give it the same command that I was just typing into my
command line window. And now, when I run Vim's built-in Make Command, let's do this here.
Let's pretend I'm actually editing some real code, so I can say find TCP. There we go. So,
if I say Make now, I can see the output from that command, but when I get back into Vim,
I have this line here that says one of two, because what Vim did is it read that output
and it detected that there were two lines and that it was in valid quick fix format,
and it figured out that these are the two messages. So, here is that actual text message,
which describes the error, and it will just bring me directly to where it exploded. And I can actually
use the commands CN and CP for next and previous to navigate through all of my test failures.
I can even say CL for a list, and the final command that I always use for this is CC,
which lets you jump to a specific one, kind of useless since we only have two, but I can type
CC2 and it will jump directly to that error. So, this is another one of those things where like
the plugins will do such an awesome job, they'll open up your tests in a separate window and allow
you to view them side by side and all the nice bells and whistles, but if you just want to get
some basic functionality like this, this is all you need. Plug this one weird thing into your R
spec, plug this one weird thing into Vim, and suddenly it can understand your test output,
which is very handy. This kind of thing has absolutely saved me tons of time,
because honestly, I have a short attention span. When I run something like this,
the six months that it takes me to be like, what line is this even the right? Is it that I don't
17? Does that mean there's 17 errors? It's too much for me. I'm lazy, and I have ADHD,
I want to just be able to say next one, show me the next error, jump right to it. This is super
cool, and if this looks like the kind of thing that will help you out, then I certainly hope
this also works when you plug it into your VMRC, as that is never quite a guarantee.
All right, that's all I got for this one. I think that might be, is that our last big,
yeah, okay, so let's do some questions on this if there are any, and then yeah.
It's one of those things where like, if you're lucky, it works out of the box.
If not, it could take you anywhere from one day to one year to stumble on just the right
series of incantations and configuration variables. So for anyone who didn't hear,
the question is recovering file. Oh, man. All right, well, it looks like you got something.
Why?
I'm sorry you had to see that.
It's not even submitting yet. How long does it take to get, get out of here.
It's ridiculous.
They're like, oh, God, that's the Vim Teamux. If your geolocation is a New York City bug,
I've seen stranger bugs. So sorry, before we were so surprisingly redirected there,
the question was refresh my memory. Copy pasting. Yes. So the question was,
copy pasting, how do the question was much more nicely phrased than that.
If it works, if it works out of the box, you can use the plus register. If you're not familiar
with Vim registers, there's more than one clipboard. There's the default register, which if I just say
dd to delete the line, it goes into the default register, also called the double quote register.
If I select a different register using the double quote command, I can say delete this into
register A. And then I can say delete this into register B. And then I can say paste from A,
paste from B, we're having a great time. But there are some very special use registers,
one of which is the plus register. I think that it's the plus and the asterisk register,
which connects to the system clipboard. So I don't know if it works out of the box on mine
right now. Let's see if it does. Yeah, double quote plus double Y. So did that work? Let's see if it
worked. Command V. Yeah, see, so I copied from my Vim into the system clipboard. That's cool.
I'm not going to talk about how much time I may or may not have spent making that work.
Next month, I'll just do an entire hour long talk of how to make your system clipboard work on
various different systems. This is one of those things where it's like it shouldn't be hard.
It really just should not be difficult. But no matter how many times I get fed up and I'm a big
cool software developer, I could figure out how to actually make this work. It's ridiculous.
And then six hours later, I'm just drenched in sweat and I'm miserable. And I'm like, it's so hard.
Yeah. And it's one of those real talk moments where they're like, why doesn't this work? And
you're just like, look, I'm sorry. It shouldn't be this way, but it is. It's software development.
Like, I'm so sorry. But you just cannot copy paste right now. So yeah, I wish I had a one
line or answer for that one. But if someone else stumbles on it, please let me know. Because I would
love to spread that knowledge. All right. Excellent question. Anyone else? Yeah.
Like, like if I did a snippet thing, but it would use environment variables and stuff,
you just fill it in. Yeah, there's got to be a way I couldn't tell you off the top of my head.
I might almost just like run an external bash script and read that in. Because you can do that.
It's just a question of like keeping track of all those moving parts. You know, I think that's
really one of the toughest parts of them is just that it has a lot of subsystems that do a lot of
different things. That's a good question, though. If anyone didn't hear that question was just,
could you do templates with environment variables and filling things in? I'm positive you could,
but I wouldn't know off the top of my head. It probably would look a little bit like the thing
that I did with the HTML. Yeah. So are there any plugins that you use? Yes. I actually am going
to talk about that, but I'm going to leave that for the end. Excellent question. Anyone else?
Cool. All right. So before my closing outro, that's what that's called, right? I just wanted to talk
for a quick second about two very important things. Important thing number one. This is mostly
tangential this talk, but it's really not because everyone who uses Vim should do this all the time.
Use the help system. Use the help system. Use the help system. It's so good. It is so strong.
And incredibly configurable. Not even configurable. Just I'm going to show you what I'm talking about.
If I want to know what the control N key does, either out of curiosity or because I know that
it's related somehow to what I want to do, there are key codes for all the different special characters
that you can use. The most common one is control, and its character code is the upper carrot. Yes.
If I just say help control N, it's going to show me what control N does in normal mode.
So it counts N lines downward. Okay, cool. But what if I want to see what it does in a different
mode? You can do that also. You can say help I underscore, which means show me what the following
command does in insert mode control N. Now find next match for words. So this is the
autocomplete keyword that we used before. What does it do in command mode when I'm typing here in
the command line C underscore control N? So you can look up any command in any mode just by prefixing
it with that mode number, mode letter underscore. The other most useful thing that I know of is
help grep. It does exactly what it says in the tin. It greps or searches through every
help document it can find. So I can just say help grep windows. And it will find every single,
it found 587 matches for windows. And I can use that exact same quick fix list from before CN, CPCL
to just look through every instance of the regular expression windows in the entire manual.
So if you can even think of a vague phrase that might have something to do with what
you're trying to figure out, then you can use help grep to jump there or find any possible
instance of it. If you want to just browse this stuff, just type in colon help and hit enter.
And this is such a nice and friendly man page compared to a lot of what you'll see elsewhere.
It just shows you most of the stuff that I just went over down here. And it will tell you how to
navigate, how to jump through, how to jump back, how to get help on specific things.
It shows you all the mode keys. So just if there's like one thing that you ever just
individually take the time to peruse, let it be the main help screen because it will make you so
much faster all the rest of the time. You won't even have to Google anymore unless you're dealing
with something real hairy. So that's super important thing number one. You don't have questions about
this or just like want to scream out loud. Wow. That's awesome. I do that all the time. Yeah.
I usually read it. It crashed again. The crash gatherer crashed. All right.
We're into the bonus now. So, you know, online viewers will just have to deal. I'm very sorry.
Really? So the question was, what's the best way to view this stuff? I think that one's probably
up to personal preference. I don't mind looking at stuff in a terminal screen. And I really like
being able to do, for example, so I can say, oh, I want to jump to this. And I can use the actual
tag feature control right bracket and jump to help summary. And if I want to help on something else,
and it says, you can see user guide topics in this file. And I can just jump to that file.
If I'm done reading, I can jump back with control. Oh, so now I'm back to the first file where I
started. That's really cool. It's just not as fast to do that on a web browser, just because,
you know, you'll have to find the link to click with the mouse. And I don't know that kind of
stuff adds up for me, or at least it feels like it does. But if it's easier for you to read this
stuff in a browser or I don't know, print it out and highlight it like a book, I kind of want to
do that now. You should do that because the important thing isn't like that you do it exactly
the way I'm doing it, but just like give yourself access to the docs. There's so much good stuff
in there. Reading through the docs is how I found all of this stuff. Some of it I had to really
search for, but some of it I just stumbled on. I was like, wait, it just does this? That's awesome.
What? And if you give yourself as many opportunities as you can manage to have moments like that,
your journey through Vim will really benefit from that because there's an awful lot just
hiding right under the surface to be found, I think. Very good question. Others? Yeah?
X mode. Which one is that? Is that X mode? I forget what in the world X mode is for.
I mean, it's kind of like, oh God.
Lord, give me the strength. It's there to keep you on your toes, I guess. In case you felt like
you'd achieved a state of flow, there's X mode. I can remember a single time
when I did something with X mode, but I cannot remember what in the world it was I did or why.
So I got nothing.
All right. Yeah, so it does something. Not one of my favorite modes, I have to say.
Yeah. I'm not using my default MRC, but I'm pretty sure I've done that finally in my main one.
Okay, other questions? These are fantastic questions, by the way. Cool. All right.
Important thing number two, plugins to use. So I do in fact use plugins.
Let's see if I open my regular MRC. Is it going to be legible here? Let's find out.
That's all right. So my MRC is huge. It's like 10 years old now.
I alternate between, like much of the material in this talk, I alternate between being super proud
and slightly embarrassed by it. The plugins I use, I use Vundal not because I have any
particular attachment to it, but because it was the first thing that I stumbled on and I
haven't had any issues with it. What I will do is I have this sort of section of my MRC where
I give every single plug in its own little fold where I can add multiple plugins that are related
or add some configuration that's plugin specific. But if you look down my list of plugins that I
use, they're all extremely specific. They're all pretty small, with the exception I think maybe
of Nerdtree, which is the file browser that I do use. But this is like Vim Elixir, Vim T-Mux,
Vim Ruby Heardock syntax. That's literally so that I can open up a whatever.rb file and say
HTML equals this and then put HTML in there and it will highlight it correctly. That's
the entire purpose of that plugin. It's really small. I forget if that's a plugin that I wrote.
I have no idea. I don't know. Let's find out, is it? No, thank you Joker 1007.
It's really cool. You can just add other things. If I put Hamel, it'll highlight Hamel. That's so
neat. Really, they're all pretty low here. They're all pretty small here. Obviously, I use all of
Tim Pope's plugins. You may be the first humans of me to lay eyes on that particular line. I'm
kind of proud of that one. I use his surround thing so you can do the change from single
double quotes like that kind of nonsense. Tim Pope makes a lot of really nice small
targeted plugins that make him a little bit more of a joy to use. That's pretty much what I do
for plugins. If I am doing something and I just need a tweak where it's like, okay,
it's not syntax highlighting mustache and handlebars, or I want to be able to
correctly indent CoffeeScript. Sorry, no, that's React files. There's a plugin for that. I try
to keep them pretty small. That's basically how I use plugins. Like I said before, I do use,
where's the big one? There it is. I do use Nerdtree, which I have configured a little bit,
but that's, I think, the only big plugin that I use. I've used a few others over time, but I
don't know. None of them have really stuck. I'm not even super happy with Nerdtree. I mean, it's
awesome. I don't think that I could make a better Nerdtree than Nerdtree, but I'm just very
dependency-averse when it comes to my tool set. One of the reasons that I tried to stay as neutral
as possible for most of this talk is because I know I'm biased towards like, don't use plugins,
but you should. So I don't use many of them, but I use Vim pretty idiosyncratically, even for Vim
users. So don't look at this and feel like you have to make sure that there are no plugins longer
than like 500 lines or something. Like, don't worry about it. If a plugin makes your life easier,
use it for sure. I think, yeah, that was my second other important thing right now.
Let's have anything else here. Yeah, all right. So unless there are questions,
all right, that's all I got. Thank you so much for joining me. This was a pleasure.
Let me go through my little outro here. I have the slides available on GitHub.
I also just for convenience, I put the Ruby quick fix formatter there in case you're interested.
I mostly post kitten pictures and complain about things on Twitter
if that's your kind of thing. I'm also taking on clients and students and
possibly looking for full-time work. So if you know anybody who needs a tutor to learn Ruby
or Vim or Python or web development, if you need someone to do internal training,
or if you're just looking for a dev or PM, get in touch, we can chat. Worst case scenario,
we get to have lunch and hang out, and that's always fun. But that's all I got. Thank you again
so much. Thanks very much.
