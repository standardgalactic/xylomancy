My name is Freya. I have been in the industry professionally for about like nine years at this point, maybe ten years.
I also used to be part of Future Games. I was in the class of 2010.
I've been teaching a Future Games since like after two years after that, I started teaching a Future Games as well.
I did mostly like C-sharp courses and math courses, as well as some guest lectures.
Otherwise, like professionally, I made a plug-in a long time ago for Unity called Shader Forge.
So it was basically a node-based shader editor for Unity, which didn't exist at the time.
There was one that was like outdated, but it wasn't maintained.
And the person who worked on it was hired by Unity, and then they kind of started working on, you know, Shader Graph internally,
which took a very long time, luckily for me, because then I could make Shader Forge.
So I sold Shader Forge on the Asset Store, which made like enough money to be two full-time salaries, pretty much.
So me and another student at Future Games, we started a studio.
So we started an indie game studio called Neat Corporation.
So at Neat Corporation, we kind of started out wanting to make our own like very specific indie game.
But then at GDC, we were sort of, we sort of like bumped into Valve right as they were releasing their HTC Vive headset.
So we got kind of inspired by VR as soon as that kind of happened.
So as that exploded, the whole VR scene, we got to be there like at the very, very beginning when everything started like growing,
which was really cool and also made us realize how like going to GDC and just talking to industry people can lead you down so many paths.
And like just that connection with people is so important.
If you want to like make connections in the industry, start new opportunities and whatnot.
And all it takes is kind of like you have to try to be available for all of these things.
Anyway, that was the story of Necorp, how we sort of started Necorp and started working on the game called Budget Cuts.
So that was our first kind of flagship release title.
One thing that I just need to mention before we get started in terms of like my approach to teaching, like my goal is that I'm here to help you learn.
Right? That's kind of that's kind of it.
So so you usually get a lot of questions along the lines of like, you know, do I have to do this assignment and so forth?
The short answer is yes, because you're going to have Krista do all the grading and all that stuff.
But the long answer is that I personally, I don't care what assignments you do or don't do or anything like that.
My goal is that you should learn the things that you want to learn, right?
And I'm here to help you do that.
But I do I do want to stress that it is important though, like what kind of like what kind of standard you're setting,
not only for yourself in terms of like what goals you have and what you want to learn and how you learn,
but also how that reflects on you in the eyes of your your fellow students, right?
Or even in the eyes of me, right?
If I if people around you notice that you are someone who is like doesn't do any assignments or like show up late for every lecture,
then I think a lot of people like are going to think of you as that person that's always late and doesn't like deliver or whatever.
And you're all going to be in the industry soon, right?
Like if you think about my classmates, pretty much all of them are in the industry now.
So, you know, I will remember people who were kind of like not great.
So like it's important to kind of like be a good person and be like kind of project the image of you that you want others to see once you're in the industry, right?
So I think it's important for like from that, from that point of view to actually do do assignments and whatnot to at least be the person who did the assignments, right?
But then again, personally, I don't care that much.
I just want you to be able to learn the things you want to learn, right?
If you hate math, you don't think it's going to be useful.
Then sure, feel free to not do anything, right?
But I think it would be detrimental for you, especially if you're if you want to do a lot of coding.
What will the assignments look like?
The assignments will be mostly to do some mathematical thing in Unity.
It's not going to be very Unity centric.
Unity is mostly going to be there as our like platform and rendering engine.
So it could be things like I would do the math for the spread of bullets in a shotgun or whatever, like that kind of stuff.
So they're going to be pretty short.
I intend to do like more than like one assignments per day.
So you can have like like three tier assignments, like one easy, one medium, one harder task.
And then you can sort of do however many you want.
I think depending on how Krister wants to grade this, I'm just going to send the like answers to Krister and he's going to work on the grading and stuff.
I usually like having a tiered like assignment thing because it tends to be more flexible and you can sort of do things step by step, which I like.
All right, another very important thing.
Please ask questions.
There are no stupid questions.
I think it's like one of the most detrimental things for you to do is to like you have a question in your head or something I said was unclear.
Please ask that question that you have in your mind.
It's so important because like usually when people like almost every time someone says this might be a stupid question, but they ask a really good question.
So please keep that in mind.
Ask questions.
Don't be afraid to ask questions.
Asking questions doesn't mean that you're stupid.
It means that you're actually smart because you actually want to learn the thing and want to understand the thing that you are observing and trying to pick up, right?
But of course, try to stay on topic like don't go like too far off.
We're going to have a lot of breaks.
So we're probably we can do like, you know, random Q&A stuff during breaks if you want.
Okay.
Oh, obviously sometimes like some people can get very stuck on one thing.
In that case, if like one person gets very stuck on something, then we can probably like talk about that after the lectures to like clarify any anything.
In case it like takes too long to like try to hash that out.
All right.
Any questions so far?
Sorry.
We haven't like started the actual lecture.
I've just been rambling about random stuff.
Will there be any linear algebra?
I believe so.
Yes.
I mean, yes, we're going to talk a lot about vectors, dot products, cross products, all that stuff and matrices too.
All right.
So let's see.
Shuffling around my notes.
Oh, if you want to, we could look over some of the things you're going to see in math papers.
I don't know if you want to like have some tool sets for like being able to parse papers.
I could plan a plan that in probably not for today, but some of the other days because we do have I do have a bunch of like time that I haven't like planned in because usually things take longer than you expect.
Sometimes they're way shorter and so forth.
All right.
So I first want to talk a little bit about like why I think math is cool.
I think math sort of has this bad reputation because I think a lot of in a lot of cases it's taught as kind of just the boring thing you have to do in school that has to do with numbers.
And you have to like, I don't know.
It seems very esoteric and the most common question that students ask is like, when am I ever going to use this in my life?
Right?
Like when do I need the cosine?
You know, like that is extremely common for people to feel like that and when it comes to math.
But I feel like game development is sort of one of the like one of these strongest cases where math is just like extremely useful, like absolutely everywhere in in doing game development.
Not only like in terms of gameplay code, but also like a lot of it is in like rendering and all of that stuff, right?
But I think the the problem with teaching math in general is that I feel like people who teach math are sometimes like excited about math.
But they don't really they kind of presume that other people are already excited about math and then they don't really like show it in an exciting or interesting or visual way.
So then it just becomes this esoteric thing where you have to charge through a bunch of numbers and it's just boring, right?
So I think that's a that's a shame.
I feel like mathematics is incredibly fundamental.
It's like one of the most fundamental fields of study that we have.
Like there like it kind of doesn't matter where you are in space.
Like you could be an alien species somewhere.
You could be like absolutely anywhere.
It doesn't matter.
It doesn't have to be on earth.
Doesn't have to be this society.
You can have other numbers of dimensions, but math is still going to exist, right?
It's going to be called something else.
Numbers are going to be presented in a different way.
People are going to use different symbols, but math in and of itself is going to exist.
Because math is like it's the like the study of quantity.
It's a study of space.
It's study of structure.
It's a study of change.
And it's kind of hard to imagine a universe where any of these things just don't exist.
Like what does it even mean to have a like what does it even mean to have a universe that doesn't have quantity as a concept, right?
And I think that's really cool.
It's kind of this like field of study where you can sort of co-discover things like, you know, the circle constants like pi and tau, e, the golden ratio.
Like all of these things are probably discovered in other societies, presuming they exist, even though we're entirely disconnected from each other.
Just because it's this study of the very fundamentals of kind of structure and change and that type of stuff.
Yeah.
And so for me, I feel like it kind of underpins like physics.
It underpins chemistry, biology.
None of these things would really exist without math working as well as it does and being applied to these fields, right?
It's similar to philosophy.
I feel like philosophy underpins everything in like social sciences.
It underpins morality, ethics, politics.
Philosophy is sort of the groundwork for all of those things.
That's kind of why I also like philosophy.
But I think it's really cool that this is so fundamental and that's why I think math is cool.
They're also like, you of course can't like apply it to absolutely everything because usually people say stuff like math is universal language.
But you know, it's kind of not universally applicable to every situation out there.
Anyway, so that's all well and good, but I'm already I'm already interested in math and you might not be.
So I feel like we should go into the like practicalities of what it actually means to use math in in games and how everything works.
Also, I think people overestimate how much math you need to know to do cool shit.
You can get so far with a few basic principles in some time.
Yes, I keep saying that you don't need to know that much math to do game development.
If you want to like make an engine, you need more.
But if you just want to do gameplay coding or even shader coding, to some extent, you don't need that much math.
So I'm going to go through most of the like the very essentials of game development math, like even things like derivatives or integrals.
They are kind of rare in game development, even though they're very fundamental in teaching math in game dev.
You don't have them very often.
Like mostly if you're doing some very like very math heavy rendering stuff, that's when you start running into especially integrals.
But otherwise, like generally like linear algebra is like most of most of game dev math understanding derivatives and integrals is really useful for anything related to implementing physics.
Yeah, so there's the idea of what a derivative is is really important, but you don't really need to know how to derive equations, right?
So like generally in game dev, unless again, you're coding a game engine, you're going to be using existing physics packages, you're generally going to do things on a per frame basis.
So like the understanding of it is really important, but to actually derive equations isn't that important.
Sometimes you will run into it, but I don't think I think I might have run into it like once or twice throughout my career.
But yeah, understanding it in terms of like, yeah, like you mentioned, like time delta time, that we're going to go through because that's really important.
But in terms of like actually deriving equations, they don't really do that much.
So I feel like there is a concept that is talked about very early on in your math course.
Usually it's referred to as the number line. So you can imagine this like one dimensional space, we can just move along this one line, right?
And in the center, we can put the number zero, right?
And then you can sort of imagine a space where these numbers are kind of put along this whole line, right?
Alright, so we have one, two, three. So all integers are on these little notches.
Alright, cool. So this is the number line.
It's like, I think it was like usually this is mentioned very early on in your math courses, and then it's kind of like forgotten.
But I think it's an extremely useful place to be.
Because it very like beautifully illustrates kind of the continuity of numbers and like where the integers are and so forth, right?
I hope I got these numbers right.
I feel like I'm going to make so many weird mistakes.
So, alright, this is correct, right?
Okay, cool. So we have zero in the center and then one, two, three, four, five.
So we have our positive numbers on this side and negative numbers on this side.
And this continues to positive infinity. This continues to negative infinity, right?
So this is a useful way of thinking about it because you can have numbers that are between the integers, right?
So these whole numbers are integers.
And then between those, you can have decimal numbers, right?
So you have 0.5 here.
So that's halfway between zero and one and so forth, right?
Okay, so now one thing that's very important, whenever you're working with math, especially in Gamedev,
is not to really think about numbers in terms of just being in numbers.
Because numbers is only there to represent something else, right?
So then you can ask like, okay, what is this number?
What is it like? What is it a substitute for, right?
And what is it representing?
So usually if we have a number, let's say we have number two and we can mark it with a dot there.
So what does two mean here?
Well, we could interpret it in many different ways.
Two, it could be a position, right?
Maybe this is the position along this line, in which case this is going to be a coordinate system, right?
Where every number says the position on this one dimension, right?
So we could call this the 1x axis, right?
So this could be interpreted as a position.
We could also interpret it as a vector, right?
It could be an arrow usually going from zero because vectors don't really have your roots of quote, unquote, the arrow.
They only have a single point, right?
So this is a vector.
It just has the value two, right?
And because it's one-dimensional, we can only have vectors that point either to the right or to the left, right?
So we can interpret two as a vector.
We can do another number.
Let's put three here.
And then this is another vector.
We can do another vector for negative one, right?
So this is sort of a one-dimensional interpretation of vectors.
But then we can ask lots of questions about these, right?
We can ask how, let's do another vector actually.
Let's do negative three.
Okay.
So usually when you work with vectors, you work with a lot of concepts in terms of length and direction and that kind of stuff.
And usually you kind of start doing that once you go to two dimensions.
But all of these things exist in one dimension too.
This is not exclusive to two dimensions and above, right?
So if you look at these vectors right here,
what is the length of these vectors?
Well, this one that's pointing to two.
This one has a length of two, right?
This one has a length of three.
But if you go to these, these also have a positive length because the lengths are always positive, right?
This has a length of one.
This one has a length of three as well.
Yeah.
So this is basically just a one-dimensional interpretation of what vector length is, right?
Also, I didn't draw these exactly the same size, but you know what?
That's okay.
You get the idea, I hope.
All right.
So what about our direction?
What is the direction of these vectors?
Well, if you think about direction, in one dimension, usually directions have a length of one.
And so in one dimension, you can only have directions that are either negative one or one.
Sometimes that's usually called a sine.
When you're working in one dimension, usually it's called a sine, sine of x.
So usually this is the one-dimensional direction, right?
Basically, it's only positive one or negative one.
There are some exceptions if x is zero.
Then it kind of depends on the implementation.
In some cases, it's going to throw an error.
In some cases, it's just going to return one and so forth.
But usually it'll either return zero, one, or an error when you pass in a zero.
Anyway, so the sine of these numbers is the direction it's pointing pretty much.
And if you want to get the length of these, actually maybe I should keep the sine of x is basically the direction.
So this is either negative one or one.
Mostly random rambles in the student chat.
No questions yet.
So zero vector has no direction.
Yes, it depends on your implementation and interpretation of what it's used for.
In some cases, it is useful to interpret the sine of x to be one.
Because quite often you use the direction to multiply something to sort of change the direction and the scale it by some value.
And sometimes when the value you're checking the sine of is zero, sometimes you want it to be one.
But generally it depends on the case, right?
But again, purely mathematically, a zero vector doesn't have a direction as far as I'm concerned.
So this is kind of the direction of a one-dimensional vector.
It's usually called sine, again, for one-dimensions.
These are sometimes called scalar values and so forth.
Then again, the length we talked about, like the length of these vectors.
Because the actual values of the vectors, like the value of this one is negative three, right?
But the length of it is three.
So to get the length of a number, you basically just, you get what's called the absolute value.
Which is just a fancy way of saying, if it's negative, make it positive, like that's it.
So the absolute value, usually abs in your math libraries, that's the length.
Sometimes called magnitude, but I feel like I'm the only person in the world that calls abs for scalars magnitude, but I think it's funny.
If sine x can only return one number when it is a float, it does return a float.
We are not talking about two-dimensional vectors yet.
We're only talking about one-dimensional values, which is floats or a scalar or a single value.
So we haven't gone into two-dimensional or three-dimensional vectors yet.
Can you sign a 2D vector?
What if the vector has one negative value and one positive?
So generally, the general case of a sine is that it gets the direction of the vector.
The sine of a two-dimensional vector would be itself a vector, right?
Because it's a two-dimensional direction.
But we're going to get into 2D vectors.
I just want to start out with one-dimensional stuff.
But I think it's kind of neat that you can have a one-dimensional interpretation that is still vector based.
So we're still just on the number line.
We don't have any two-dimensional vectors here.
So then we can ask a lot of questions.
What does it mean to...
Let's say you ask some question like, what is the distance between 1 and 3?
What does that question mean?
Well, generally, a distance would be, we want to get this length here between these two numbers.
So that would be a way to get the distance, right?
So if you want to get the distance between these two numbers,
then generally, you would have the two numbers represented as like,
well, we could represent them as just letters, right?
So in this case, we want to do 3 minus 1.
And then that gives us 2, right?
So then we get the distance between these two numbers.
So usually, doing like subtracting is usually,
it can be interpreted as getting the difference between two values, right?
So if we want to get the distance between these two values,
generally, you do 1 minus the other.
But if you flip the order of these, if you do 1 minus 3, you're going to get negative 2, right?
So in this case, we actually want to,
we want to make sure that we get the length and the magnitude of this, right?
Because if we do 3 minus 1, what that gives us is that we basically take this vector.
This is 3, right?
Because it lines up here.
This is the one-dimensional vector representing the value 3.
And then we want to subtract the vector 1.
And the vector 1 is this vector, right?
And the way to kind of interpret subtraction is that you can sort of take this arrow
and you can subtract it as in you flip the direction of the arrow.
And then you get a new value that stops here, right?
And that's going to be an arrow that goes here.
And this is the value 2, right?
But then again, this is order dependent.
This presumes we have the 3 before the 1.
Otherwise, we're going to get negative 2.
So if you ask the question, what is the distance between these two values?
If you say negative 2, that's going to be a bit of a weird answer.
Depending on the implementation.
There are some cases where you want to get what's called a signed distance.
And again, signed distance is referring to the fact that it can be either negative or positive.
But generally, distance values are always positive.
Same thing with area.
If you want to get the area of some polygon, then the area is considered to also always be positive,
except if you want a signed area.
So a signed area just means that it can be either negative or positive.
So you're probably going to hear a lot about stuff like signed distance fields,
which is a term that has kind of exploded for the past few months.
It's just a fancy way of saying you have a field of distance values that can also be negative.
So if we want to get the actual true distance between these two things as in the positive distance,
we would need to get the magnitude of this.
So that would be the absolute value.
So generally, this is the way to get the distance between two values.
Or more generally, if we want to generalize this,
we can say that the distance between, let's say we have values a and b,
we're still only talking about float values or scalars, one dimensional numbers.
So if we want to get the distance between a and b,
all we need to do is do the absolute value as in the length of the difference between a and b.
So now we have the difference between a and b,
and then we get the length of that, and then we get the distance value.
Okay, everything clear so far.
Also realize I haven't talked about addition.
That might be a good thing.
Addition is probably good to know.
So if we want to do three plus one, let me just erase things.
It's a little messy.
Let's say we want to do three plus one, then in a one dimensional interpretation of vectors,
then this is three, right?
And then we can have another vector.
This is one.
So if you want to do three plus one, one way of interpreting that is that it's kind of like taking the vector
and kind of just adding it on top of the other vector.
So now we have three and then plus one.
And the final vector we get out of this as sort of the result of this equation is this vector going all the way here,
which is the value of four.
So that's kind of like how addition works.
Previously we did subtraction when we wanted to know the difference between these two,
in which case instead of adding this to the top, we negate it and then add it, right?
Or just subtract it, right?
Yeah.
So then doing that, we ended up with a vector adds two, right?
Because three minus one is two.
As far as I know, I'm bad at doing math like I mentioned before.
I might be wrong.
Okay, cool.
Any questions so far?
Sorry for the like weird one dimensional vectors.
But right now we're only talking about scalars.
We haven't gone two dimensional yet.
Yeah, so so far we've learned that three minus one is two.
That's how well this math course is going.
What's the difference between length and magnitude?
Nothing.
It's the same thing.
Three plus one equals four.
That's true.
We did learn that too.
This is Thor.
The void howl now.
Buddy, you don't have to use your claws.
Oh, I missed a question.
Will we go deeper into quaternions later on in this course?
No, we're, I'm going to talk about how to use rotations, but I'm not going to talk about
how quaternions work internally because that's not relevant.
You don't need to know that in order to make games because we're not going to be engine
coders.
We're going to make games, right?
So I'm not going to go into like how to write a quaternion class, but I'm going to talk
about how to use Unity's quaternion class, how to apply rotation, how to think about
rotations, what they are, and so forth.
What's the difference between quaternions and rotors?
Mostly an interpretation difference as far as I know.
So let's see.
There are a few things we haven't talked about yet.
So we've talked about some of the operators you can do.
You can do the sign will get you the quote unquote direction of a one dimensional vector
or a value, which is either just negative one or one.
Abs will get you the magnitude of a vector, which means that if you have a vector or a
value of negative four, abs of that abs of negative four is four, right?
It just makes negative values positive in terms of one dimensional vectors or floating
point values or scalars, right?
It's a little different for two dimensional vectors and we're going to get to that.
And then we have the distance is you get the difference between two values.
It could be like we had before three minus one or yeah, three minus one.
So that will be two.
If it's negative two or whatever, then abs will make sure that it's positive.
And that's the way to get the distance between two values.
So if we want to get the distance between negative two and two, like we want to get
this distance, then we can just do that formula up there, right?
And then it will work out.
We talked a little bit about adding and subtracting as well.
But the next thing that we should talk about is like, what does it, what does it mean to
multiply a value, right?
So usually the way that I like to think about it is that when you're adding something,
addition is an offset.
Addition is to move something or increase something by some amount, right?
So I usually think of addition as an offset and multiplying as a scale.
So we can scale something by multiplying something by some other value, right?
So let's say we have the number two, right?
We have the number two, and then we want to multiply it by some other value.
Let's say we multiply it by two.
So if we multiply that by two, what this means is that it's going to be twice as long.
So that's going to go from being on two to being on four.
So the result of that is four, right?
So what that means is that because we have multiplied by two, the length of this vector
is going to be twice as long, right?
Because again, if you do abs of this one and like check the length or the magnitude,
it's now going to be twice as long as it was before.
And this relationship holds for any other vectors too.
It's not just for scale our values or one dimensional values.
Okay.
So and then we can do, we can do other examples.
So we can do two multiplied by 0.5.
So this is basically half a length, right?
So 0.5 is 50%.
So what we're going to do if we multiply two by 0.5 is that it's going to be half as long, right?
So that's going to have a value of one, because two multiplied by 0.5 gives us one.
And the same thing is, it's the same thing when it comes to dividing, right?
So this is the same thing as doing two divided by two.
So multiply and divide are kind of the two sides of the same coin.
So for instance, let's say we have A plus B and then we have A minus B.
So if you think about these two situations, like having a like subtraction, all that is,
is kind of like you're adding a negative number.
So another way of interpreting this is that instead of looking at it like this,
we could just say that this is the same thing as A plus a negated version of B, right?
And negation is not the same thing as subtraction, right?
So this flips the sign of it.
A negation means that if it's positive, it's going to be negative.
If it's negative, it's going to be positive.
So like addition is generally kind of like, or subtraction is sort of a special case of addition, right?
Actually, let's do, no, let's do multiply.
So A multiplied by B and then we have A divided by B, right?
So in this case, this is sort of also a special case of multiply, right?
So in this case, it's actually A multiplied by the reciprocal of B.
As a reciprocal is basically one divided by the value.
So these two are the same thing, right?
So you can sort of think of addition and multiplication as the core things that you do,
where when you're doing subtraction or division, it's kind of like a special case
where you're kind of multiplying by the reciprocal of something.
Or in this case, you are adding the inverse of something, right?
Anyway, sorry, that was a bit of a tangent.
Anyway, I just think that's kind of cool.
Probably not super relevant to know.
But usually the point is you can kind of convert between these two.
You can you can translate a multiply to a divide if you want to, or divide into a multiply.
Yeah.
Okay.
That's a big word.
What's a big word?
A lot of this meowing in the background, I had to bless our chat for their authority mode.
That's a great emote.
Thank you so much, Marcus.
Oh, reciprocal.
Yeah.
Oh, sometimes it's called one over as well.
But yeah, sometimes there are actually cases where instead of dividing and multiplying can be like slightly faster in terms of like computationally.
But usually that goes into the category like unnecessary micro optimization.
I guess it depends on what you're doing.
But yeah.
Okay.
Cool.
Let's see.
I think we think it might be ready to move into two dimensions.
So let's erase a bunch of things.
Don't need that.
These are kind of weird.
Why are these numbers marks?
Why do those numbers matter?
It's a little unfair, actually.
Can you explain Quake engines inverse square at some point?
What part of it?
I'm not super familiar with the actual maths of it.
But as far as I know, it was like, it was an approximation of doing the inverse square of something.
And we used like kind of weird bit shenanigans that sort of only works with certain representations of numbers in binary.
But yeah, I don't know too much of the history behind it except what I just said, basically.
But I'm sure there's a Wikipedia article or something you can cut it.
Okay.
We've talked about one dimensional numbers.
One dimensional or one dimensional vectors are usually not called one dimensional vectors.
Usually people just call them scalars.
People call them floating point values in programming or decimal values.
So I've sort of approached this in a non conventional way.
So don't call things one dimensional vectors because you're going to confuse people.
But the only reason I approached it this way is because all of these functions have direct analogies to the higher dimension vectors.
So let's go to two dimensions.
Let's just enter another world or something like that.
So usually when we talk about dimensions, usually we have axes, right?
Currently we've only had one axis, like it's the x axis.
Usually this is the number line.
We only have the one axis where we have all the numbers, right?
And if we want to represent a position here, all we need is one number, right?
And we also need to not lock alpha on the layers.
Anyway, okay.
So basically if you want to represent a position on the number line, all you need is one number because there's only one dimension.
So what we're now going to do is that we are going to add a dimension to this.
So first off, when we work in multiple dimensions, it's really useful to use colors.
So usually when working in 2D or 3D space, usually we use the colors red, green and blue.
So the x axis is, I'm using the eraser.
There we go.
x axis is usually red.
And there's a neat little, little shorthand if you want to like remember which one is which.
So usually you have x and y and z.
So these directly correspond to, you know, RGB, right?
So if you want to remember like what axis is what color, then they follow RGB.
Like RGB is usually the color, color space we use and they directly correspond to the colors of the axes that we have in our, or the each dimension axes, basis vectors, whatever like term you want to use.
They correspond to those.
So like if you open up Unity, the colors of the gizmo is going to match this, right?
If you see a red axis, you know that that's going to be the x axis, right?
So it'll look something like this.
There we go.
It's something that like, I don't know, it's weird how many people have not realized that.
It's like, it's, it's one of those things that's obvious once you learn it.
But before that, it's like really not obvious for some reason.
But yeah, someone in Twitch said left handed.
The reason it's left handed is because we are going to talk about Unity.
And Unity is left handed.
And Unreal is also left handed, although Unreal is Z up.
But yeah, anyway, so that's why it's left handed.
So I'm sorry for any like actual professional mathematicians, because math is usually right handed, which is kind of, kind of not great.
But whatever, it's okay.
I'm also left handed.
I'm glad you figured out your chirality, right?
So we're going to add another dimension.
So so far, we've just had one dimension.
And we also need to close this document because Photoshop decided to lock the document, which is sometimes does when I'm using the tablet.
Right.
So we're just going to, we're just going to take this axis and copy it and rotate it.
There we go.
Oh, if you're like very familiar with math, this is probably painfully slow.
And I apologize, but I do want to make sure that everybody feels very covered and know what we're talking about throughout this entire course.
So sorry if it's a little, a little too basic, but that's okay.
I hope that's okay.
All right.
So let's see.
The number line still works the same way.
We still have not like it's still a number line.
We just have two of them, right?
So now we have one, two, three, four, five, negative one, negative two.
Okay.
So now instead of a one dimensional space, which was the number line, we now have a two dimensional space.
So generally, when you add a dimension to something, the dimension is always perpendicular to the other dimensions.
So, or the other axes.
So, so whenever you're looking at something like this, then actually it's not always perpendicular.
But if you want to have like an orthographic space, which you usually work in, then all of the axes will be orthographic to each other.
So they're, they always meet at a right angle.
Again, there are exceptions.
If you're working with like projection matrices or whatever, then, but whatever, that's irrelevant now.
Sorry, I'm going into unnecessarily weird details.
All right.
So now we have a two dimensional space.
So, you know how we previously marked a point where, you know, we would say that some place is three, right?
In terms of position, right?
When we are working in two dimensions, instead of every point on the number line being a single number, a point in two dimensional space is two numbers.
So there are a lot of like different ways you can like write vector notation.
Usually in mathematics, their notation is really garbage and terrible.
So I'm just going to sort of do whatever because math hasn't hasn't worked this out yet.
So usually I just do parentheses when I want to like mark a vector.
So, so let's say we have, we want to get a position in this 2D space.
Let's say we mark this point right here.
Just like we did before, we could draw an arrow representing the position.
And if you want to draw a position or a vector, vectors, vectors kind of always originate from zero because vectors don't have a root and a tip.
They only have a tip.
So like where you put the vector is only for like visualization purposes or interpretation purposes.
This is really important if you want to like know the distinction between like a vector and a point in a direction, which we're going to get into.
So now we have a point.
So this is a point we can represent it as a vector too.
And now if we want to like type the coordinates of this one, it would be two on the x-axis and it would be one on the y-axis.
So, so basically what this means is that each of these are called components.
And these components of this vector correspond to each of these two number lines.
So this is the x components.
And this is the y component of this vector.
Right.
In unity, this type would be called a vector two because it's a two dimensional vector.
There we go.
Vector two.
So, so this is how you would sort of write it in code.
You would do new vector to you and then you have a two dimensional vector.
Right.
Okay.
So this, these are the coordinates for this point.
Right.
All right.
So, so now if we look back at everything we talked about before, we can start doing a lot of operations with these that works exactly the same way in two dimensions.
So, so let's start with addition.
Let's say you want to add something, right?
So, let's say we want to lock the Photoshop document again and then reopen it.
Right.
So let's say we want to add something to this.
Let's call this something.
Let's call it a.
All right.
Maybe, I don't know if we should do a lower case.
Let's do a lower case.
Why not?
Oh, discord just said 170 new messages in the student chat.
Hope not.
No, we're fine.
Okay.
Thanks discord.
All right.
So we have the vector a, the vector a has these values, right?
And then we want to add to this.
So again, when we were adding numbers, we, we sort of had one, a one dimensional vector plus another one dimensional vector, right?
If we want to add two dimensional vectors, you would kind of get some number here, some number here, plus some number here, some number here, right?
Because you have X and Y coordinates, right?
So you would have X, Y, X, Y.
If you want to add two, two dimensional vectors together, right?
Okay.
So let's, let's pick another vector.
Let's say we want to do the vector.
Here.
So what are the coordinates of this vector?
There we go.
A question for class.
How would we write the coordinates of this vector?
It's always really awkward when you ask the class for like questions, because it's usually obvious.
And then like, some people don't really want to answer anyway.
And it's like, it's, we, I'm not going to do this again.
This was a mistake.
Okay.
Negative one one.
Exactly.
Because it's, it's, if we look at the X axis here, this position on the X axis lands on negative one, just like this position on the X axis landed at two, right?
So now we're, the coordinates of this one is going to be negative one on the X axis.
And then on the Y axis, it's going to land at one, just like the other one.
This one was also at one on the Y axis, right?
Cool.
So this, this is the vector that we're working with.
So let's say we want to add these together.
Adding vectors together is you kind of do it exactly the same way as you would do with scalars or one dimensional vectors.
But you do it for each component separately.
And Jesus Christ Photoshop does not want to cooperate today.
So one way to think about this visually is that, you know how we sort of imagine taking an arrow and putting it on the tip of the other arrow when adding?
Well, we can do the same thing with this one.
And we can kind of take this arrow and put it on the tip over here.
So that would give us this arrow, right?
I don't know how to draw straight lines.
There we go.
So now we've moved this one over here, right?
And what we end up with is that, oh, this is called B, by the way.
There we go, vector B.
So we have a here and then we're adding B here.
So where do we end up?
Well, this is the point where we end up, right?
Because we add this vector, add this vector, this is where we end up.
So what we get in the end is this vector right here.
Let's do it in a different color because I got a little confusing.
We end up with this vector.
So this vector, the yellow one is A plus B, right?
And you can sort of, one thing that's nice about looking at it this way is that
if you have some value like A plus B, this is actually equal to B plus A.
This might seem like it's kind of trivial that, well, of course, that's the case, right?
Well, why would it not be?
But remember that that's not the case for like, if you have A minus B,
that's not equal to B minus A, right?
So it's not always the case that if you flip the values, you get the same result, right?
So it's really important to keep in mind when things are,
I always forget if it's commutative or which one is which.
There are terms for this.
Anyway, so if we look at this, if we think about what we did here,
we have the vector A at the bottom, and then we added B to A, right?
Because we added B here.
So if we just look at the geometric interpretation of this,
we should get the same point if we do B plus A, right?
So if we try that, then we have the vector B.
So now instead of moving B over here, we can move A over here, right?
So if we put A here, we end up at the same point.
It's the same result regardless of what order we do this in, right?
Commutative, okay, people are confirming that it's called commutative.
Good, okay.
Anyway, sometimes that's a useful term to know.
Like it's the same thing for scalars.
A multiplied by B is the same thing as B multiplied by A,
but that doesn't always apply.
In some cases, multiplication is not commutative.
So for instance, if you're working with matrices or quaternions,
then multiplying those is different depending on the order that you do it in.
I think matrices are non-commutative.
All right, any questions so far?
Is this clear how things work with something a little weird, wonky?
Then I guess you just ask questions at any time.
I'm always up for answering questions.
So that's sort of how addition works, right?
If we talk about, let's say, subtraction,
let's see, I should probably undo a bunch of arrows.
All right, so as Steve is saying in the chat that I'm not supposed to read,
subtraction is addition in the wrong direction.
So just like we took one arrow, put it at the tip of the other arrow,
subtraction is, again, like we talked about before,
subtraction is the same thing as addition, but we negate one of them, right?
And negate in this case,
well, we were thinking about like one dimensional numbers before, right?
We have a value of two, and then when negate it,
we're going to get negative two, right?
And if we have negative two and negate that, we're going to get two.
So negation is basically, we flip the arrow to the other side around the origin.
So in two dimensions, it's exactly the same thing.
We could do it like per component, we could think about like,
what does it mean to negate the x-axis?
Well, if we negate the white component of this one,
we're going to get this vector, and then we negate the x-component,
which used to be two, and then it's going to flip to negative two, right?
But an easier way of thinking about it is you just flip the arrow
to point in the opposite direction, right?
So if we negate this vector, then we're going to get this vector, right?
Which is the same thing as just negating these individually.
So we could just copy those, move them over,
and then get negative one and negative two, right?
So now, if we want to subtract something, if we want to do B minus A,
then we add these two vectors, or we do this one minus this one, right?
So if we do B minus A, then we basically take this vector
and we add this vector, and then that's going to land us over here, right?
And then if we did this in the opposite direction, if we flipped it,
because remember, when we did addition, flipping them gave the same result, right?
But in this case, it won't, right?
So this point right here, this is B minus A, right?
If we do A minus B, then we would, we can imagine A,
and then we subtract this vector, and that would get us over here, right?
So over here, we have A minus B.
So here we can see that subtracting is not commutative.
If we flip the order, we're going to get different results, right?
Okay, so if we do B minus A in this case, we're going to get this vector right here.
So this yellow line going all the way here.
So one thing that is really, really important and crucial to know about doing subtraction between vectors
is that this vector right here is the difference between the two points, right?
So this yellow vector is the same vector as this yellow vector, right?
We've just moved it to a different place.
So if we want to know, like, what is the, again, the difference between the points A and the point B,
then that gives us this result, which in this case, this would be a 2D vector still,
but the Y component happens to be zero, right?
So on the x-axis, we have negative 3, and on the y-axis, we have zero.
So that's the difference between, that's B minus A, right?
And if you want, you can still do this component-wise.
If you want to do B minus A, you could do negative 1 minus 2 gives us 3, right?
You can do 1 minus 1 gives us zero.
So you could do it component-wise as well.
Okay.
So with subtraction, they become each other's inverse values then.
Not really.
I guess it depends on what you mean by the inverse values.
And they also don't become the distance from one to the other.
The distance is a separate concept because the distance is a scalar,
but if you subtract two vectors, you're going to get another vector, right?
So the vector is a difference between A and B, right?
So this is B minus A, and this again is a vector, right?
We're going to talk about distance soon.
So all we're doing here is we're doing B minus A, right?
Better described as an offset.
Technically, it's called a displacement, or usually a displacement is used when it's like over time, I think.
But yeah.
Anyway, so it's important to remember that this vector, the way we want to interpret this,
if this is the difference between B and A, is that this is not a position, right?
Now, vectors don't inherently have a property that makes them a position or makes them a direction
or makes them a quote-unquote vector.
But we need to interpret things, right?
And that is super important to know what each vector represents, right?
So if we have this vector, negative three and zero, it's more helpful to visualize it as an arrow between A and B.
But the actual values is negative three and zero on the y-axis, right?
So it's really important to interpret this in the correct way.
And also, when you're writing code, make sure that you're actually clear about what this is, right?
Like, if you want to keep this vector for something, call it B to A or call it the difference between something or the delta or whatever.
But if you just have a vector, then you're not entirely sure, like, should we interpret this as a position?
Should we interpret it as a position relative to A, which we are in this case, and so forth, right?
Yeah, so this is like a very crucial concept.
It's very important once we're getting into using different spaces.
So when you're doing a lot of things in GameDive, the difference between local space, world space, and all of that stuff is really important.
So you need to keep track of, like, you know, if you have a vector like this on its own, this one doesn't say if this is in local space, if it's in world space,
if it's relative to some other point, or, like, how this is used, right?
So always be, like, very careful, like, how you name your variables when it comes to this.
So, like, the, so this is something that I hate math for.
Math is so bad at this.
Math notation generally is really garbage, because they, like, there's so much stuff that's very implicit and, like, notationally ambiguous.
But in code, we can actually name variables.
We can make functions that are very clear what they're doing.
So in code, you can be very explicit.
And I think that's really good because math is unreadable sometimes.
Yeah, in math, you would have things like, well, if you have V, then you need to restart document again in Photoshop.
Thanks, Photoshop.
So sometimes you will have papers.
This is an actual case, by the way, where, like, V means one thing.
This is bold, but then you have a non-bold V that means a different thing.
And then you have a cursive V that means something else.
Like, this is bad, like, don't do this.
I hate it that, like, math papers actually do this kind of garbage.
So, like, you will run into this, especially if you're, like, reading shader papers or whatever.
That kind of stuff is really frustrating.
Yeah, so math notation usually rely on these types of things, and it's really annoying.
But in code, be explicit, be very, like, clear with what everything is.
Have variable names that make sense and so forth, right?
Yeah, and then you would have things like, oh, if it's bold, this is a vector.
But we don't draw the vector arrow because we're just going to presume that people know that this is the vector now.
And if it's cursive, it's a scalar value.
This is a component of the vector or whatever.
It's frustrating.
Okay, stuff like this is why I don't call myself a mathematician because I kind of hate math notation.
And I also don't know much math outside of GameDive.
Oh, speaking of which, if there's ever something where you are like, when is this going to be useful or what is the point of this?
Ask, just ask.
Everything I'm going to talk about is useful for game development.
None of this is going to be, like, esoteric, unuseful, just bad things, right?
So don't be afraid to ask, like, when am I going to use this?
Or can I order fries with trigonometry with that type of stuff, right?
Just feel free to ask questions.
In my experience, vector math is probably 50% of gameplay programming.
Yes, pretty much.
Again, people ask me many times, like, do I need to know a lot of math to do game development?
I'm just like, no, not really.
You need vector math, trigonometry, matrices help.
And then you need to know how to manipulate values, like remapping ranges, doing oscillation, that kind of stuff.
But usually, it's, you don't need that much.
Anyway, I'm going to take a picture of this and send it to the students in case people want to keep this beautiful piece of art.
What does orthogonal mean?
That they are 90 degrees off of each other.
Have you ever worked in non-Euclidean geometry or altered space in any of the games that you've made?
Not really, no.
I guess there are, like, there are matters of, like, interpretation, right?
I mean, if you want to call polar coordinates non-Euclidean, then yes.
But usually, outside of that, no, I haven't done a lot of that.
Mostly because I, like, I don't know.
It seems like it might be fun, like, experimentally, but I don't think I'm going to actually, like, make a game out of it.
But it seems like it might be fun to, like, try those things.
Boop.
Hey.
The most interesting math problem I had in Game Dev is trying to forecast the path of certain projectiles.
That is a thing we're going to talk about, like, ballistic trajectories.
For me as a Game Dev math course, this is a vector.
It's, like, two numbers stacked together.
Twitch at Lawrence Transform, yeah.
Yeah, last time I did a math course on Twitch, there was someone who was, like, an actual mathematician.
And every time I brought up a concept, they would, like, bring up the incredibly esoteric, like, really complicated, generalized concept in math.
With, like, really complicated words.
And I'm like, this is not the time.
Like, I don't even know what those things are.
Jill, I'm not going to be able to explain, I don't know, lie groups and algebraic rings to students.
Oh, geez.
It's amazing how people can understand esoteric concepts in math, but not regular social norms, kind of, yeah.
Well, but they are separate skills.
So, you know, that's how it goes.
Okay, so we talked about these things, right?
We talked about the sign of a value.
We talked about the length or the magnitude of a value.
Talked about the distance between two values.
All of these concepts also generalize to 2D and any other numbers of dimensions you want to use.
So it works for 2D, 3D, 4D, 5D, however many dimensions your game is in, right?
Okay, so let's see what these would mean in 2D, right?
So let's bring back some vector.
Let's say we do this one.
You know, drawing straight lines is one of the hardest things in art.
There we go, nailed it.
All right, so now we have a vector.
Cool.
So the components of this vector, again, we can look at the axes here for the x and the y components.
And then we can see that the x component is three.
So this would be three.
And the y component is two.
Cool.
So now we have our vector.
I also didn't really want to draw all of this.
All right, so now we have a two-dimensional vector.
Again, two values, one for the x-axis and one for the y-axis.
All right, so we talked about the sign of the value, right?
So if we have a negative five, for instance, the sign of this is going to be negative one.
The sign of a value like two is going to be one.
So basically what this kind of represents is, because again, we are on the number line, right?
And we have zero somewhere.
So what the sign kind of is, is that it can only be either one or negative one.
So turn to think of, I should call these unit vectors, one-dimensional unit vectors,
which is a little bit of a curse term.
But if you talk about unit vectors, that means that you have a vector that has a length of one.
And both of these have a length of one, right?
So what this means is that when we do the sign of something, we get the direction, right?
We get the direction for if it's going on the negative direction on the axis,
or we get the direction pointing in the positive direction of this axis, right?
So what the sign kind of, what it really does is that it gives us a direction, usually direction vector.
Okay, so what does that mean in this case?
Well, we talked about, I mentioned unit vectors.
So a unit vector is a vector that has a length of one, which both of these have, right?
Even though they're one-dimensional vectors, they do both have a length of one,
because this distance right here is one, this distance right here is also one, right?
So one way of representing something that has the same distance is usually using circles.
But in one dimension, we can't really do circles.
So let's go to two dimensions.
So now that we have two dimensions, basically, oh God, I need to draw a circle.
Drawing circles is hard.
You know what, there are tools for this.
Let's do a, let's cheat.
There we go.
What a beautiful circle.
Okay, is that visible on stream or is it too faint?
I think it's good, right?
Okay, so all the vectors that are pointing towards the boundary of this circle.
So if you have a vector pointing here, then this has a length of one, right?
This vector also has a length of one.
If you just measure the length along this arrow, it's one.
So what this means is that all the vectors that end up on the boundary of the circles are all unit vectors, right?
So when we talk about unit vectors, quite often they're referred to as directions.
So directions are always unit vectors.
So if we want to know the direction of this one, all we're doing is that we're kind of making it the length of one.
So this vector right here is the direction of this vector, right?
And what this is called the process of making a vector the length of one is called normalization.
So normalization.
Eyes were inconsistent.
There we go.
So the process of making a vector normalized or the length of one is normalization.
So this vector right here is the normalized version of this vector.
And this concept is also very important.
Like this is super, super useful in so many different ways.
Yeah, this is like ubiquitous whenever you're dealing with, you know, dealing with vector math in terms of positions of objects, the relation to each other, the direction to some other objects and so forth, right?
All right, so let's erase this confusing arrow.
So this is a normalized vector, right?
So that is the direction, right?
In one dimension, the vector could only have two states, right?
It could either be negative one or it could be one, right?
These are the only two states that are valid for a normalized one dimensional vector, right?
But for a two dimensional vector, we have an infinite number of points, right?
This circle can can fit so many points, the slaps roof of the circle or something.
So like any of these vectors would be a normalized vector and all of them have a length of one, right?
Yeah, so so normalized vectors means that it has a length of one that that's kind of it.
So when you talk about normalizing vectors, so let's say this whole vector is called V.
If you want to normalize it and math notation, you will usually see it with two vertical bars like this.
So this usually means the, well, actually, this could be the length of it.
Sorry, if you have V and then a little hat on top of it, this is a normalized vector.
If you have bars on the side, that's usually the length of it.
Sometimes you'll see two bars on the side because nothing is consistent and everything is garbage.
But yeah, so usually this would be the direction and this would be the length or magnitude, same word.
All right, so this is just the math notation garbage.
I'm pretty sure this is correct.
I don't, I feel like I have to relearn it every time I read a math paper.
So so we might wonder, like, how do you get a normalized vector, right?
Like, how do you, how do you get a normalized vector, right?
So we might wonder, like, how do you get a normalized vector, right?
Like, how do you, how do you go from V to the, to the normalized version of V or the direction of V?
Kind of use those like interchangeably, right?
So this little vector down here would be the normalized version of V with a little hat on top.
But basically the direction of V.
Okay, so we're going to talk about how to normalize a vector.
So I didn't quite get the normalization.
So, so basically if you have any vector, pick up any point on over here, then you're just going to be a line from zero, right?
If you want to normalize this vector, what that means is that you make the length one.
So what you get out of it is a vector pointing in the same direction, but it's got a length of one, right?
So it used to be this little vector, but if you normalize it, it's going to shrink down into a length of one.
Or if you pick a vector that is, that has a length that's smaller than one, this vector is going to normalize into being longer all the way out here.
So, so basically you can sort of consider it to be a way from going from a point to an arrow that represents the direction to that point.
Yeah, when do you usually need to normalize a vector?
So the concept of a direction is really important.
So, so say you have, say you have an object that is over here, let's say maybe this is an enemy like at this location.
And then you want to know that maybe the player is at zero and you want to know what is the direction that you need to move in order to move towards the enemy.
So if you are dealing with like physics or something, and you want to add the vector to move toward the enemy, then usually you want to move at like a fixed rates in terms of speed, right?
So what you usually do then is you normalize the vector between the player and the enemy, and then you have a normalized vector, which again, that's a direction usually in terms of terminology.
And then once you have a normalized vector, if you multiply that by your speed or some value that represents how much you want to move in that direction, you can guarantee that that's going to be in, you know, meters per second, or that that distance is going to be in meters, because the length is one, right?
So that means that you get consistent movement in, in space.
And what's the difference between you do is normalize method and normalized.
Yeah, the dot normalized will modify the original one, whereas the other one returns a vector.
Okay, did that make sense?
So basically, pick any point normalizing it means you get the direction to that point.
And a direction in this case, I'm using the word direction to be interchangeable with a vector with a length of one, right?
But it's still pointing towards that point, right?
Like I mentioned before, one of one of the powers, the powerful things about having normalized vectors is that, let's see if I can undo a bunch of things.
So, so if you have a direction like this, you can multiply a vector with a scalar as in a single value.
So if you have a vector, again, usually when people say vector, they mean multiple components rather than one.
But if you have a two dimensional vector, you can multiply that by two, for instance, or like some, some number.
But if you have the normalized vector, so let's say we have our vector that's normalized, it's the same thing as this one.
And then we multiply that by a value of two.
Let's pick two.
What that means is that the new vector we are getting out of this, that is going to be the direction along V right here.
But the length of it is going to be two.
So this is kind of what is like extremely useful about normalized vectors.
Because if you want to move like you like two units towards something, then having a normalized vector means that you can get a position that's exactly like some number away from some point.
So if you normalize a vector multiplied by a distance, then you're going to make the length of that vector the value you're multiplying it with.
And it might seem like that's not that's kind of trivial, but that's not the case with this vector, right?
If you multiply this by two, then at the length of it is going to be like all the way over here, right?
So the length of this is definitely not two, right?
It's way longer.
So this is why normalized vectors are extremely useful because of the fact that the length is one.
If we multiply it by some scalar, the length is going to be that scalar, right?
Yeah, so that's something that's useful when it comes to this.
So like I mentioned before, it's useful in physics, for instance.
So if you have the normalized vector, then if you want to move something along this vector, then well, what you can do then is that you could have time multiplied by your speed, for instance.
So time multiplied by speed.
So now we're just multiplying all of these together.
So what that means is that if time is a value that is ticking in seconds, when you start the game, time goes from zero to whatever the current second is, then you're going to have an object that moves along this vector at the speed you give here.
We're going to go into more physics stuff later, but so this is just one of the really, really powerful things about having normalized vectors, right?
Can you show an example in Unity?
Yeah, sure.
Do people want to see examples of this?
Show examples in Unreal?
Nope.
I think showing it in practice is really, really good because you're going to work in Unity.
So why not?
All right, let's nuke some objects.
There we go.
Let's go 2D because we're not into 3D yet.
Let's guess correct.
Will the game crash if it runs for more seconds than the float 32-bit limit?
You're going to have to run the game a very long time.
It's not going to crash.
It's just that your equations are going to get a hitch and a weird thing that's going to happen once it goes over the limit.
I don't think it's going to crash.
You're just going to have very weird behavior as soon as you hit that point.
Okay, let's see.
All right.
I probably showed it on code examples earlier, actually, because again, I like keeping things very pragmatic and practical.
Okay, let's just do some of the things we've done here.
Just to show how it works, right?
I usually really like using onDragismos because you can see it in the editor.
You can very easily draw lines and whatnot.
OnDragismos is a special function in Unity that is called in the editor.
You could optionally enable it in the game view as well, where you can draw lines and whatever.
You can do stuff like gizmos.drawline and then you can supply some positions, right?
We do something like that.
Then we go back to Unity.
We now draw a beautiful, tiny little white line, right?
Oh, wow.
I wonder if there's a vector graphics package you can get.
Okay, so draw line, just a very simple one.
We probably want to be able to supply some other points.
Do I have to wrap onDragismos in Unity Editor?
I'm pretty sure that's going to get stripped for builds, but I could be wrong.
Sometimes you use methods in there that are only in the editor namespaces and whatnot.
If you use handles, for instance, but gizmos, it ignores that, I'm pretty sure.
I'm pretty sure you don't need to strip it.
Maybe the code in here will be part of the assembly.
I'm not sure, but at the very least, it's not going to get called, regardless.
We probably want to be able to pass a vector into this or a point or whatever, right?
Instead of just hard coding it here, we can add a property.
Or in my case, I'm just going to pass in a transform because it's easier to move it around.
Let's call it point transform.
Let's make a new game object.
Actually, because since we're drawing all of this in a world space, we can just use this transform.
All right, let's pass point into there.
All right, so now we were drawing a line between zero and this transform, right?
So now we're basically just taking the position of this transform and we're drawing a line to it, right?
So again, we can think of this as the two normal lines we had where this is the origin
and then we have the x-axis and the y-axis right here.
Oh, you couldn't hear the discord?
You should have been.
It might have been a lower volume.
All right, so now we have the points, right?
So now let's say we want to get the direction to this point because we have been talking a lot about directions, right?
So let's get that.
So let's get that.
So direction to points.
So in this case, because it's originating from zero and we just want the direction to this arrow,
then all we need to do is normalize that point, right?
And Unity has a bunch of built-in functions.
You can do point.normalized and that's going to return a normalized version of this point, right?
So, yeah.
So now we have the direction to the point.
And again, I'm using the word direction to mean a vector of length one,
which is sometimes also called unit vector, normalized vector.
Like it has a bunch of terms, but usually when I use the word direction,
I mean a normalized vector just to clarify.
Okay, so if we draw that instead and then go back to Unity,
now this line always has a length of one, right?
It doesn't matter how far away the transform is, but the length of it is also one.
Even if it's shorter or longer, it's going to normalize it to always be unit length.
So now it's sort of tracing the outline of what's called the unit circle.
So the unit circle is just all the points of the vectors that have a length of one.
So it's this circle right here, right?
So now we have a direction, right?
What if you set the transform to zero?
So probably now it gets very sad because I'm pretty sure normalized,
it looks like it's just returning a zero vector.
So now the quote-unquote direction that this returns is going to be zero.
So it's trying to draw a point from, or a line from zero to zero.
So speaking about that, this is a very good case where when you have something like this,
this is actually division by zero, like technically,
we're going to get into how to calculate the length,
or how to calculate the normalized vector it's later.
But this is actually division by zero.
And something that is kind of beautiful in mathematics is that any time you are dividing by zero,
I think this is like so mind-blowing,
but like every time you're dividing by zero in some equation,
that is kind of the math talking back to you,
saying that like, hey, this is a weird case.
You need to handle this case.
Something is happening here.
And you need to think about what do you actually want to happen in this case?
Because it's kind of telling you that there is a degenerate case,
or a case that you cannot calculate because division by zero is undefined.
So whenever you have an equation where there is a divide line,
think about if the denominator can ever be zero.
If it can be zero, figure out what that means, right?
Like when would this be zero?
Anyway, okay.
So now we're just drawing the normalized version of this vector.
Do you have a course that you need to meet?
No, but I have my YouTube channel, which is free, so you don't have to pay for it.
Cool.
Okay, so let's talk about the length,
because we've sort of mentioned the length a lot when it comes to normalizing things.
We probably should have talked about length before normalization, but you know what?
That's okay.
All right, so let's talk about length.
How do you get the length of the vector, right?
I might be skipping ahead, but when you say the vector two dot normalized divides by zero,
where does it do that?
You are sort of skipping ahead.
I'll get to that.
Technically, Unity's vector two dot normalized handles that case and just returns a zero vector
instead of, you know, crapping out and not knowing what to do.
You could sort of make a normalized function that just throws an exception, which might be useful,
but Unity's normalized just kind of just returns a zero vector.
Oh, a zero vector is just a vector with components at zero.
So all of the components are zero, sometimes called a zero vector.
Yeah, okay.
So we talked about normalization, but not how to calculate it.
Like how do you normalize the vector?
Like how do you go from this to whatever the heck these coordinates are, right?
All right, so if there is, I don't know if we should use this vector.
Let's do another vector.
Let's do this one.
What a vector.
It's a little curved, but pretend it's not.
All right, so let's see.
What is this?
What is this vector?
So we have x-coordinate, we have negative two, y-coordinate, we have three, right?
So this is our vector.
So now we want to know the length of this.
Like how do we do that?
So now this is going to get into the hecking Pythagorean theorem, right?
Because if you think about it, if you want to get the length of this,
you can sort of imagine a triangle here.
And this is a right angle triangle.
And this is something that is taught in math class.
So if you remember how to get the length of the hypotenuse,
then you know how to get the length of a vector, right?
So basically what we need to do then is we take the x-component,
square that, and then we add the y-component and square that,
and then we take the square root of all of this.
There we go.
That's the Pythagorean theorem.
That's how you get the hypotenuse of a right angle triangle, right?
But this is how you get the length of a vector, right?
Is that clear by the way?
We haven't talked about, like, exponents
or what it means for something to be squared
or talked about square roots,
but I'm guessing we don't need to talk about that or...
But if not, let me know.
We can talk about it.
Okay, so this is basically how you get the length of a vector.
All right, that's it, I think.
So now we've been talking about,
we talked about for one-dimensional numbers.
We had abs instead of something else.
But the generalized concepts,
you usually write it like this for any other vectors.
You can add more components inside of this square root.
You can add, you know, z squared,
and then you have the length of a three-dimensional vector.
So it's the same thing,
regardless of how many dimensions we have, right?
And this actually holds even for one-dimensional vector.
So, you know, we talked about one-dimensional vectors,
where you can use the abs function,
which is basically just if it's negative, make it positive.
But you can do this for one-dimensional vectors too.
So if you have the square root,
and let's say we have the one component of negative five,
for instance.
So, all right, so let's just do the equation for that, right?
We do the square root of five squared.
So that's five times five, right?
Which is 25, I think, I don't know, pretty sure.
So that's 25, right?
Oh, actually, sorry, not five times five.
Negative five times negative five.
If you multiply two negative numbers,
then it's going to be positive in the end,
because the sign sort of cancel out, right?
So we get positive 25.
And then when we do the square root of that,
by convention,
square roots technically have two results,
but we're not going to get into that.
So technically, this then returns five,
because the square root of 25 is five.
The equal sign is incorrect, yes,
because this is the length of that, sorry,
length of negative five,
then just ends up being five,
because that's what the square root then returns, right?
So, yeah.
So it's just kind of like this same equation
works for any vectors.
Now, in practice, when you want to get the length of,
you know, want to get the length of,
wait, are you getting notification sounds?
I think I'm just getting it locally.
So when you want to get the length of a vector
for one-dimensional vectors or just scalar values,
usually you use abs.
You don't actually do the full equation.
But for anything like any dimensions about that,
you generally use the Pythagorean theorem.
Okay.
So this works for two-dimensional vectors too.
Oh, actually didn't.
Sorry, legs.
You know, I actually have a cold right now.
So this is like canonically kind of more accurate,
but sorry.
Sometimes my backwards writing doesn't work out.
Okay, cool.
So now we have that, right?
Now we can actually do that math.
So if we want to get the length of this one,
we can just do that, right?
So that's negative two times negative two
plus three times three.
And then we do the square root of that.
This is not a good-looking square root.
Where's my good color?
There we go.
So then we can just run these numbers, right?
Sorry, all right.
We do square root of negative two times negative two.
Pretty sure that's four.
So it's going to be four plus three times three.
That would be nine.
So four plus nine, which is, oh God, that's 13, I think.
Look again, I'm really bad at doing math in my head.
Pretty sure that's 13.
All right.
So it's no longer really tied to the X or Y axis.
I guess we can make it blue or something.
So that becomes 13.
And then we want to calculate that.
So that's when you pull out the calculator
and you type 13 and then you do the square root of that.
And it turns out it's 3.6 something, right?
So this is approximately equal to 3.6.
Oh, sorry.
We will do it in blue.
Why not?
Cool.
Let me get the length.
So now what this value represents
is the length of this right here, right?
The full length of this vector turns out
to be 3.6 something something, right?
So now we know the length of it, right?
Cool.
That's how we do it.
If you want to get the, like, if you want to do this in practice,
you almost never write this formula yourself.
So if you go to Unity, if you want to get the length of the point
or the vector, again, length is a scalar.
It's just a single value.
So the length of this one would be point dot magnitude
because again, magnitude and length, same thing.
Yeah, so this is how you get the length.
Sometimes it can be useful to calculate the length manually
because sometimes you want both the length
and the normalized vector.
And in that case, calculating things manually can be really useful.
Cool.
Everything clear so far.
How to get the length of a vector.
So now we've just talked about how to get the length
but not how to get the direction or sign
and not how to get the distance.
Okay, let's do the distance.
So the distance, now that we know how to get the length of something,
now if we get the difference vector
or the displacement between two vectors,
let's say we want to get this vector between these two right here.
Then this vector, this would be, we don't have names for these.
Let's call it A and V, there we go.
So in this case, this vector right here would be A minus V, right?
A minus V.
So now we have the difference between these two points, right?
So if we want to get the length or the distance between these two vectors,
all we need to do is get the length of this vector
because if we know how to get the length of this,
then we now know the distance between these two points.
And in this case, it also doesn't actually matter if we do V minus A or A minus V
because if we're just interested in the distance,
the distance is always positive, so it doesn't matter which order we do this in.
So if you want to get the distance between two points,
previously we did the absolute value
because that's how we did the distance in one dimension.
Actually, we never call it length.
Anyway, so this is how you do the length.
So we can basically just replace this by calling it length instead, right?
So now we have the, now we can get the length of this one
and the way to get the length is this one right here, right?
There we go.
Cool.
All right, so basically this is how you get the length.
If you want to get the distance between two points,
then you subtract the points, one subtracted by the other,
and then you get the length of that vector and then you get a distance.
So there is a slight difference in terms of interpretation between distance and length.
So distance usually is between two points
and length is usually the length of one point
or the length of the vector that represents that one point.
So when we want to get the distance between this point and this point,
we first subtract them from each other to get the difference vector
and then we check the length of that difference vector.
All right, so now we have a way of getting the length.
We have a way of getting the distance.
Have we clarified that the resulting blue vector is still centered on the origin?
We talked about that.
Vectors don't have a root and a tip.
It's only the vector data itself, right?
So we talked about that when we talked about subtraction
that if you want to draw it at its origin, it would be this vector, right?
Length, magnitude is of the vector.
Distance is between two vectors.
Generally, yeah.
So when you talk about distance, that's a special case where you want to know
how long is the vector that is the displacement between these two points, basically.
So when you talk about distance, again, distance has an input of two points usually.
And then you get the difference of those two points and get the length of that.
If you want to know the length of something, it's just one input, right?
So that's just the length of one vector.
Yeah, of course, there are built-in helpers for this.
You don't have to do it manually.
So if you want to know the distance between two points,
you can use vector two dot distance from A to B or DB null, I guess.
So this would give you the distance.
But you can do it the other way around, too.
You could do A minus B dot magnitude, for instance.
This would also give you the distance.
It's the same thing, right?
Or you could do the manual way if you want to,
like doing A minus B, like A dot X minus B dot X.
And then you square that.
And then you add the same thing, but for the Y component.
And then you do the square root of all of that.
So this is the same thing.
This is also a way you can get the magnitude or the distance between two points, right?
Yeah, just different levels of abstraction, I guess.
How to apply it in practice?
Well, we could make two points.
Let's make A green, B red.
Now we have two points, right?
What a good pair of points.
Okay, let's say you want to know the distance between these two, right?
First, we need the actual points because we only have transforms here.
Oh, I need to probably assign them in the inspector.
Dude, there we go.
So now we have, let's say, we just call them A.
So that's going to be A, transform dot position.
Then we do the same thing for B.
So now we have the two points, A and B.
And again, we can draw lines to make sure that this is working.
Right, I'm not using my library.
Gizmos, draw line from A to B.
There we go, cool.
So now there should be a line between these two points.
So we can move them around.
We now have, yeah, what a good line, right?
But we want to know the distance of that.
So if we want to know the distance,
I guess we can print it in the inspector or something.
So if we want to know the distance,
then again, we can use everything we typed here, right?
So we can do vector to dot distance.
And now we should set this value right here.
It might be hard to see it in the inspector,
but there's a little value there.
There's updating.
Now it's 0.45.
Now it's 1.9 and so forth.
So now we actually have the distance right there.
Yeah, so that's how you use it in practice.
And again, the distance value is going to be exactly the same thing
if we do A minus B dot magnitude.
So we can compile this.
It's going to work.
And yeah, still at the same distance.
Any other questions before lunch?
Any thoughts?
How to make a game like Angry Birds?
I can't answer that.
That's a very long question and a whole production pipeline.
Start doing things.
That's how you make games.
Generally speaking, no one's going to get mad at you
for doing A minus B dot magnitude instead of vector to dot distance.
I don't think so.
I mean, the first one might be slightly more esoteric
because you sort of need to know the underlying math for that to be readable.
But I think the...
I mean, most people should know about that.
It's a very important concept.
Like vector to dot distance.
The nice thing about using that one is that you're being very explicit
that you literally want the distance between two points.
If you use the A minus B dot magnitude, it's a little unclear.
Like you get the length of the difference between these two.
But like, are we going to...
Is that interpreted as a distance?
Maybe these aren't points.
Maybe this is something else.
So, you know, sometimes it's useful to like use the one that literally says distance
because it's very clear that you kind of want a distance, right?
And conversely, if you don't want...
If you want to do the same math as this, but it's not a distance value,
then using vector to dot distance is likely going to be more confusing than useful, right?
So it kind of depends on the context.
I personally really like doing...
Like being explicit and clear with my code.
Hugo, you're spoiling it.
I haven't gotten to that yet.
But, yeah, actually, let's use...
We can just talk about that.
That's the last thing before lunch.
Okay, so we talked about the...
We have this line right here, right?
The one that's pointing in the direction of this transform, right?
So what this one is that is the normalized version of that point.
Like this is the only thing we've done there.
So the way to calculate a normalized point...
So instead of just doing dot normalized, we can do the point
and then we divide it by the length of that point, right?
So point dot magnitude.
So this is how you normalize a vector.
So by dividing it by the length, the length becomes one, right?
Yeah, so that's how you normalize a vector.
I previously talked about the fact that there is a degenerate case
where you're dividing by zero.
And if you look at this equation, you can probably tell
what the degenerate case is, right?
Because point dot magnitude can be zero.
So what that means is that point is at zero.
So if you have a point that's at zero,
and your goal is that you want to get the direction
that this point has from the origin.
But if the magnitude is zero, then you're dividing by zero.
So now, again, math is telling you that something is messed up
and you need to think about what you actually want to do here.
So what this means is that you're trying to figure out
a direction of a vector that doesn't have a direction.
It's zero. It doesn't point anywhere, right?
So usually in these cases, you need to figure out,
okay, what do I do to handle this special case?
If it's at zero, do we want to fall back to just using zero?
Do we want to check if the length is zero
and then not draw it or not execute some piece of code?
Usually it's really like every time you see a division operator,
it's really useful to think about if the denominator can ever be zero.
If it can, then that means that you have an interesting case to solve.
Yeah.
All right. I think that's it for lunch.
Yeah, we're going to talk about the square magnitude stuff
that you're talking about after the break.
And yes, doing square magnitude is faster.
Yes. I think there are some intricacies of the property call itself
has some weird overhead, but if you manually do the square magnitude,
it's way faster than actually doing magnitude.
So I've heard.
But that's not for mathematical reasons.
That's for silly overhead reasons.
We should do a lunch break.
There's no audio in the lunch break room.
So yeah, I'm just going to place an image here.
See you soon. See you after lunch.
Look at that little boy sleeping in the goblet.
He's a peaceful little cat now.
Where were we?
We just covered how to actually normalize vectors,
how to do that, right?
Not just in terms of what it is,
how to do it using Unity's helper,
but how to actually do it yourself, right?
Okay.
What's the state of things?
So we have our code and we were just showing directions, right?
Okay.
All right.
So here's a short little exercise that we can think about together.
So for instance, now we have these two points, right?
Previously when we looked at direction here,
this is the direction of the point itself in world space, right?
Like this one is just a line drawn from zero in the world
and then out to one distance away from the center
in the direction of this point that we move around, right?
So let's say we wanted to draw the direction
between these two points.
Let's say you want to do direction from A to B.
So let's do that.
Let's just figure out how to do that, right?
So we're going to ignore the center points.
Let's just hide those.
Let's forget all about this.
Let's forget about this too.
Forget about everything.
You have learned nothing so far.
Okay.
So now we are drawing a line between A and B, right?
So now should just keep this line.
So now the goal is that we want the direction from A,
the green point to B, the red point.
So we want that arrow, right?
So how do we get a direction between two points?
Well, the first thing we need to do is to get the difference
between these two points, right?
So if we take one point and subtract it by the other,
we get the vector going from one to the other, right?
So that's something we talked about earlier.
Like the, we have the two points here, both of these.
Sorry, my desk layout is not in tablet mode.
So we have this point and we have this point.
And then we want to get the direction between these two points.
But first, in order to get the direction,
we need this blue vector right here, right?
So all we need to do is subtract one from the other.
The order in which we do the subtraction will change the direction
that the arrow is pointing, right?
So usually you can go either way,
depending on how you do the subtraction.
So generally it's kind of annoying that if you have,
if you have two points, like you have A and you have B,
and you want to get the direction from A to B,
the way you do that is B minus A.
And it's kind of annoying that this is the order that you do it,
because it feels like you kind of want to have the A first.
But I kind of just have this mental model of,
you always have to like flip them if you want to get from A to B.
So yeah, so it's always like the two points minus the from points.
So then from this to this in terms of like direction.
Okay, so that's all we need to do to get that vector, right?
So let's, let's do that vector.
So that's going to be called A to B.
And that's going to be B minus A.
And now we have the vector going from A to B, right?
All right, so now that we have that vector,
what happens if we draw that one?
Well, we can try it out, right?
Draw it from zero to that vector.
So now we're just going to visualize the raw vector, right?
So if we do that, it's now going to draw at the origin, right?
Because the vector itself doesn't have a root of the arrow, right?
So it doesn't really care about the location where we did this calculation.
But it is getting the correct vector.
Like this is the vector going from A to B, right?
So what we need to do now is that we just need the direction, right?
So we don't want the actual full vector.
We want this to have a length of one.
So if we want a direction vector,
we even need to normalize this, right?
So let's make the direction.
So A to B direction.
So then we can do A to B dot normalized.
And then we can draw the direction.
So now this one is always going to have a length of one.
So it doesn't matter how far apart they are,
but we do have the direction, right?
We can move either of these points
and the direction is still going to be correct.
Okay, so far so good.
But now we probably want to draw this one at the correct location
because it's kind of confusing that it's down here.
Like the direction is correct,
but the visualization of this vector is kind of offset.
We kind of want to see it here, right?
Like we want to see it go from the green point to the red point.
Okay, so we need to move this vector.
We also need to hide this line
because that line is going to be covering up a bunch of stuff that we want to see.
So let's first hide that line.
And then we want to move this vector.
So draw line is you supply two points in it, right?
And the first point is A
because we want to originate this line from A.
So we can just pass the point A into that one.
And then in order to make this be relative to A,
all we have to do is add A
because then we're going to move it up by this vector
going from zero to A, right?
Because that's what A is.
The coordinate of A is a vector going from zero to A.
So then we can do A plus that direction.
And then we recompile.
It's not going to point toward the red point, right?
And so now you can start to see, like,
you can imagine these being units in a game, right?
And you need to point toward some target or whatever.
And you need that direction somehow.
Then this is a way you can do that, right?
Yeah.
Although this part is only for drawing purposes.
You already have the direction here.
The only reason we had to do the A and A plus the direction
is to draw it at that location, right?
But the direction itself is already done
because directions, in terms of interpretation,
directions should not be, like,
they don't really have a position.
It's just a direction, right?
Yeah.
Okay.
Did that make sense so far?
If it didn't have A plus,
it would point to the location based on zero.
Yeah.
If this is just zero, or the, sorry, a zero vector.
Oh, it didn't.
It was sad about that.
If we just set this to vector two dot zero,
we remove that one.
Then it's going to be positioned at the origin,
but it's going to have the correct direction, right?
So the direction is correct here.
Yeah.
So kind of usually you only need this direction.
Usually you don't have to move it there.
We're only doing that for visualizing what's going on.
Okay.
Why are you doing A plus?
Why don't you draw at that location, right?
So if we don't do A plus,
it's going to draw the vector going from zero
in the origin of the world to the direction
that the vector is pointing, right?
But in our case,
we want to draw it at the location where it's relevant, right?
So again, if we just do this,
vector three dot zero, recompile.
So now it's going to be at the origin of the world,
zero.
So now we're kind of showing the raw data of this vector.
But in terms of like visualizing it,
it's kind of like annoying that it's at the origin
because if these things are very far away,
then we don't even see the origin,
even though the direction here is correct.
This is the direction going from A to B, right?
So the direction is correct,
but just visualizing it,
we need to supply two points to draw it, right?
When we're using draw line.
So yeah.
There is also a draw ray one if you want to use it,
although I tend to not use that one.
But yeah, so the A here is just to offset everything
so that it's positioned here instead, right?
So yeah.
So all we need to do to make this one positioned at A
is that we add A.
So zero plus A and A plus A to B direction.
And this is unnecessary.
So we can just remove that.
And then we have A to A plus A to B direction.
And then we get the two points, right?
So what A plus A to B direction is, is the point here.
It's the end of this line right here.
So that's what the second point is.
And this is where the first point is.
So what this gives us is this point,
which again goes from the origin all the way out to this tip
because depending on if we want to interpret it as a vector
or as a point, we can visualize it in different ways, right?
But that's where that returns.
It gives us that point right there.
What happens if you draw a line A to B direction?
I mean, it's just going to be confusing.
There's no like interpretation that that makes it,
that makes it useful sort of.
Yeah.
So there's not really much point of doing that.
Although it is very common to sometimes forget
to do things correctly.
So sometimes you will see issues like this
where you're kind of just confused about what's happening, right?
Cause this doesn't, this doesn't look like a direction at all.
This has, this does not have a length of one, right?
Yeah.
Because then what we're doing is essentially
this point is originating at the correct location,
but this one would still be, if we didn't have A plus,
it would still draw the end point at the origin.
So we need to move both the origin of the line
and the end point of the line by A, right?
So that it's relative to A.
Yeah.
You're offsetting both end points or the starting point
and the end point with A.
All right.
So now, now we have a way of getting the direction
between these two, right?
Let's see.
There have been a few more things we talked about.
So one of the more useful things about directions
is that we can very explicitly position things
at fixed distance along that line that is very easy to write.
So, so let's say you have some float value.
Let's make it a range actually from zero to four.
Let's call it offset.
It's fine.
All right.
So now we have a value called offset.
Don't need AB distance anymore.
Okay.
So let's say we want to draw a point between these two points.
We want to want to draw it along the line that goes here, right?
And we want to set the distance away from the player.
So now we're going to call that offset.
And we can do gizmos.drawSphere.
So just drawing little points.
So we want to draw that one at the location.
So just to make sure that this works, we can try.
Let's draw at the midpoint between these two.
So if you want to get the midpoint or the average of two points,
as you would do with any other numbers,
you do the same thing with vectors.
You add them together and then you divide by the number of entries you have.
So a plus b divided by two gives you the average point of these two coordinates, right?
All right.
So then we also need a radius.
You can just make something pretty small.
Actually, let's be a bit more explicit.
So midpoints equals that.
There we go.
So now we want to draw a sphere at the midpoint between these two points.
All right.
So we got this gray little sphere and it is right between these two points.
Okay.
So now we got this thing that we can draw.
But we don't want to draw it at the midpoint.
So we want to draw it a fixed distance from the starting point toward the end point.
So if we want to do that, like I mentioned before,
the fact that this direction is normalized
means that if we multiply it by some value,
we know that the length of the resulting vector is going to be that value.
That's not true if it's not normalized.
So this is kind of the really, really powerful things about direction vectors
or unit vectors, normalized vectors, same thing.
It's the same word.
Wait, different words, same concept.
So we have the direction here and then we want to get a point along that, right?
So we can do atv direction, multiply that by our offset.
So offset is the parameter that we can tweak for the distance along this line.
So let's call it offset vector.
So now, there we go.
Sorry.
So now we have the vector that is the offset that is going to move from this one toward the red one.
Now, same thing as before.
If we just draw this one, it's again, this offset vector is relative to the starting point.
So if we just draw this vector, it's going to be drawn at zero in world space, right?
So we probably want to move that one.
So we want to make sure that it's relative to A, just for drawing purposes, right?
So we add A to offset vector and then we can go back to unity.
And now we can see that we have this sphere and it's exactly one unit away from the starting point.
And we can change this offset.
So we set it to zero, it's zero units, and we set it to two, it's exactly two units away.
And unlike the midpoint that we got before, this one doesn't like squash and stretch.
It's always the exact same distance away from the player, right?
So what is the point of this?
What's the use of this?
Well, if you imagine this offset being a time value, then we just created a projectile, right?
This thing is just moving at a fixed velocity, right?
So now all of a sudden we just have a very simple formula where if we increase offset over time,
we have the flight path of an object in motion.
And all we've done is basically take the direction, multiply it by the distance.
And that's it.
If you increase the distance over time, then you have a moving object that's moving along that direction vector, right?
Okay, did that make sense?
Anything that, any questions or things that were not very clear?
Such a good way of explaining it.
I wish I had this lecture three years ago.
You should be a teacher or something.
I should be a teacher, you know?
If only I was a teacher.
Yeah.
Okay.
So yeah.
So now this is very much a, this is very, very central and very core to working with vectors in in games.
And the concept of a normalized vector or a direction is super crucial to have a good understanding of.
I'm probably going to make that a very central part of all of the, like all of the assignments that you're getting, because this is extremely core.
Okay.
Let's see.
Where are we in the schedule?
Oh, right.
Okay.
Maybe we should make more than one script just to make sure that we're not like cluttering this whole thing.
I forgot my hotkey for disabling objects.
All right.
Let's make, let's make another script just to like show more examples of like, why is this useful?
So let's say we want to make a radial trigger.
Like we have a trigger and we want something to happen by the distance to that thing, right?
So let's create it there.
And then some objects, we can test the code.
Maybe this is a player.
Maybe it's an enemy.
Who knows?
All right.
So we have an object now and we have our trigger that is just nothing right now.
So let's go back to onDragismos again, because it's useful for just testing things very quickly.
There we go.
Okay.
So let's see.
What do we want to do in this trigger?
For instance, we might want to set a radius on this one, right?
Like what is the threshold at which we want to want this trigger to activate, right?
So let's make another range from zero to four.
And then this is going to be the radius and we default to one.
All right.
And then we probably want to draw this so that we can actually like see what the radius is.
This is, by the way, something I talk about a lot when I have my tool dev courses onDragismos to just visualize things like radius and whatnot.
It's super important.
I'm really good for level designers so that they can actually see what the range is of everything, right?
Otherwise, everything is kind of like difficult to parse.
All right.
So let's draw this.
We can do that with gizmos.draw.
Let's see.
There are many functions here.
I'm going to draw a wired sphere, for instance.
So wire is wireframe.
Okay.
I don't know.
I think handles has a wired disk.
Maybe we should use that one instead.
Okay.
One thing to note though, whenever you're using handles, handles is in the editor namespace.
So if you want to ship a game and you're using handles and onDragismos,
you have to make sure that you compile that out, right?
So in this case, as soon as you're using handles, always make sure that you compile out the code, right?
Otherwise, you're going to get builders and that makes people sad.
Okay.
So we're doing handles.
Let's draw a disk.
We want to draw this at the location of this trigger, right?
That's the wrong using.
That is true.
There we go.
Unity editor is the one that should be wrapped.
All right.
So we want to draw this wire disk.
And let's see.
We need a center point.
So the center point is going to be the location of this trigger, right?
So it's going to be a transformed opposition.
Actually, let's abstract this a little bit more.
So we have the origin, right?
Of the trigger.
So that is just transformed that position.
So we're going to draw that there.
Normal.
Okay.
We need to supply a normal for the disk.
We haven't really talked about 3D vectors yet.
We're going to get to that later and what normals are in general.
But quickly, if you imagine you have a plane, like not an airplane.
Just the physical plane, then the normal is the direction that is pointing out from that plane.
So my finger right now is the normal of the plane of my hand, right?
So that's the normal direction.
There we go.
Now we have a better, better normal direction, although usually Z is the normal for surface.
So the blue vector there is the normal of my hand.
So in order to draw a disk, what that means is that the normal of a disk makes the disk
lie in the plane of my hand if we supply the blue vector as the normal to this, right?
But we're in 2D, right?
So in our case, our coordinate system kind of looks like this, right?
So we just need to supply the blue vector, which is the Z axis in world space.
So in this case, we're in 2D, we can just tip over our water bottles.
So we can just do vector 3.forward.
This is equivalent to doing new vector 3, 001.
So this is just a direction vector that is pointing in the Z axis, right?
And then we have the radius.
So we want this radius to be the same as the radius of this trigger, right?
Jesus Christ, all of you want to have that, my gizmo.
I only have two and I hand made them, so I don't know how to like sell them.
Anyway, so now we've supplied a normal to this disk.
We have a radius and an origin.
So now we should be able to see a wireframe ring around this trigger.
Cool.
So now we can now tweak the radius, right?
We can change the radius and the ring will change size.
We can move this around and everything is working as expected, right?
Okay.
I 3D printed my gizmos and then I painted them.
That was my process.
That's about it.
Yeah.
Nice.
I have two.
They're very useful, especially when you get to talking about cross products.
It's super good.
Do you have the schematics?
I just made it.
3D model at some point.
I don't know.
It might actually be at my work computer at an e-corp, but I could just remake the model
or whatever.
It's not a very complicated model to make.
All right.
So now the question is, how do we actually get the, like, how do we know if we are inside
of this trigger or outside of this trigger?
Right?
So now all of a sudden we have a math problem.
We have a math problem.
Right?
So now all of a sudden we have a math problem that goes through all of the concepts we've
been talking about.
Right?
So we have a point.
This is going to be a player or an enemy or anything else.
Right?
And then we have the point that is the center of the circular trigger.
All right.
So how do we solve this?
Does anyone have any ideas and chat about how to do this?
What are we going to do?
Move it?
All we need to know, all we want to know is whether or not this point is inside or outside
the trigger.
How do we know that?
It's a Boolean state, something we can put in an if statement.
Right?
Check the distance between the two objects.
Yes.
Okay.
We have the distance.
What do we then do?
If it's greater than the radius, it's outside.
Yeah.
Exactly.
Physics.overlap.
That works for physics objects, but right now we're not using any physics objects or colliders.
All right.
Cool.
So let's do this again.
How do we check the distance between these two points?
Well, we have the origin and then we have the object position.
Let's call it object position.
That's object transform dot position.
Okay.
So now we need to know the distance between these two.
So distance equals, we can do vector two dot distance between object position and the
origin.
So now we have a value for how far away is this object from the trigger?
Right?
But now we also need to know the state of whether or not it's inside or outside the radius of
the trigger.
Right?
That's kind of what we're interested in.
Okay.
So we'll have the distance and the radius.
So all we need to do then is to, we can make a Boolean state.
So let's call it is inside.
And the only case where this is inside is if the distance is less than the radius of the
trigger.
Right?
So if the distance is less than the radius, then it's inside.
You can do less than or equal to.
Implementation dependent depends on how you're going to do this.
Yeah.
So now we have a state for whether or not it's inside.
And let's set the color of the ring to be red if it's outside and green if it's inside.
So handles dot color is inside.
And if it's inside, we want to do color dot green.
Not green.
Otherwise, color dot red.
So red outside green inside.
And transform has not been assigned.
So now we have a bunch of null refs because this is not serialized.
So let's serialize it.
All right.
Still null.
There we go.
Cool.
All right.
So it's green.
Move it outside.
It's red.
And it seems to be able to check this distance, right?
So as usual, you need to test things, make sure you can change the radius and it still
works.
It seems like this.
This is working.
Was everything clear how this was set up, why it works and everything?
Oh, what's the vector 001 needed for?
Yeah, that's just because the disk function is meant to be able to draw in 3D space.
So this is just our way of telling it to, we just want to draw on the xy plane, right?
Because we set the normal of the disk to be on the z-axis, which means that the disk is
going to traverse on the xy plane, right?
Why not use vector 3.forward?
I mean, if I were to write this code when I'm working on something, I would write vector
3.forward.
Just for educational purposes, talking about what this is, what it means, vector 3.forward
is a little bit unclear when I'm teaching what vector 3s are.
So in this case, I just typed vector 3 because it's made things a bit more clear in terms
of what the underlying data is, right?
But yeah, that was the only reason.
Yeah, but otherwise, this is equivalent to vector 3.forward.
It's the same value, right?
The only reason that I sometimes don't do it is because transform.forward is very much
not the same thing as vector 3.forward.
So you need to keep in mind what you mean when you type the dot forward, and sometimes
you can confuse the two.
So yeah, sometimes I think it's good to just write the whole vector out to clarify that
this is just a vector on its own.
One more thing.
So we talked about how to get the length of a vector, right?
And if you recall, this is how you get the length of a vector, right?
So you have an x component of a vector, you square that, and then you add the y component
squared, and you take the square root out of that.
It was the Pythagorean theorem that we talked about earlier, that whenever you have a right
angle triangle, you can get the length of the hypotenuse using that formula, right?
Which is equivalent to asking what the length of a vector is, right?
Okay.
So we got this formula, and we can use this to calculate the exact length of a vector.
If you are doing, like, if this is in some sort of for loop, and also this person in
Twitch chat is really annoying, can we just time out this person?
There we go.
Great.
Okay.
So if we can, we can use this distance value to check a threshold, just like we did here,
right?
So if we, we can check if it's less than some value or greater than some value, right?
So if you are doing some code that is, like, iterating over 600 objects or whatever.
So in that case, then you might want to optimize this, because if you're doing a distance check,
like, every frame across 600 objects, or maybe even more.
So, so in that case, you might want to, you might want to optimize it, right?
And there is a very nice way you can optimize distance checks when you're doing stuff like
this.
So, so one thing that is probably good to know is that square roots are not like super
expensive, but they're a little bit more expensive than like multiplying.
They're a little bit more expensive than adding or subtracting.
So it's sometimes good to keep in mind that the square root itself has a cost to it.
So again, when you're doing four loops over many objects in an update loop or something,
that's when it really matters, right?
Otherwise, don't micro optimize this all the time, because it's going to make your code
unreadable.
So don't do this all the time.
I'm just like bringing this up as an optimization tip when you have like very heavy, many distance
checks and whatnot.
All right.
So, so if we want to make this cheaper, we could actually get rid of the square root,
we could just nuke it, just remove it and then we can see what happens, right?
Okay.
So previously we were checking the distance, right?
This distance in and of itself contains the square root.
So this one is doing the whole square root check, right?
But we can do this manually.
So, so let's first get the displacement, difference vector, we can call it trigger.
Actually, let's call it displacement.
There we go.
Now we're going to use esoteric terms.
So the displacement here is that we subtract one from the other, right?
So, so this is the vector going from the origin of the trigger to the, to the object that
we're checking the distance to, right?
So that's the vector going from the center to this one, right?
All right.
So that gives us the displacement vector.
Now, now we want to calculate the length of this, right?
So we want to get the length of this, we could do displacement of magnitude.
But if we want to do this manually, just to like clarify the math involved in this.
So, so the length or this technically the distance, maybe we call it distance.
There we go.
Comment that out.
Or just dist, there we go.
All right.
So we're going to get the distance between these two points, right?
And the way we do that is get the length of the displacement vector, right?
So we do the x components, and we square that as in multiplied by itself.
Usually, if you want to square something, multiplying it by itself like this is usually faster than using
like a floating point power function.
So if you do like displacement dot x to the power of two, in some cases, this is going to be way slower
than just multiplying it by itself, right?
So that's a useful thing to know.
So, so displacement dot x times displacement dot x, what did we just type?
Well, we just did this part, right?
The x squared.
All right.
So now we do the same thing for y squared.
So we add displacement dot y multiplied by displacement dot y.
So now we did this part right here with the y components.
And then finally, we do the square root of the whole thing.
All right.
So math dot square root of all of this.
So we got the distance.
And now I'm pretty sure everything should work the same way it did before, unless all of my math is wrong.
All right, seems to work.
So nothing's changed so far.
So now all we've done is basically replace Unity's distance function with the math underlying all of that stuff, right?
Okay.
So what we're now going to do is the optimization part.
So we talked about how you can actually remove the square root and still make the math work out so that we can do a threshold check.
Because again, we're only checking a threshold.
All we're interested in is, is it less than or greater than some value, right?
So in that case, we can remove the square root.
So what does this mean then?
Well, now this is not the actual distance, but this is the distance squared as in the distance multiplied by itself.
So usually it's good to like, note that with like sq is usually what I use whenever something is squared, right?
But now the, the distance squared is not the actual distance, right?
Oh, if you want the like actual algebra involved in this, sorry.
Should probably, should probably write that down.
So x squared, if you want to get x out of this, then if you take the square root, if you take square root of x squared, these are going to cancel out and you just get x in the end.
So like the, the square root and reason something to the power of two, they're kind of like opposites of each other, right?
So technically, square roots are, it's just x to the power of 0.5.
You do, we just usually write it out as the square root symbol.
Anyway, so basically they can cancel out and whatnot.
So if we take the square root of x and raise that to the power of two, then we get x.
So same thing between these two.
Okay.
So, so basically, when we get the distance here, where we remove this square root, we actually have the, the squared distance, not the actual distance.
Because if we want to get the actual distance, we need to do the square root on it first.
All right.
So now we have this weird, weird squared distance value.
So now this one is going to be incorrect, right?
Because we just removed a piece of the math where we just removed a piece of the math that happens to work in this case.
And this is again, important to check for, or to test your code, right?
The reason it works here is because our radius is one.
If we set radius to 0.5, then now you can see that the threshold is incorrect.
It marks it as inside here.
And the same thing if we make the, if we make this larger than one, then it's, it's counts as outside already here, but it really shouldn't do that, right?
So the way to do this is that we're using the squared value here.
But the radius we're comparing to is the actual distance.
But what we can do is that we can take the radius and square that.
So now both of these are squared.
So if we square the radius, we're comparing the square distance with a squared radius.
And now if we go back to unity and recompile, this is now correct.
And everything is like working exactly the way we want to, but we managed to optimize away the square root.
Like we're not actually using a square root anymore.
All we're doing is one more multiply instead of the square root, which is much faster in many, many cases.
So if you, again, if you're doing very performant sensitive code, you can get rid of that square root.
Now it's a little annoying to have to type all of this.
So there are built-in functions for this.
So instead of like typing all of this manually, you can get the displacement vector and do squared magnitude.
So this is built into unity.
So you can just do square magnitude.
And now you have the, well, the squared magnitude of the distance between these two.
And there is also, actually, is there, is there a, there's no square distance.
Okay.
Well, anyway, this is sort of the square distance then we were just doing the displacement vector manually,
and then we'll get the square magnitude of that displacement vector.
Right.
Anyway, so this is a neat little optimization you can do.
But one thing that's very important.
This only works if you're only checking a threshold.
If you need the exact distance, you have to do the square root because we are no longer calculating the distance over working with.
This is wonky space that is not linear, right?
Actually, let's, I can show you the quick little example.
Oh, decimals.com slash calculator.
This is an incredibly useful tool.
We're going to use this a few times throughout the course.
It's good.
You should use it anytime you want to graph something.
All right.
So, so let's say we, we have our distance.
Let's say that's X.
So we interpret this along the X axis.
So now we have a value representing the distance as we go further away, right?
And obviously it's just going to be, it's just going to be one.
It's a diagonal that just goes up there.
But if you do X squared, then you can see that.
But wait, are you?
What?
Oh, no.
Oh, I'm sorry.
Okay.
All right.
So like I mentioned, this only works for thresholds.
If you want to know the exact distance, then you want the red value here, not the blue value.
Because this is not a distance value.
But if you take any points, like if you, if you say here, we have one coordinate and then we have another one here.
We want to know if you're to the left or to the right of this value.
That's going to be true regardless of which of these two curves you're using.
This is a little esoteric if you're, if you're not like accustomed to reading curves.
But basically, if you want to check if something is less than or greater than something else, which is exactly what we're doing here.
We're only checking if it's less than or greater than something.
In that case, you can just use the squared versions because the comparison is true regardless of if you have the square root or not.
That's why we can do this optimization, but only when checking thresholds because the blue line is not an actual distance.
It's a squared distance.
That was a long thing.
Any, any questions so far?
How do you calculate the normal of the plane?
Is it the rotation that are?
So the, it depends on how the plane is defined.
It really depends.
If it's a two dimensional plane, then if you want to calculate the normal of that plane, like say the, say your plane is defined by the red arrow here.
And this is 2d.
Then the normal is just going to be, it's just going to be the red arrow rotated 90 degrees, right?
And that's it.
And then if you imagine the plane extending it to infinity along the red axis, right?
Then you can just rotate the direction of that plane to get the normal.
But then again, the, the thing is, whenever you have a mathematical plane, the normal is usually built in to the plane itself.
So you can usually get that normal out of just the representation of the plane that you have.
But it really depends on like, what is your plane defined by?
Like a mathematical plane works in one way.
If you have an actual 3d mesh, then things work in different ways, right?
Because now you have triangles and maybe colliders that you need to like, I don't know, ray cast against or whatever.
So that works differently than like purely mathematical planes.
Okay, so the last thing we're going to talk about now.
Before we end today's thing, we are going to talk about the dot product.
So swoosh, I think we might need to clean up this whole thing.
Okay, there we go.
What a, what a good, good circle.
Let's make a new layer and straw some lines.
Now, okay, so this is, this is going to get very close to trigonometry,
but we're not going to have time to talk about trigonometry today.
So instead, we're just going to talk about the dot product.
So the dot product, when you're talking about multiplying vectors together,
generally, that is an ambiguous statement.
So when you talk about multiplying two vectors, there are many, many different ways that we can approach that.
Like what do you mean by multiplying?
Kind of the most straightforward one is that, let's say you have two vectors.
You have vector A, and again, the vectors are their components.
You have the x components, and then you have the y component of a vector, right?
Or if it's a 3d vector, you also have a z component.
All right, so what does it mean to multiply two vectors?
So if we do A multiplied by B, if you just write this sign here, just this little dot,
usually that means that you're doing the dot product between vector A and vector B.
And the dot product is actually a very specific type of multiplication.
When you talk about multiplying vectors, there are like, there's a dot product,
there's the cross products, and I do believe the wedge product,
but the wedge product is very close to what the cross product does.
But anyway, so there are different ways of multiplying them,
and knowing which one you want to do is really important.
There's also component-wise multiplication, where you kind of take,
so there is the component-wise multiplication,
where you kind of multiply these numbers together,
and then you get a third vector out of that.
That is the, you know, this x multiplied by this x gives you some value here,
and the same thing with the y component, then you get some value here.
This is actually one of the least common multiplication methods.
This is almost only used when you want to scale things
on like a non-uniform scale or whatever.
So this is usually called component-wise multiplication.
Unity has it in the form of vector 2 dot scale or vector 3 dot scale.
Yeah, so this is usually a very specialized form of multiplication
that's not always very, this is not used very much actually, except for scaling.
Okay, anyway, so let's talk about the dot products.
Now, the way that I usually like to approach the dot product,
like there are many approaches,
some people like to go through trigonometry to talk about it,
but I like to think about things geometrically,
because that makes sense to me in many, many ways.
All right, so we have our unit circle.
So by unit circle, I mean that the radius of the circle is 1.
So any vectors that is pointing to the edge here has a length of 1, right?
So if you have, let's see, let's put two vectors here.
We have one vector there and another vector here.
Actually, let's use separate colors because that's going to be useful.
So we have a vector here, let's call it A and another vector.
Actually, let's do, let's do this one.
There we go, perfect.
And B. So now if you have, now we have two vectors, right?
We have vector A and we have vector B.
And then we can ask what happens if we take the dot product of these two vectors?
Because the dot product has two inputs, it has two vectors as input.
Usually in math libraries and whatnot, it's just called dot.
So let's write that down.
The dot product between A and B.
There we go.
Okay, so the dot product, what is the dot product?
Geometrically, you can think of the dot product as projecting one vector onto another vector.
So if you look at B here, for instance, if we do the dot product between A and B,
what we're going to get is actually, if you can think of B flattening onto A perpendicularly,
what the dot product gives you is this length right here.
So sometimes a dot product is referred to as a scalar projection because of this reason.
It's called scalar because the result of the dot product is not a vector.
The result is just a numerical value.
So the dot product between B and A here would be, well, the whole thing is one.
So this is less than half.
So I guess this is like 0.4 or something.
So it's approximately 0.4 in this case.
Okay, so you can sort of think of it as projecting one vector onto another.
Now, there are some caveats.
For this to work, A has to be normalized.
This one has to be a length of one.
You can change the length of B.
So if you say make B this vector, now the length of B is not one,
but the scalar projection is still going to be the projected distance along here.
So in this case, it's going to be like 0.8 or whatever.
Okay, so that's a very simple way of visualizing what the dot product does.
It projects vectors onto each other.
And in this case, if you reverse the order of A and B, you actually get the same results.
So this one, it doesn't matter what direction you do this in.
Because again, if you do this the other way around, then we're going to do a 90-degree projection onto B.
And that gives us this distance right here.
And that is also 0.4, right?
So it doesn't matter what direction we do this in.
All right, so you can swap those.
It doesn't matter.
But you still get like a valid value out of that, right?
All right, so that's what the dot product does.
One thing to note though, is that the dot product can be negative.
So it's a little bit misleading to call it a distance.
So for instance, if we have this vector as our B, then what's going to happen is that it's going to project against the kind of the infinite line here, right?
So in this case, it would be the same thing.
It would project against the other vector like this, 90-degree angle.
And then you would get, again, you would get this distance.
But in this case, it's going to be negative.
So you can sort of think of this as a signed distance in this case, right?
So this is a negative 0.4.
So here's a very useful way of thinking about this.
Now, if you look at A here, and you look at the values we have, we have 0.4, we have negative 0.4.
It's one over here.
And if we were to do the dot product where they're completely opposite of each other, we would get a value of negative one, right?
And you know how we've talked about the number line before, right?
If you think about it, B projected onto A is kind of a way of getting a number on the number line of A, right?
So you can sort of extend A and consider that to be a number line, right?
Sort of like this.
So when you project it onto that, you kind of get the coordinates along the direction of the axis of A.
So this is kind of a very nice way of just converting something to some other coordinate system.
And this is actually used.
If you want to do space transformation, which we're going to talk about next time, this is used for that.
For instance, okay, where do you use dot?
I'll get into that very soon.
First, I'm just going to talk about how you do the dot product, like how do you calculate the dot product between two vectors?
It is very, very simple.
It's like surprisingly simple for something that is incredibly useful.
So the dot product between vector A and vector B, this looks like it's not equals.
So the way to get the dot products, well, the actual practical way is that you use the dot product function in your vector library.
But if you want to do it manually, you would do A dot X as in the X component of the A vector.
And then you multiply that by B dot X.
And then you add A dot Y and then multiply that by B dot Y.
That's it.
It's very straightforward.
Multiply the X components and then add the multiplied Y components.
There's not much more to it.
So that's how you get the dot product between two vectors.
Now, again, this projection example is only valid if one or both of your vectors are normalized.
It doesn't quite work out if none of them are normalized because then it doesn't really project because then it projects and scales that distance.
So it's good to keep in mind that the projection interpretation mostly holds if you're doing, if one of them is normalized.
So again, the number line example kind of presumes that A is normalized because then you're kind of getting the B coordinate along the vector of A.
Okay, another useful way of looking at it is that, let me erase some things.
I'm raising too much.
Why did I draw these on the same layer?
It's fine.
Everything's fine.
Oh yeah, like someone is mentioning the square magnitude.
This also happens to be the way that you get the squared magnitude of something.
So if you do the dot product between A and A, and then you do the square root of this, you have a distance function.
This is mathematically equivalent to getting the distance or the length of vector A.
So it's kind of a shorthand to do that.
And if you use the same vectors for both inputs for the dot products.
Okay, so here's another way to interpret the dot products.
So the dot product can also be used to kind of figure out how close are these vectors to each other.
So if you think about A here, and you have your vector B, when you project this one, you're going to get a value that is very close to one.
This is going to be like 0.999 or whatever.
If they are exactly equal, as in the vectors are the same and they're both normalized, the dot product is going to give you one.
So if we can kind of think about what happens when you rotate this vector around.
If B is pointing here, we're going to get a lower value in the projection, right?
Because it's moving toward the center now.
So this is going to be 0.6 or something.
And then when you kind of imagine keep rotating this one.
If it's perfectly perpendicular like this, as in it's 90 degrees off of A, then the dot product is going to be zero.
And this is really, really crucial.
So this is important to know.
So if we track what the values are, then it's going to be one over here.
Let's do one somewhere here.
It's going to be 0.5, right?
Somewhere here.
It's going to be like 0.8 or whatever and so forth.
And because we're projecting this onto A, there's also symmetry in this where we would have 0.8 over here as well.
And if we go perpendicular in the other direction, this would also be zero.
This also projects to zero.
It's 90 degrees off.
It's going to project towards this and it's zero again.
So we get back to zero.
And then we can continue to the other side.
If it's completely opposite, then you get a value of negative one.
And then you have values in between here.
So, you know, you would have 0.5 here and 0.5 somewhere here, right?
So what does this mean?
This means that if you have two normalized vectors and these are, and you're comparing two vectors,
what you are getting is kind of an approximation for how close they are to pointing in the same direction, right?
So in this case, I'm just talking about normalized vectors.
Both of these are normalized.
So if one of them is not normalized, then these values are not going to be interpreted exactly the same way.
But the sign of this still holds.
So what you can notice now is that all of the values on this side are negative.
All of the values on this side are positive, right?
So one thing that the dot product is very useful for is, is this vector pointing towards something or is it pointing away from something, right?
Because now if we consider the green arrow to be the direction a player is looking and the red arrow is the direction to an enemy or something,
then we can tell if the player is looking away from the enemy by doing the dot product, right?
If the, if the player is looking in this direction, well, oh, this should be negative, sorry.
Then this is a negative value, right?
Because all of these are negative.
Sorry, I forgot to do negative for these.
Yeah, so all of these are negative values.
All of these are positive values.
So now if we do the dot product between the player direction and the enemy direction, it's going to be negative here because it's projecting here.
Got the distance here and that's negative.
So this is super, super useful.
I do have an animation for this too.
Not that animation.
It's the wrong one.
So here's an example.
This is basically what I've just been talking about now.
You have two vectors.
If they point in the same direction, you have a value of one.
If they point directly perpendicular to each other, it's a value of zero.
If they point completely in opposite direction, it's a value of negative one.
And that that's kind of it.
So again, this is only when you have two normalized vectors.
If one of them is not normalized, the positive and negative thing, those rules still apply.
In that case, they don't have to be normalized.
But for these values to be exactly one and negative one when pointing in opposite directions, they have to be normalized.
Can I calculate the second vector if I only have the first vector on a dot product?
Well, it would be ambiguous, right?
Because you would have two results, not one.
But I believe it's possible.
Is there any point to having one vector larger?
Yes, if you don't want to check the if you if you're not interested in checking, like, are they facing the same direction or some other direction?
Sometimes you want or very often, actually, the vector is shorter or longer than a normalized vector.
So this vector projected onto this one.
Sometimes this distance is still interesting.
And it's very often interesting as well.
So let me be a bit more practical, because we've been talking about like esoteric things.
And let's let's think about what this can be useful for, right?
Let's see, maybe I should move.
Do I move that?
Or do I keep it?
Angle is implied by the dot product.
No, angle is we're not talking about angles, angles of spoilers.
We're going to get into angles as soon as we talk about trigonometry.
But right now we're just doing vectors.
Okay, here's an actual example from the game that I'm working on.
So let's say you you happen to have a game that has a surface of all things.
So let's see.
Guess we can give it some direction.
There we go.
It's very soft and good.
I don't know how to make this continuous.
There we go.
Cool.
Okay, so we have a surface.
We have a point on the surface.
It's solid underneath here.
So you can just pretend that this is a solid and you have air here.
Now we quickly mentioned or we briefly mentioned the normals or what a normal is of a surface.
And again, a normal is a something that is pointing directly out from some surface.
So like the blue vector here is normal to the palm of my hand, right?
The other two vectors are tangent to my hand.
They are not normal, right?
So pointing directly out from some surface, that's the normal.
So let's let's let's visualize some normal.
So if you have this surface, again, the normals point directly out from the surface.
So the normals along the surface would like kind of continue like this, right?
And then you get a vector like that and so forth.
You imagine these have a length of one.
So these are the normals of the surface.
So let's think about this point in particular.
And let's draw the normal.
The normal is going to be very large because our circle is very large.
So this is the normal.
Let's call that and now we have the normal of a surface.
So here was a problem that I had when I was working on a game back in the days.
If you have a surface and then you have an object for some simplicity sake,
let's say we have a have a sphere or a ball or whatever.
And this object is moving at some speed and it's going to hit the this ground
and then bounce off of it, right?
Okay, cool.
It can bounce off of this surface.
Now you want to play an audio clip.
So let's say you want to play some audio clip.
There we go.
That's my audio clip symbol because you have an impact sound.
You want to make a clonk sound when the ball hits the ground or something.
And now the question is, what is the volume of this sound?
Like how loud should this be?
How would you solve this problem?
So now we're getting into like trying to figure out, okay, if we are moving very quickly,
then obviously we want it to be louder than if it's not moving quickly, right?
If it's moving very slowly, hits the surface, then we might not even want to play a sound, right?
Okay, so let's just think about this some more.
So maybe volume is just the speed of the object, right?
Cool.
All right, we got the volume equal speed.
But consider this case.
If you erase these.
All right, so we have this ball.
Let's say we throw this one down, straight down at some speed.
Let's say it's the 10 meters per second.
And then we have another ball that's at a very low angle and it's going to hit the ground at the same speed.
So we want this one to be louder than this one, right?
Because obviously this one is going to make a very hard impact on the surface.
Whereas this one is not going to make a very hard impact.
Like it's going to mostly going to grace the ground and then do a little bounce, right?
So now we have this issue of like, well, it's not just based on speed, we have to do something else, right?
Okay, so what can we do?
So what we can do is that we can use the normal of the surface to figure out how quickly is it moving toward the surface?
Because that's the key thing that we need to know, right?
So let's bring out the normal again.
So the normal represents the direction of the surface, right?
And what can we then do?
Well, we can think of these arrows here as our velocity vectors.
We're going to get into more physics later.
But you can sort of represent velocity as a vector.
So basically each component, like x says how quickly you're moving along the x-axis and y is how quickly you're moving along the y-axis.
So okay, so how does a dot product come into this?
Well, what we can do then is that if you imagine this normal here, we have the velocity vector here,
and then we can project this onto this line, right?
Again, the dot product gives us the projected distance here.
And then we can do the same thing here, right?
We take this one, do the dot products, and now we get this distance right here.
So even though I guess pretend this arrow is as long as this one.
But the point is that now using this normal, we can get speed in this direction rather than speed overall, right?
Getting the length of the velocity vector is your overall speed,
but it doesn't say what the speed is in the direction of the surface, right?
But that's what we're interested in.
If you're moving directly toward the surface, it should be really loud.
If you're moving really fast, but you're not really hitting the surface fast,
you're kind of moving fast just tangentially, then we don't want it to be loud.
In this case, every time you have some object that is hitting some surface,
this object is flying onto the surface, then we can just do the math.
If this is the velocity, we project this onto the normal vector,
and then we get a magnitude here for how loud this should be, right?
Okay, so let's try a different direction.
Another ball that's flying in this direction.
Well, if we do that, then we're going to get a vector like this.
And when we project this one, it's not as loud, right?
Because now we're only using this span right here.
And this is much shorter and a much smaller volume.
So what we're getting is the speed along a specific axis.
So we get the speed along the normal.
That's what we're getting when we do the dot product
between the velocity vector of the object and the normal of the surface.
Yeah, so long story short, you need the dot product, basically.
Yeah, so that's one use case.
So that's what I've used dot product for, for instance.
There are millions of use cases for the dot product, but this is just one of them.
Yeah.
Do both of these vector need to be normalized before using the dot product?
No.
So specifically here, it's very important that the normal is normalized
and that the velocity vector is not normalized.
Because we do want to, the longer the velocity vector is,
the faster this object is moving, right?
So if you imagine the one that's moving downwards, that's this velocity vector.
If it's moving faster, we want it to be louder, right?
So that would still project onto this line here.
And then we get this value here.
So we still want it to be louder.
So we don't want to normalize the velocity vector.
We do want to normalize the normal vector though.
Otherwise, we're not going to get things that are in meters per second anymore.
And it's not going to be a correctly projected speed along an axis, right?
Can you post that image here?
Yes.
All right.
Let me just complete this because I kind of left this incomplete.
Okay.
So a better way is something along the lines of volume equals the dot product.
Between the velocity and the normal.
There's some caveats here.
So if you remember how the dot product works, these values are going to be negative.
So you have to make sure that they're positive.
You might want to multiply them to change the overall loudness or whatever.
Yeah.
But again, the dot product is a scalar.
If it's negative and you don't want it to be negative,
then you can just do the absolute value of that, right?
So getting the absolute value of this would get you some volume.
But the core concept is that with the dot product, you get a projected velocity along some axis.
In this case, the axis was the normal of the surface, right?
Was that clear, by the way?
Yes, I can post that image in the discard.
Actually, let me write some notes to make sure.
It's a little misleading to say speed because speed is generally not signed.
It's pretty much always positive.
So I'm going to put that in quotation marks.
Oh, people are talking about the cosine.
Yes, the dot product has a very intimate relationship with the cosine,
but we haven't done trigonometry yet.
So we're going to do trigonometry later.
Okay, yeah, let's post this in your discard.
Geez, when people are skipping ahead of your math class
and spoiling what's going to happen in the next chapter.
Yeah, I can just show you another example of the dot product if you want to see.
In game this time.
So here's another use case for the dot product.
So I'm working on this game.
This is called flowstorm.
So right now, another thing that I used the dot product for
was the pitch of the thruster of this rocket.
So if you listen to the rocket here,
you can hear that the pitch is changing depending on what's happening.
You can hear that it increases in pitch.
So far, no dot products.
If you move fast, we increase the pitch.
If you move slowly, the pitch is lower.
It's sort of the same thing with sliding.
You can hear the pitch change depending on if you're moving quickly or slowly.
So the thing that I'm using the dot product for
is that if you are accelerating and you're turning the rocket left and right,
actually let me zoom in,
then the pitch is going to be different.
It's not just based on speed.
So if you listen to this while watching the rocket,
like even if I'm moving, sometimes when I turn the rocket,
the acceleration or the pitch goes down again,
even though I'm moving fast, right?
Yeah.
So basically what I have done is that,
actually let's go to the level editor instead because there's more space.
No level editor is currently broken.
That's okay.
We can have no refs in the console.
So if you listen to the rocket now,
we're moving faster and faster sideways,
but then I look up.
You can hear that every time I turn,
where the rocket is now perpendicular to the velocity vector,
the audio will now change pitch because what I'm really interested in
is how quickly is the rocket moving in the direction you're pointing.
That's the crucial thing here.
So in this case, what I'm doing is that instead of a normal direction,
I have the direction of my rocket, right?
So I have this vector right here.
This is the direction.
And then I have the velocity, right?
The actual velocity vector for how quickly you're moving in that direction, right?
So the actual velocity could go in either direction, right?
It could be in this direction.
It could be along this.
It could be opposite towards it, right?
Yeah.
So that way I can get the speed in the direction of the rocket,
and then I can use that to change the pitch of the rocket.
So that's kind of it.
That's basically like just depends on how you're moving and then project that
along the direction of the rocket.
And then what I get is what is the,
how much are you moving along this direction?
And that's it.
That's how I got the pitch there.
Sounds like it's the absolute value of the dot product.
Yes.
So that's, that's kind of it.
Do I use the dot product for something else?
I do use it for the impact sounds.
Just like I mentioned before, this is the game where I did the impact sounds.
So when you hit the surface, there are little sounds that play.
That one is based on the dot product just like we talked about.
Yeah.
Otherwise there are many like placeholder sounds like when you crash.
That's a placeholder sound.
So there's a lot, a lot of stuff that I haven't done in this game, but,
but yeah, otherwise that's how it works.
Peter.
Oh, someone asked about the lighting in this.
No, the, the lighting is not the Unity's built in one.
I wrote my own custom lighting system.
Here's some lighting buffers if you're curious about how my lighting system
works.
The, the first lighting buffers kind of self-explanatory.
The, the other three are a little less altering.
Oh, I also use a dot product for the water physics.
So underwater, I kind of want you to be able to turn the rocket and that would also change
direction of the rocket.
Again, you do stuff with the dot product and the direction you're moving versus the
direction you're pointing.
And that way you can make the rocket sort of behave as if you have drag underwater.
Right.
Yeah.
Otherwise, I think that's it.
Unless you have more questions.
Now I'm going to try to figure out what assignments to give you.
Yeah, I'm just going to, I'm just going to have a slow Q and A thing while I figure
out the assignments.
All right.
I got two out of maybe three, four assignments.
I haven't decided how many yet.
Be gentle.
I mean, we've mostly gone through a lot of like fundamentals right now.
So I'm not going to do something like super advanced.
What are these assignments do?
I have no idea.
I think Christa is going to do all of the, all of the assignment stuff.
He's also going to be correcting them.
So I'm just going to do the, I'm just going to make assignments and then Christa can decide
everything else.
And also Christa is going to be doing the, he's going to do the grading and whatnot.
Okay.
There we go.
Assignment one is now ready.
I'm going to reveal all the assignments as soon as I'm done writing them.
Oh, I just, assignment two has a thing we didn't talk about today.
Isn't that spicy?
I presume all of you know what transform.forward means or transform.write because those are
going to be relevant.
But I presume you've done that already because you've been using Unity for a while.
You don't have to be a student to see them.
I will show them as soon as I'm done writing them.
I know it's now for the assignments.
I'm going to draw more specifically.
I know you can't see right now.
I'm going to draw what the assignments are going to be.
A lot of these concepts are probably going to be very easy if you like rewatch the stream
and whatnot.
So like it's mostly about, I want you to get some practice in actually doing the assignments
and practically writing code that does the things we've been talking about.
Cause that usually helps you like solidify what we've been talking about.
So like try not to copy code from each other unless you really, really have to.
So like try to see if you can do it on your own at first because that's kind of a better
way to make sure that you've learned the things you need to learn.
Otherwise, of course, look things up if you need to.
But it's always good to make sure that you actually know what you're typing.
If you're not sure what you are doing when you type vector two dot dot, like you should
know what is happening when you do that, which you might not if you just copy someone else's
assignment, right?
Cause again, my goal is for you to learn what these things are.
I don't care if you do the assignment or don't do the assignment or copy code.
I don't care, but I want you to learn.
I want you to learn the things that are important to you.
But then again, I'm not going to do the grades Krista probably carries if you copy or cheat
or whatever.
And if you do them at all.
Okay.
All right.
I got the assignments.
Here we go.
I'm going to draw these so that it's like very clear what they're doing.
And I'm going to post both the pictures and the text for it.
Assignments.
Number one.
Yeah, I don't, I think the, the assigned, the date for these assignments is probably
going to be much later as in, you don't have to do them tomorrow.
If you do them tomorrow, that's going to be good because then I'm going to cover these
assignments at some point.
And so it's probably good if you done them before that.
If you want to like maximize your learning, but if you're stressed, then this is, I mean,
don't stress yourself out.
Okay.
Cool.
First assignment.
Re-create the radial trigger.
So this is the thing we made on-screen.
We, we had a trigger that had some radius, right?
There we go.
It's got a radius.
And then we want to detect whether or not a point is inside or outside, right?
Based on this trigger.
And the trigger should be able to be anywhere.
You need to be able to move the trigger around.
You need to be able to change the radius.
And it should still be able to detect whether or not this point is inside or outside, right?
So, so that's all you need to do really.
Like it's inside versus outside.
And you can do all of this is on drug in on drug gizmos.
You don't have to make like an actual update loop or whatever.
Just do the dude and on drug gizmos.
The point is, I want you to like try this out yourself and make sure that you've actually
like, you can do the concepts that we've been talking about, right?
So recreate the radial trigger is the first assignment.
Can it be moved and seen only?
You don't have to animate anything.
It doesn't have to be in play mode.
Just the same way we did it on stream.
Just like make sure that you know the mathematical concepts.
But like, you don't have to involve like physics or rigid bodies or gameplay or anything like that.
Just to make sure that like, you have the idea of detecting whether or not something is closer to something or not.
Right?
Yeah.
So that's one way of doing it.
Or that's the first assignment.
So assignment number two.
So previously we, the radial trigger kind of checked like, you know, are you inside of a trigger or outside of a trigger?
Right?
And that is based on the radius.
But now I want you to make another trigger.
I feel like I had a name for this.
Actually, I just renamed it.
There we go.
That's rebellious I am.
So the next one is that I want you to make a look at trigger.
Okay.
So basically, you have a similar thing here.
You have a, actually let's name this player.
There we go.
Player objects.
Another player.
Cool.
So then we want a look at trigger.
So in this case, if you have the trigger at some point, and then the player is looking in some direction, we want to be able to detect if you are looking toward this trigger or not.
Right?
So that's what this one is for.
So if you are looking at this trigger, you want it to be true.
If you're looking away from it, you want it to be false.
Right?
So this one should also, you know, this one has a radius that you can modify to set the threshold of this.
The look at trigger should also have a threshold from zero to one.
So let's see.
Actually, let me move this down because I need to clarify a few things.
All right.
The threshold from zero to one.
And if the threshold is one, that means that it's going to be very strict.
Probably impossibly so.
Because you're probably never in practice because of like floating point imposition.
All right.
So one is super strict.
And this is a floating point value.
You can set it to 0.5 and everything.
All right.
And then we, if it's set to zero, that means that, so perpendicular or closer means you're at it.
There we go.
So this is the threshold.
So you should be able to, if this is set to one, you have to look like exactly at the thing.
And it's going to count as triggered only if you look exactly at it.
Because of floating point precision, that's going to be like pretty much impossible.
Never going to happen.
But if you set it to like 0.5, it should allow you to look a little bit away and still count as looking at this thing.
But then as soon as you are looking away from it, like this, that should not count as looking at it.
So basically, this threshold should set how sensitive it is.
If it's a one, it's hypersensitive.
You need to look exactly at the point.
If it's zero, it's not very sensitive at all.
If you look in this direction, it's going to count as looking at the thing.
Yeah.
That's about it for number two.
Oh, and to clarify.
We haven't talked about angles yet.
So this doesn't involve angles.
None of this is angle-based.
This is still just vectors.
All right.
And let's do the third one.
Still just vectors.
Yeah, angles don't exist.
You've never heard of angles.
This one is smaller.
Okay.
Heck, I'm trying to figure out how to draw this one without spoiling the solution because this is kind of difficult.
So this is the one we're going sort of toward concepts we haven't talked about yet.
But that's a little teaser thing or something.
So let's say this is the origin of the world.
Like this is zero, zero.
And then you have an object in unity that has some orientation, right?
So usually in unity, you would have this gizmo that looks something like this.
And then you would have the z-axis pointing sort of toward the camera.
And then let's say you have a point.
There we go.
Okay.
And then you have this object.
Let's call it object.
So this one is I want you to make a transform function to transform world to local and local to world.
Cool.
Okay.
I want you to have a transform in the scene that has some rotation and a position.
And I want you to write a function that can transform this point either into local space of this object or from local space of this object to world space.
We haven't talked about spaces yet.
So that's why this one is a little bit of a curveball.
But I'm sure you sort of understand the concept of what it means for something to be local space or world space.
So that's what I want you to do.
And you're not allowed to use unity's transform functions in order to transform this point.
You're not allowed to use matrices.
You're not allowed to use transform dot transform points.
Not allowed to use those.
Those don't exist anymore.
So you need to do this using vector math and dot products.
That's what you need to do.
Right.
Yeah.
You can still use transform dot writes transform dot up to just get vectors and whatnot.
But you're not allowed to use the transform functions.
No, you don't need to use quaternions.
This is possible using only the things that we have talked about.
Oh, yeah.
This is 2d only.
We don't need to care about 3d yet.
So yeah, 2d only.
I don't know where to fit that in.
I don't think I get the goal of this.
You need to be able to transform a point from world space to local space, which means that you need to figure out where a point is.
So if you look at this point, for instance, this is really hard to explain without spoiling the whole thing.
If you look at this point here, if you consider the coordinate of this one in world space, well, it's this vector, right?
And then you have an x coordinate.
You have a y coordinate and so forth.
But making a transform function means that you should be able to take this point in world space and transform it to this space.
As in, I want it to be relative to this object.
So now I want the x coordinate and the vector and everything to be based on the local space of this thing right here, right?
Yeah, and it should take rotation into account.
So it's not just position.
You can ignore scale. Scale doesn't matter.
But it has to take rotation into account.
And you can do this using only the concepts that we've been talking about.
You don't have to do anything outside of that.
In fact, you're not allowed to use matrices or the transform dot transform point functions.
You need to do this with vector math and dot products.
If I move the point to the position, it would be under the new appearance, facility move point being world space.
You mostly just need to get the coordinates.
How you make it in the scene or how you move them around doesn't really matter.
You just need to be able to get those coordinates.
But how you visualize that or whatever is a separate thing.
You need to be able to get a point relative to a different space.
So what I mean by that is that if you ignore these lines that I used to draw, you just need the coordinates of this one.
If you pretend that this right here is world space or whatever, because that's what you do.
Basically, you want to get this point relative to this space.
That's it. And also the other way around.
And just parenting objects and getting their location defeats the purpose of it.
And the reason I call this a curveball is because we haven't talked about space transformation yet.
That's the only reason. Otherwise, the ways to do this only talks about everything we've been,
that you only need stuff we've been talking about earlier.
You can use transform.forward, transform.forward, transform.right, transform.up.
You're allowed to use those. You're just not allowed to use the space transformation functions.
Because the whole idea is that you need to do the space transformation yourself.
Okay. All right. I think that's it. Those are the three assignments.
Oh, yeah. If you want to join my Discord for my streaming shenanigans, feel free to hop into Discord.
We're a bunch of game developers. A lot of us are under the LGBT umbrella.
So it's sort of like a Venn diagram overlapping those two things.
So feel free to join Discord. Let's see.
I'll post this in the math channel that seems appropriate.
For the transform from world to local, is it okay to use a child object for output?
Oh, if you just wanted to test your code to see if it works, sure.
But you could do it if you want, just using gizmos so you don't have to use actual objects or whatever.
Okay. My voice is dead. I need to stop talking and I need to stop streaming.
But thank you all so much for joining. I hope this was useful and that this has helped you learn something
or get a refresher on things. I don't know. I hope it was useful.
