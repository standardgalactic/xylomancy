Hey everyone, welcome to yet another episode of my video series on Joshua Bloch's Effective
Java where I take the items enumerated in this book and expand on them and try and make
sense of them and hopefully as I do that you learn something and gain some value from it
too.
Today I gotta say we're in item 9 as the title suggests but I gotta kind of, I'm sorry to
be a bit self-aggrandizing and self-indulgent here, I gotta give myself a pat on the back
because I'm actually quite proud of myself that I got through the first chapter because
the first chapter which was, wait, what was the first chapter?
Yeah, sorry, well chapter 2, the first chapter was introduction, I really skipped that bit
but creating and destroying objects, got through the first chapter, this is the final item
and then we move on to chapter number 3, methods common to all objects and I feel good.
I'm learning so much and really enjoying this a lot more than I thought that it's way
way better than just reading the book, trying to explain it and expound on what's highlighted
in the book, it's really beneficial and it's great, I'm really happy about this, anyway
enough of that, without further ado let's get to the introduction, as per usual if you
have been following along in these episodes please do skip this bit, I want to save you
a time because I'm just gonna repeat, whatever I've been saying in all the other videos and
the first point in this proviso slash introduction is that this is not a tutorial, I'm not a
teacher or an expert so if you're new here, if this is the first video you're watching
please do keep that in mind, if you've been following along you probably can already tell
that I'm not an expert because you can see me making mistakes live and trying to make
sense of things, therefore this is not a typical tutorial where you should just take
whatever I say as gospel truth despite me following this book, it's still, I could
make mistakes in interpreting what Joshua Blok has stated here, I like to think of this
as a expulsory disquisition or the blind, living the blind as I say it, I'm trying to make
sense of a topic for concept, sometimes pertaining to Java but sometimes pertaining to programming
in general and I am as blind or perhaps even more blind but the point is I'm as blind as
you are or perhaps even more, therefore I will inevitably make mistakes so please point
them out as some people have in the previous videos, I'll try my best to use forums as
if you've been flowing along things like Stack Overflow or Reddit to ask questions and then
not to make the mistake in the video itself and rather make the mistake when I'm preparing
for the video and then rectify those mistakes but I'm sure I'll make them in the videos
too so please do point them out and of course since this is a programming video series it
only makes sense to have all the code used up on GitHub so I'll leave the links down
below to my GitHub repository but not only that even Joshua Bloch's public official
repository for this book and definitely a lot of stuff in my repository, I've taken
this code and repurposed them to make them a bit more demonstrable let's say, like that
let's get to item number 9, the last item in this chapter and that is prefer try with
resources to try finally and this is since Java 7 I believe the try finally was introduced
and now the proviso on this item specifically it's in fact better to go through item 8 before
going through item 9 so if this is the first video you're coming across in this video series
of this book or if you haven't read the book at all just kind of curious about it I would
say you know specifically for this item it's better to get an understanding of what he's
talking about in item 8. Saying that though before I get to kind of the crux of the matter
let's just read, I'm going to read a bit from his introductory paragraph in this item. Joshua
Bloch states the Java libraries include many resources that must be closed manually by
invoking a closed method and that exact sentence the first sentence of this item is exactly
why I said it's probably a good idea to go through item 8 so do watch that video before
watching this if you haven't watched it already or if you don't know the idea of closing resources
in Java. I continue closing resources is often overlooked by clients with predictably dire
performance consequences while many of these resources use finalizes as a safety net finalizes
sorry I read that too fast I'll read that again while many of these resources use finalizes as a
safety net finalizes don't work very well as he highlights an item 8 sorry to keep beating on a
dead horse here but I really want to make that point clear so it's quite straightforward what we
have here on line number 14 right here is simply a buffered read instance being created and that
object being stored in this br variable and then we're trying to read off that object using the
read line method that's in buffered reader and then if it fails what happens is simply the finally
block would just take care of there a cash there and then close that resource because we don't want
to leave that resource without being closed by any chance and exception is thrown we want to reclaim
that memory so yeah there's really nothing much to talk about this code if I do run that you'll see
it's reading from this nature text I've got and it quotes without life sorry without music life
would be a mistake that's the first line in this text file and it's right Nietzsche is right without
life indeed sorry without music indeed life would be a mistake but that's the try finally block
that would typically be used before the try with resources block was introduced so I was thinking
about this a bit and I think I misspoke by using the word catch in fact there is no catch that's
the problem in this try finally block in this part of the block in for instance where you're
reading off the buffered reader if an exception is thrown we won't decline of this API to know
that an exception is thrown however what happens is because in the finally block it just simply
closes the resource we don't have a stack trace there's no record that there was an exception
thrown when trying to read a line of these of this buffered reader instance it'll just close
the object and that's it so it leaves no record that something went wrong and that generally is
bad practice in programming and to make matters worse if we take a look at the other example
Joshua block is given it's using two try blocks it's a physical it's a very verbose code and it's
really confusing to read but essentially what he's trying to do here is read off a input stream
and then write to another file by an output stream and you can see there's a nested try statement
inside it and what happens here is again as I said apart from the code being a bit let's say
not very aesthetic in a case like this where there are nested try blocks let's assume in this
section here line number 18 to 22 in the writing an error is thrown and that's enough so the writing
is done in this out object that was created via the output stream and then that resource is closed
fine but an error is thrown something goes wrong and the resource is closed and then this
resource is closed too what happens is this block will suppress the stack trace of this block we
will have no record that something went wrong here and that will make debugging a nightmare we all
know infamously that most time is spent by programmers debugging code on runtime generally and if we
don't have a proper stack trace if we don't have proper information where something fails or an
exception is thrown that can make things very complicated and that's the one of the other
problems apart from it being verbose and ugly that we shouldn't use this kind of nested try
finally statement which is why just to I guess bring it more formally in a bit more eloquent way
Joshua Block states and he makes the statement pertaining to this line this code here but also
I'll propose the previous top line code that I showed he states it may be hard to believe but even
good programmers got this wrong most of the time and then he goes on how he made the same mistake
in a book he wrote called java puzzlers then he states the code in both the try block try block
and the finally block is capable of throwing exceptions for example in the first line of file
method so that would be the method here the call to read line could throw an exception due to a failure
in the underlying physical device and the call to close could then fail for the same reason so
there could be an error here sorry apologies there could be an error here in the read line
in line number 16 and then even the closing would also cause another exception because errors can be
thrown in try blocks and finally blocks both as I read before and the call to close could then fail
for the same reason under these circumstances the second exception completely obliterates the
first one there's no record of the first exception in the exception stack trace which can greatly
complicate debugging in real systems usually it's the first exception that you want to see
in order to diagnose the problem while it is possible to write code to suppress the second
exception in favor of the first virtually no one dead because it's just too verbose
I may have said something that was completely wrong before as I reread that paragraph I was
looking at the previous on a code and I said that an exception thrown here could be suppressed by
these exceptions I don't know I think I think that's a lack here in the the point still stands
because exceptions can be thrown in the finally blocks too whatever that's thrown here will be
obliterated by these other exceptions thrown in these finally blocks too in this case when
closing these objects so the point still stands the point the point still stands I wasn't
missing any money if I was pleased to point it out I really hope I didn't push it there
and due to these inherent problems with try finally java 7 introduced try with resources however
before we get to that before we discuss what try with resources are I realized
I didn't discuss a bit of theory I got lost in the code got a bit excited by the code as per
usual I am a programmer for all I think it's worth discussing what closing resources resources is
sorry that was like a bit of a tongue twister it's worth discussing what is closing a resource
before we get to the try with resources part because they're quite tightly related
so what is closing a resource it's pretty simple when we create a new object when we have the new
keyword and we create a new object that object takes up memory and either when an application
no longer requires that object again this is why I said to refer to item number eight because we
go a bit deeply into item in fact item seven and eight both we discussed this idea so there's a
bit of flow to the items in the book even though just your blog stating in the introduction that
all these items can be understood distinctly and individually of course they're interrelated
because after all we are talking about a broader programming language and a programming paradigm
so getting back to the point I keep going off on tangents when an object is created that object
takes up memory that's simply taking up resources and either when that object is no longer required
by application or when an exception is thrown by that object like for example when reading a line
that could be an exception that resource must be closed and that memory must be released to
be used for the things by jvm and it's simply cleaning up after you're done it's just good
etiquette good hygiene even in real life and that's simply what it is and of course a lot of this can
be done with the garbage collection in with the jvm but of course at times it has to be done
explicitly and manually by a programmer so I ended up asking of course I've been doing this like
every other person these days I've been asking uh ask chat gpd uh what is closing the resource in
java and here's what my programming buddy uh and told me what this is uh sorry I just kind of I was
like having a moment I was like this is amazing where I've really been using chat gpd quite a lot
at work and just asking questions and getting help with code it's it's like an advanced evolved
version of stack overflow so according to chat gpd in java closing a resource means that you
are releasing any resource that the object was using I agree mr chat gpd mr I shouldn't generate
whatever man woman I want to be uh uh inclusive here this is typically done by calling the close
method on the object that represents the resource for example if you have an input stream like we
do in that method object that is used to read data from a file you would call the close method
on that object to close the file and free up any resources that were being used by the industry
and then a bit more formal definition on closing resources uh by the oracle docs this is a pretty
old article it's in fact called better resource management with java seven and that was released
a while back uh julian ponch states um the typical java application manipulates several types of
resources such as files stream sockets and database connections such resources must be handled with
great care because they acquire system resources for their operations thus you need to ensure that
they get freed even in case of errors indeed incorrect resource management is a common source of
failure it's common source of failures in production applications with the usual pitfalls
being database connections and file descriptors remaining open after an exception has occurred
somewhere else in the code so similar similar to the example that we were looking at you know reading
reading off a file this leads to application servers being frequently restarted when resource
exhaustion occurs because operating systems and server applications generally have an upper bound
limit for resources of course because at the end of the day the software still runs on hardware and
it's still a limited domain or we have limited resources as to how the what we can do with the
software even though perhaps that's changing now with cloud computing and all that uh anyway
another tangent man i can't help myself my mind goes everywhere um so and as i say that historically
resources were closed with the tri-finally and then java 7 introduced tri-width resources
i should have read this bit a bit uh somewhat earlier in this item on in the video but it's okay
we got across a point so this is where this is the solution so this tri-width resources is the
solution to the pitfalls of tri-finally and again another formal definition
by yorka docs the tri-width resources statement is a statement that declares one or more resources
a resource is an object that must be closed after the program is finalized with it i feel like
we've we're repeating that point a lot now i apologize for being just repetitive but that
really helps for that idea to get settled in your your mind let's say if that's how cognition works
the tri-width resources statement ensures that each resources
each resource is closed at the end of the statement yes we shall see in code the example let's just
get the theory out of the way any object that implements java lang auto-closable again this
bit was covered in item a so please do watch the previous previous video which includes all
objects which implement java ioclosable can be used as a resource so similarly also in the
book joshua book states to be usable with this construct what he means by this construct is
using tri-width resources a resource must implement auto the auto-closable interface which consists
of a single void returning closed method so here are the examples the first one is
this not the top line that was a mistake first one using tri-width resources i believe is
this one here
yeah that's it for now just ignore this catch bit we'll get to that a bit later but essentially
as you can see in the resource in the tri-statement itself these objects are being created is that
the correct one yeah that's correct one in the tri-statement itself uh the reason i'm looking
at the book is because i took this code off the book and repurposed it um yeah so in the tri-statement
itself the object is being created uh and then within it we we run the read line method
and if there's an exception it can be it can be suppressed and in this case you can probably see
two objects are being created that was a mistake i should probably move it here so that it's easy
to see but we're creating two objects the file reader and the buffered reader and the point
joshua book states and i shall read it out a bit later is that if an exception is thrown
over here in the new buffered reader and then another one is thrown over here this won't
obliterate the stack of the error or the in the stack trace the what indicates that an
exception was thrown this won't obliterate that we could suppress the exceptions and
in the stack traces it even states that an exception was thrown uh
before above the tree i'm trying to think of the word here but an exception was thrown before
the stack trace will indicate that um and then there's another example
where he's using the try with resources or he's using multiple resources you know these examples
are a bit confusing i wish he put a bit more comments in them um so this is the other example
he hopes sorry that's a wrong one this is the other example where we're creating multiple objects
so similar to the previous example we saw we're creating uh two objects here we're having
the n object and the outer object one is an input stream the other is an output stream
and here's what he states firstly uh again this point relates to the two examples i showed you
not only are the try with resources versions shorter and more readable than the originals
but they provide far better diagnostics and this is the point i was trying to make
and i made quite badly in fact here's what he said so hopefully this will make a bit more sense
consider the first line of five that would be this let's consider that
method the first line of five method if exceptions are thrown by both the read line call
which is oh it's going to be invisible in this case sorry uh the read line call is here but
there's also a closing of resource that takes place oh so that's really important right so
i'll read the sentence and then then try and explain what what he's he means here if exceptions
are thrown by both the read line call so the read line here and the invisible close the latter
exception is suppressed in favor of the former so in the try with resources uh block an automatic
closing of the object does take place we don't have to do it explicitly so we don't see the close
happening but these objects that were created are in fact closed and then he goes in fact multiple
exceptions may be suppressed in order to preserve the exception that you actually want to see these
suppressed exceptions are not merely discarded they are printed in the stack trays with the notation
saying that they were suppressed so that's important um this is what i meant by the fact that
depending on where the exception is thrown in the tree uh you you can decide which one you want to
see and in fact i asked chat gpt again how do we do this and here's what chat gpt said uh
apropos try with resources to print the suppressed exceptions on the stack trace you can call the
print stack trace method and that does work i looked up a few examples i'll leave links down
below on the first exception that was thrown and passed through as the argument this will
print the stack trace of the first exception along with the stack traces of any suppressed
exceptions so we don't want our logs being too verbose and to pollute it we can have it suppressed
but if you want some extra diagnostics or additional information we can use the print stack trace
method pass through to it and get that information that's the point and then he says of course we
could have a catch statement here where we could do whatever with this exception either throw it
throw it and let the client know or return some kind of default value um i've even done that in
the other example too wait you don't know that one i think the top line example so in this case see
i'm printing the stack trace so here if i want all the suppressed exceptions all i gotta do is pass
true and that's an error remove redundant argument interesting oh perhaps it probably is a case that
this was pertaining to Java 7 you don't even have to pass through i guess oh perhaps chat gpt was wrong
there i don't think so because i did see a few examples where you are people are passing through
onto the print stack trace i'll look into that and leave some links down below uh so this will
print the whole stack trace and tell exactly where the exceptions were thrown uh and that's a great
thing about using try with resources because you could catch the exception you could print the
stack trace and as Joshua Block has shown in his example you could even once the exception is caught
maybe return some kind of default value and not end up breaking the whole application
and okay putting putting more formally he states you can put catch closest on try with resources
statements just as you can on regular try finally statements oh i probably made a mistake and said
that you can't do that in try finally of course you can because we can have try catch and then
a finally uh this allows you to handle exceptions without selling your code with another layer of
nesting and then to conclude he states the lesson is clear always use try with resources in preference
to try finally when working with resources that must be closed the resulting code is shorter and
clearer and the exceptions that it generates are more useful that's it that is the end of chapter one
and the end of that item uh and then in the next chapter as i did state before we're going to move
to chapter three with it which is methods common to all objects i apologize if i did a bit of a
i'm not i always feel like i don't do a good job at explaining these concepts a lot of that is
because i'm learning a lot too but this seemed like quite an easy item that i
struggled quite pathetically to explain um hopefully the comments i've left in the code
and even the resources i leave will help you supplement what i'm doing in this video in some
way um and of course the best thing you could do is read the book but i don't know a lot of people
prefer watching videos than reading so hopefully this video can be useful because of that in any
case enough self-flagellation i hope you enjoy this video thank you for watching i shall see you in
the next one cheers
