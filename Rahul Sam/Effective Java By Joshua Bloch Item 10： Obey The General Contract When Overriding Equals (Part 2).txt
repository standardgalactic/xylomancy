Hey everyone, welcome to part two of item 10, obey the general contract when overriding equals
of Joshua Bloch's effective Java. Needless to say, please do watch part one to make sense of
this item because it's just a follow on from from part one. And I'll be working down this
item into multiple parts because it's quite long. But without further ado, let's get started because
this is quite a long part. So in the previous part, we discussed when it's appropriate or warranted
to not override the equals method. Generally, it's always a good idea to override the equals method.
However, there are certain instances where it's not required. And we discussed that in part one.
And in part two, today, we're primarily going to focus on when is it appropriate to override the
equals method. And afterwards, kind of kind of gonna, we're going to go into detail as to what
the general contract is. So firstly, I propose when it's appropriate to override the equals method,
Joshua Bloch states, it's appropriate when a class has a notion of logical equality
that differs from mere object identity. And a superclass has not already overridden equals.
So we did discuss what logical equality was in the previous part. But for all intents and purposes,
as a Java programmer, what we care about is in logical equality, a programmer doesn't care about
the memory reference or the the quality of the object per se, but rather the content or the
value of an object. The easiest way to put that is by looking at classes such as string or integer,
where if we take, in fact, string, string objects are mutable. So there's only one object of this
type that exists in memory and everything else will point to that. So in this context,
when it comes to logical equality, what we care about really isn't the object per se, whatever
the data of that object is, however, the value of the object. So we should only care about this bit
here. And that means it's logical equality. So if you have string s, and then if we also have, let's say,
that was a mistake,
a string b, let's say, both these strings, s and b have logical equality because the content is the
same. So these classes have a notion of logical equality. And then he states, not only is overriding
the equals method necessary to satisfy programmer expectations, it enables instances to serve as
map keys or set elements with predictable desirable behavior. And then he adds an ancillary point
saying that enums or enum objects are an exception to this value class heuristic. I coined that
term value class heuristic. He doesn't really use that term. But I feel like to understand the concept
of logical equality, apropos Java programming, that is a good heuristic to keep in mind.
So enums, though, are an exception. That's what he states. And just to get some formalities out of
the way, let's say, according to the Java language specifications 8.9, here's how an enum is defined.
An enum type has no instances other than those defined by its enum constants. It is a compile
time error to attempt to explicitly instantiate an enum type. The final clone method in enum ensures
that enum constants can never be cloned. And the special treatment by the serialization mechanism
ensures that duplicate, duplicate instances are never created as a result of deserialization.
Reflective instantiation, so that's from the Java reflections API, reflective instantiation of
enum types is prohibited. By the way, what that API, the reflections API does is it changes the
structure of classes on runtime. It is not something a normal Java programmer would do.
It's mostly used by framework designers. So I've never used a reflections API,
but it's just good to keep good to keep in mind what what it does. Anyway, getting back to the
definition. Sorry for like interrupting it. Reflective instantiations of enum types is
prohibited. Together, these four things ensure that no instances of an enum type exist beyond
those defined by the enum constants. So and again, attending to our point, it's for these classes,
so enums, logical equality is the same as object identity. So objects equals method functions as
logical equals method. What that would mean really is if let's say this S and B were enums,
if the objects were identical, we could say for all the types and purposes,
there's also logical equality. So here's a small demo. Let's take a look at it that I put together.
So I have two enums here, day and day two, both have days of a week. Now if I do run this,
it's going to print false because there's no logical equality in this case because there's no
object identity. However, let's say I create two instances of a day, day dot, is it was it Monday?
Yeah. And then I also create another day two with the same thing, with the same day. You'll see here
if I print this out, if I do compare these two objects, it'll print true because the logical
equality here equates to the object identity. So I'll just go day one,
day two, I'll comment that out, you'll see a true being printed now.
That's it. So the object identity equates to the logical equality, and that makes sense.
So reiterating that point, so the idea really settles in our mind,
overriding the equals method is required or is appropriate when logical equality
differs to object identity. Now I accept the enums class of course. Whenever we know that
object identity is not equate to logical equality, override the equals method. And that gets us to
the general contract when overriding the equals method. And that's what we're going to discuss
for the rest of this part. And in fact, the next part too. And there's a lot to get into here.
All right, before we get to the properties that define this general contract, I need to skip ahead
a bit and read a caveat that Joshua Block has put in. Because in fact, I wish you would have put that
bit earlier before getting to the properties, because the caveat is a good starting point
in understanding these properties. Because it's really important that we don't ignore them.
They can be a bit overwhelming to understand. Nevertheless, ignoring them isn't the solution,
it's enduring through and assisting and trying to make sense of them and implementing them in our
code. So here's the caveat Joshua Block has put in. Unless you are mathematically inclined,
this might look a bit scary. So what he means by that is the properties that he
listed, listed down or enumerated. But do not ignore it. So don't ignore these properties.
If you violate it, you may well find that your program behaves radically or crashes. It can be
very, very difficult to pin down the source of the failure. To paraphrase John Donne,
is that how you pronounce his surname? D-O-N-N-E. John Donne, probably. No class is an island.
Instances of one class are frequently passed to another. Many classes, including all
collections classes, depend on the objects passed to them obeying the equals contract.
Just on that point, there's a really interesting kind of philosophy in object-oriented programming.
And I think even Alan Kay, the inventor of OOP, he makes this idea that I'm going to,
I'm going to get a book. I was reading this book by Sandy Metz, which is a book on object-oriented
design, but using Ruby. And what she states in this book is that it's better to conceptualize
object-oriented programming more as message-oriented programming. And even Alan Kay,
I believe, said in one of his talks that he wished that people emphasize the importance of
messages between objects than objects themselves, which is the point that Joshua Blocks making here,
all these contracts, all these properties that define these contracts that we ought to respect
and take into account when writing code, they're more about the messages and how objects communicate
with each other. Therefore, it requires a bit of a change of mindset. In any case, I don't want to
get too carried away, but I thought that was an important point to add on to what we're discussing
here. So given that we've got that caveat slash warning out of the way, let's get to the specifications
for the contract. The equals method implements an equivalence relation. It has these properties. So
there are six properties, sorry, five properties. And in this part, we're going to discuss three of
them, especially because symmetry, sorry, not symmetry, transitivity is quite a lone property,
and there's a lot to discuss there. And then in part three, we'll discuss consistency and
non-nullity. However, that's later on. Let's stay on track here. So what is equivalence
relation? And what does it mean to have equivalence relation between two sets?
Look, Joshua Bloch puts it best. Here's what he states. Lucy speaking, so this is pertaining to
equivalence relation, which the equals method implements. It's an operator that partitions
a set of elements into subsets whose elements are deemed equal to one another. These subsets
are known as equivalence classes. For an equals method to be useful, all of the elements in such
equivalence class must be interchangeable from the perspective of the user. Sorry about that
background noise. It gets so annoyed by this because I live in a very quiet neighborhood,
but every time I record a bloody video, there's some noise outside. In any case, so what he means by
for an equals method to be useful, all of the elements in each equals class must be interchangeable
from the perspective of the user means again, going back at the string. From the perspective of
the user, both these objects have logical equality. And that's what necessitates equivalence relation.
Saying that, let's get to the first item or the first property that pertains to the general contract.
Oh, gosh, man. The noise is not ending. Is that a leaf blower or a lawn mower? What the hell is it?
Okay. Pardon parcel of living in a suburb.
Hey, look, I look, I'm not complaining, though. It's way better than the city.
Ah, it ended. No, I didn't. I'm just going to wait till it ends.
I think it ended. Back to it. So reflexivity. Ah,
he's starting. Dude, the guy is trolling me. The guy is trolling me. You know what? I can't,
I can't do this. We're just going to keep going. I apologize about the background noise.
So starting off with the first property, reflexes. See, I got distracted. Reflexivity.
Reflexivity. Okay. What does that mean? What does reflexivity mean? I've got to be really
flexible here right now. So that means for any non-null reference, value x should equate to x.
So it's saying that an object x should be equal to itself, which kind of seems self-evident.
So if we have a x equals x, it must return true.
Which is why, which is why Joshua Block states the first requirement says merely that an object
must be equal to itself. It's hard to imagine violating this one unintentionally. If you were
to violate it and then add an instance of your class to a collection, the contains method might
well say that the collection didn't contain the instance that you just added. So let's take a look
at a quick demo because obviously code makes more sense than theory, even though I personally
always like starting with theory because it really helps to start high level. Where is this? So if we
go to reflexivity, it's really simple as this. So I have a list of strings here. And what we're
doing is we're adding the word Java into that list. So it's a set, let's say, it's a string. And if
you run this, it'll return true because we're just checking if this set, this list contains, using
the contains method that's in the, using the, sorry I bit my tongue, using the contains method in
the object class. It's checking if Java exists in that list. And obviously it does. That's pretty
much what reflexivity is. So the next, it's a hard word for me to pronounce. So the next one is
symmetry. So symmetry states, again, for any non-null reference values x and y, so we have two
objects in this case, x equals y must return true if and only if y equals x returns true. So again,
going back to, I'm going to demo it in a bit, but go back to this here, s, s and b. So string s,
so string s, if we take this equals b, this should return true only if b dot equals
s returns true. So that's what symmetry is. And before we get to the demo, let's just read out
this bit, Joshua Bloch has stated. The second requirement says that any two objects must agree
on whether they're equal. Unlike the first requirement, it's not hard to imagine violating
this one unintentionally. So we have this class here called case and sensitive string. And it's an
attempt to implement a case and sensitive string class. In the class, what we have is we have a
private final string s variable. We have the constructor, which in this case just
checks if the object is non-null, if it is null, it returns a chosen error. And then it sets that
value in our private field here in the class. And then we have the equals method that we have
overridden, which breaks symmetry. So firstly, I'll show the one, but the problem, I'll show
the wrong way to do it. And then we also have another equals method written
below here, which is the proper way to do it. And that'll fix the issue. So let's take a look at
this equals method that we've overridden. So we have two f conditions here in the equals method.
In the first one, what we're checking is if this object we pass is an instance of the case
insensitive class. So that's what we're checking here using the instance of method. And if it is,
then it'll just return true if that. So firstly, we cast that object into case and sensitive string.
If it is an instance of that, let's say a subclass of that, then we cast it to become a case and
sensitive string. And then we compare it to our string field really that we've defined here in
line number 15. And if it is equals in that case, we return true. And that's fine. That's going to
work. But then we're trying to go one step further and attempting to make this interoperable with
a string class. So again, the same way we're checking if this past object is an instance of
the string class. And then we are saying return true if it's equal to a string. And we just cast
it accordingly. And this is what breaks the symmetry. And I'll show you what that means. And
of course, this line here, if it doesn't meet all these conditions, it'll return false.
So in the public static void main, what I have is I have an instance of case insensitive string.
And then I have another normal string instance. What we're doing initially is we're checking if
this case insensitive string is equal to s. And that will return true as expected, because
we're passing the word Polish here, the string Polish, and the string itself has Polish. And
even though the first letter is uppercase, and here it's not uppercase, it's lowercase,
it doesn't matter because this equality, what we're doing, the logical equality,
what we care about is for it to be case insensitive. We don't care about the case.
But here, this is where the symmetry is violated. Because we are attempting in I equals method
to, for this to be interoperable with normal strings, we're doing the comparison the other
way around. Instead of comparing sys with s, we're comparing s with sys, and this returns false.
Furthermore, if we add this string, the, sorry, the, I don't want to call it a string because
it's a case insensitive string, sys, into a list of type case insensitive string,
it's a bit of a mouthful. And we print it, we expect this to return true, but it doesn't,
it returns false. So that again demonstrates the violation of symmetry, because the contains method
uses the concept of logical equality, and we don't have logical equality here.
So if I do run this, you'll see it'll return true, false, false, right there.
So this is the problem. Now, before I get to the fix, let me read out to put it a bit more
formally and cleanly what Joshua Bloch has stated. He states, as expected, so he's referring to
this bit here, as expected sys dot equals s returns true. The problem is that while the equals method
in case insensitive string knows about ordinary strings, the equals method in string is oblivious
to case insensitive strings. So that is the equals method that we're going to use
here in this slide that we use.
Therefore s dot equals says returns false. So he's referring to that bit here now, where it returns
false. A clear violation of symmetry, suppose you put a case insensitive string into a collection.
So that's where we're moving on to the next bit here, which we again see that it's returning
false. And this is a bit difficult to understand because here's what Joshua Bloch states on the
contains method. Now, I was under the, well, I guess my assumption is right. My assumption was that
because this violates the equals contract and the idea of logical equality and the contains
method ensures that objects that it gets respect this contract. It acts accordingly,
therefore why it's printing false here or it's returning false here. But here's what Joshua
Bloch states. And I think my assumption is at least quasi accurate. What does list dot contains s
return at this point? And then he says, who knows? In the current OpenJDK implementation,
it happens to return false. So that's what we saw here. The third force is by this list of
contains. But that's just an implementation artifact. In another implementation, it could just
as easily return true or throw a runtime exception. Once you violated the equals contract, you simply
don't know how other objects will behave when confronted with your object. To eliminate the
problem, merely remove the ill-conceived attempt to interoperate with string from the equals
method. I shouldn't have read that part yet. I'll read that again, but that's how we fix the problem.
So I'm going to read that bit again, though. Once you violated the equals contract, you simply don't
know how other objects will behave when confronted with your object. This goes back to the idea I
touched on a bit before by Sandy Metz on the book I was referring to, the Ruby book, that it's
probably the best way to think about OOP is in the context of messages and how objects interact
with each other over objects, because objects aren't an island, as we read from John Dunn. So
that's what happens here. The contains method makes a lot of assumptions, and those assumptions
are wrong, because, well, the assumptions aren't really wrong, but we've made a mistake in our
object. Therefore, it breaks things. There's no logical equality. Now, getting back to how we
fix this, as I did read that line, which I shall reread, it's simply ensuring that we don't try and
attempt for the case in sensitive string objects to interoperate with string objects. And the way
we do that is I'm going to comment out this equals method, because we can't have two equals method
in the same class equals methods in the same class, unless it's overloaded. And then I'm going to get
the other equals method, which doesn't attempt to override, oops, doesn't attempt to not override to
interoperate with strings. It simply checks if it's an instance of case in sensitive string and then
casts the case in sensitive string and just a normal equals ignoring the case. So now, if I
run this bit here, you'll see I'm going to comment out these lines, because they're, in fact,
actually, no, maybe what I should do is I'm going to go and run the whole thing.
And now the first three are printing faults, and we expect it to print faults. We want it to,
because we don't want any interoperability with strings. And then in the second one, we're checking
if it's equals, and we're seeing if sys equals this new string we've created, again, Polish,
and then we're checking if sys equals the other way around. We're checking for the symmetry. So
you can see here in line number 53, it's uppercase P. And in line number, oh, that's a mistake,
actually. That should have been lowercase. Now we can truly demonstrate the point. See,
so if it's lowercase here, line number 37, it's still ignoring that and printing true in these
two lines. So line number 54 and 55 correlate to these second true statements. I hope that made
sense. So rereading what Joshua Bloch wrote, to eliminate the problem, merely remove the
ill-conceived attempt to interoperate with string from the equals method. And now we move to the
longest property from all the ones that Joshua Bloch has enumerated. And I had to take a smaller
break just to refresh myself because this property is four or five pages. So there's a bit to go
through. But let's get started. You know, the only way to get started is to get started. Wow,
brilliant, brilliant. So what does this transitivity property states? Some of these words are a bit
hard to pronounce. It's not going to lie. It states transitivity states, for any non-null reference,
values X, Y and Z. If X equals Y returns true and Y equals Z returns true, then X equals Z
must also return true. Or simply it's that if we have three objects with the content being
same, three string objects, let's say, they should all print true when compared to each other.
Simple as that because we require the logical equality there. Now, before we get to the demos
and we demonstrate how this can go wrong and how to fix it, and even in fact, some inherent
flaws with Java and object-oriented programming, we've got to get some theory out of the way.
So should I read this out first? Let me think. Okay, I'll first read out a bit of like an
introduction of this property from the book. Here's what Joshua Block states.
Transitivity, pertaining to transitivity. If one object is equal to a second and the second
object is equal to a third, then the first object must be equal to the third as we've
showed here. But as I said before we continue, let's get some theory out of the way. So
something important to understand for this property is the less curve substitution principle.
It's the less curve substitution principle is probably popularized by Robert C. Martin and his
solid design principles. And of course, less curve, Barbara less curve, is that her name?
I believe that's her name. Yes, she is the scientist who invented this principle and made
the contribution into the field of computer science. Here's how Robert C. Martin summarizes
the less curve substitution principle. Subtypes must be substitutable for their base type. So
and of course, I've got a example here that I use charge PD to generate to demo this principle
simply. And then a bit more formally, or let's say a bit more mathematical definition,
Barbara Liskow defines it like this, which she did in 1988.
If for each object, O one of type S, there's an object O two of type T, such that for all
programs P defined in terms of T, the behavior of P is such of P is unchanged when O one is
substituted for O two, then S is a subtype of T. So or another way of putting it is that
if S is a subtype of T, then the behavior of O one can be substituted for the behavior of O two,
which are two objects. An example of that would be again, generated by charge PD. Thank you.
Open AI and charge PD not to anthropomorphize it. But nonetheless, thank you. We have a class animal
with a public void move method. And then we have a subclass, a subclass, the animal class by dog dog
extends animal. And then we define a method that makes the animal move. So the, the subclass has a
method called make animal move, which takes a object of type animal of the, of the, that's not
the sub, that's a subtype, not the, sorry, that's the super type. And then this method, in fact,
this method should be inside the, that was, I mean, it's not my fault, it's charge PD's fault.
If we put it in there, so it probably exists inside the dog class. And we create a new dog
object. And then this method make animal move can take in an animal typed object too, because it
respects the list called substitution principle or it owed to, because dog is a subtype of the
super type animal. It's quite straightforward actually. And I think the best way to think about
it is how Robert C. Martin put said subtypes must be substitutable for their base types.
So now let's get to the demo that Joshua Block has used in the book. There are many classes to go
through, but let's start off with the point class. So here's what Joshua Block states,
consider the case of a subclass that adds a new value component to its superclass. In other words,
the subclass adds a piece of information that affects the equals comparison. What we have here
is this public class. This class is going to be the superclass that we're going to use. It's a
concrete class, keep that in mind, because the idea or the juxtaposition of a concrete class with a
abstract class, that's something we're going to catch on later on in this part. So we have the
concrete class point, which is simply an immutable two dimensional integer point class. We've got x
and y privately defined. We have constructor. And then you have an equals method, which just
the equality, similar to what we discussed in the previous example with symmetry checks if it's an
instance, and then returns true if there's equality. Now let's suppose that we want to enhance the
ability of the point class. Therefore, we subclass it and we have this color point class that extends
the point class. And it attempts to add a value component to point. In this case, it's the
it's the value component of color. We want the points to also have color. Now what would
this class look like? Or more importantly, what would the equals method look like for the color
point class? That is a subclass of point. In this case, we have a normal constructor. We have line
number 14 that invokes the constructor in the superclass. That's what this super keyword does.
And we can do that for x and y, those coordinates. But here, since we're introducing this value
component, we want to initialize the color component to when constructing the object.
But then we come to the equals method that clearly violates the symmetry of the
symmetry principle or the symmetry properties. Well, for starters, of course, we can't use the
equals method from the superclass because the superclass did not even have a color field.
Therefore, it would break the idea of logical equality if we just inherit that method. Therefore,
we need to override the equals method in the subclass color point. But in this equals method,
it violates symmetry because yes, we're invoking the equals method in the superclass and then we're
even doing a check for the color point equality here by casting that object the color point type
because if it is an instance, in that case, or yes, because if it's not an instance, it'll return
false. But it's a one way comparison. So if you look at the implementation or a client using it,
and if I run this, you'll see the first comparison will return true because that's fine. We're comparing
point and we're passing the color point object, that's okay. But the second one will return false
because in this case, we are typing or we're passing the super type object. So it's a clear
violation of symmetry. And that's why Joshua Bloch states the problem with this method and
what he means by this method is this implementation of the overrides method we have here
is that you might get different results when comparing a point to a color point and vice
versa. The former comparison ignores color while the latter comparison always returns false
because the type of the argument is incorrect. So what he means by the former comparison ignores
color is that in this ampersand, the end statement here, that's the former comparison where it's
simply invoking the equals method in the superclass and it's doing a basic equality test. But in that
equality test, we are ignoring color completely. So it will return true if it is an object of
proper type. And that again, doesn't give us what we want. It breaks logical equality. And in the
second one, the problem is it'll never even get to the second one because we check if this object
is an instance of color point. And if it's not, it'll always return false. Therefore, it'll all,
so if whenever we pass anything, that's not of type color point, it'll return false. And that also
violates not only symmetry, but even the less curve substitution principle. So then we're
trying to fix this, what we're trying to fix this is we're trying to resolve this issue with
violating symmetry. And that fix also unfortunately doesn't work because it violates the
transitivity property. And we shall see what that fix looks like. So by trying to fix the
issue with symmetry, we unfortunately violate transitivity. In this case, in this new equals
method that we overrode, we in fact are considering objects that are of a different type to color
point. We're checking if initially, if it's a normal point, if it's a normal point, we're doing a
color blind comparison. Great. And if it's a color point, then like the previous one, we consider
color and then do a comparison. And absolutely, if it's not an instance of either point or color
point, it'll just return false. So in this case, symmetry ticked. However, unfortunately,
as we shall see from the implementation, it does violate transitivity.
So in this comparison, we have three objects, we have two color point objects and a point object.
So in the P one equals P two comparison, that's fine, it returns true. Also in the
P two equals P three comparison, that also returns true. However, then comes the transitivity
issue in the P one equals P three comparison, it returns false. I totally got the wrong,
I read that as if that's what was expected. In fact, that was not what's expected because
there's no logical equality there. We're trying to compare P one with P two. And it's returning
true, it should return false because obviously P one has that added value component of color
and P two doesn't have that. So that's that's wrong, it shouldn't return true. And it shouldn't
in the second comparison, where we compare again, a point and a color point, it's returning true
again, it shouldn't. And okay, the third one's fine, because the third one, it's doing a proper
comparison between P one and P three, which are both type of color point, and it's returning
false, which is expected because the color is different. That's okay. But these two
are a problem. So which is why Joshua Bloch states, this approach just provides symmetry,
but at the expense. So I don't think I read the previous bit. So just to add on to what he was
saying about the override method, he says this method here, he says, you might try to fix the
problem by having color point or equals ignore color when doing mixed comparisons. And that's
what we're doing. In this condition here, where we're doing a color blind comparison by using
the instance of method. So even a point can be passed on to this object of type point.
And then he continues. Now, so what we discussed here before, now P one equals P two when P two
equals P three returns true, where it shouldn't, while P one equals P three returns false, a clear
violation of transitivity. The first two comparisons are color blind, while the third takes color into
account. And that shouldn't be the case. So what do we do here? We've got this huge
object oriented predicament, or for us programmers, even a existential crisis, what are we going to
do? What's the solution? He states, it turns out that this is a fundamental problem of equivalence
relations in object oriented languages. This is kind of what I said before. There's no way to extend
an insensiable, insensiable class and add a value component while preserving the equals contract.
The problem again, the big problem is in our design, where we may point a concrete class.
And we shall see why it should have been made a abstract class instead.
But later, sorry, I'm getting a bit carried away. Let's stay on track.
Again, re-reading that point, because it's important, there's no way to extend an insensiable class,
insensiable class and add a value component while preserving the equals contract, unless
you're willing to forego the benefits of object oriented abstraction. And then Josh
Shublock states that we might try to circumvent this issue in a bit of a sly way by trying to use
Java's Reflective API or Reflections API. In any case, it's changing the class on runtime,
which is what I tried to demonstrate with the second equals method, which we think would work.
So if I do, oops, I shouldn't have clicked that. If I do look at this equals method, I'll comment
this out. We're using the .getclass method from the Reflections API. Okay, before we get to that,
let me quickly read out some theory. What is getclass in Java? Again, according to chatGPT,
here's what getclass is. In Java, the getclass method is a method of the object class that returns
the runtime class of an object. Correct. It returns an object of type class, which is a class in the
Java Reflection API that represents a class or interface in the Java programming language.
This in fact is very accurate, which is amazing because if you look at the Oracle docs and whatnot,
chatGPT puts it in a more simpler way to understand. And an example would be here,
if we have this employee class or the employee object of type employee,
if we go and they have another class, which we get, we get the class of employee and save it.
We don't even really have to do this. We could just go employee.getclass, really.
We could just skip this step and go employee.getclass.getName. And then return the name of the class.
And that's done runtime by getting the type of the object. So we're trying to circumvent this
issue by using the Reflections API, where we're saying only if it's a type of the implementation
of that object. So we're checking the class of the object we pass on to the equals method. And then
we're checking the class of the current object's runtime. So we're comparing two objects here,
the object of this class, the broader class, and then the object we are passing on to the
equals method. And then we're doing the comparison. Unfortunately, this is not going to work because
it violates the less carb substitution principle and breaks logical equality, which is why
Joshua Bloch states, this effect has the, this has the effect of equating objects only if they
have the same implementation class. So which is why we're checking here for the type of the
implementation class. This may not seem so bad, but the consequences are unacceptable. An instance
of a subclass of point is still a point. So an instance of point, for example, like a color
point is still a point, and it should work with this equals method, but it doesn't. And it still
needs to function as one, but it fails to do so if you take this approach. Now let's take a look at
an example where we're trying to tell whether a point is on the unit circle. Here's an example.
So what this kind of point test is trying to do is to see if, if this is a point, this point class
is a point on a unit circle. We're creating a set of type point, and we're adding some points into
it. And then we have this public static Boolean, which returns a true force that checks if this
point is a point on a circle. And we're doing that by returning true if whatever point that
we pass on to this method is contained in this set, the unit circle set. Now initially here,
it'll print true. It'll print true because it's of type point. But because our point class, we
used the reflections API and used get class. When we pass something, a subtype of kind of point,
which again, if it did respect or follow the less curve substitution principle,
it should still print true because it's still a type of point and it should behave as such.
It'll print false, unfortunately. There we go. In the second one, it's printing false. And this is
a clear violation of the principle. Therefore, using get class and the reflections API is still
not the way to circumvent this issue with object oriented languages. So again, I know we discussed
the less curve substitution principle before, but in the book Joshua Block states the less curve
substitution principle says that any important property of a type should also hold for all its
subtypes so that any method written for the type should work equally well on its subtypes.
This is the formal statement of our earlier claim that a subclass of point such as counterpoint
is still a point and must act as one. Now let's take a look at the problem with this.
I mean, let's take a look at not the problem with the less curve substitution principle,
but the problem with not following this principle. So we have this trivial class here that really
does nothing. It doesn't really add a value component. It simply keeps track of how many
instances of, it's called counterpoint, which keeps track of how many instances of point are
created. If you don't know an atomic integer is a thread safe counter, a variable which you can
increase. So simply every time an instance of counterpoint is created, we also, we're invoking
even the super class, the point in this case, and then we can get an account of how many instances
of point were created because of this atomic counter. So again, counterpoint is a subtype
of point. Apologies, I demoed this bit a bit earlier before, and I think I used the word
color point by mistake. I think I should have said counterpoint. It's just both counterpoint
and color point are subtypes of point. But as you saw before, it also returned faults,
because we've got a problem with, we haven't got a problem with, sorry, I was going to say we've
got a problem with the, with the contains method. The contains method exactly behaves the way it's
supposed to, but we have a, we have a violation of the less curve substitution principle, which is
why it's turning faults. Again, I apologize if I confused you by stating color point, I'm going to
say counterpoint, which is this class that this is, this is a useless class really, it just invokes
the constructor in the superclass point and then keeps track of how many objects of point have
been created. But why, so the question of course is why do we get this second force here, despite
counterpoint being a subtype of point? It is because of this. Because most collections, so
set is a collection here of type point, including the hash set that we used here,
by the own unit circle method, use the equals method to test for containment. And no counterpoint
instance is equal, equal to any point. And why is that? That is because as I said before, we're
using get class here. And if, if counterpoint is not of type point, we aren't gonna, it's going to
return faults. So therefore, that's why we get a false here too, which the, sorry, it's a wrong
one, we get a false here too, which the contains method uses the equals method in the object,
in the point object. And that's why Joshua Bloch states, if however, you use a proper instance
of base equals method on point, the same on unit circle method works fine when presented
with a counterpoint instance. And let's take a look at that. So on point, instead of using
this equals method that uses get class, if we go back to the previous one that uses
instance of, because instance of does consider even sub types. And if we run this again,
we'll get two truths. So in that case, it's behaving as expected. So unfortunately,
there's no way getting around this, we should all give up programming. And just quit, quit,
because life is meaningless. Everything is futile. I'm kidding. I'm kidding. I'm kidding.
Life is meaningless and everything is futile. But in true Nietzschean essence,
we ought to create our own meaning, which is why we're going to use the good old object oriented
principle and favor composition over inheritance to circumvent this issue with which is inherent to
object origin languages. So let's take a look at this example, class color point, where we don't
do any kind of extension or any kind of inheritance, we're in fact using composition. So in this new
color point, which don't get this confused to the one that we use for inheritance, as you can see
from the package, this is in a separate package called composition. But in this new color point
that uses composition, we have a instance of point defined, and we have an instance of color,
which is an enum, by the way, that holds some colors. And we have these two instances defined.
And then in our constructor, we have a new instance of point being created. And we assign that, of
course, to the private private field in our class, we do the same thing with color, new instance,
sorry, in this case, we don't create a new instance of color, we expect the client to pass us a
a proper object of type color. And then we return the point of this color point, just
this again, what the client expects. And then the equals method, because we're using composition,
it's not an issue, we just check if it's an instance of color point. And then we do the
casting accordingly, if it is an instance of color point, the object we pass onto the equals method,
then we do a proper comparison, where we do both the comparison between
between the type point of color point, because this we get from
here, and also the comparison between color. So the color has to be true, and the point has
to be true. And if they both are fulfilled by the double ampersand and operator, it returns true.
And that solves a problem. So if you look at this test class, for instance, I'm going to run this
test class, I've done something really ugly here. In one file, I've defined two classes,
you should never do that. In fact, there's one item where Joshua Block talks about that later on,
it's bad programming etiquette. So in the counterpoint test, again, I've screwed this up,
it should be color point test. This is a bit confusing, I apologize. In the color point test,
we've similarly have a hash set that we've created of type point. And then we're doing the same
thing we did in the previous test, we're checking if the point we pass contains this object P in
this hash set. And then if you run this, the difference here though is firstly, if I run this,
you'll see they both print true. That's because we're using composition. And what it does is though,
when we are adding it, when we're adding a new color point, we do use this additional method
saying add this, however, as a point though. So that changes things. Because now we're saying it's
still, we're still adding something of type color point, but we're using this method here,
which adds as a point. And it returns that point that we've defined here, which is what we do in
the constructor. And even though we still have this value color in this private field here,
which we can use. So that's how we circumvent the issue. Interestingly, Joshua Bloch states that
there has been historical errors, where for instance, in the date and the SQL timestamp
classes, so in the utilities and the SQL packages, they've made the mistake of
use having the implementations of the equals method that violates symmetry and that this
causes erratic behavior. And he says the equals implementation for timestamp does violate symmetry
and can cause erratic behavior if timestamp and date objects are used in the same collection
or otherwise intermixed. This behavior of the timestamp class was a mistake and should not
be emulated. So again, it's because of the inherent drawback in object oriented languages,
these kinds of mistakes happen. However, in many circumstances, using composition over inheritance,
the way we showed in the composition pace color point class is a way of getting around that.
And then we get to the interesting idea or the interesting notion of using an abstract class
instead of a superclass. And simply the reason we can add value components to a subclass of
an abstract class is that you can't instantiate an abstract class. So that really solves a lot
of the problems we have with using the concrete point superclass. So in this case, we have an
abstract class shape, which has two protected values, so x and y, and we have a constructor and then
we have two concrete subclasses that extend the shape class. And we've got circle and we've got,
I think circle and rectangle, where's the other one? Yeah, circle and rectangle,
where in the circle one, we are adding a radius. And in the rectangle one, we are adding a length
and width. And in the constructor, of course, we are invoking the constructor of the superclass,
which is shape. The issue is quite straightforward, we can create a concrete object of this concrete
class rectangle. However, if we try to, that's a typo, try to instantiate the shape class, it says
you get a compile time error, say you can't instantiate abstract shape classes, which is why
this is a way to get around this issue. Where Joshua Block states, when adding a value component,
note that you can add a value component to a subclass of an abstract class without violating
the equals contract. This is important for this sort of class hierarchies that you get by following
the advice in item 23, preferred class hierarchies to tag classes. I'm not going to go into too much
detail on that because we're going to be covering item 23 next year. And then he says, for example,
you could have an abstract class. So what I pretty much described here, I'll just read it out again.
For example, you could have an abstract class shape with no value components, a subclass circle
that adds a radius field and a subclass rectangle that adds a length and width fields.
Problem of the sort shown earlier won't occur so long as it as it is impossible to create a
superclass instance directly. That's it. That is the the property of transitivity as to how we
need to try and follow it to ensure that we follow the or we abide by the general contract of the
equals method and even discussing the inherent problems with OP languages. But saying that,
there are also two other properties that we need to follow, which is consistency and non-nullity.
They're a lot more shorter than this one, but I'm quite tired. So we're going to cover that in
part three. But I hope this made sense. I was from my best to get this across. I found this
quite interesting though. I really enjoyed this transitivity bit. So I shall see you in the next
one. Thanks for watching and I hope you gain some value from it. Cheers.
