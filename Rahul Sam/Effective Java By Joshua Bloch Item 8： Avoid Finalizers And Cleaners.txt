Hey everyone, welcome to yet another episode of my video series on Joshua Block's effective Java,
where I take the items that he has enumerated in this book and expound on them, trying to make
sense of them. And hopefully, as I do that, you can gain some value from it too. You can hopefully
learn something from it. That at least is one reason that I put out these videos out in the public.
Without further ado, let me get started. This is certainly one of the longest items that I had
to go through and probably going to be the longest video of this series as of yet. In fact,
I was thinking if I should break this down into two videos because the video might be too long.
In any case, let's get started with the proviso. I've been doing this proviso slash instruction
in every single video. So if you have been following along, please do skip this bit to save your time.
The first point in the proviso is of course, and it's a very important point, this is not a
tutorial. I'm not a teacher, nor am I an expert. Therefore, don't think of what I say as gospel
truth. In fact, when I do make mistakes, I'll try and correct them down below in the comment section.
And as I've said in the second point, think of this as the blind leading the blind. This is purely
an exploratory disposition. I'm trying to figure something out publicly and in a very, let's say,
what's what I'm looking for? I'd say thinking out loud, trying to make sense of these items,
not just in the videos itself, but even preparing for them as I post questions on Stack Overflow,
as I try to involve the community. I feel like hopefully, I'm adding some value into the programming
community, the Java community by asking certain questions pertaining to this book, as I'm trying
to learn, which is why I call it an exploratory disposition. It's a collective endeavor. And
as I did touch on a bit before, I will inevitably make mistakes. So please point them out, not just
for my sake, perhaps even more for the sake of the viewers, because I certainly don't want to mislead
them by sharing any misinformation to use a politically overloaded term. And of course,
as this is a programming video series, all the code is available on GitHub, not just mine,
but even Joshua Bloch's public repository where he's published the code that he's used for this
book. Saying all that, let us get started with item number eight, which as I said is a long one.
There are a few concepts that I had to sort of think about and muse and reflect for a bit to
get my head around. But it was a very interesting item as I found all the items in this book,
and especially if you're a Java fan like myself, or for all, even though I don't
program in Java in my day job anymore, Java is my first love, and you never forget your first one,
isn't it? I'm sorry, that was pathetic, but I can't help myself. Okay, item number eight,
avoid finalizes and cleaners. And we're still in chapter two, creating and destroying objects.
And again, as I said, all the code available on my GitHub repo links down below in the description.
And I've kind of added like this, another caveat here. This item does have a lot of theory. So
before we get into the code, which of course I have right here, before we get into any of this code,
I think it's important to get through some theory. Just in general, I prefer doing that to get a
conceptual understanding. But specifically this item, I think has a lot more theory. So as I normally
do, let's look at some keywords here. Avoid finalizes and cleaners. What the hell are finalizes
and cleaners? Full as closure, I've never used a finalizer nor a cleaner. A cleaner, yes,
but I've never used a finalizer in my day job when I used to do a lot more hands-on Java programming.
But here are a few definitions that I found on finalizes. In fact, they're from Bialdang,
my favorite Java learning blog slash website. And then of course the Oracle docs. So finalizes, the
sorry, I had to think about that just for a bit. I didn't want to mindlessly read out the
definition. Essentially, when I mean finalizes, it's simply a method we're talking about, which is
in the object class, which the in the class hierarchy in Java, the object class is right at the top.
So everything is a subclass of object Java, FII. The finalize method for all intents and purposes
is what we call the finalizer. Even though finalizes is more like a mechanism. And Bialdang states
finalizes get invoked when JVM figures out that this particular instance should be garbage collected.
So when the JVM understands that a certain object or an instance of a class
is ready to be garbage collected, it can be invoked this finalized method.
Such a finalizer may perform any operations, including bringing the object back to life.
That bit, full disclosure, I don't understand. I didn't really go into detail as to what it means
bringing the object back to life. Perhaps it's referring to the object later again in the code
and then allocating memory to it. But even in the item, Joshua Block hasn't really got into
what that means. This is just a definition from Bialdang. The main purpose of a finalizer is
however to release resources used by objects before they're removed from memory. A finalizer
can work as a primary mechanism for cleanup operations or as a safety net when other methods
fail. So at a very high level, just a good bit of start is to think of finalizes being related to
memory management and garbage collection. It's not something particularly done by the JVM.
Programmers could do it too, explicitly. But of course, a caveat is we should in fact avoid
using finalizes and cleaners. That is the caveat here. So even though it's possible, it doesn't
mean we should do it. So again, to repeat the point, think of finalizes as something that relates to
memory management and garbage collection and ensuring that any unreferenced objects are
cleaned and that resources are freed up. And then another definition, again, from the Oracle
docs this time is, as I said, finalize is part of the object class. If you go take a look at the
docs, it'll even state, if only my internet loads, it'll even state the finalize method is there.
As you can see there, it'll say they're called by the garbage collector on an object when garbage
collection determines that there are normal references to the object. The general contract,
sorry, the general contract of finalize is that it is invoked if and when the Java virtual machine
has determined that there's no longer any means by which this object can be accessed by any thread
that has not yet died, except as a result of an action taken by the finalization of some other
object or class which is ready to be finalized. So, okay, effectively, this means when the object
is not going to be used, we need to free up that resource and get that memory back to be used for
something else. That's what finalizes. But, again, we shouldn't use them. That's the point
Joshua Book is trying to make. Okay, so the first keyword finalizes, we've got a very high level
conceptual understanding of what it is. Let's take a look at what cleaners are,
which is kind of like an evolution of finalizes and is perhaps a bit safer to use,
even though that too should try and be avoided, ideally. Once again, from the
so cleaner is in fact, let me let me open it up. It's an interface.
Sorry. Sorry, I meant to say cleaner is a subclass of object. I was thinking of auto closeable,
which is an interface. We'll talk about that later on. And the definitions for the cleaner is,
again, by the Oracle docs, cleaner manages a set of object references and corresponding cleaning
actions. Cleaning actions are registered to run after the cleaner is notified that the object has
become phantom reachable. So what is phantom reachable? I did discuss this in the previous
item, item number seven. I'm not going to go into too much detail, because you could just
watch that video. But phantom reachable is when an object has no strong, soft or weak references,
but at least one phantom reference. So this kind of has to do with how the JVM algorithms or how
garbage collection algorithms decide if a certain object has to be or can be garbage collected.
So basically, strong objects can never be garbage collected. And then it's sort of the,
there's like a cascading effect, not a cascading effect, there's like a triaging process where
it goes from strong, soft, weak, and then the lowest one is a phantom reference.
Read this document by a bullet down, which goes into detail, of course, linked to this in the
description too. For more context, I'm not going to go into detail because it's sort of out of scope
for this item. And as I've said here, these delineate when objects can be garbage collected.
That's what phantom references do. And with cleaners, cleaners are used when an object has
become phantom reachable. That's how it relates. And then another definition from inside Java by
Roger Riggs is, unlike a finalizer, a cleanup function holds the state needed for cleanup
separately from the object because we want the object to be reclaimed as soon as it is unreachable.
When, when it states, when it states reclaiming an object, what that really means is freeing
up memory. So we can use it for something else. The cleanup function must be able to work
independently from the object. It's correct. It should be able to run on a separate thread,
thread, for instance, and that does happen. We shall see an example. If there are any
references to the object from the cleanup function, it would still be reachable and could not be
reclaimed. Any state needed for the cleanup must be encapsulated in the cleanup function.
Any state needed for the cleanup must be encapsulated in the cleanup function. What does that mean?
I believe what this means is when the cleanup does take place, so
a quick peek in the code. Let's say the cleanup happens. Let's say this close method. This is
a bit different. Ignore all this, but the state of an object should be localized to this function,
this method, when the cleanup, when the cleanup is taking place. I believe that's what it means.
It's encapsulated within this method. Ignore all this, but it's a really subar context,
but we shall get this code a bit later. Now we get to what Joshua Block has stated in the item
in the book. The first thing is he's kind of talking to C++ programmers.
A point he wants to make salient and very clear is that finalizers or cleaners are not the same
as destructors in C++. Now obviously, because C++, I'm not a C++ programmer in any way,
I've probably written like 10 lines of C++ code in my life, probably a bit more than that. I did do
a unit, a data structure and a patency unit back in uni, which was in C++. Obviously, because
C++ doesn't have automatic memory management or garbage cleaning, we need to do it ourselves,
the programmer. I believe it's done through destructors. Take what I say with a great
assault. Maybe they'd rather us do it, but one way it is done in C++, probably the most popular way
is using destructors and Joshua Block wants to make it clear that cleaners and finalizers are
not the same as destructors. Here's what he states. Finalizers are unpredictable,
often dangerous and generally unnecessary. I shall also discuss that bit about them being
unpredictable or non-deterministic as to why that's a huge risk when programming as we go into the
item. Then he states, as of Java 9, this is an important point, finalizers have been deprecated,
but they are still being used by the Java libraries. The Java 9 replacement for finalizers
is cleaners. Cleaners are less dangerous than finalizers, but still unpredictable, slow, and
generally unnecessary, which is why we should be avoiding old finalizers and cleaners.
Despite having to caveat that finalizers and cleaners aren't the same as destructors,
he states, or he continues, C++ destructors are also used to reclaim other non-memory resources.
In Java, a try with resources or try finally block is used for this purpose. Then he continues,
one shortcoming of finalizers and cleaners is that there's no guarantee they'll be executed
promptly. Yes, before I read that, I need to go through the notes that I took down.
I had to go through the code base a bit and read up again because I wrote this a while back and
I've forgotten some bits as to how it's all going to come together. In fact, my struggle to demo
this, to demonstrate this problem, is in many ways the point Joshua Block is trying to make,
that it is non-deterministic. I can't exactly show the problem with finalizers because
it's not deterministic. In programming, you'd expect code to be deterministic and causal.
The big problem with using cleaners and finalizers is firstly that we aren't sure when the garbage
collection will take place. We aren't sure when GC will run and JVM can do it virtually any time.
It won't. Even though it is possible, as I will show in a bit, for us to explicitly run a GC
or a garbage collection cycle, it's ill-advised. One shouldn't do this. There are many other side
effects that can affect the program. It's possible that the finalizer thread, so the thread where
the closing of the object is taking place, can be of low priority. That can lead to an
out-of-memory error because some other threads would run, take up all the memory and when this
thread runs, that can throw an out-of-memory error. Then there's another caveat that cleaners in fact
do run in the background. The garbage collection is controlled by the class itself. The class
owns that garbage collection. However, there still is a problem of it not running promptly.
Sorry, I made a mistake there. The class doesn't have control of the garbage collection,
but it has control of its own threads, which we shall see because we use a runnable interface.
Nevertheless, it still does not guarantee the promptness. Due to the non-determinism in both
cleaners and finalizers. Now, I quickly show what the hell finalizer even is because there isn't
really a proper example given in the book. I found an example courtesy of Wild Done. Before I show
the codebase, let's go through something a bit more, let's say, clear. I try to be a bit more
explicit as to what Joshua Block has written here because I think I didn't do a good job at
explaining that. Here's what he states. One shortcoming of finalizers and cleaners is that
there is no guarantee they'll be executed promptly. It can take arbitrarily long between the time that
an object becomes unreachable and the time its finalizers or cleaners run. This means that you
should never do anything time critical in a finalizer or cleaner. The promptness with which
finalizers and cleaners are executed is primarily a function of the garbage collection algorithm,
which varies widely across implementations. So, what does that mean? The thing is, even after
finalizer runs, a GC still has to run in the background, clear up resources, clear up memory.
But before we get to the idea of the promptness, let's take a look at what the hell a finalizer
even is. So, I was going through this example as I said courtesy of Wild Done and let me try to open
up that article if I could find it. This one right here. It was this article that he wrote
and he's just given a background as to what finalizers are. Even though in the article it goes,
it does say why you shouldn't use it. It talks about why we shouldn't take care of garbage
collection because JVM knows better, in fact. And I have this class called Finalizable and I
have an instance, a buffered read instance. And then for the constructor, what I'm doing is reading
a file, getting the input stream and then saving a new buffered read instance in this private
variable of declared class variable of declared here. And it does specify from the specified
class part from some Nietzsche quotes. And here we have a method called readFestLine,
which reads from the first line. So, if this works as expected, it should read without music,
life would be a mistake by Mr. Nietzsche and I very much agree. And then once we have this
instance created, we need to clean it. We need to finalize it. And here's where, sorry, we need
to close it, apologies. And here's where the problem occurs. Now, once we have this reader,
the buffered instance reader, which we declared here, it's used, we do the reading, whatever,
and then it's used and then we're done with it. We need to use a finalized method, which as you
can see is deprecated, the IntelliJ does specify that, that is deprecated. It needs to be closed,
which implies that the method was called and it has to clean up the resource. So, in this
finalized method, it'll close the resource and now when I run the unit test, you will see it'll
say closed buffered reader in the finalizer. If not, it'll just throw an error. If I go to the unit
test that I wrote, and if I run this, you can see it's printing that line here. I could probably
zoom into that a little bit. Close buffered reader in the finalizer. Really, that's what a
finalizer does, even though we shouldn't use it. And yeah, over here, you can go through the code
later on. I'm just checking if it's printing the first line. That's not putting into the point
I'm trying to make. And then this is important, though, because the GC is rather arbitrary. Well,
it's not arbitrary, but we don't have really control of when garbage collection will take
place. The JVM does that. We're using a system.gc, but it shouldn't be invoked this explicitly. This
is not something we should do, again, due to its non-deterministic behavior. So, this is,
you probably can see it as like a theme that's going to be in this whole item. The big problem
with cleaners and finalizers is non-determinism and it's the fact that it's tardy. It's tardiness
that's not prompt, which is why Joshua Block states as we continue, tardy finalization is not
just a theoretical problem. Providing a finalizer for a class can arbitrarily delay reclamation
of its instances. And that's a problem. The language specification makes no guarantee
guarantees. Sorry, I'll read that again. The language specification makes no guarantees
as to which thread will execute finalizers as there is no portable way to prevent this sort of
problem other than to refrain from using finalizers. And then, of course, as I stated, unlike finalizers,
we still can use cleaners. Cleaners aren't deprecated yet and they would give us control
of the thread of the class that's using it. But still, ultimately, the garbage collection,
we still have no control. The JVM has control, which is probably why we should avoid using
cleaners too. As he states here, as a consequence, you should never depend on a finalizer or cleaner
to update persistence state. That's correct if it's like a database connection or something
that requires persistence. For example, depending on a finalizer or cleaner to release a persistent
look on a shared resource such as a database is a good way to bring your entire distributed system
to a grinding halt. Oh, that is something you certainly don't need. Programming is easy.
It's really easy. It only gets complicated once it becomes distributed programming and when
concurrency gets involved. And that's why I have a beautiful gift of my favorite actress,
Margaret Robbie, probably the most beautiful woman in the world after a certain other woman
that I'm currently in love with. But we shall not talk about that. Don't be seduced. That's the
point I'm trying to make. Do not be seduced by Margaret Robbie, nor be seduced by the methods
system.gc or system.run finalization. So which is why just to go back to the unit test before,
I said it here, one shouldn't do this. This is a bad move. Try and prevent using system.gc in your
code. Again, due to its non-determinism. Because both of these, the garbage collection and
what runs the finalization method makes no guarantee that they'll actually get executed.
And in fact, these two methods run finalize their own exit, which are two other methods that can be
that pertains to finalizes have been deprecated because they aren't safe. Another red flag,
especially if you're an API designer and aren't all programmers designing APIs these days, is that
finalizes ignore uncored exceptions and doesn't notify the client what the hell is going on
if you do use a finalizer and there's a corrupt object. So for instance,
let's say we have an object in corrupt state due to the non-deterministic arbitrary behavior of
a finalizer. Let's say we have an object that isn't fully cleaned up or an object that shouldn't be
accessed by another thread. When the object crashes, this thread will not be terminated by a finalizer,
whereas a JVM would certainly do that. It would make sure that if a thread crashes,
if some competition goes wrong somewhere, and some error is thrown, it's physically clear and
explicit to a use of an API and it would be terminated and cleaned up. This is a problem because
if you do use finalizer, it'll allow objects in a corrupt state to be accessed by a client
of an API, which is why again, he states, another problem with finalizers is that an uncored exception
thrown during finalization is ignored and finalization of that object terminates.
Uncored exceptions can leave other objects in a corrupt state, but when an object is left in
a corrupt state and an exception is thrown, generally you'd see that exception in the stack
trace. With finalizers, there wouldn't be that and in fact, he says it won't even print a warning.
But however, with cleaners, it's not an issue because with cleaners, the library or a class
for all intents and purposes using a cleaner has control of its thread, so the class itself can
throw this exception. So it's a bit safer than using finalizers, even though the item as a whole
states avoid both. The other issue is performance penalty. Finalizers inhibit efficient garbage
collection because we are trying to manually do the garbage collection instead of letting the JVM do it
and even though cleaners are still faster than finalizers, it's still slower than using the
auto-closable interface, which we shall get to in the item later on in the item. So the other problem
is of course, yes, performance penalty and that's why Dr. Block states there's severe performance
penalty for using finalizers and cleaners. It is about 50 times slower to create and destroy
objects with finalizers. This is primarily because finalizers inhibit efficient garbage collection.
And then we get to probably one of the biggest issues with using finalizers and cleaners and
it's that it does leave our program vulnerable to malicious code and security attacks.
This point, despite being an important point, I found it a bit difficult to understand,
especially because I couldn't get what he meant by having a malicious subclass,
but this is what I meant, but I'm trying to collectively learn here. I did post a question
on Stack Overflow and I got some really good answers. And then finally, Holger, great blog,
I'm assuming it's a blog, the person answered the question and it was, I think it was
somewhat clear. It did make sense. So all credit goes to Holger. I'll leave an answer to this
question down below in the description where he explains how finalizers in fact do create security
problems. And before I read what Joshua Block has stated, let's go through some code and understand
what this issue is practically. So firstly, I've read this class called Finalize Attack Example
and that also has an inner class. This inner class in fact is what is supposed to do the cleaning up.
So it's got this check call method. It was kind of like a Boolean, which is like a security check
that verifies where that calls this, has permissions, let's say. That's a bad way of putting it. But
just for all the intents and purposes, think that all callers are invalid for our demo.
And then we have this method which does some critical action. That's it's really important.
So I forgot to mention that since the inner class is static, that won't allow the JVM to garbage
collect this resource. And then we have this malicious subclass that extends the resource
class. So this is where the issue lies. This resource class, once it was used, should have
died on the vine as Joshua Block would state in this item. It should have got garbage collected
and no one should have access to it to that object. However, because we know that the finalize method
can be accessed via the object superclass of resource class. And then the fact that the malicious
subclass extends the resource class, all that all it's got to do is override the finalize method
and invoke it. And the moment it's invoked, this object, which is probably a corrupt object now
is resurrected. And that gives this malicious subclass access to this critical action method,
which probably could do something like access the database to do something that could
potential calm your application and its users. So which is why when I run this code, you'll see
in the public static void main function. Initially, oh, I've added this thread here with the GC.
This helps to kind of demonstrate the non-domestic behavior. I shall show you that too. Initially,
in the try statement, it creates a new object. And when it does, it'll say because it ran a couple
of times, it would initially say I wouldn't get hands on a resource class. So, okay, that's a bit
confusing. I can see I shall first get rid of the sleeping of the threat and try running it again.
When I don't make the threat sleep, it will throw a security exception. It'll catch that
there's an issue here by the check holder and then throw the security exception. But the important
point here is finalizes aren't deterministic. It's a problem. So if we do get the thread some few
minutes, two seconds to sleep, then what you see when you run it is it's printing that log where it's
saying, see, I got hands on this object, which is it's printing that from the finalize method,
which was a subclass, well, not subclass, which was inherited from the resource class. And then
because we got our access to this object, you can probably see here what it's printing out is,
in fact, this object. But then also it has access to the critical action method, which ideally,
which not ideally, but which actually the malicious subclass shouldn't have access to.
Because once again, it should have died on the vine.
I hope that makes sense. I think I got it. So I was trying to, when I asked the question on
Stack Overflow, here's what I said. I'll read out this bit of the chapter, but then I said,
in like a very systematic way, my understanding is that finalizes are not deterministic,
a malicious subclass can run its finalize method on a particular constructed,
corrupted superclass object, which is what we are doing right here by extending the resource class.
Moving the corrupt objects reference to a static field doesn't let the GCM garbage collect,
not GCM, JB, I should fix that. So because it's static, it can't be garbage collected.
The attacker can use this object that should have died on the vine and do as they will,
pass the security flow. So this is the problem with using finalizes. I hope that makes sense.
I'm asking that question more from myself if I really understood that.
But I think I did. But I think I did. At least I'm going to tell myself how to feel better.
Now that I've kind of demoed that, even though I admit that was a rather pathetic demo,
let's try and get to what Joshua Block has stated here. Please forgive me. I'm trying my best to
demo it here, but because he's really hasn't given tangible implementations and examples,
I'm trying my best to see if I could find code and write code and connect it to what he's trying to
say here, given that I haven't really used finalizes before ever in my programming life.
But anyway, let's see if what he's stating here makes a bit more sense.
Finalizes have a serious security problem. They open your class up to finalize their attacks.
The idea behind a finalize attack is simple. If an exception is thrown from a constructor or its
serialization equivalence, so that would be the constructor, for instance, of let's say this class.
The finalize of a malicious subclass can run on the partially constructed object that should
have died on the vine. So that was this subclass that extended it. This finalizer can record a
reference to the object in a static field, preventing it from being garbage collected.
Just a point here, you probably noticed I didn't store the reference to this resource class anywhere
in any static field or didn't really hold the reference in the subclass.
The reason for that was because Holger, the answer that I got, said something like this.
He said, your description is basically correct, but over complicating things.
I'm not surprised there. I tend to do that quite a lot.
There's no need to store something in a static variable as soon as the finalize method is invoked.
The object is already just resurrected as invoking a method on an object implies invoking code
with access to the object. That really did make a lot of sense to me because that's exactly what
we're doing here in this override method in the subclass. Storing the object reference in a variable
is a way to expand the lifetime beyond the execution of the finalize method. But this is not
necessary, but this is not a necessary thing for the attack. Also, instead of using a static variable,
the attacker could also make the subclass and inner class and store the reference in the still
reachable outer object. So the following program is already enough to demonstrate the issue.
So that's the program that I showed to you before, which it's Holger's code. In fact, I just kind of
repurposed it and made it a bit more presentable, which is why I haven't done what Joshua Blocker
stated here. Once the malformed object has been recorded, it is a simple method to invoke arbitrary
methods on this object that should have never been allowed to exist in the first place. So
that is the arbitrary method, which was critical action that I did invoke.
Throwing an exception from a constructor should be sufficient to prevent an object
from coming into existence in the presence of finalizers. Unfortunately, it is not.
And then he states, which is kind of what I was, I tried to demo here,
to protect non-final classes from finalizer attacks, write a final finalized method that
does nothing. That's exactly what we can do here. So what you'll see is we have the resource class,
and then because the resource class itself obviously has the finalized method,
if we create a final protected void finalize, you'll see that it'll throw an error. You can't
subclass it because, sorry, you can't override it because this class that inherits that subclass
resource class now can't override it. And that never really solved the problem here. That's
one way of protecting ourselves against the finalized method, but the better way is to not
use it in the first place. And that, of course, begs the question, given that Joshua Block
and the broader Java community, the experts are so adamant as to why one shouldn't use finalizers
or cleaners, what is the alternative? What should we use instead? And that's what Joshua Block
states here, to use the autoclosable interface. Before I get to what I've written down and
taken notes of and kind of tried to demo what autoclosable is, let's first go through the
definition because that'll set a foundation, let's say. So what should you do instead of writing
a finalizer or cleaner for a class whose objects encapsulate resources that require termination,
such as files or threads? Just have your class implement autoclosable and require its clients
to invoke the close method on each instance when it is no longer needed, typically using
try with resources to ensure termination, even in the face of exceptions. So the point on try
with resources is, in fact, the next item. So I shall go into detail as to what try with
resources do in the next video. So a definition of autoclosable, which enforces encapsulation
by Oracle docs is an object that may hold resources such as files or socket handles until
it is closed. The close method of an autoclosable object is called automatically when exiting
a try with resources block for which the object has been declared in the resource
specification header. This construction ensures prompt release, avoiding resource exhaustion,
avoiding resource exhaustion, exceptions and errors that may otherwise occur. So let's take a
look at a demo. Let's see how autoclosable has to be used. Also, there's another caveat he's added
here that it's important that when an object has been closed, that we should keep track of how,
if the instance has been closed. And we shouldn't rely on the client to do that. It was a bit hard
to find a good demo of what this meant. So I did ask a question on Stack Overflow on that too. I
asked how to keep track if an instance has been closed with Java autoclosable. I even got a negative
download on that question because I realized it's actually quite simple as to how to do that. I
just got a thought about it a bit more without being lazy. But nevertheless, I did find an answer
and I did post it here. So firstly, the demo, the demo on autoclosable is this. Again, courtesy
of Baladang. So we have a demo class which implements autoclosable. And then we have another
buffered instance like the previous one we were going through for the final finalizable class,
a similar concept. In fact, a similar exact class that I've repurposed for this demo.
And this here, this Boolean is in fact what does that bit I asked here. It's what keeps track if
this instance of, in this case, the demo class has been closed. So when in the constructor,
the same way we are accessing a file, reading off the file, creating a new,
using a resource, reader. And then we're reading the first line,
similar thing, doing, and we're checking if we can read the first line. And here, there's something
extra added. We're checking if this resource, so that is reader, has been closed. I think I made
a mistake. I said that what this does in line number 13 was keep track of if demo class instance
has been closed. That is wrong. I apologize. What this keeps track of is if the buffered reader
instance has been closed. And that's what we're checking in the read first line method. And if
it is closed, we can't access it. So it should throw a illegal state exception. And that's what
we're doing here. And then we override the closed method, which is the method in the
auto-closable interface. That method right there.
And in the class itself, we do the closing. We close that resource. And then, of course,
we set the flag to true because now it has been closed. And if not, it'll throw an IO exception,
in this case, because it's a buffered reader. So if we go to the unit test,
you could see if I'm going to run it.
It did pass because all it's going to do is read the line. But, of course, if we try to access
the reader instance and it was closed, it would have thrown an error. The test did pass because
it's just checking if the first line is this. Oh, I should show the log here, in fact.
It's printing this log here, closed buffered reader in the closed method and flag changed to
true. So that is this right here. Where is it? I've got so many classes opened up. Oh, yeah.
That's printing this bit here, closed buffered reader instance, and it's printing the flag,
which is true in this case. So that's really, it's quite straightforward, the auto-closable bit,
and even how it keeps track of how it closes it. I was over-complicating in my head and I was thinking
there's some way to do it, in fact, it's tabooly. So despite being told not to use them, and we
probably will never have to use them for normal average Java programmers like myself,
what really are they useful for? What are they good for? Caviar there, of course, is that as of
Java 18, finalizers are in fact deprecated and will be entirely removed in the future. So we'll
never use finalizers, but let's say cleaners. What are they really useful for? Firstly, it's for them
to act as a safety net. And let's try to understand what that means. One use of Java cleaners, I'm
going to stop saying finalizers because it's deprecated, is that one use of that is to act as
a safety net in case the owner of a resource neglects to close its, to call its closed method.
Well, there's no guarantee that the cleaner or finalizer will run promptly, or at all. It is
better to free the resource later than never if the client fails to do so. If you're considering
writing such a safety net finalizer, think long and hard about whether the protection is worth the
cost. So the way I see it, it's just an extra check one adds when writing an API or a class,
just as a safety net. By overriding that finalized method, we could ensure that any of the resources
that should have been clued, sorry, not ensure, we could hope that any of the resources that should
have been closed or were closed because of the finalized method, even though it's not a domestic.
So that's, it's a trade off one has to make and think about carefully. And then the second use is
using it with native peers. What is native peer? As the simplest way to think about it is that
native peers are objects that aren't owned by the JVM. They're sort of like platform specific
objects that the JVM runs on, the virtual machine runs on, it could be C or C++ objects,
and the JVM can't garbage collect them. And that's why they're called native peers, even though
they call peers because the objects still have dependencies on them. But the JVM has no control
of these objects in memory. It's quite interesting. I really didn't know much about it. But of course,
I found this pretty simple stackover flow answer, which can explain that it said that a native
object is not programmed only in Java, but is a, but in a platform specific language typically
C or assembler even memory allocated by this code cannot be disposed by the garbage collection
by GC. Therefore, you may need to clean clean it in a finalizer. The native peer is the native part
of a Java object. So I leave an answer to this question in the description. And that's what I
route here by the user Andres on a stackover flow. Thanks for that. And Joshua Block states,
a second legitimate use of cleaners concerns object with objects with native peers. A native
peer is a native non Java object. That's an important point to which a normal object delegates
via native methods. Because a native peer is not a normal object, the garbage collector
doesn't know about it and can't reclaim it when the Java peer is reclaimed.
A cleaner or finalizer may be an appropriate vehicle for this task, assuming the performance is
acceptable. And the native peer holds no critical resources saying that finally, we, we in fact,
get to some actual code in this item, because the other code I showed was code that I wrote,
and I kind of use from other people. And that is this room class, which demonstrates the
concept of it being a safety net by implementing auto closeable. Yeah.
So the class is called room. And I do appreciate that pun there because
the room must be cleaned before being reclaimed. I like that. I appreciate that. And it implements,
as I said, auto closeable. It's got a private static final cleaner, which cleans. And this in a
class, which implements runnable is what holds the resources required by cleaner to clean the room.
So this in a class is in fact what does the cleaning in a separate thread in the background
of this broader class. So what you can see is we're simply registering the cleanable instance
with with with the state, which is a variable we hold here in line number 34, and register it,
we assign it. And after that, the number of junk piles should be set to zero. And the way that happens
is the close method, which is what we override from the auto closeable interface, that will invoke
the run method, which is inclinable. So once we register it with the with the with the object
itself, and then the state, so this refers to the current object, and then in the state of the room,
that we pass into the, we pass the we invoke the clean method of the of the cleanable instance.
And the clean method, what that does is it triggers the run method that sets the number
of junk piles to zero. So every time before it's reclaimed, it has to clean all the resources.
Now, I think I don't think I did a good job at explaining that. It's a bit difficult to explain
because I I lack the verbal visual city and deep understanding of how cleaner works. Therefore,
probably what I'll do is I'll go through Joshua blocks description, or sorry, his elucidation,
and then I shall refer to the code as I read them out and kind of learn it live, let's say,
which is exactly what I'm doing in this video series. The the room class implements auto close
book that I showed here. The fact that it's automatic cleaning safety net uses a cleaner
is merely an implementation detail. Unlike finalizes cleaners do not pollute across this public
API. That's correct, which is why it's a bit hard to see at first, because I'm using it as a client.
The static nested state class holds the resources that are required by the cleaner to clean the room.
So that is the static nested state class. Also, to understand how nested classes work, just go and
read these docs in Oracle. It's pretty simple. It's it's a it's an inner class. I'll leave a link to
that in the description. It's got access to all the properties of the outer class in this case.
And then and then he continues. And then he continues, in this case, it is simply the
number of junk piles field, which we need to clean up, which you shall see we're going to be doing
this integer value, which represents the amount of mess in the room. Yep. State implements runnable.
So you can see here, it's going to implement runnable because we need to run this in the background.
And it's run method is called at most once. So this method, which we're overriding is called
at most once. And that is this one method is from runnable.
Because we're running a new thread by the cleanable that we get when we register state instance
with our cleaner in the room's constructor. So that that bit here is done right here in the
cleanable, which is what I said that we're doing the registering as we create this new state by
passing the number of junk files, junk piles, sorry. And that's what we're passing on to this
and doing the registering, which is what invokes that run method eventually.
The call to the run method will be triggered by one of two things. Usually it is triggered by
call to room's close method, calling cleanables clean method. So that's the close method,
which we have overridden here of the outer class room. If the client fails to call the
close method by the time a room instance is eligible for garbage collection, the cleaner will
hopefully call states run method. So that's what he meant by a safety net. Because if the client
doesn't call the close method and clean up that resource or clear up, clear up that resource,
then we expect this run method to run, hopefully.
It is critical that a state instance does not refer to the room instance.
That's important and we shall see why. If it did, it would create a circularity that would
prevent the room instance from becoming eligible for garbage collection and from being automatically
clean. Yes, because for it to be eligible for garbage collection, we have to make sure that
there aren't any references to that object in memory. Therefore, state must be a static nested
class because non-static nested classes contain references to their enclosing instances,
which is why exactly we've declared this static. And I said to do some reading on nested classes
as to how the difference between non-static and static in the Oracle docs.
And then we shall take a look at how this class is used. So if we take a look at, let's say,
teenager, we're doing some garbage collection manually, explicitly, but we should not depend
on this behavior. So if I go run this and run this, in fact, first let's take a look at adult,
sorry, where we're using a tri-width resource. So the room is clean as used only as a safety net
if clients surround all room instantiations with tri-width resource blocks, automatic
cleaning will never be required. So as you can see here, I'm not, or just your block in this case,
isn't doing any explicit garbage collection because we've used it with a tri-width resource block.
And if I run this, you will see it says goodbye, but also says cleaning the room. So the object's
created and it prints goodbye. But afterwards, this cleaning the room along comes from
this run method here, which we've all written and written. And that also means
that the number of chunk paths is zero. So in fact, if you want to print out the number of
chunk files just to make sure that we know what's going on
and run that again, you'll see it's going to print zero.
Yeah, there we go. It printed zero. That's what we expected. But then if you go take a look at the
teenage's room and if you run it, it will not run it unfortunately. Oh, it did, but it's kind of
not. So I'm going to try it again. I'm going to keep trying it until it does not run it. Oh,
actually, sorry. If I comment the garbage collection, because I had that uncommented,
it should have been commented out. Now it shouldn't run it. You see that it just printed
out peace out, but there was no cleaning done. And then when I do the garbage collection explicitly,
now it's going to print cleaning room. And that's what we expect. And that was, though,
that cleaning room was imprinted from the previous line.
Sorry, it was printed off the previous line, of course, because it ran the run method, but
because we did do the garbage collection, that doesn't exist anymore. The memory was cleared.
And that's virtually it. That's kind of the utilities of using auto-closable and how it's
got to be used and why it's preferred over, let's say, using a finalizer, for example. And then
just to conclude that point and of that demo, Joshua Block states, you might expect it to print
peace out followed by cleaning room. But on my machine, it never prints cleaning room.
It just exits, which is kind of, well, that was before we did do the explicit garbage collection.
This is the unpredictability we spoke of earlier. The cleaner spec says,
the behavior of a cleaner during system.exit is implementation specific. No guarantees are made
relating to whether cleaning actions are invoked or not. While the spec does not say it, the same
holds true for normal program exit. On my machine, which is what we did here, adding the line
system.gc to teenagers main method is enough to make it print cleaning room prior to exiting.
The reason we didn't see that log here in line number 30 is because the moment it cleaned the room
and cleared out the resources, it exited and it doesn't really exist in memory anymore.
So I repeat that point again. On my machine, adding the line system.gc to teenagers main method
is enough to make it print cleaning room prior to exit. But there's no guarantee that you'll see
the same behavior on your machine, which is exactly why Joshua Block states here to test the behavior.
But note that you must not depend on this behavior. Again, not to beat on that horse,
but the biggest problem is the non-determinism. And we don't want that in programming. We won't
think to be logical and deterministic as script programmers. And in summary, he states,
don't use cleaners or in releases prior to Java 9 finalizes, except as a safety net or to terminate
non-critical native resources. Even then, be aware of the indeterminacy and performance
consequences. That's it. That was item number eight, avoid finalizes and cleaners. I hope I did
a good job at demoing certain parts of it. As you all know with these tutorials, the best way to
understand it is to after watching them or while watching them goes through the code base because
that's the best way to crack these concepts. But nevertheless, I hope my efforts were worth it. I
will try and keep enduring and getting through this whole book because I'm enjoying it. I'm learning
a lot, but also I want to kind of get into the habit of putting out these videos in a certain
schedule, let's say at least once every two weeks. But thanks a lot for watching. I hope you gain
some value from it and learn something. I'll see you in the next item. Cheers.
