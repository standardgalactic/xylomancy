Hey everyone, welcome to this video series called Textbook to Code, where I take computer
science and software engineering textbooks and sort of expand on them and convert them to code and
discuss them, kind of like what one would do with a tutorial in university. Now, if you
knew this channel, I generally make videos on philosophy, but I realized my other great love
other than philosophy is computer science and software engineering. So I was thinking,
why not do the same thing with that field too? And as the title suggests, the first book I'll be
covering is Effective Java by Joshua Block, certainly the best Java book I've read, even though
I'm still trying to grok certain concepts on it. It was recommended to me by my CTO and my current
company and he's been a Java programmer for, I don't know, ever since the internet. That was a
joke, by the way. I know Java was created after the internet. He's been a Java programmer for a
long time. And he said that this was a really good book to read, not really for beginners,
but more for intermediate Java developers. I consider myself still a beginner to intermediate.
So I don't really know at what level what should get into this book. However, I do believe
really the way it's structured, anyone can jump into it if you have a basic understanding of
programming. So Effective Java contains about, I believe 90 items, which means this video series
will encompass 90 items. And afterwards, I'm hoping to get to this book, which probably is
going to be next year, because it takes a long time to make these videos. The Headfirst Assigned
Patterns by O'Reilly, which I've just started on. And it's brilliant. I'm so grateful for all
these authors who just take so much time to educate and help upcoming learning software
engineers like myself, who generally aren't the most intelligent programming wizards out there.
Saying that though, as per usual with my normal videos, if you do follow this channel, you know
that I tend to make a lot of provisos or caveats. And the first proviso is this is not a tutorial.
And that's really important because the last thing I want to do is to propagate false information
or teach something that's wrong. And you know, to make this a video series of misinformation to use
a very politically loaded term. I'm not a teacher, not an expert. I've only been a Java
programmer really hands on for about two years. I'm still learning myself. I'd like to think of
this video series and all the videos in this channel, as a matter of fact, as more of a blind,
leading the blind kind of experiment, let's say, where I'm also naive and ignorant about these
topics. So it's just more of a exploratory, disquisition, let's say. I'm just trying to
see what this particular concept is. I'm trying to break that down, which means I will inevitably
make mistakes. No question about it. So please point them out, leave those out in the comment
section below. I'm sure there are much more advanced competent Java programmers who point
out some of my flaws. And when I say a blind, leading the blind, I don't mean I'm leading
anyone else in that sense. The point I'm trying to make is that let's try to collectively work on
this. And again, the best example I can use or the best analogy I can use is what one would
typically do in a university tutorial where you work with the tutor and the other students to
solve a particular problem. And of course, since this is a programming video, engineering video,
all the code that I used to expand on the first item, I shall have it on my GitHub account. I'll
leave a link down below. You could go download it and play around with it yourself. On that note,
let's jump into it. We'll start with item one. So this is from chapter two, creating and
destroying objects. I'm not going to cover chapter one because it's essentially just an introduction.
And the same way that I gave caveats in this video, Joshua Block himself gives a couple of
a few caveats on what this book is about. Just in context, Joshua Block is is brilliant. He
he was, I think he created or he was a big part of the Java collections framework. He's a
distinguished engineer at Google, I believe. So he's been a part of the Java JVM community
for a long time. And I certainly look up to him and I really enjoy just even watching some of
his talks on YouTube. But this book, this book really opened my mind into the the power of the
Java language. And in fact, all P principles in general. So again, as I said, chapter two is
creating and destroying objects. And the first item we're going to cover is let me zoom in a
bit because I don't want this to not be visible. The first item we're going to cover is consider
static factory methods instead of constructors. So when I read this item, the moment the first
time I read this chapter, sorry, this item, my question was, what is a static factory method?
And and in simple, the very textbook answer would be, it's a static method that returns an instance
of a class. Now, don't worry, I've got the code base right here, we're going to jump into all of
these things in much more detail a bit later. But I think it's sort of important at a high level to
get the terms right and get them all in order just to help our thinking. Look, I'm just going to say
my thinking, I'm not going to pretend as if this is a collective thing. It's initially me making a
video. And then eventually, hopefully it can be a collective thing in the comment section down below.
And, you know, not a bane, this is not the same as the factory method design pattern.
Even though I'm not going to lie, it maybe this is my lack of understanding of the design pattern.
I see many similarities between what the static factor method does and then the design pattern.
So perhaps that's why it's called a static factor method. So let's take a look at the keywords,
first of all. So when we say a static factor method, and let me give you a quick example,
in fact. So here we have the big integer class and a static factor method here would be
that right there, public static, big integer, the probable prime method, for instance,
is a static factor method. Which means we got a question that I asked myself was, what is static?
And I took down a few notes. Of course, the word static means a lot in software engineering.
And my notes said that the word static ensures that a member belongs to a specific class. So again,
in the example of this big integer class, this member belongs, this member as in this method
belongs to this specific class. Therefore, only one instance of the member exists, regardless of
the number of objects of the class created. So it doesn't matter how many instances of the big
integer class is created. But there's only going to be one instance of this method, because this
method, the probable prime method belongs to this big integer class, there won't be multiple objects
of that being created. And a static member is shared amongst all objects. So
because it belongs to a certain class, any other, let's say, client that uses this class and creates
an instance of this class with the new keyword, just shares that specific object, pardon me,
not all the objects, I think I'm a spoke there, more the static member, I think it's better to
think of it that way. So of course, I'll get into all of these stuff in detail a bit later. So of
course, that means that when you want to use this method, the probable prime method, one doesn't have
to create an object of the class, you know, use the new keyword, the way it's done in Java,
it just makes things easier. Also, and another caveat here, my understanding of
Java memory management is very, very high level. I know it's a very deep topic. It goes all the way
into the depth of what computer science is and engineering in general. So I have a very, very
superficial understanding of it. But my understanding is that static content, so any, it could be a
class, a variable, a method, doesn't matter, will be stored in a, in a place called the dynamic
meta space. This is a JVM will will store it in a place called dynamic meta space, which I've learned
to replace something called the permanent generation since Java 8. So all these static members live
in the dynamic meta space. Now, here's this is an important point that we're going to get to in this
video. I've, I've, I've got a whole bunch of resources and study material that I used as I was
creating this video and studying this book. So for each item, all the, what's the word, supplementary
reading material and studying resources, which I have a whole list here, just articles, blog post,
videos, whatnot, I shall leave them down below in the description. I really think it's, it's
super useful, along with the book, along with each item, reading those supplementary
articles, it gives, at least for myself, it gave a really good understanding of what
Joshua Block is talking about in each item, especially given that he, he expects the readers
of this book to be quite proficient in Java. So if you're sort of a int, in an intermediary level
like me, these, these background articles help. And on Java memory management, a very
groggable, easy, easy to understand video that I watched with us by Naveen Automation Labs. I
thought he explained it quite well. He's a great pedagogy, great teacher. It made a lot of sense to
me. And then I read this article about what the meta space is in particular, because since we're
talking about the keyword static. So along with the word static, the other sort of keyword of these
methods is factory. And here's where I said before, it seems a bit similar to the
factory method design pattern. And maybe, maybe it's because it does follow certain aspects of the
creation of the design pattern, even though there's no direct relation. In fact, in the book,
it says here, there's, oh, yeah, it says here, note that a static factory method is not the same as
the factory method pattern from the design patterns. I feel terrible now when I looked at the book,
I realized that I've highlighted certain things, as you can see, these bits from the book I wanted
to read out. And I didn't do it in the beginning of this item. So I'm going to do that right now.
I'm so sorry if this is chaotic and a bit messy. Please forgive me. I'm still trying to figure
out how all of this works and how to expand on these matters. So I'm going to read the, this is a
mess. I'm so sorry. I'm going to read the introduction to the item now, which I was supposed to do in
the beginning of the video, but I only realized that now. So here's what Joshua Block says.
The traditional way for a class to allow a client to obtain an instance is to provide a public
constructor is another technique that should be a part of every programmers toolkit. A class can
provide a public static factory method. There we go. Which is simply a static method that returns
an instance of the class. I'm glad I read that because I should have started with that bit,
because it's too confusing if not. Anyway, getting back to the factory keyword. So what this also
does is it allows to encapsulate the object creation process, because if you do notice,
and we'll get into this again, the constructors are private. So clients cannot access the
constructors and create objects as they wish. In many ways is in fact one of the advantages,
which we'll get to again later, of using static factory methods. The class can decide
when to create new instances of the class, and it's not that a new object is created for every
invocation when a competition is required. So therefore, I don't know if this makes sense,
but I think it's because it resembles certain creation design pattern, let's say
elements, the word factory is used to describe them. So now let's get to the why. The advantage is
what's the justification? Why is Joshua Block telling us to use static factory methods instead of
constructors how one would typically do? The first one Joshua Block talked about is that
unlike constructors, static factory methods have names. They tell it to the client, or they indicate
to the client what this method's doing. The example he's used is in the big integer class. Now he's
said here, the constructor, which is this, which I've taken down here. So in fact, maybe I should
go to the code itself without just showing it off notion. If you go to the big integer class,
here we have the, all right, sorry, it's a really big class. I have to go through the
code. The constructor here, which is the constructor for the big integer class. In fact,
on the comments that even says here constructs a randomly generated positive big integer,
there's probably a prime with the specified bit length. But it also says here, it is recommended
that the probable prime method is used in preference to this constructor unless there is
a compelling need to specify a certainty. Correct. So what this does is it just returns
a big integer, which could be a probable prime. But this is just a constructor. It's just the name
of the class. It doesn't really, to me as a client using this, doesn't tell me what this does,
which is why it's better using the static factory method, the public static big integer
probable prime conference. I would
write there where when me a client is using it as I've used it right here, I clearly know what
this method is doing. It makes the code clean. And of course, a class can only have a single
constructor with a given signature. You can't have, at least in Java, I don't know about other
programming languages, but I don't think so. One can't have multiple constructors for a class.
I assume maybe I'm wrong there, but that's at least my understanding. And then a very basic
question to ask us, what's the purpose of a constructor? The purpose of the constructor really
is as the name suggests to construct a class as it's said in the Oracle docs, a constructor is
used in the creation of an object that is an instance of a class. Typically it performs operations
required to, I'll zoom in a bit. Typically it performs operations required to initialize
the class before methods are invoked or fields accessed. Constructors are never inherited. So
for me at least as a client, using the probable prime method makes more sense. He says because
a class can only have a single constructor with a given signature, programmers have been known to
get around this restriction by providing two constructors whose parameters, whose parameter
lists differ only in the order of their parameter types. So method overloading. This is a really
bad idea. The use of such an API will never be able to remember which constructor is which
and will end up calling the wrong one by mistake. People reading code that uses these constructors
will know what the code does without referring to the class documentation because they have names
as in static factory methods. We don't have this restriction. And when I was reading this paragraph
I had a bit of a grin because in the project that I'm currently working on, which is a huge
enterprise massive Java project, I think we've got 40 odd microservices. And I see this happen
all the time. We, you know, a lot of legacy code, we've done a lot of method overloading. And sometimes
when as a client I'm using a certain class, or even if I'm instantiating a class, I'm not even
sure which method, which parameters to pass into the method because it's been overloaded so much
that it's, it's hard to work on as a client. Whereas with the big integer class, I exactly know
what I'm doing here, just using the problem prime method. So the second justification or advantage
is that static factory methods, as I sort of said many times already, do not require object
creation each time they're involved. It's one of the biggest advantages in my opinion that this
allows immutable classes for sure. It's also similar to the fly weight design pattern. Now I
put this note here just because I want to kind of put into the notes everything that's in the book.
I have no idea at the moment what the fly weight design pattern is. I haven't done any further study
into that. So hopefully when I do, I'll probably revisit this and leave a comment explaining what
it is from my point of view. The example that we can use here is in fact, this little method
method that I created. It's an example from the book, which was this method right here. It's this
simple method that I created called value off. It's an example from the book. So if I want to use
this method, and this method is in this class called manipulate strings, I don't have to create an
instance of the class. Let me demonstrate. So for instance, if I go here, and if I want to print out
something, let's just say value off, and we go manipulate strings dot value off, I'm going to
pass a true there. And then I run that, you will see it'll just print true. Okay, so I'll use this
method. And as you saw there, I didn't use a new keyword. There were no objects being created. I
simply accessed the method while the class, because that method's owned by the class,
so to speak. Then another advantage of not having to create objects is, and it took me a while to
grok this concept, because I had to do a bit of stack overflowing to use a term that we all love as
soft engineers. It makes classes instance controlled. So it says here in the book,
the ability of static factory methods to return the same object from repeated invocations allow
classes to maintain strict control over what instances exist at any time. Let's try to understand
this. So firstly, just keep in mind this makes a class singleton and non instantiable. So essentially
singleton means it at a given time only one object of that class can exist, whatever the class may be,
if we follow that pattern. And I really only understood this thanks to Joshim Sao, who posted
a really good answer on Stack Overflow. I shall leave a link to this down below of what this
concept means and how using static factory methods makes classes singleton and immutable. So to get
this concept first, let's see what Joshua Block is saying. He's saying that it allows immutable
value classes as I repeated multiple times already. And then it says to make the guarantee
that no two equal instances exist as in A equals B. So class A equals B only if it's equal in this
sense as in this equals sign means that the values in the objects are compared. The double equal sign
is a reference or a memory location of objects in the heap. So as I said, thanks to Joshim Sao,
I think I got what this meant. It gives complete control to the class as to when instances of
this class will be created. Now here's the example that he's used. So I did have it here. I'll zoom
into that. One of the methods here is deprecated. So you can't clearly as you can see here in the
docs it says that it's marked for removal because we don't really create new instances of the Boolean
class anymore. Now I'm going to comment that out for now and see here if I print this,
we're getting a true and false despite the first one because we're looking at the value in the
object. We're getting a true but here in the reference comparison or in the memory, we're
getting a false. Now personally for me, this was okay. I got what he meant conceptually but really
what I did was this. I created another small class called Fuba. As you can see, I made the
constructor private. So it's inaccessible to any client. And then what I did was I created a static
factory method called construct Fuba. If you can clearly see here what I'm doing is I'm returning a
new instance of the Fuba class. But in the method body, I have an F condition and I say only if the
number is greater than five, is it allowed to create a new instance of this class? Now yes, one
could say you could do this in a constructor too but doing it in a static factory method makes more
sense due to the previous advantage we spoke about, the fact that we can use the name in the
method. So you probably see here, I'm going to comment this out again. Now I'm using the construct
Fuba method and I'm passing, initially I'm passing the number seven. And then if I run that,
if I zoom in here, there you go. That's the object that was passed through. So it returned a new
object of the Fuba class. But that's because seven is greater than five. But if I pass two,
it's a null. So this is what Cheshire Block means by it gives classes complete control as to when
instances of that class will be created. On that point, I would also say just to keep in mind that
enum types provide this guarantee, by the way. So if you do this comparison that I did before
between different classes or between different types, you'd see it follows a pattern with enum
types. The third point is, or the third justification or why, so to speak, is unlike constructors,
static factor methods can return an object of any subtype of their return type. This again,
a bit like the instance control bit, it took a bit of time for me to understand what it meant. So
let's see what we mean here. The best example to use is certainly my favorite Java framework,
the collections framework, is to demonstrate what an interface based framework is. So the first thing
you'll notice is, if you go to the public class collections, it's constructors private. So you
can't instantiate it. And then if we take a look at this little bit of code that I put in,
I'm creating an array list. I'm creating, in fact, two array lists, a source and target list
of string type, and I'm adding values into it. And then in the collections class, I'm using this
static factor method right here. And what that does is it returns, let me just read the documentation,
it's much easier because they put it in much better terms with brevity, returns the starting
position of the last occurrence of the specified target list within the specified source list or
a negative one, if there is no such occurrence. So here we have the source list, here we have the
target list. And what I'm trying to see is I'm trying to find the first occurrence of this value
of the target list in this case. So as you can see, this CDE, which is the, let's call it the
sub-list for the old intents and purposes, it starts at the index number two, zero, one, two.
And if you print that out, it returns that here. Now that's, that's besides the point,
but the important point here over here is that the collections class is returning a type of
index, of integer, it's returning a subtype as it says here, is that unlike constructors,
they can return an object of any subtype of their return type. So it's returning an integer subtype,
which is different to the type of the collections class. And then of course, he expounds on the
matter, he says, this technique lends itself to interface-based frameworks, where interfaces
provide natural return types for static factory methods. And of course, a good example of that
is the collections framework. This class itself, just going through it, would prove that.
Then he says, prior to Java 8, interfaces couldn't have static methods. By convention,
static factory methods for an interface named type were put in a non-instantiable companion class
named types. So these kind of methods had to be moved to a separate class. And then as I said,
he says, for example, the Java collections framework has 45 utility implementations of its
interfaces, providing unmodifiable collections, synchronized collections, and the like. Nearly
all of these implementations are exported via static factory methods in one non-instantiable class,
namely this right here, java-utils.collections. Furthermore, using such a static factory method
requires the client, which is me in this case, to refer to the return object by interface. That's
what I'm doing right here. Interface rather than the implementation class, which is generally
good practice. The fourth advantage is that the class of the return object can vary from
call to call as a function of the input parameters. And the example he's used in the book is that in
the enum set class. So let's take a look at that. What I've done here is, oh, by the way,
the example I've used is thanks to Bill Dung. I know that every Java developer out there uses
this website as reference, but I know that all of us struggle to pronounce this word right here.
I think it's pronounced Bill Dung. It's the best outside of the Java Oracle docs itself.
It's, in my opinion, the best resource out there. So courtesy of Bill Dung for this example.
So to get back to this, what does Joshua Block mean by the return object or the class or the type
of the return object can vary from call to call, depending on the input of the function? So I'm
using the static factor method, none of here, which is a part of the enum set class. And I'm
passing a enum into it, which is this enum I created called color, which is contains a bunch
of colors. And then it returns a enum set. Now, what changes here? So what changes here really
is this. In this method, you could probably see it's extensor generic. That's fine.
Well, not that's fine. It has to be a generic because the types have to differ.
So of course, if it's null, it'll throw a class class exception. However, you see this, the
returning object, there are two types of objects that are being returned here. If the length of
the enum pass, so the enum, but I'm passing colors here, if the length of this is greater than or
greater than or equal to, sorry, less than or equal to 64, it'll pass a new instance or a new object
of the regular enum set class. So if I run this code now, you'll probably see here, I'm printing
out the class name of the return enum set, the class name is regular enum set. It's in fact,
a subclass, pardon me, or a subtype to be more accurate. If you look here clearly, it's of a
different type. It's not the type of enum set. Now, what happens here, though, is if the past enum
is greater than 64, it returns a different type called a jumbo enum set. So it's this flexibility
that using a static factory method gives us. So to reiterate, depending on what the input is to
this method, a different type can be returned. It'll vary purely based on the input. And then
Joshua Bock says that clients neither know, nor care about the class of the object they get back
from the factory. They care that only it is some subclass of the enum set. Correct. As far as I'm
concerned, when I was using the none of method, all I wanted it to be was of the type enum set.
I didn't care what subtype it was or what subclass it was. And that moves to the final
justification as to why one should use static factory methods as per recent by Joshua Block.
And I got to say, if you can already see from this video, I'm even struggling a bit to explain
myself and properly articulate my understanding of these concepts. Perhaps that's my own lack of
communication, lack of the ability to articulate myself, but also it's because I'm still dealing
with issues and trying to make sense of it in my own mind. This one right here, the fifth point,
it took me about a week to write the script. The fifth point, I spent four days on it,
because it did take a bit of understanding of the JDBC framework to see what Joshua Block
is talking about here. The fifth point he tries to make is that the class of the return object
need not exist when the class containing the method is written. So let me re-read that. The
class of the return object, whatever the method invocation returns, need not exist when the
class containing the method is written. Now, firstly, he says such flexible static factory
methods form the basis of service provider frameworks. Now, I was a bit embarrassed because
I've used JDBC quite a lot, but I didn't know that it was a service provider framework. I didn't
know that that's what it was called until I read this book. By the way, I just want to make this
point here. The great thing about reading such books is that all these different libraries,
like all the frameworks like the collections framework or JDBC API, that we use in our day-to-day
job that we really don't think too much about, we start really appreciating the engineering and
the kind of the craft of them once we understand the reasoning and the principles behind how they
were built. So this is a good example of how JDBC is a, sorry, my mind threw a blank there,
a service provider framework. So I find it a bit hard to understand the point
just a box making using the JDBC framework. However, just to get the ideas of what it is,
I put together this bit of code here. And as I read before, it's got the provider registration
and the service interface. So in the start of code here, the driver manager, sorry, the
registered driver, this bit here is the provided registration and driver is the service provider
interface. And then if we go here to connection again, connection is the service interface
and driver manager dot get connection is the service access API. So essentially what I'm
trying to demonstrate here is the different components of what, of what the service provider
framework encompasses. And as you clearly saw, I had a terrible job at explaining how this relates
to our item in, in using static factor methods, which is why I found a much simpler example
on second of a flow where we have this right here. This was by Bruno Reyes and I thought he
explained it much better. So he says here, with this code, your library doesn't need to know
about the implementations of the service. Users of your library would have to set a system property
containing the name of the implementation they want to use, which is if we go down here, this
static factor method here, which is stored in this class will just give us a new instance.
As in, I don't care if this class was created or if it exists or not, all I'm expecting is because
I'm getting it through the, through the contract between the interface that I'm getting a instance
of my service class. That's it. Gosh, I think I butchered that. So again, to reiterate, this static
factor method full name is going to provide an instance of some class, which is the class right
here. In this case, it's the driver class. And that's all I care about. I just wanted to come
off this type. I'm doing a typecast here. And that's all I really care about. And that's because
of this contract that I have with the interface, essentially. Okay, this is why I said that this
isn't a tutorial because that fifth item is something that I'm still struggling with. And
I swear, I tried to make sense of it through the JDBC framework, but it's still, it was a bit hard
for me to really grok. And then I found this answer on Stack Overflow, which I thought was
done much better. But look, if any of you know a better way of explaining it, please do leave it
down in the comment section, I would be very grateful for that, because that's certainly one
advantage from this item that's still, I don't, I don't still fully get. So having discussed all
the advantages or justifications, a proposal using static factor methods, let's now get to the
limitations. The limitations aren't really much. So it makes a lot of sense to use them in most
places, unless there's an exception, let's say. The first one is that classes cannot be subclassed
without public or protected constructors. On the note, just before I get to demonstrating what this
means, there's a good resource, sort of, I guess, an answer on Stack Overflow that I found, which
discusses why constructors are needed for subclassing. And I thought it was quite good. So I'll leave
a link to this in the description down below too, if you want to go give it a read. But simply,
it's very easy to show. So here I have a class called main. And then I have one class, which is
another, another class called animal with constructor. So if I go to that right here,
here we have the public class, and we have a public constructor, as you can see here. Now I can
easily go to the main class. Oops. Anti extends animal. There we go. And it simply extends that
class. However, now I have another class without a constructor. In fact, I've made the constructor
private. So it's not accessible by the by the subclasses. And if this tries to extend this,
an error is thrown. It says here, there is no default constructor available in the
superclass. So and also if I try to create an instance of this, we get the same error.
Now what's funny here though is, of course, Joshua Block says, and I'll read this out,
arguably, this can be a blessing in disguise because it encourages programmers to use composition
instead of inheritance. Exactly. I don't have to extend that class. I can use one of the most
fundamental OOP design principles to try and favor composition over inheritance. The second
limitation is that he says, I don't even really know what he means here, that it's hard for programmers
to find that these methods are hard to allocate. I'm not sure if that really applies anymore,
because with for instance, I use IntelliJ with really powerful exhaustive ideas like IntelliJ.
All I got to do is hit command and click on the method and boom, I'm there. I've got the docs,
everything I need. So I wouldn't say it's hard for programmers to find. Nevertheless, he does
state that some show there's a good reason for it. And then what he says is biggest some of these
static factor methods are hard for them to find that he's going to enumerate a few of them and
list down some commonly used static factor methods. So I thought I'd do the same. And once again,
all of this code is going to be on get up. So if you want to take a look at some of these methods,
just click the link down below and you'll have access to it. So the first one is a from method,
which is essentially a type conversion method. So it's quite easy to understand really. What
we have here is we have a type of instance, and we pass it to to the date. And from from that
instance, we get a type of date. So it does a type conversion. If I run that code,
you'll see that that instance type was converted to a date type, and then it printed it down here.
The second one is a aggregation method. What this does is similar to a previous example that I use
is it takes this enum list. So I've got an enum called rank here, Jack, Queen, King, and then it
just gives us a set, an enum set of this enum right here. So if I do print that out,
you can see here it's printing that set on the face card. So it makes sense to call it an aggregation
method because what it does is it takes all these different items in an enum class and then
aggregates them and returns a type of enum set. And then we have the big integer value of which
again, this is the same thing. It's a type conversion method. And he says, yeah, it's a verbose alternative
to to from and off. So in this example, you could probably see I'm passing into this method,
something of type integer, and it returns something of type big integer. So just that type
conversion there. The next example is it's sort of like I've created a quasi demo for this get
instance methods. Essentially, what it does is that it's described, it returns an instance that is
described by its parameters, if any, but cannot but cannot be said to have the same value. So the
example here would be, I've got this void method called method three. And this Stackwalker class
here is getting an instance of the class class that invocates this method. So
here is this is in the Stackwalker demo class. And as you can see, if I go up here,
there's an instance. Oh, that was a mistake. I should have I wonder I should have made that a
static method. I don't know why I let me correct that right now.
Public static. That is good because it shouldn't be a
sorry, that was a confusion. The actual static factor method was this in the Stackwalker class
to get instance class. This is what happens when I work on these things way back and I record the
video on a separate day. Sometimes even I forget why I did what I did. But just to get back to this,
so I've created the Stackwalker demo class and I've created an instance of it right here,
which is boom. And I'm accessing this method through the object or the instance of that class.
And what this is really is it just prints out the color class. So the Stackwalker instance,
as you can see here, it prints, it gives us a reference to the class that invoked this method.
So method three was method three was invoked by this class here, the common static factor methods
class. So if I print this out, you'll see here, it tells us, huh, this was the class that invoked
this method. And it's using the get instance static factor method. And the next example is quite
similar. The new instance method will guarantee that every invocation of it will return a
instance of the string.class here, the class that I've specified here. So I'm passing an array.
And then I'm also passing the type of the class here. In fact, let me just go to that method.
It takes these parameters as shown here. It takes the,
yes, the component type, the type of the class, it's a generic, and then the length of the array.
That's what this does. And if I print that out here, it just prints out the type of the class
you can see here. It's just a string class that I've passed through. And then the get type static
factor methods are similar to the example, not this example, the previous one with the Stackwalker
demo class that we, with the get instance demo there. What this does is it returns a different
type, essentially. So if you look at this here, I'm getting a path, I've got a file that I've
created. And if I go to the files class, it's of type files, obviously. And then this get files
to static factor method returns a different type. It returns a type of file store, despite being
in the class files. And if you look at the method, you'll see, I'll zoom in there again,
the get file store, it's in a separate abstract class called get file store. Pardon me. It's
in a separate abstract class called file store. So it's not in the files class. And similarly,
the buffered reader does the same thing, but instead of getting a new instance, it creates a new
instance. So if you go to the buffered reader, which again is in the files class, and if you go
to the static factor method, it is returning a new instance of, whoa, that's a bit weird. Oh,
of course, of buffered reader. There we go. And of course, similarly, the new type does the same
thing, but instead of getting an instance, it'll return a new instance. So if you go to the new
buffered reader, static factor method, which is in the files class, by the way, as you can see here,
it returns a new instance of buffered reader against a different type or to what what files is,
or it's in a different class, let's say. And finally, really, all the other stuff won't even
get useful because well, they are useful. But I think most of us use this, the generics, which is
in the collections, things like less area lists, which I'm in the collections framework. And what
this does is it returns a new vector of a given type. So for instance, I've created this enum
called complaint, and I can create a list of that type and add stuff into it essentially. And if you
want to see, it's going to print all that stuff. All these examples that I've used was sort of
in the book, and I repurposed them just for me to understand. But really, from all the static
factor methods I went through, I think the ones we use mostly are the ones in the Java
collections framework. Nevertheless, it's important to enumerate all of them. And in summary,
Joshua Block says static factor methods and public constructors both have their uses,
and it pays to understand their relative metrics. Often, static factor methods are preferable.
So avoid the reflex to provide public constructors without first considering static factories.
That was much harder than I thought. I have to admit, I thought I could sort of go through my
thought process, but you know, any programmer would understand that sometimes we don't even
know where we do what we do, we just type and things just happen. That's fascinating, isn't it?
In any case, I hope you enjoyed the video. I hope you found it informative. I certainly, as I said,
in the proviso middle, I'm sure I've made a lot of mistakes, so please do point them out.
In some sense, selfishly speaking, for my own learning, but also so that I don't
mislead anyone and provide false information. I've already started working on the next item.
I'm still rereading that item and starting the different examples. The second item is
consider a builder when faced with many constructor parameters. I shall hopefully get to that soon,
but at least for now, I hope you enjoyed this item and I'll see you in the next one. Cheers.
