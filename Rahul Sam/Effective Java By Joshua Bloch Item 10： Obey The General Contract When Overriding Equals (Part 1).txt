Hey everyone, welcome to yet another episode of my video series on Joshua Bloch's Effective Java where I go through the items that he has
Animated in this book and expand on them and try and make sense of them
And hopefully as I do that you can gain some value from it too and today and forgive me for being
Self-advertising but I am quite happy because I managed to get through the first nine items which is essentially chapter two
So the first part of the book and I am I'm really happy that I didn't do it through I'm I'm glad that
First of all, I'm really enjoying this. I'm learning a lot, but also
Given that this is something I'm new to
Expanding and elucidating on programming or just any concept in general
It's something that I'm I think it's a skill that I'm developing on learning to
Communicate and articulate myself when discussing programming concepts or software engineering concepts, let's say
and obviously, I
Still don't think I have a really deep understanding of the Java language
therefore, it's a great feeling to get through the
first nine items or the second chapter which
Essentially is the first chapter in this book because the first chapter is the introduction
And today we're gonna move on to chapter three
And as per usual before I do that
This is not gonna change. I've got to always do this
proviso in the introduction
So if you've been following along in the series, you could skip this bit to save your time
But without further ado, let's get started with the proviso
Firstly as I always state
This is not a tutorial and I certainly am not a teacher or an expert
Which is again one reason I'm really glad that I managed to persist through the first to the first nine items
as
It is not something that naturally comes to me to be able to
Let's say teach firstly because I too am learning as I go along
Trying to make sense of these items and the concepts in the book. So again, sorry
I'm talking too much the proviso or the caveat is this is not a tutorial. So please don't treat it like one
I'm pretty sure I've in fact
I've already made a few mistakes in the previous items and I've corrected them and tried to rectify them in the comment section
When people have pointed them out and I'm pretty sure in the remaining what 90 odd items
I'm going to make a lot more mistakes. So firstly, please do point them out
and
Again, don't take what I say as let's say gospel's truth. This is
An analogy that I use is
Blind leaving the blind which is kind of what I feel like I'm doing here. I don't know what the hell I'm doing and I'm trying to
Hopefully
Make things a bit more lucid for you the viewer who probably also doesn't know what the hell you're doing
Probably you have a better idea than I do, but still I feel equally lost in this world. Isn't that the ultimate verity?
Yeah, I call this a
Exploratory discusion. So it's something I'm trying to collectively make sense of using stuck-hole flow using the community that I'm trying to build around
this video series and
Since recently even a chat GPT. I've been asking questions for a company to this book from chat GPT and it has been
Sublime. It's it's been extremely helpful. That's great. So again, I think I already made this point
I will inevitably make mistakes. So yeah, please phone them out and
Given that this is a
Programming video series
All the code that I use will be up on GitHub
It'll be published on GitHub not only on my personal repository, but also Joshua blocks. Let's say official
Repository on this book. I'll leave the links down below in the description
And saying all that let us get started with item number 10
which is
Obey the general contract when overriding equals and this item since we are now in a new chapter is a part of chapter 3
Which is methods common to all objects
so
item 10 is
Undoubtedly the longest item in this book. I think it's
Probably
15 20 pages. It's quite long. Therefore. I have no choice but to
Well, I probably could cover the whole item in one really superficial video
But that's not the intent behind this video series
Yeah, it's not really annoying. I live in a very very quiet neighborhood, but the moment that I've got a recorded video
Some son of a bitch doesn't matter. Okay, back to this
Where was I see I got distracted. Okay item 10 is quite a long item and
and
And the intent yeah, that's that's where I was the intent behind this video series was always to try and and go as deep as
possible into these ideas
within what
Within what I can manage
There's a limit as to what my understanding is
I don't think I can go to like the compiler level than explain the JVM algorithm and whatnot
I'm not that knowledgeable on Java or programming in general, but to my limits to my current limits
The goal was always to go as deep as possible
So therefore I am gonna split up this item into
Multiple parts for now
I'm thinking three parts because it kind of breaks down the item if you go through where they come has this
Part where it's it's no connected of course
But then one leads to the other and I think you could break it down into three coherent parts. Let's say
But also apart from its length
I really enjoy this item because it does involve some quite interesting computer science
I mean basic first-year uni computer science
But still it's always a good feeling at least for me to revisit some of those concepts like truth tables
And and logic and all of that that we learned it in uni
So again item 10 states
obey the general
obey the general contract when over writing equals I
Apologize I just realized that since we are starting a new chapter
I looked at the book and I didn't read out the introduction for chapter 10
Which is methods common to all objects. So before we get to the item itself. Let me read that out
The chapter starts off like this
Although object is a concrete class
It is designed primarily for extension. That's correct. All classes
Are subclassed from object
All of its non-final methods equals hash code to string clone and finalize
have explicitly
Sorry have explicit general contracts because they are designed to be overridden
It is the responsibility of any class overriding these methods to obey their general contracts
Failing to do so will prevent other classes that depend on the contracts
Such as hash map and hash set from functioning properly in conjunction with the class
So exactly as the introduction does suggest
Essentially this whole chapter is going to be about this object concrete class. It's a good segue to this diagram. In fact
this is
this is a
Let's let's just call it a skeletal diagram of what
All the classes in Java look like so as you can see
The object is a super. Let me zoom in a bit
The object is the super class of all the other classes in Java and they inherit from that. So these methods that
Joshua block just a block in
Animated equals hash code to string clone and finalize
They're all methods of the object class that we'll be using across all the other classes and even the classes that we create
On our own it provides a really good blueprint and in this item
We're gonna really focus on the equals method and why we should obey the general contract when overriding this equals method by any of these
Other subclasses that do inherit it from the superclass object
So firstly just to get some formal definitions out of the way, I always like doing that
I think it's a good way to get a very high level understanding and slowly
Narrow into a to a concept
The Oracle doc state
Class object is the root of the class hierarchy
Every class has object as a superclass all objects including areas implement the methods of this class
So which is why again the the the
The advice by Joshua block is to please try and obey the general contract when overriding any of these methods that we inherit
and
Now pertaining more to item 10. Let's take a look at the equals method because that's what we're gonna really discuss in this item
Again from the Oracle docs, I really like this definition actually it's it's a very straightforward one and kind of
Puts it quite coherently
The Oracle doc state with the equals method is
That's how it's defined in the object class public Boolean equals
So it returns a Boolean and then you can pass an object into it as a parameter. It takes an object
The equals method implements. Sorry. I should say as a parameter. It takes
Something of type object. Okay back back to the definition the equals method implements an equivalence relation or non-null object references
The equals method for class object implements the most discriminating possible equivalence
relating
Sorry, I'll read that again
The equals method for class object implements the most discriminating possible equivalence relation on objects
That is for any non-null references reference value values x and y
This method returns true if and only if x and y refer to the same object
Or in a bit more logic based sense x double equals y has a value true
So firstly it's important to understand this this double equals operator. I forget if there's a proper word for it, but
We need to firstly explore what?
This idea of equivalence relation means because that
Pertains a lot to this item
But before we get to that, let's
Firstly try to understand what this double equals operator is
So I got this article from Geeks for Geek and firstly let me read out the definition and once we are done with the definition
Let's try to make a bit more sense as to what how bad differs to the equals method. That's in the object class
So the definition goes in Geeks for Geek Geeks
We can use the double equals operators for reference comparison address comparison and
Dot equals method for content comparison
In simple words, the double equals checks if both objects point to the same memory location
Whereas the equals evaluates to the comparison of values in the objects
So it's a really simple concept. I mean I can just show it right here
Actually instead of showing it on my notion page. Let me just open up this article and show it here. So this is quite straightforward
We have two variables
S1 and S2 of type string and then S1 and S2
Will will give
What will pass through because this string value? Hello?
It's memory address is the same
It's it's it's immutable
And it'll it'll be the memory with the same address. So this will really do a memory address comparison
But here with S1 and S3 because we had firstly, this is an anti pattern one should never do this because it's a waste of memory
This new object of string we are creating called hello this hello for a variable S3
That gets a
Separate memory address so then when we do the same comparison despite the content being the same
It's gonna return false because the memory address is different
But that's not the case with using the dot equals method. That's in
Dot equals method. That sounds weird the equals method. That's in the object class
So string obviously is an object it inherits this method from the from the object class and
Here in both these lines. It's a pure content comparison. So despite
S3 and
Either S1 or S2 having a different memory location the content is for the same
so that's the comparison that the equals method does so
You gotta remember that that's a general contract that we need to respect and we need to follow when if we are to override
This equals method that it's the content that we compare. So going back to the definition from the Oracle docs this term here
Equivalence relation. It's actually a mathematical logic concept
So we I don't think we're gonna get get to that really firstly even I myself because I'm not a logician
I haven't got a good understanding of of of everything that entails or everything behind the theory behind equivalence relation
but
I propose Java
What equivalence relation really means is comparing the content of the of two objects
Which is what we did in this example here. We're comparing the content and not really the reference in memory and
Saying all that let's get to so I should have mentioned this earlier in part one in this video
Which is part one of item 10?
We're really gonna focus on this when not to override the equals method and
Then in the next part we'll get to the crux of the matter as to when exactly to override it and then
How to to follow the general contract or obey the general contract?
so
firstly
When not to override the equals method
So if we do inherit this method from the superclass object
When is it okay to not override it despite most times we may have to override it?
In the item 10 Joshua block starts off like this
The easiest way to avoid problems is not to override the equals method
In which case each instance of the class is equal only to itself and then he states
This is the right thing to do if any of the following conditions apply and he's listed down a few of the conditions
So in this item will go through sorry in this part of this item
Getting a bit confusing in this part will go through those reasons
The first one is if an instance of the class is inherently unique now. What does that mean firstly?
Let me read out the definition
He states
Don't override the equals method if each instance of the class is inherently unique
This is true for classes such as thread that represent active entities rather than values
The equals implementation provided by object has exactly the right behavior for these classes
So of course a question with asking is what is thread?
What is the threat class the threat class you can go through the docs on Oracle
But it's for it's used to spin up a new thread a new thread of work simply put according to the Oracle docs a
Thread is a thread of execution in a program
But JVM allows an application to have multiple threads of execution running concurrently
So obviously the thread class is used for a concurrency
And much threading so why would a instance of a thread be inherently unique?
it it seems rather obvious isn't it because
Whenever a new thread is spun up, even if these two threads are spun up from the same state
We we were pretty sure that they're not gonna act the same way once they're spun up and they start executing in their computation
they the threads in that sense represent a dynamic computation a dynamic object where
It it throughout its lifetime. It's gonna change. It's gonna. It's not gonna be consistent and therefore
Two threads that may again start on with the same state
Will still act completely differently because they're doing completely different work. Therefore, it makes no sense to
To override the equals method that that only compares the content of
Two objects for the threat class because we know that they're gonna be inherently unique
Therefore if you do compare two thread objects, their content is gonna be different
Therefore, it's no use to overwrite it and try and change it because
What the object class has defined in the equals method that does the job
And if we just suppose the threat class with something like the string class
Where we know the content of the string class is gonna be the same as in not the content of the string class
But if you have two objects like this we can make this object immutable because we know the content is gonna be the same
Therefore, it's no use doing something like this where we
Recreate a new instance of that class and have a new object. That's again, as I said an anti-pattern
So this is a static object in that sense for for all intents and purposes
Whereas that that won't be the case for the threat class
the next reason is
to not overwrite the equals method is if a
Logically quality tests in a class is not required
So a warranted question is
What is a logically quality tests firstly?
Let's understand what logical equivalence is and this kind of what I meant by there's a bit of basic computer science that I find always interesting
So Khan Academy defines logical equivalence as the idea that more than one expression can have the same meaning
But have a different form often a form that helps make the meaning more clear
So the example on Khan Academy for logical equivalence is
If you take these three statements, you cannot go to the park if your sister is awake or
Your room is dirty. That's one statement. The other one is you can go to the park if your sister is not awake and
Your room is not dirty
Or even simpler
You can go to the park if your sister's asleep and your room is clean now these three statements
despite having a
Different structure or different let's say content
They are still logically equal in terms of the meaning we derive from them. There's logically equivalence
But but for Java, of course, I just wanted to read that up because I thought it was quite interesting. Oh, by the way
Before we get the Java idea in the context of Java. I mean, let's let's take a look at this is like a
Biconditional truth table. So another way of thinking in a bit more formal sense of logical equivalence is is if we take
logical equivalence if if both P and Q are true, then
The biconditional value is also true if either one of them is false. It's gonna be false
But also if all of both of them are false, they're still they still have this logical equivalence. Therefore, it's gonna be true
so it's it's it's like a
One one is one and then zero zero is still one if that makes sense
But you know in the context of Java, it's I just saw that was interesting
And I wanted to go into that and the context of Java of course logical equality compares the content
The content of the object the data of the object
Instead of the values of the memory reference as we discussed earlier
So let's take a look at a quick demo. Oh before I get to the demo
Let me read up definition by Joshua block on that point. So again, he says
there's no need to
override the equals method if they if there's no need for the class to provide a
logical equality test
For example
The Java util reg X pattern class
Could have overwritten equals to check whether two pattern instances represent represent exactly the same regular expression
But the designers didn't think
That clients would need or want this functionality. Correct. It's if this very much
This is like the art of object-oriented design
It's important to understand
What what the context of a API be right will be used and and these the designers of this API
I thought that it's it's not necessary to override the equals method because
We would never really use the
Equals method to compare two instances of pattern and let's take a look at an example
so a quick demo I have here is
Let me open that up
So I have this static Boolean method called run regular expression against string which takes a reg X and takes a
text of type string and
really what we're doing is we're creating a
Compile reg X of type pattern a pattern object and
Afterwards, we're using the matcher which interprets this pattern that that's so pattern dot compile returns a pattern a compile pattern and then match
Interprets what it returns to look for equivalence
So not for equivalent. Sorry to find that pattern in a given string or a given
object of type string
So over here if I run this
You'll see it returns true false false
So the reason for that is because obviously this reg X is a reg X for an email address
And the first one is an email address these two don't fulfill the requirements of this reg X pattern and
Attending to our point
This the designers made it made a call that
Uses of this API
Will never never want to compare
Instances of the pattern class. There's just no reason for it. Therefore, we can leave the this as an order to put it in a bit more
formal sense
The designers made it made a call that the users of this API
Will never require logical equality between instances of the pattern class
Therefore we can leave the equals method as it is they they thought and at times like that
There's no requirement to override the equals method and the other reason of course not override is if the class you're writing and designing
already has a superclass and inherits
Methods from the superclass and if that superclass is already overridden the the equals method appropriately to the subclass
Then this wouldn't be an issue. We wouldn't have to again override the overridden equals method. That would be a bit absurd
In fact, we're not gonna get to this
in this part but in the next part we're gonna discuss
the
The list code
Substitution principle that is something we should follow when in class hierarchies and inheritance because of that principle
And if we do follow that principle
Theoretically, there shouldn't be a reason for our subclass to override a
Equals method of a superclass that's already overridden the equals method of the object class if that makes sense. So for instance
Before I get to the demo, let's take a look at this
This is the class diagram for and I I'm not sure what the accuracy of this is because the Java collections framework is huge
And it's growing huge sound like trumpet. It's huge and it's growing
Quite a lot and and as you can see here
There's a there are there are many that all the class hierarchies their implementations and extensions and inheritance taking place so
The example that just your block has given in the item is
So don't override when a superclass has already overridden equals as I did say and the superclass
Behavior is appropriate for this class
And if we do follow that principle theoretically, it should be the list curve
Substitution principle for example most set implementations inherit their equals implementation from abstract set
list implementations from abstract lists and
Map implementations from abstract map and that's why I wanted to have this
Diagram here because so if you take a look at set you can see that the
the set or the hash set in this case is
inheriting
Sorry the set interface is implemented by the
abstract set as you can see here
And so yeah, sorry, I gotta be confused there the set interface is implemented by the abstract set
And I've closed in the concrete class, which is the hash set that is here
extends that abstract set but also implements the set interface
Not sure why that happens, but why would it?
extend the abstract set and again implement the set interface if the
abstract set has already
Influenced at the set interface
I'm not sure but in any case. I'm not gonna get into the Java collections framework here, but the point being if the superclass is appropriately
Done the overriding. There's no requirement for
The subclass to do the overriding again. So in the example that I've used I've just created a few
hash sets hash sets
I'm just gonna write and show it to you
Oops
You can see here. I'm comparing
the first hash set to the second one and the
Again, the first one of the third one the first two has set. So hash hash set
Has set and has set two
They both have equivalence a in the sense of
Logical equivalence. So the content of the objects are the same. They both have effective Java
Where's the third one hash set three has effective type strip a type script and we compare
Hash set three to hash set one. It's part. It's returning a false and that's what you expect
So that means a superclass, which was the abstract
Set class has done the overriding correctly and it's following the general contract of the object class equals method
Just on the Java collections framework as you saw even I was quite confused
I mean, I really don't know if anyone except probably the designers and
You know the the pantheon of the Java legends
Uh, have a tarot understanding of the collections framework. It's it's quite quite large and
extensive
Uh, but if you do want to read about it
This is in fact not even read about it
But it's just good to like bookmark this page and use use it as a reference or these says you could just ask
Chachapiti
Life is much easier
Okay, before I go off on a tangent the
the other reason
to not override the equals method is
If you're certain that the equals method will never be invoked
quite straightforward that again probably relates to the other point where
As a designer what has to make that call and and and see
If users of this api will ever really invoke the equals method
So just show block states that the class so if it will it will not be invoked if the class is
Is private or packaged private and you are certain that its equals method will never be invoked that was a
confusing way
Of for me to put it but you get the point and then he states if you're extremely risk averse
You can override the equals method to ensure that it isn't invoked accidentally
And I think it's good to be
Risk averse in that sense and I shall show the demo as to why it's probably a good idea to override the equals method
Regardless of it being private regardless of the class being private or packaged private
In this demo
So we have this class called demo and then in that class we have a private inner class
So a private inner class now this class would only be used by the demo class because it's private
No one outside can use it. It's
Well encapsulated and in the private inner class. We have overwritten the equals method
And I shall show this bit a bit later. This is how you be
fully risk averse and prevent
Any class from overriding the equals method or or any use of this api
So if you go to the this private inner class method, which I know can be a bit confusing
I call it a private inner class method not because it's inside the private inner class
But this method, which is a public method
Can be used to access this private inner class via
The outer demo class. So that's what we're doing here. We're creating a new object of the inner class
And we're calling this function called
Display and then we have perhaps a malicious actor who's trying to
Do the same thing access that private inner class
Uh via the outer demo class
And trying to invoke the equals method
So if I do run this code, so here's a client that's using it
We've created an object of type demo a new instance of demo class
and if I run this
You'll see as expected. It's it's running the private inner class method and it's first printing
This log here and then it's also printing the
log inside
The method display which is inside. Sorry
Of the method display which is inside the inner class the private inner class
And that's fine. That's that's okay. We we probably expect that however
let's say
this person wants to access
What do I do there?
I collapse my function. Okay. Let's say, uh, this person wants to access the equals method
That's in the private inner class and we don't want it to be
accessed by anyone
In that case what we can do is we can throw a new assertion error saying keep away
Uh, and therefore if a client now tries to access the equals method
By the outer class it'll throw an error
Just like that
Throw an assertion error saying keep away and that's how you be extra punctilious and careful
And not allow anyone to use the equals method
Especially if that's someone's expected by the designer
That is that is the end of item
10 part 1
I was going to say at the end of item 10 most certainly not we've still got heaps to cover in fact part 2 of this item
Is going to be quite long because we need to go through all the reasons
When it is appropriate to override the equals method and that's quite interesting
So and then in part 3 we'll we'll finish it off with kind of summarizing on how
To respect and obey the general contract when override an equals method and again
I know it's quite long, but there's a reason that i'm doing that as I said I won't the intent of these items
Is to go as deep as possible
Within what what I can manage
Uh, and I hope you find value in it because what's the reason what's the use of just superficially reading these things if we don't really
Grock the concepts
Saying all that thank you for watching. I hope you found value in this video. I shall see you in the next one. Cheers
