Thanks very much for having me.
Yes, so today's talk is going to be the value of values.
And I'd like to start by pulling the room.
How many people are in IT or an IT-related field?
This is great.
The key is to start with an easy question after the party.
So what does that stand for?
It stands for information technology.
And one of the themes of this talk is going to be keeping in mind
what information means and what we're actually trying to accomplish.
And looking at the tools and technologies we're using
and seeing if they are actually suitable for accomplishing
what we're trying to do.
So we'll start with that key word, because the technology part
I think is straightforward.
And we'll look at information.
And of course we'll start with the definition.
Everybody knows this is my stick, right?
If you're going to do a talk, you just pick a word,
then you go look it up in the dictionary, and you're rolling.
And it's a cheap trick, but it's actually quite useful
because there's a lot of the history of human thought
sort of boiled down into language.
So if we look at the word information, it's based on the word inform.
And inform actually means to convey knowledge via facts
to shape your mind or to shape someone else's mind
by communicating facts to them.
That's what it means to inform.
And the key word I think in here, again, which is going to be a theme
of this talk, is the word facts.
Because we're going to try to give more precise meaning to that
and see if our information technology actually manipulates information.
Because that's what information is.
Information is those facts that are used to inform.
And not anything else, not any of the artifacts we use to represent it.
So start again with what is a fact?
Now this is not the dictionary definition.
So a fact is a place where information is stored.
And there's a place for every piece of information.
And every fact has a set of operations.
Like definitely get and maybe set.
And although if set doesn't have the right controls for the fact,
there might be other kinds of operations that would control that.
And then that's essential, right?
That operations control how facts can change.
And then when we want to communicate about facts,
all we need to do is convey their locations.
Right?
How many people are uncomfortable right now?
I am.
I keep a straight face with this slide.
Are you kidding me?
This is not right.
This is very, very wrong.
If my partner, Stu Holloway, is in the audience,
he probably almost had a heart attack.
Well, this slide is up.
This is not what a fact is.
And yet a lot about that description is similar to what our programs do.
So let's dig in to the word place.
And a place means a particular portion of space.
And space is another word that's very interesting.
It's going to come up later.
The keyword here is particular and portion.
And the delimiting nature of this,
this other definition has that same characteristic, right?
An area used for a particular purpose, a specific area.
And we're really comfortable with the notion of place, right?
Because we have two critical places.
We're constantly manipulating with our programs.
One is memory.
And the other is, you know, the disk.
And they very much co-align with place, right?
They are places.
You know, there's only so much memory in the particular justice of memory.
And there's only so much disk space.
And there are sectors on the disk.
And these are all places.
They're subdivisions of the universe.
You know, there's only so much in the universe that's on my hard drive.
There's only so much in the universe that's in the memory of my computer.
So, I mean, I want to look at what we are calling information systems now.
Because we're building information systems.
And in memory, we're building them out of mutable objects.
But mutable objects are actually abstractions of places.
They don't actually have meaning other than that.
They're little barricades we've set up in front of memory
so that we don't have to directly manipulate memory addresses anymore.
So, the subtraction that is an object
that sort of helps us manipulate that place, you know, without too much craziness.
And a key characteristic here is that objects have methods, right?
They have those operations we talked about before that facts really don't have.
Objects critically have them.
They're operationally defined.
And we use them to provide a layer of abstraction over the places that our program uses.
And the same thing happens in storage, right?
We again have, you know, tables and documents and records
and these higher level notions that fundamentally are born of the desire
to, again, abstract away the details of that fact that we're working with a place.
But the abstraction isn't really a first-class abstraction other than to hide place from our programs.
Actually, it isn't a sound abstraction above that.
And one of the ways you can tell that it's a place-oriented abstraction
is this update, the same notion of going to a particular part of the universe and manipulating it.
So, these are what we're building information systems on right now
and I think we may have some difficulty seeing how that's correct.
So, I have a new label for this. It's called PLOP.
And PLOP is place-oriented programming.
That's what most of us have done for most of our careers and most of us continue to do.
And it's characterized by a very basic operation, which is new information replaces the old information.
It's that simple. If that's happening, you're doing place-oriented programming.
It doesn't matter if it's in memory. It doesn't matter if it's on disk.
If new information replaces the old, you're doing place-oriented programming.
And it doesn't matter if your implementation technology is not actually doing that directly.
So, I don't care if you're using MVCC or an append-only database.
The logical result is that new information replaces the old.
That's an in-place system, even if for efficiency it depends on the disk.
If in the end it can only give you the most recent piece of information, that is a place-oriented system.
It doesn't matter if it's actually going back to the same disk sector.
And there's a very good reason why we were doing place-oriented programming decades ago.
The first computers were really tiny.
They had incredibly limited memories, very, very small disks if they had any disks at all.
And so we had to do place-oriented programming.
There was no way to get a computer to do anything useful unless we took the tiny amount of memory that we had
and completely mapped out the role of every place in terms of, you know,
to find our program in terms of the role of every place of memory
in helping our program accomplish what we were supposed to accomplish.
Guy Steele gave a talk in the most recent couple of years
where he had this great anecdote about the worst program he had ever written
and he held up a card showing what it was.
And then he described the computer on which it ran, which had 4,000 words of memory.
And how, you know, there was this map of that memory and this part here was this dispatch table
and then there was some code here, but sometimes you could cram data into it.
Then there was this other jump table and then some data structures.
And every program knew exactly where in memory those portions were
and directly used the addresses.
And that's how you had to do it.
And then we got bigger memories and we said,
ah, we don't really want a program with addresses anymore.
And so we added some stuff.
But the basis for the way we computed was still that, right?
We're still just trying to do that, but probably not deal with the hassles
of knowing addresses directly.
We used some indirection there.
The problem is that those constraints, the constraints Guy Steele
and the early pioneers of computing faced before him, they're gone.
Computers, just in the time I've been using them,
are a million times more capacious in memory and disk
than when I started, which was after he started.
But we're still doing place-oriented programming.
I think we definitely need to consider why that is.
So one reason that always gets brought up right away is
there's this efficiency to manipulating places.
And that's definitely true.
And I'm not opposed to that.
I've bashed as many bits as the next person.
And I know how much fun that is, and I know how fast that can be.
And I think that there still is a role for that,
and there will always be a role for that.
And one way to talk about when that's appropriate
is to have a notion of this birthing process,
of a point in time when you're starting to create a new value
and we'll talk more precisely about values in a minute.
And in setting up that value, you need to manipulate memory, for instance.
You need to manipulate places.
That's completely okay.
I would never advocate languages that didn't let you, for instance,
manipulate the contents of an array,
because during this process, you need to be able to do that
in order to write efficient programs.
But this birthing process is a window that ends.
And it ends whenever the thing that you've made
is going to become visible to any other part of your program.
At that point, it's become a fact.
It's become perceptible.
And then you have to stop doing place-oriented programming.
Because as we'll see, it's not a fit for the models we're trying to build.
So this use of place to create values
or the use of place to represent values under the hood
is an implementation detail.
Of course, we have to use places.
Computers have memory and they have disks.
But what's important is that our program is not about places.
It's information technology.
It's not technology technology.
We've taken abstractions of the technology
and raised them up to being what the program is about.
And that's an error.
There was a reason why we had to do it, but we don't anymore.
So two words that I think are very, very important are memory and records.
We have to remember these words had meanings
before we started to try to emulate them with tiny computers.
We use these words for millennia prior to that.
We've not only co-opted them,
but I think that we're starting to believe our own myths
about what memory and records are.
They are what our programs say they are
as opposed to what they really are.
And real memory is a cognitive abstraction
over how our brains work.
And some of the characteristics about it
that are really interesting are the fact that it's associative.
If your friend gets a new phone number,
it doesn't go into your brain
and find the phone number neurons for your friend
and overwrite them with the new phone number.
That's not how memory works.
You get the new phone number, it's some novelty
and your brain accommodates it and what was there before.
So it's associative to some connection between my friend
and the phone number and those numbers,
but it's also open.
It's not a place.
Your friend's phone number is not a place in your brain.
And memory is about that, activity,
acquiring your friend's phone number when he changes it.
And then records, record keeping existed before we had computers,
records are enduring.
People didn't go back to their partchments
and scrub them out when there were new facts
and they didn't go back to their stone tablets
and pave them over with concrete and then re-etch them.
They just wrote new pieces of paper and carved new stones.
They're enduring, so we keep them around,
and they're accreting.
If you have new information in the old record keeping systems,
you added it to what you had already.
You didn't go and erase it.
So these are critical notions.
We actually do pretend that our systems do this work,
but to the extent that we're using memory records
the way we've come accustomed to, we're not actually.
So the point of this talk is that values have many advantages
over this place-oriented programming,
and I'm going to talk about values in many different ways
in order to try to give you a better idea
of the many kinds of meanings it can have for programming.
In particular, though, I want you to focus not only on values in memory
and functional programming, wherever you think of
when somebody says you should program with values,
but also our use of values in communicating across processes
and our use of values inside storage systems
because there are many architectural advantages to values
that go beyond the parochial notion that a program might have.
The other point of this talk is you already know this stuff.
You were all made uncomfortable by that first slide.
Your activities show that you know this stuff.
The only thing that sort of counteracts the fact that you know this stuff
is the fact that you continue to choose some of you
technologies that don't implement what you know to be true,
and there may be many reasons for that.
But the most important point of this talk is that place itself
has no role in an information model.
It is only an implementation detail.
If you elevate place to be a first-class thing in your information model,
it is only an information model.
It's pretend it's not actually doing its job.
So let's dig into the word value.
This is a particularly tricky word,
and the title of the talk is a little bit tricky.
The value of value seems to imply two meanings of the word value.
The first one is relative worth.
The value of values is how do you estimate the worth of something
is the notion of value.
And then we have what's probably the clearest mapping to programming
of the word value, which is a particular magnitude,
or numeric value, or an amount.
And this is 42.
This is the one we can really hang on to.
Everybody understands 42 is a value.
But it ends up that these two definitions are not different.
When you take this third definition to account,
which is precise meaning or significance,
because what ends up happening is all notions of value
are about being able to directly perceive something
and compare it to something else.
And we'll see that that allows us to have a broad notion of value,
which will not only cover 42, but other things that we encounter.
So what else might we encounter?
Strings. Are strings values?
How many things strings are values?
How many things strings are not values?
Okay.
It ends up that the answer to this question is a question.
It depends on your programming language.
Are strings immutable in your programming language?
If they are, then strings are values.
If they're not, then they're not.
And how many people work in a language where strings are mutable?
How many people have ever worked in a language where strings are mutable?
How many people worked in a language where strings are mutable
and now they're not in the language they work in now?
There have to be some people who've programmed in C and then Java, yeah?
Okay.
Of people who have programmed in languages that had mutable strings
and then ones that didn't,
how many people want to go back to mutable strings?
Wow. Do you work with other people?
It's really tricky, right?
Because, you know, we've sort of accepted, at least in Java.
I mean, how many people have ever been in Java?
Here.
So in Java, we sort of accepted string as a value.
We've moved on from 42.
We said, oh, no, this composite thing that has a bunch of different parts,
a string, could be a value.
And it ends up that it is, right?
If it's immutable, it now taps into that definition of value we saw before
because by being immutable, we can go and take a string value
and another string value and say, are they the same?
Do they have the same magnitude?
Are they talking about the same thing?
Are they expressing the same specific meaning?
All those definitions of values apply to something that's not mutable.
So that relative worth thing kicks in.
And I don't think anybody who's programmed with both wants to go back.
I'm not actually sure I believe you.
But by and large, this is something that we've accepted.
So if you want to expand the notion of value up and talk about programming values,
we're going to have some characteristics we really care about.
The first and unconditional one is that they be immutable.
We're going to see, as things become mutable,
our ability to do any of the things we say we can do with information and values disappears.
On the other hand, another important characteristic of values
is that they don't need methods.
Now, I'm not saying that values can't have methods.
I'm not saying you can't have an object in your programming language
that has the role of a value and meets the criteria for values and has methods.
I'm not saying that that's not allowed.
But the important thing about values is that they don't need to have methods.
They're not operationally defined.
If I can convey a value to you somehow and I've forgotten to give you any code,
you can use it because semantically the value is accessible.
So that's the other critical thing.
It must be immutable and it must be semantically transparent.
There can't be any operational interface over a value that tries to encapsulate
what it means or your ability to do equality on it.
You might have additional methods.
You might have two upper on a string.
That's just sort of object-oriented goofiness, but it's harmless in this case.
The important thing, though, is you can't have a value where only on Tuesdays
by calling this method and that method, can you see what it's about?
They have to be semantically transparent.
And it's okay, again, to have abstractions.
In particular, when you start talking about composites and collections as values,
you'll often have an abstract definition of that.
But that abstract definition satisfies the other two critical properties.
It is immutable and it's semantically transparent.
The abstraction is not trying to get in the way of you seeing what it is
and seeing all of what it is.
It may just be hiding the storage part.
So let's go through some properties of values and how they compare to places.
The number one properties, values, can be shared.
And they can be shared freely.
And that the way you share them is just by aliasing them, right?
Because you know that they're immutable.
If you ever encounter a value, you can just start using it.
And it's funny because people talk about functional programming
and, you know, higher order functions and all of this stuff
and, you know, concurrency and other advantages.
But when someone actually goes from not using a functional programming language
to using one, one of the deepest pleasing benefits they have is this one.
Is the fact that when you program with values, you can share pervasively
and you never need to think or worry for one fraction of a second, right?
You can't mess anyone else up and they can't mess you up, right?
All values are freely shareable.
If you've never done it before, it will change the way you program forever.
It really makes a big difference.
One of the things that also happens, especially when your values are implemented
with persistent data structures, is that incremental change is cheap.
So it's quite common to say, somebody gives you this big thing
and you're like, I love that big thing except for the first thing.
I'd like to have that big thing except for the first thing.
And that ends up being completely straightforward to a-do and inexpensive to do.
So that's really great.
If we compare that to programming with places, what happens?
Defensive copy. How many of you have heard the term defensive copy?
Why do we need to defend ourselves from ourselves?
This is really not a great phrase to be using every day.
Cloning, another nasty notion, and locks.
These are all things that are either part of or in the way of sharing
when you're programming with places.
Reproducible results are another fantastic benefit of values
because operations on values are stable.
You do them over and over again.
They never give you a different answer.
This is really a great benefit when you're doing testing, obviously,
because if you want to say it still works,
hopefully you have code that is reproducible in the first place.
And you actually spend a fair amount of time with place-oriented programming
making that sentence true,
that the test actually, when run twice, should return the same result.
If you're programming with values, that's not even a question.
Debugging is also critically different when you're programming with values,
especially when your architecture is based around values.
So some customer has a problem in the field,
and you have a value-oriented program.
You can say,
obtain the value from your database and the query you're running,
and email them to me.
Just the value that was the input to the process,
and just the process, the query.
Those two things, and I can reproduce here,
over email versus what?
How many people have ever tried to set up a database
and a running process that emulates a customer failure?
That is not a party, right?
Not fun.
Not fun.
And that's the problem with places.
You have this sort of global state that you have to reproduce
in order to debug a field problem.
That's very, very tough.
Another advantage of values is that they're easy to fabricate.
Anything can create a value.
Any programming language can make a value.
You may have written it in this,
and then later you need to have somebody who uses different languages
drive it to see if it's working.
So for testing, it's really fantastic that you can fabricate inputs
to test programs using any technology.
You don't have to sort of get the class library
that has the right classes and interfaces
related to the GOOK that you used in your program.
It's like your program takes data,
you now can write another program that can produce data to test it.
And also for simulation purposes.
So when you start raising your testing up to the next level,
and you're trying to drive your program
to different kinds of situations,
all you need to do is algorithmic generation of data
to get a variety of simulation points for your program.
If your program can only get into a particular state
by a series of interactions through objects,
how are you going to algorithmically drive that program
to different kinds of test cases?
It's a huge problem.
It's just a mess.
Whereas if you can just algorithmically generate data, you're done.
And again, it goes to this point about places.
With places, you have to emulate an operational interface.
That's a ton more work.
And also when you want to drive it,
you have to drive it through the operational interface
instead of with data.
Imperativeness.
We love it, right?
And values are in the way.
That's a feature.
That's not a negative aspect.
They just refuse to help you do this.
And I think that once you start using languages
that make values the default,
you feel frustrated initially about this.
But in the end, it's a tremendous benefit
because imperative code is just more complex.
As used to it as you may be, it's more complex.
And the problem with places is they force you to do this.
It's the exact opposite, right?
Values thwart you and places force you to write imperative
and therefore in a more complex way.
Starting to lift the game a little bit out of your local view,
which might be, you know, I'm in Java and I'm doing this,
I have these interfaces, I have this class model and blah, blah, blah.
A great thing about values is language independence, right?
If you ever want to pretend you're a polyglot shop,
you're going to immediately face a challenge, right?
With all your interface-driven, object-driven designs,
which is you can have them all over in your Java program,
but then, you know, your Python program or your JavaScript program,
it doesn't know how to talk about that stuff,
has no means of doing it.
And immediately you're going to face this pressure to move away from that.
And towards what?
Towards values is where you're going to end up.
They are the tool for polyglot programming.
They are the tool that gives you this independence in language,
because places are defined by language constructs.
You're stuck. You're really stuck.
You don't have a definition independent of your language
that you can use as a basis.
And sure, you know, you can build proxies,
you can automatically build, you know,
soap interfaces to your objects and remote your objects
and generate, you know, matching objects in different languages,
but that's just a ton of effort.
That's not really adding any value.
So this language independence actually falls out of a bigger property of values,
which is that they're generic, right?
We can get representations in any language, as we said,
but the other thing is that there are very few values,
you know, in the general sense, right?
Once you start talking with values,
you don't end up with a lot of specificity, right?
There's a logical notion of a list,
there's a logical notion of a map and a logical notion of a set, right?
And strings and numbers and whatever,
but you can probably exhaust what you need to use in the value space
with fewer than 20 of these things.
Whereas how many people can build, you know, a system with 20 Java classes?
Just 20.
No large system, right?
As the system gets larger, how many more classes do you need?
More and more and more and more and more.
Just they keep going on and on and on.
And that's because operational interfaces are specific, right?
That generates a ton more code.
And it actually is a counter argument to the promise of object-oriented programming,
one of the promises.
One of the promises was reuse, right?
That's the big lie of object-oriented programming.
Every new thing you have to do, you write a new class.
Where is the reuse in that?
There's none, right?
The other thing is you're sort of breaking away from the job you're trying to do, right?
If you're trying to represent information, you need to represent facts.
You need to have values in order to have things be comparable, right?
If I have a person class and you have a person class in our own namespaces,
and they have name, address, and email, and name, address, and email,
what can we do with those two things?
Nothing.
Even though they're semantically identical, they use the same names,
and they use the same names for the fields, they're completely not interoperable.
Even if they all had, like, public getters.
Like, they're sort of complying with the accessibility part.
The specificity that you added killed your reuse.
And again, getting more in the large, or looking towards programming in the large,
values make the best interface.
This is actually one of the biggest problems, I think, we have right now.
Is that when we're working in the small, right, we say,
we're going to have this new thing, and we start with sort of a monolithic design,
but within that design, it's not monolithic.
We say, oh, no, we have a subsystem for this, and a subsystem for that, and a subsystem for this.
That's all great.
And then it's like, oh, you know what?
I want to, that's getting too big for this box.
I want to move this out of that box to this other box.
And when I do that, I think there's a different programming language
that would make that easier, or it's going to be shipped to another team
that works in a different programming language,
and so we're going to do this other thing.
If you have a value-based interface, you can do that move, right?
If you've programmed with data-driven interfaces, you can do that move.
You can port that code, right?
Or you can write new code that interoperates in a different language,
because it's data-driven, right?
Another critical thing you can do if you have a value-oriented interface
is you can enqueue it.
So even if you stay in process,
a lot of times one of the architectural needs you have is,
you know what, I'm calling this and calling that and calling that,
and I need to buffer.
I need to do some more management of things,
or maybe I want to get some more concurrency in play, right?
And therefore, I'd like to enqueue those calls.
So I want to set up a queue, so now I have this flow
and maybe get some pipelining in my program.
If you've called a specific interface,
just call a specific interface and call a specific interface.
And then you want to pipeline that?
What can you do?
You're stuck, right?
Because you've got to go and build, like, proxies that look like your objects,
that then have a queue inside, that then spit out on the other end,
another thing that looks like what it was talking to,
and then, if I haven't forbid, it was bidirectional.
You're just totally toast.
But if you had a data-driven interface, like this guy was calling that guy,
he was just passing data.
If you want to stick a queue in the middle of that,
that's straightforward to do, because you can put values on queues.
So in contrast, if you're doing place-oriented programming,
your stuff is application-specific,
your stuff may be language-specific,
and it may be coupled to your program flow.
Architecturally, you're dramatically limited.
And this is a big deal, because you desperately need to be able
to take your small programs and make them large programs,
and take your one-machine programs and make them end-machine programs.
If you can't start with an end-machine program, you're not forced into this.
But the thing is, we know this.
Because when we program in the large, we don't pretend we have objects.
We don't create operational interfaces.
We don't chat. We don't use Corba anymore.
That's dead. That lost for good reasons.
When we actually start out building a more distributed system,
we program with data all the time.
We already know how to do this. We use data on the wire.
We use, you know, RESTful interfaces.
Everything is different in the large.
Why are we still doing this arcane, goofy, memory abstraction-oriented stuff
in the small? It doesn't match the large.
It's not going to help us make our programs bigger.
And there's no benefits to it.
As soon as we look at our programs in the broader sense,
we don't do this. We don't make the same choices in the large.
We're still making them in the small.
I think it's just because we're comfortable with our programming languages.
Another key advantage of values is that they aggregate.
In particular, values aggregate to values.
So if I have five values, and I put those five values in a value list,
that resulting thing is a value.
In particular, everything I've said about values accrues to that composite.
That composite thing has all the advantages of a value that all the value parts of it have.
It's transparent. It's transmissible.
All the characteristics are great.
Now, contrast that with programming with places.
If you have a bunch of objects, mutable objects,
and you combine them into a bigger thing,
what properties does it have that you can understand?
Even if you really understood all the subcomponents,
what properties does the composite have?
None. You have to start from zero again,
defining the operational interface of the aggregate.
Even if you had very carefully defined cloning and copying
and locking policies for each part,
as soon as you combine them together, you're toast.
None of those things work.
You no longer have a copying policy, no longer have a cloning policy,
no longer have a locking policy on the aggregate.
So nothing composes with places.
That's a big negative.
So now I'd really like to start broadening the notion of what we're talking about
when we're talking about values to outside one process,
to talk about them in the large and in the small,
I'll still mention the others,
and talk about a few what I'll call extended value propositions.
Using values as a mechanism to convey things and to perceive things.
Using values as a mechanism for memory,
how values will reduce coordination,
how they provide location flexibility,
and finally how they're essential to making programs
that support decision-making, which is our job in IT.
So we have conveyance.
Conveyance means to send something to somebody else.
So this is sending.
In the small, with values, it's really straightforward.
If I give you any reference to the value, I'm done conveying it to you.
I've conveyed. It's extremely cheap.
And again, as we saw before, it's worry-free.
Imagine, though, that you want to try to do conveyance with places.
So you have this mutable object and you put it on a cue,
and later somebody's going to consume that cue.
What actually have you communicated to that person?
Nothing. You don't know.
I mean, you put it on the cue now,
it's just a reference to a thing that could change.
Whatever your intent was in conveying it,
it's not captured by that mutable thing on a cue.
So conveying places is an extremely difficult thing to do.
We waste a ton of time.
I mean, everybody who's thinking about places,
you know, I do these things,
but I spend a huge amount of work trying to do them.
You have to try to clone it or something like that.
You have to turn it into a value, essentially.
Now look at conveyance in the large.
Again, here, I think we figured this out.
Values rule on the wire.
We don't really do anything other than values on the wire now.
HTTP, really, all distributed programming puts values on the wire.
We don't set up multiple objects with tiny little interfaces
and chat across the wires.
We just don't do it, right?
People imagine that, right?
When they first tried, you know, objects were like all the rage,
they were like, oh, distributed objects,
because that's all we can think about,
and so we'll think about it broadly.
But it was an utter complete total failure, right?
And we're done with it.
Again, in the large, we understand this.
So that's sort of the wire part.
And then in databases, we have the same problem, right?
If I give you the primary key of a record in the database,
if I send that to you over a queue,
what have I actually communicated to you?
Nothing, right?
Because what you're going to see depends on when you look that thing up,
just like with objects before.
Putting an object on a queue, sending somebody the primary key of something,
if what's behind that stuff is places,
you actually haven't conveyed anything specific.
In other words, you haven't conveyed information.
All right, perception, it's the flip side.
I know there's something out in the universe,
and I want to see it.
I want to perceive it.
And the word perception is an interesting word.
It really means sort of to take it in the entirety of something.
And it's very important, right?
Because you need to take things in the entirety
to get that value proposition from before.
So in the small, again, it's really straightforward.
If you're programming with values,
if I can reach your value, however,
you pass it to me or it's in the collection that I can see,
if I can reach it, I can see it.
I can perceive it.
My part of the program can capture that value,
because I know it's never going to change.
So as soon as I can reach it, I've acquired it.
Places, it's amazing how difficult this activity is.
How can you perceive a mutable object that has more than one getter?
What's the way you do it?
How do you do it?
You can't do this at one point in time.
Who knows how to do this?
Who could say right now how to do this?
No one can, right?
Yeah, you can.
Yeah, either.
Stu is like...
He cannot.
I know he can't, from personal experience.
No, you can't do this because you need this other thing, right?
You need the recipe for doing this.
And the recipe is something everybody has to make up
over and over and over again, right?
The cooking recipe.
The locking recipe.
The cloning recipe.
We've got to make this stuff up, because the thing could change, right?
And we have multiple independent operational interfaces to the parts.
We can't actually perceive the whole.
Can't do it without help.
Without these recipes.
And again, we know those recipes don't aggregate.
Same thing.
In the large, on the wire, right?
We do not go and chat with an operational interface to a thing
that has all its pieces.
I mean, just imagine doing that.
Imagine if HTTP, you know, in order to get a web page, you had to say,
get the header.
Get the cookies.
Get to this. Get to that. Get the other thing.
Get the title. Get the first segment.
Get this div. Get that div.
Blah, blah, blah.
Forget about communication overhead.
You couldn't actually know that the end of all that communication
was the page that anybody ever wrote at one point in time,
that was something somebody looked at and said,
yeah, that is what I intended.
That is what I'm going to do right now.
Because the operational interface is in the way of you
perceiving the entirety of the thing.
And we don't do that, right?
We don't do that on the web.
You ask for the page, you get the whole page.
You get the entire value.
It's a little bit trickier with databases.
Many databases will give you the ability to capture
the, as a value, some subsection of what they have
in a coherent way.
But beyond that, they either can't
or they require a transaction to do that.
I'll talk about that in a second.
All right.
So what about memory?
It's very important for our programs and for the
users of our programs that our programs
remember things at various points in time.
So what does it mean to remember something?
In the small, again, there's really
just nothing to it, right?
Remembering is aliasing.
If I can touch the value, I can remember it.
I can keep a copy of that indefinitely.
Right?
With places, I'm really in trouble.
I'm back to that copy problem.
I need to copy it if I want to remember it,
because I know it's mutable lifetime
is going to take it to different values.
So I need to be able to copy it if I can.
In the large,
the same thing comes about.
How many people remember early days of the web?
First, it was all static pages.
It was great.
You go to the page, you get the static page.
Maybe people updated it or whatever.
Then, people had websites
that were based around programs.
They're like, oh, cool, I can generate pages.
This is awesome.
Who around that time period
of the web, when that was first possible,
ever said, oh, I'm researching this thing.
I'm going to bookmark
all these things I encountered that are
interesting and relevant to what I'm doing.
And then went back to those bookmarks a month later
to find that absolutely none of them
pointed to the thing that you were looking at before.
And then you actually had remembered nothing.
Eventually, we figured this out
and we had these conventions about permalinks
and things like that. But again,
if you don't have something like that,
you don't actually have a memory system.
You only have places out there.
And it's the same problem that happens with the database.
If I remember something in a database,
how am I going to do that?
Because people are saying, I'm talking about databases
and databases that lose track of things.
And people will say, well, we don't.
We only add stuff to our database.
But you're doing it yourself then, right?
You're doing it yourself.
You're saying, I have this place-oriented thing.
I'm not going to use it in that way.
I'm going to keep new values myself.
And you can do that, right?
How many people have ever written a system
that made a new record for every new piece of data
and kept timestamps on those records?
Right? How many people
wrote the now query for that?
Yeah. And is that fun?
That is not fun.
How many people are trying to make that now query fast?
Not fun.
Very, very difficult.
So you don't want to do it yourself there.
Reduce coordination is another critical benefit
of values, right?
In the small, when you're programming with values,
there's no, there's just, there's simply,
it's not a question about this.
It's not a question to answer.
It's a question that doesn't come up.
There's no such thing as contention for values, right?
And the problem we saw about places, you know,
exists here.
The lock policies don't aggregate.
We have to lock and we can't
combine those policies.
In the large, this is another big
problem, right, for databases.
When you have a place-oriented database,
if you want to read consistently,
you have to read in a transaction.
You have to go to the database server
and hold up the world to some degree
in order to see something coherent.
It's really a coordination problem.
It's an architectural problem, right?
It's a throughput problem.
And it's a scaling problem, right?
This is a big architectural
disadvantage of place-oriented programming.
And I think it really highlights
one of the big, you know, wrongness here.
In addition, even if you think,
you know, all right, I know I have to do
read transactions, this is one of the things
that's most frequently gotten wrong, right?
People just don't understand
read-committed or how read-committed's
combined or how independent reads
in a batch file work.
I mean, how many people think the program is in their shop
actually don't know how that stuff works?
Yeah. They don't.
They really don't.
Okay.
One of the things that's really important to value
is location flexibility, right?
In the small, again, with values,
there's actually no need for more than one location
because aliasing covers every case we've seen so far.
Memory, perception, conveyance,
it's all covered by the fact
that you only need one copy.
On the flip side, with place-oriented programming,
there's very specialness to that master copy.
If I want to know the value,
I've got to manipulate that master copy
and coordinate with everybody about doing that,
which means where that is starts to matter to me.
In the large, again,
we really do this
and we really care about it, right?
We've incorporated those things
in the HTTP protocol and whatnot
so that we can do caching. We can say,
this expires, this value is
stable, and therefore
you don't need to come to me every time
to figure out what it is.
You can go to this cache over here,
right? You can go to this content distribution network
over there.
We saw already,
well, one of the interesting things
about content distribution networks is
why don't we have CDNs for databases?
Why do they make sense for webpages
but not databases?
That doesn't make any sense to me.
The other thing we saw is that
database interfaces are movable inherently, right?
I don't really care where you are.
We're going to communicate data. I don't care what language
you're implemented in or if you move around
or if I have to redirect to get to you or things like that.
So, again, I think we understand this in the large
part, except in the data storage
but definitely in the communication protocols.
So,
now the big point,
facts,
the things we said are the source of information,
our values, by all the definitions
I've given and have all the benefits we've said.
They're not places.
Right?
But don't facts change, right?
Didn't my friend get a new email address?
Didn't that change
the fact of his email address?
No.
It did not. There's now a new fact
which is today
your friend's email address is this.
It did not change the fact that yesterday
your friend's email address was that.
They don't change.
And this goes down to the very core
of what fact means.
A fact means something that
happened.
Something that existed.
That's what fact means.
It doesn't mean the slot where you keep your friend's
email address.
We all laughed at that slide earlier.
But it's true.
This is what a fact is.
And the roots of the word fact
actually go all the way back to Latin
where it was a past participle.
It said something done.
Fact them. Something done.
Something that happened.
So this is really critical if we want to build information
systems, right? Because information is based around facts.
And facts doesn't mean
just the most recent facts.
We know
knowledge is derived from facts.
We compare facts to each other.
We combine them. We make decisions about that.
But one of the critical things we do all the time
is
compare facts from different time points.
Imagine
if you only knew
the present
value of every fact
that's relevant to you.
You only knew the present value of everything.
What kind
of decision-making power would you have
compared to knowing something about time?
It would be dramatically reduced.
I don't know if anybody saw the film
Memento or whatever.
If you had a limited window of time over which you knew
what had happened or if you only knew the present
you actually can't make decisions.
It's like built into our brains.
If your programs are serving humans
it is built into our brains to delta
now with before.
That's how we make decisions.
So building systems that only keep the most recent values
of things is not
information systems.
So you can't update a fact.
There's no such thing as updating a fact.
A fact is not a place
you can't do that any more than you can change the past.
So now let's revisit information systems.
What should they be?
They should be about facts.
They should be completely about maintaining
manipulating facts.
They should be about giving our users leverage
over facts.
Helping them make decisions
based upon the facts that the system is maintaining
on their behalf.
That means that our system should be value
oriented.
They should not be place oriented.
We have to stop using
process constructs for information.
I'm not trying to bash objects
universally.
You can go home and do that.
The very few places where they're appropriate
are more process oriented
places.
Their use for
information is actually
an idea bereft of merit.
There is not one
good component
of using mutable objects for information.
It's just wrong.
So, we know
this is wrong.
We're decision makers.
We all do stuff all the time.
We know what it takes to support our own decision making process.
And it's information.
We build systems.
We run shops.
We have stuff we have to accomplish.
We're like mini businesses.
Programming shop is like a mini business.
It has stuff it has to accomplish.
It has successes and goals and objectives.
We need to compare the present to the past.
We try to spot trends and rates and things,
especially in our own systems.
We often need to aggregate things.
This is what decision making is about.
Both in the large and in the small
and for businesses and for programmers.
It requires a time component.
So,
let's look at program or
IT.
We also use computers to support our own decision making
process, don't we?
What kind of systems do we give ourselves?
What kind of information
systems do we give ourselves?
Well, one big one is source control.
Anybody
keep their source control in a directory
where when somebody edits the file
they save it into the directory over the one that's there.
Update in place.
How many people do update in place source control?
No.
We don't do that.
How many people store the stuff in source control
with no dates on the edits?
No timestamps.
No.
We keep track of time.
How many people throw away their old source code?
No.
We don't do that.
Why would we do that?
We couldn't make decisions about what was happening
in our system.
We would be crippled by that.
What's another critical thing that we keep track of?
We run our programs
and we keep track of what our programs do
in logs.
Because we need to look at those logs.
We need to make decisions about is our program working?
Is it working well?
Is it using memory well?
Is it having good performance?
If there was a problem, what went wrong?
All this decision making we need to do
is our little programming business.
We have a log system that only keeps track
of the last latency
or the last time somebody communicated
with a particular endpoint.
Maybe we want to do that?
No.
They are not update in place.
Anybody have a log that has no timestamps in it?
No.
We keep times this.
Of course we do.
How are we supposed to make decisions without timestamps
and without keeping track of everything that happened?
Because we want the facts when we need to make decisions.
This is our IT.
Anybody want to have the ability
for somebody to go back to an old version of a source file
and change the old version in place?
Or change logs in place?
Edit logs?
Any value in that?
No.
Our IT systems are not like this.
So, let's talk about big data.
It's my contention that a certain portion
and quite possibly a very large portion
of big data, the hot new topic,
the big thing
is this.
It's businesses saying to programmers,
I like your database better
than the one you gave me.
Because your database has everything in it.
The one that you gave me,
it only remembers the last thing.
I can't track trends.
I can't see latencies.
I can't see where everybody was on the site.
I can't make the same kinds of decisions that you can.
I want to mine your logs
because that's business-critical information.
Because that's the only place that it exists.
Because you're not keeping your own database this way.
These logs have everything.
They have time on them.
They're huge, rich sources
of decision-making power.
They're all filled with stuff
we're not putting in the database
for some reason.
And I think it's actually quite embarrassing.
I think that IT right now
is in a very reactive place here.
Business has discovered the value
that was in our logs.
Our logs were just like for ourselves.
We could see if our programs were working.
But they had to keep track of where everybody clicked,
how long things took,
what the flow was between events,
and everything that happened,
including stuff that happened that in the database
ended up overwriting old stuff.
That's all in these logs.
But really, mining logs?
Flat files?
We know better than that.
We have technology that's better than flat files.
Anybody really happy that their logs
are in flat files in the end?
I mean, obviously, it's efficient
to sort of append on them.
But in the end, you struggle right after that
to try to get leverage
over that data.
Because we know flat files are not great.
One of the advantages programmers gave to businesses
was the invention of databases,
the invention of indexes and trees
and these other data structures
that really let people leverage information.
We're not actually putting this critical information
into a leverageable place right now.
And it's co-mingled with a bunch of crap
that's not actually useful to the business.
Like, latencies and things that were really
to communicate with us.
This is mixed in the logs
of stuff about seeing if the system's working okay
and actual activity against the business.
Right?
If you could pull out this part
and put it in a leverageable store,
your businesses will be a lot happier.
And that's where we're going to end up.
You know, big data is forcing us to do that.
But you should all look at the deep reasons
why this is happening.
They have to do with the fact that we've built
better information systems for ourselves
than we've delivered
to our business customers.
So I think we're entering the space age.
And the space age
is the age where
we have access to space
from our programs.
We said place was a portion of space.
Space,
is the unlimited
expanse
in which all things exist
and all events occur.
And this definition of space,
I mean, it goes all the way back to
the roots for spatial
and the Latin there.
It's always incorporated both
place
and time.
The notion of space has always encompassed
both place and time. They're connected together
quite significantly.
Are we in the space age?
Are we programming now with space?
I think we are.
We had virtual memory
which really took us a level away
from the actual addresses.
Then we had GC
which meant more was
transparently available. Whenever I needed more
I could get it.
Guess what? If your program runs indefinitely
long and calls new and new
never fails, your program
is running in space
and not in a place.
It's running in space.
If S3
never fills up
or if you can always go to the store
and buy another hard drive and stick it in your array
live
you're programming with space.
There's no place there.
There's no limit. There's no delimiting that.
That's space.
What does this mean?
It means that we can take a different
approach to the way we do things.
We're going to say we are building information
systems. Those systems should be maintaining
facts and that new facts
require new space
and we have space.
This is the end
or this should call for an end
to place oriented programming.
If you can afford
to do this
why would you do anything else?
What's a really good
reason for doing something else?
And guess what?
You can afford to do this. You already can afford it.
You're already running programs that call new
indefinitely and don't fail.
And you have access to S3
or things like it.
There will be garbage. There will be
different characteristics to our
use of space, especially storage
that are very analogous
to what we saw when we enabled
space and memory.
The whole notion of garbage collection is going to happen
in storage.
If you have a grip on that
you have no problems understanding
a space orientation
with storage.
So, to summarize
for some reason
we continue to use
place oriented programming
both languages and databases.
We even make new ones.
It's actually the saddest
thing is the fact that we continue
to make new
languages and new databases
that still emulate
the decisions that were made
when computers were tiny
and we needed to program in a place
as opposed to in space.
This is not a no-sequel versus
old-sequel. There are older systems
that maintain time correctly and most
no-sequel and new-sequel things
are still place oriented.
It's not about old and new.
It's about place oriented or not.
The rationale for doing this is gone.
I don't think anyone could
deny the benefits
that I just enumerated for values.
In fact, by your actions
especially in your own IT
services for yourself
you're demonstrating
you know this value proposition.
We recognize this.
So, we need to start making
information systems that are really
about facts.
That are really about information.
I think the demand is clear.
This big data explosion
is saying, businesses are saying
I demand to know
everything that happened. I demand
not to lose track of the facts.
These things are important to me.
They're important to the decisions my business makes.
And they're soon going to say
why the hell is that
only exist in a log?
Why are you sticking it there?
You have indexes and databases and things like that
you can use for this.
So, I'll leave you with this
and thanks very much.
Thank you.
