Hey there, how's it going everybody? In this video, we're going to be learning how to use
regular expressions. So we're actually going to look at regular expressions as a standalone topic
because they aren't specific to any one programming language. Now there are some slightly different
flavors here and there, but for the most part, whether you're programming in Python or JavaScript
or Java or whatever, if you learn how to use general regular expressions, then it should mostly
carry over into your language of choice. And it will also allow you to use them in text editors
and the command line and things like that. Now I am going to do a follow up video where I show
how to use regular expressions specifically in Python, since that's a language that I cover
most on this channel. But for this video, we're going to be learning how to use regular expressions
by themselves so that you can apply these to other areas. So with that said, let's go ahead and get
started. So regular expressions basically allow us to search for specific patterns of text. And
they can look extremely complicated. But that's mainly because there's just so much that you can
do with them. You can create a regular expression for just about any pattern of text that you can
think of. So let's see what some of these look like. So I have a test file open here that we're
going to use to search for specific patterns. And I'm going to be using the regular expression tool
in the atom text editor to write these regular expressions and find what text matches our patterns.
Now in order to open up this regular expression search tool, I'm just going to go to find and
then find in buffer. Now you could have also opened this up with command F on a Mac. And I believe
that's control F on Windows. Now within the options here, make sure that you have the dot
asterisk selected over here because that's going to tell our search tool to use regular expressions
and also select this match case option here as well. That's just going to give us behavior that
is more common to how regular expressions usually behave. Okay, so let's start writing some regular
expressions. And first we'll start off kind of simple. So first of all, we can just search for
literal characters. So if I was to search for ABC, then we can see here at the top that it
highlighted ABC because it matched the ABC and our lowercase alphabet. Now it didn't match the
capital ABC here, because it's case sensitive. Now this search right now is looking specifically
for A, B, and C. But if I was to type in something like BCA, then we can see that there were no
results found because the order does matter. Now if we look at this meta character section here,
I have some examples of characters that I say need to be escaped. So for example, if you wanted to
search for a literal period, now if I was to just type in a period here and hit enter for my search,
then we can see that it does this weird thing where it matches everything. And that is because
the dot is a special character in regular expressions. And we'll see more of this in just a second.
But for now, if we just wanted to actually search for a period or a dot, then we have to escape it.
And to escape characters, we can use the backslash. So if I do a backslash and search,
then now we can see that it only matches the actual literal dot or period within our document here.
And that goes for any of these meta characters that I've listed here. So for example, we can see
that the backslash is a special character also. So if you wanted to search specifically for a backslash,
then you have to escape itself. So a backslash to escape, and then a backslash for the search.
And if I search for that, then we can see that we matched a literal backslash. So a practical
example of this might be trying to match this URL right here. So if we wanted to match that
literal URL exactly, then we could just say query MS. And then for the dot on the dot com, we have to
escape that with a backslash and then a period and then com. And we can see that it matches our URL.
Okay, so that's how you match literal characters. But a literal search isn't too exciting because
we're used to that already. Really, we want to use regular expressions to search for patterns.
And to do this, we're going to be using some of these meta characters that we were just escaping.
So I have a snippets file open here. So I'm going to switch over to this. And in here,
I have a list of values where we can see the types of characters that we can match.
Now just for now, I'm going to try to make this into a split screen here,
as we're walking down this list. So the first one I have listed here is this dot or period.
And we can see that this matches any character except a new line. Now we've already seen this,
but let's take a look again. If we just do a dot and search for that, then we can see that it matches
any character except it does not match the new lines. Okay, so next on the list is backslash D.
And that matches any digit zero through nine. So if I was to do a backslash D here and search for
that, then you can see that this matches all of our digits. So anything zero through nine, it matches.
Now we also have an uppercase D here. And that matches anything that is not a digit. So if I
search for an uppercase D, then we can see that our digits are not matched. But everything else is
highlighted. So it matched everything except for the digit. Now you'll notice that this is a common
theme here that the uppercase versions of all of these are the ones that kind of negate the search.
So moving on down here, we have backslash W that searches for any word character and a word character
is lowercase a through Z uppercase a through Z zero through nine and an underscore. So let's search
for the word character. And we can see that it matches, you know, all these lowercase uppercase
numbers and things like that. It doesn't match these special meta characters here. And just like
with the digit, the uppercase W will match anything that is not a word character. So anything that
is not in this list here. So let's go ahead and search for that uppercase W. And we can see that,
you know, it picks up the spaces and these special punctuations and things like that. But it does not
match the word characters that we saw before. Now if you're not quite getting this just yet,
we are going to look at a lot of examples to where it'll start to sink in. So moving down the
list here, we have backslash S, which will match any white space. And white space is a space tab
or a new line. So if we search for backslash S, then we can see that it matches our new lines here
and our spaces. But it doesn't match any of these characters in here. So it's mainly white space.
And just like with the others, the capital S will search for anything that is not white space. So
now you can see that we have, you know, all these lowercase uppercase digits and then also this
punctuation, anything that isn't a new line or a space or anything like that. Now these bottom
ones over here, the backslash B, the carrot and the dollar sign, these ones are a little bit different.
So these are called anchors. And they don't actually match any characters, but rather they
match invisible positions before or after characters. So let's see what I mean by this. So
for a word boundary, if I search for a word boundary here, so now let's search for where we
have this ha ha ha here. Let's search for a word boundary and then ha and match that. So we can
see that that matched because there is a word boundary here at the start of this line before
this first one here. And this space here is also word boundary. So this one gets matched as well.
But this last one does not get matched because there's no word boundary between these two ha's
here. Now just to show what this would look like without the word boundary, if I was to search for
that, then you can see that it highlights all three of those. Now just like with the other ones,
if I do an uppercase B, then that matches anything that is not a word boundary. So if I do an uppercase
B, then we can see that we matched the one that it didn't match before because there is no word
boundary between these two here. So it doesn't match these first two. Now if I was to put word
boundaries on both sides of these, then it should only match this first one because this is the only
one that has a word boundary at the beginning, which we're matching here, and at the end. So this
one has a word boundary at the beginning, but not at the end because it's in the middle of this word.
And this one has a word boundary at the end, but not at the beginning. Okay, so our other two
anchors here are pretty similar. So the carrot matches the position at the beginning of a string,
and the dollar sign matches the position at the end of a string. So let's say for example, that we
only wanted to match a ha if it was at the beginning of a string. So for example, if I was to do a
carrot and then a ha and match that, then we can see that it only matched this one because it's the
only one that is at the beginning of a line. Now if we wanted to only match it if it was at the end,
then we could put that dollar sign at the end. And what we're saying here is that we only want to
match this if the end of the string is in the following position. So we can see that it not
only matches this last one, because the end of the string is the next position in line. Okay,
so now that we've seen what we can match with these special characters here, now let's go ahead
and take a look at some practical examples. So I'm going to move my snippets file back here,
and we will keep referencing that later on. But for now, let's go ahead and say that we wanted
to match a couple of phone numbers. And let's write some regular expressions to do this. Now
with a phone number, we can't just type in a literal search like we did before, because all of these
are different. So they have a similar pattern, but they're not all the same digits. So in this case,
we need to use the meta characters instead of literal characters. So we just have a pattern here
of three digits, and then a dash or a period, and then three more digits, and then a dash or a period,
and then four digits at the end. So we saw before that we can match a digit with a backslash D.
And that is going to match all of the digits in our file. So we want to match this phone number
here. So we want to match first three digits in a row. So we can just put in three backslash Ds,
and that will match any three digits in a row. So now that we're matching those first three digits,
now we're getting to where we can see that we're either going to match a dash or a dot in our
phone number. So for now, let's just match any character that's in this position. So from our
snippets file, we saw that if we want to match any character, then we can use a dot. So we can see
that for now, our pattern is still matching some other stuff as well. But let's just continue on.
So now that we're matching this hyphen or this dot, now let's go ahead and add in the next three
digits. So we want to search for three more digits. So I'll do three backslash Ds. And now we're
going to want a dot to match any character, which should match that dash or that dot. And now we want
four digits. So we can just do four backslash Ds. So now we can see that this regular expression
highlights both of our phone numbers and matches both of those. So now we're starting to see how
this could be pretty useful. So for example, I have a data file here. Now if I pull this up,
then I have a bunch of fake names and numbers and addresses and emails. But if I wanted to match
all of the phone numbers in this file, then you can see that the regular expression that we just
wrote matches all of the phone numbers here. So now we're starting to kind of get a sense of how
this could be more useful than just a literal search, because now we're actually searching for a
specific pattern. So now let me go back to our simple text file here. So now let's get a little
bit more specific. So let's say that we only wanted to match a phone number if it had a dash or a
dot. Now right now, this pattern will match any separator, because we're using the period down
here, which will match any character. So if I was to put in a another number here, that doesn't have
a regular separator, let's just say it's an asterisk, then we can see that it matches this
number as well, even though the asterisk isn't really a phone number separator. So to only match
the dash or the dot, we're going to have to use a character set. And a character set uses square
brackets with the characters that we want to match. So to create a character set, I'm going to replace
our first dot here. And this is going to be square brackets. Now this is a character set. Now within
this character set, we want to put the characters that we want to match. So we want to match either
a dash or a dot. And I will just copy that. And we'll replace this second dot here, which was
matching any character. And we will put that in for that as well. And now you can see that it only
matches our phone numbers here that have a dash or a dot separator. And it does not match this one
with the weird asterisk there. Now you probably also notice that we didn't need to escape our dot
character within our character set. And that's because character sets have some slightly different
rules. Now you can escape these characters if you'd like, but it just makes it a lot more
difficult to read if you do that. Now even though the character set has multiple characters here
in the set, it's still only matching one character in our text. It's matching one character that is
either a dash or a period. But if I was to put in, let's say two dashes here into one of these
numbers, then you can see now it doesn't match that number, because it's only matching the first
dash or a dot. And then it moves right on to looking for a digit. So it's looking for a digit
in this position. So that's something that can kind of throw people off when they first start
working with regular expressions. So even though, you know, we have four characters total here in
this character set with these square brackets, and all of the characters in this set, it's still
only searching for one literal character up here, which is either a dash or a dot. Now to show
another example of this, let's say that we only wanted to match 800 and 900 numbers. So I'm going
to create two different numbers here, I'll do an 800 number and a 900 number here. So if we only
wanted to match 800 and 900 numbers, then our first three digits here, we have to do something
different. So first, we want the first digit that we're going to match to either be an eight or a
nine. So we can do a character set. And we can say that we're looking to either start with an eight
or a nine. Now the following two numbers are going to be 00. And that's just a literal search.
So now you can see that we're finding the 800 and 900 numbers here. Now within our character set,
the dash is actually a special character as well. So when it's put at the beginning or
the end of the character set, then it will just match the literal dash. But when it's placed
between values that can actually specify a range of values. So for example, we know that the back
slash D matches any digit. But what if we only wanted to match digits between let's say one and
seven. So to do that, we can use a character set. And we can just say instead of typing out 1234567.
If we wanted to specify a range of those values, then we can just say one dash seven. So now we
can see that we're matching all of the digits between one and seven. But the eight, nine and the
zero aren't getting matched up here. Now you can do this with letters as well. So if we only wanted
to match the lowercase letters A through Z, then we could just do a character set of A through Z.
Now you can see all of the capital letters aren't getting matched, but the lowercase ones are. Now
if we wanted to match the uppercase and lowercase numbers, then we could just put our ranges back
to back. So I could say A through Z, and then just add on to this character set and say capital A
through capital Z. And now we're matching all letters, regardless of whether they are uppercase
or lowercase. And you could keep adding to those ranges. If you wanted to, you could do a zero through
nine there as well to add in all digits. Now another special character in our character set
is the carrot. Now we saw before that outside of the character set, it matches the beginning of a
string. But within the character set, it negates the set and matches everything that is not in the
set. So for example, if we wanted to match every character that is not a lowercase letter, then we
could say this carrot and then A through Z. So we can see that it matches everything on our screen
that isn't a lowercase letter. It's not matching these lowercase letters here. So it's even matching
these new lines and the spaces and everything. So just to show another example of this,
let's say that we had some words here, cat, mat, pat, and bat. So let's say that we wanted to match
every word that ends in AT, except bat. We don't want to match bat. So to do this, we can just say
that we want a character set of everything that is not B, followed by AT. So now we can see that
it matches all of these three letter words that end in AT, except for bat, because our character
set here negated that B. So everything that we've looked at so far has involved single characters.
So in this example right here, we are matching any single character that is not a B, then followed
by an A, and then followed by a T. But we can actually use these things called quantifiers
to match more than one character at a time. So let's go back to our original phone number example
from earlier, and we'll just match any character like we did before. So I will do three digits and
then a period for any character, and then three digits again, and a period for any character,
and then four digits at the end. And I'm just going to remove what we had there for an example
and scroll those back up. So to see what quantifiers we have available, I'm going to
make my snippets half of my screen here again, and then scroll down to my quantifiers section.
So the asterisk will match zero or more of what we're searching for. The plus sign will match
one or more. The question mark will match zero or one. And to match exact numbers, we can use
these curly braces with a number on the inside. So in this example, this would match exactly
three of what it is we're looking for. And we can also specify a range of numbers as well,
with the first number being the minimum, and the last number being the max. So this would search
for whatever our pattern is, it would look for three or four of those. So let's take a look at
an example of this to see how this works. So you can see that with our phone number, we are searching
for one digit at a time. But we could change this. If I erase my digits here, then we could say that
I'm searching for a digit. And then we could put in our quantifier for exactly three digits. And we
could do this after our separator as well. So we're searching for three digits, and then any character.
And then here at the end, we want to match four digits. So instead of writing out the same characters
over and over, we can see how these quantifiers allow us to specify exactly how much we want.
Now here, we're matching exact numbers. But sometimes we don't know the exact number. And
we'll need to use one of these other quantifiers. So for example, here at the bottom of this test
file here, we have some lines where each starts with a prefix of Mr, or Ms, or Mrs. So let's say
that we wanted to match these prefixes, as well as the names after. So just to start, let's start
by matching the names that start with Mr. Now we can see that some of these have a period after
the prefix, and some do not. Some of them just have a space. So let's start our regular expression
by searching for lines that start with Mr. And then we're going to put a backslash period to
search for that literal period. And right now it isn't matching this Mr. Smith, which doesn't
have a period after the prefix. Now to match that also, we can use this question mark quantifier,
which tells our pattern that we want to match zero or one of that character. So if I put a
question mark after that literal period, then it's saying that there can be zero periods there,
or there can be one. So we can see that now it's matching the ones with one period there,
and it's also matching the one with no period. So now to continue and match the entire line.
Now we want to match a space after that. And after the space, we want to match any
uppercase letter. And to do that, we can use our character class, and we can match any uppercase
letter by doing a range of uppercase letters there. So at this point, after that first uppercase
letter that we match, we've completely matched the name for Mr. T down here at the bottom.
But we still need to match the rest of our other names. So we could say that we will match any
word character after that uppercase. So let's put in a backslash w to match any word character.
And now we don't know how many more characters are going to be in our name. So we'll have to use
a quantifier here. Now if we look over here, we could use the asterisk or the plus sign. And the
plus sign will match one or more of these word characters. And the asterisk will match zero or
more. So if we used the plus sign, then we can see that it matches our two top names here. But now
it's not matching this Mr. T because after our word character, it's searching for one or more
word characters after our uppercase character. So a better solution in this case may be to use
the asterisk which matches zero or more word characters. And if we use that asterisk, then
we can see that it matches all three of our names that begin with Mr. Now I know that we've covered
a lot so far, but we've got a couple more concepts to go. And then we'll look at some examples that
wrap everything together. So we still haven't matched our miss or misses names here. So how
would we do that? So you might think that we could use a character set that matches either an R or an
S. And there are maybe some ways that we could get that to work. But it probably would be a bit
ugly since we'd have to match either an R or an S as the second character and then the optional S
after that. So that could get kind of ugly. But I think a better solution here would be to use a
group. Now we haven't looked at groups yet. But groups allow us to match several different patterns.
And to create a group, we use parentheses. So after the M here, instead of just searching for
Mr, I'm going to create a group with open and closed parentheses here. And now within our group,
we can specify different matches. So I can say that we want to match either an R,
and then or and we use this character here to specify an or. And that is just the vertical bar
character to specify an or. So we can say that we want to match an R or an S. And whenever we add
that in, we can see that now we're matching the miss name here. But we're still not matching this
Mrs. So to match the Mrs, we can put in another or and say that we want to match an RS. Okay,
so now we can see that we are matching all of our names here. So let's do a quick walkthrough
of this one more time to make sure we know what's going on. So we have a capital M to start. And then
that capital M is followed by either an R and S or an RS. And then we are looking for a literal
period. And this question mark says that we can have zero or one of those. So that is optional.
So it's matching the ones that do have that period and the ones that don't. And then after that,
we are matching a space. Then after that space, we the first letter of the last name, we're looking
for any capital letter. So we have a character set here, that is a through Z of capital letters.
And then for the rest of the last name, we are matching zero or more word characters. Now these
groups can actually be used to capture sections of your matched regular expression. And that's
something that we'll look at in just a minute. But for now, let's do a quick recap of everything
that we've learned so far. And look at some examples that incorporates all of these things
together. So I have a file here, and I'm going to move my snippets back into the group here and
open up this file emails.txt. So I've got a file here with three fairly different email addresses.
So let's try to write a regular expression that will match all of these emails. So let's just
match the first email address first and see what that looks like. So the first email address,
we have a mix of upper and lowercase letters here before we hit this at symbol. So let's go ahead
and match those first. So to match any upper or lowercase letters, we can do a character set,
and we can do a lowercase a through Z, or an uppercase a through uppercase Z. Now right now,
this is only matching those single characters. So we can use the plus quantifier to say that we want
one or more of these upper or lowercase letters. So we're still working on the first email address
here, we have our upper and lowercase letters here. And now we want to match that at symbol. So
I'll just put in a literal at symbol. And now for the domain name here, I'll just do a another search
for any upper or lowercase letters. So I'll do the same as we did before. And then I will do a plus
sign for a quantifier to match any upper lowercase letters after that at symbol. And then that's
when we hit the end with the dot com. So to match the dot com, we can do a backslash period for the
dot. And then we can just fill in a literal com. So now we've successfully matched that first address.
Now it looks like it's not matching the second address. So let's see why and see if we can mold
this to match the second address as well. So we can see that the second address has a dot in the
first part of the name here. So let's add a dot to our first character set so that dots are included
in that character set. So now it's still not matching that second address. And it's because at
the end here, we don't have a dot com but a dot edu. So in order to search for both, we can use a
group like we saw before using open and close parentheses. And we can search for either com
or edu. Okay, so now we are building this up a little bit at a time. And we can see that we are
now matching our second email address. Okay, so now let's see if we can change this to match our
third email address here. So in our third email address, it looks like before the at symbol,
we also have some hyphens and some numbers in the first part here. So let's add those to the
character set as well. So back here after our capital letters, I'm also going to add in digits
by doing zero through nine. And we also want to add a dash in there as well. So that should match
everything before the at symbol. Now it looks like we also have a dash in our domain here.
So we'll have to add that in as well. So after the at symbol, we're matching any characters right
now, it's just lowercase and uppercase. But we can put a dash in there as well. And lastly,
it's still not matching because just like the other two, instead, we have a dot net here instead.
So we can just add in a second or at the end and also include dot net. So we can see that we built
that up a little bit at a time to match all three of our email addresses. Now with something like
email addresses, it can be pretty tough writing your own regular expressions from scratch. But
there are a lot of these available online. And once we learn how to write regular expressions,
then we should be able to read them and figure out how they're matching as well. Now I've always
found that reading other people's regular expressions to be a lot harder than writing them.
But let's take a look at one and see if we can do this. So I have an expression here that I pulled
offline that matches email addresses. And let's paste this in here and see if we can read through
and see what this is matching. So we can see that the one that I got offline does match all three
of my email addresses here. Now let's look through this. So we can see that it's somewhat similar
to what we had before. But first we have a character set here and it's a pretty large character set.
And it matches lowercase, uppercase, any number, an underscore, a period, a plus sign, or a hyphen.
And then the plus sign here says that we want to match one or more of any of those characters.
And we match one or more of those characters all the way up until we hit an at sign. And then
after the at sign, we have another character set here. And in this character set, we have lowercase
letters, uppercase letters, any digits, and also a hyphen. Now I don't know a lot about email addresses,
but I'm assuming that since they left out the underscore, the period, and the plus sign that
we're in the first part of the email address, I'm assuming that those aren't allowed in the domain.
So then we have a plus sign after that character set, which means that we're matching one or more
of any of those characters all the way up until we reach this literal dot. And that literal dot
is escaped with a backslash. And then after the dot, we have another character set here. And this
character set is any lowercase letter, any uppercase letter, any digits, any hyphen, or a period.
And then that is followed by a plus sign, which matches one or more of anything in that character
set. So just like I did with the phone numbers, if we open up our data file here, with this
regular expression that we've typed in, then we can see that it does match all of the email addresses
in this data file as well. So we've got an expression that will match email addresses fairly well.
So doing what we just did and reading through a regular expression written by other people
is probably the hardest part of all this. But if you walk through it bit by bit,
then you should be able to break down just about any pattern. Okay, so the last thing
that I'd like to look at in this video is how to capture information from groups. Now we've
already seen how to match groups, but we can actually use the information captured from those
groups. So to show an example of this, I'm going to open up a file here with some URLs. Okay,
so we can see here that some of the URLs are HTTP, some are HTTPS. Also, some of these have
www before the domain name and some do not. So let's say that you had a list of a lot of different
URLs within your document, and you only wanted to grab the domain name and the top level domain,
which is .com or .gov. So for example, out of all these domains, you only wanted to grab
google.com or coreyms.com or youtube.com or nasa.gov. And you just wanted to ignore everything else.
So let's see how we can do this. So first, let's write an expression that actually matches these
URLs. So let me get rid of the one that we currently have. Now, first to match this, we can say all
of these start with with HTTP. And then the s is optional. So we can say s and then put in a
question mark to say that we want to match zero or one for the s. And then after that optional s,
we want a colon forward slash forward slash. So at this point, some of these domains have a
www dot before the domain name and some do not. So that www dot is optional. So since this isn't
one character, we're actually going to create a group here and say this group of www and then a
literal dot, which is a backslash dot. Now, all of that group is optional. So now you can see on
all of our URLs, we've matched up to the domain name. So now to complete this, I'm just going to say
any word characters, so backslash w, and I will put in a plus sign to say one or more of those
word characters. And then we get here to the top level domain. So we want to match a literal dot.
So we'll do a backslash dot. And then for the rest of that top level domain, I will just do
any word character one or more times so we can do a word character with a plus sign to do one or
more. Okay, so we can see that this matches all of our URLs. But the point here was to use our groups
to capture some information from our URLs. So let's capture the domain name and the top level
domain, which is the dot com or the dot gov and things like that. So to capture these sections,
we can just put them in a group by surrounding them in parentheses. So what we want to group here
is our domain name. And the domain name is this part right here, this string of one or more word
characters. So I'm just going to wrap those in parentheses and create a group. And we've seen
that before. And now we also want to put the top level domain in a group as well. That is the dot com
or the dot gov. So we can put a parentheses around that dot, and then also around the ending
there that is the string of one or more word characters. Okay, so we can see that we're still
matching all of our URLs here. But now we have three different groups. So our first group is just
that optional www dot. Our second group is the word characters that make up our domain name.
And the third group is that top level domain. Now there's also an implicit group zero. And group zero
is everything that we captured. So in this case, it's the entire URL. So now let's get to the cool
part about this. So let me show you what we can do now that we've captured these. So we can use
something called a back reference to reference our captured group. So for example, here in Adam,
we have the ability to replace our matches, we can see down here that we can replace. So let's
replace all of our matches with just the literal text group one, and then a colon, and then a dollar
sign one. Now this dollar sign one is a reference to our first group. Now sometimes this is a backslash,
but for some reason in Adam, they use a dollar sign. So if I do a replace all here, then we can see
that it replaced our matches with this literal text group one. But then it also replaced the dollar
sign one with our first captured group. And the first captured group is that optional www dot.
So for the ones for the domains that had that www, we can see that it shows up. And for ones
that didn't, it doesn't have anything. So let me undo this. And now let's replace our matches with
the second group. And now the second group should be the domain name. So now if I do a replace all
now, then we can see that now it says group two is Google, CoreMS, YouTube and NASA. And if I undo
that and replace this with the group three, then the group three should give us our top level domain.
So our group three is the dot com dot com dot gov things like that. So let me undo this one more
time. So now that we know how to use those back references, then we can actually take our regular
URLs and clean them up like we meant to from before. So we could convert these to a cleaned up
version without the HTTP or the www just by replacing our matches with the domain name,
which is group two, followed by the top level domain, which is group three. So now if I replace
all of our selections with those two, then we can see that replaced all of our URLs with just the
domain name and the top level domain. So you can imagine if you had a lot of information
like this that you needed to clean up or modify in some way, then knowing how to match these
groups with regular expressions could save you a ton of time with doing things like this.
Okay, so I think that's going to do it for this video. Now there's a lot of advanced features
that we could go over with regular expressions as well. So if anyone is interested in learning more,
then I could put together an advanced video covering those topics in the near future.
But hopefully now you feel comfortable with being able to read and write these regular
expressions that we went over in this video. But if anyone does have any questions about
what we covered in this video, then feel free to ask in the comment section below and I'll
do my best to answer those. And if you enjoy these tutorials and would like to support them,
then there are several ways you can do that. The easiest way is to simply like the video and
give it a thumbs up. And also it's a huge help to share these videos with anyone who you think
would find them useful. And if you have the means you can contribute through Patreon,
and there's a link to that page in the description section below. Be sure to subscribe for future
videos and thank you all for watching.
