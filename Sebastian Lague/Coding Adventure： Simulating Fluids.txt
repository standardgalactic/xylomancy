Hello everyone, and welcome to another episode of Coding Adventures. Today I'd like to
dive into the world of fluid simulations. So to begin with, let's draw a circle.
Very nice. This circle represents a tiny bit of water, or whatever fluid we want to imagine,
and it's going to move around in response to various forces. For instance, gravity is
probably a good place to start. So back in the code, I'll add in a gravity variable,
and let's also keep track of the particle's position and velocity.
Each time step, we'll then want it to be accelerated downward by gravity,
and to then move according to its new velocity. Let's take a look.
Okay, not bad, but it is falling off the screen, which is a bit annoying,
so I've added a tiny function that just checks if the particle has moved outside of a box,
and if so, we shove it back into the box, and send it bouncing off in the opposite direction.
I'd actually also like to multiply the velocity by some collision-dumping factor between 0 and 1
here, so that we can control how much energy it loses with each bounce. Alright, so we can set
up our little bounding box, and turn on the gravity again, and off we go bouncing.
By the way, I've also made it so that we can control the display size of the particle here.
Okay, let's then also try out our collision-dumping setting,
and we can see the particle now bounces low and low each time until it comes to a stop.
Believe it or not though, one particle is not enough particles to simulate a fluid,
so I've quickly upgraded our position and velocity variables to instead store a whole array of
positions and velocities, which we can then loop over and just do the same update as before to each
of them. I've also created a simple function that runs at the beginning to set up the particles
in a little grid arrangement, just so that they're not all on top of one another.
So let's make a bunch of particles, and I'll quickly tweak the size and spacing over here
to something more reasonable, and then we can let this run. Okay, there's a pretty clear problem
though, which is that the particles are all just collapsing on top of one another,
so I guess we need some sort of force to push them apart. I'm curious to learn how this is
typically handled in the fluid simulation world, so I'm going to do some reading. I found a bunch
of intriguing particle-based fluid papers, and I've just spent the last few hours trying to work my
way through those. Honestly, most of the maths has gone well over my head, as it often does,
but the broad ideas at least are encouragingly simple. So I think my goal for today is not to
try and make some amazingly accurate simulation, but just to build a rough starting point from
which we can delve deeper into the maths and physics in the future, when I'm hopefully a little
bit smarter. Anyway, the first step to fixing that overlapping particle problem we were having
is to be able to estimate the density of our fluid at any point. So I've just scattered our
particles around randomly for this example, and of course since we're imagining that this
represents some kind of fluid, in reality there should be way more particles in this,
but we're always going to be limited by what our computers can handle, so to approximate reality,
we can just cheat a little bit by blurring or smoothing out the few that we have, so that it
appears more as a continuous field than a bunch of individual points. This simple idea is the basis
of smooth particle hydrodynamics, a technique introduced back in the 70s to help solve astrophysics
problems and further our understanding of the universe, which today we'll be using for the
equally lofty goal of making some little pixels go splash splash for our amusement.
Alright, so to see how we're going to calculate this sort of density field we have here,
let's zoom in on a single particle and define a smoothing radius, which gives us this circle of
influence around the particle, where it will have maximum influence at the center, falling off to no
influence at all at the outer edge. Let's draw a little graph of this behavior, so on the x-axis
we'll have the distance from the center of the particle, and because negative distance doesn't
make a huge amount of sense, I'll just make the left side of the graph be a mirror of the positive
side. Then the y-axis will represent the influence of the particle at any given distance, and let's
say for now that our smoothing radius is just one. So as if a simple function we could use would be
something like this, just subtracting the distance from the radius and clamping it to never go below
zero, and here's what that gives us. This is not very smooth though, so we could take that straight
line and qubit for example, which will ease it out as it approaches zero. Another option if we
wanted it to be smooth at the start as well, would be to also square the radius and distance
before subtracting them, and here's how that comes out. Obviously we could also try different powers
or different functions altogether, I think it's mostly a case of just playing around and seeing
what works best, but let's go with this one for now. So I've used that to write this little
density function, which takes in the point we want to find the density at, and then for each
particle it gets the distance to that sample point, which determines how much influence the
particle has at that location, and then it simply increases the density by the particle's mass,
multiplied by the influence value, and the mass I've just defined to always be one for simplicity.
So let's test this quickly with an evenly spaced grid of particles,
and I'll just try sampling the density at the center here with a radius of 0.5 for example.
Now at the moment the density is coming to about 0.48, but if we squish the particles closer
together we can see that the density value goes up, which makes sense, and if we move them further
apart it goes down of course. But what about if we increase the smoothing radius? Well our density
value has just shut up through the roof, which is very concerning, because making the radius bigger
should only make the result more blurry, which for this uniform grid of particles should actually
have no effect on the density at all. So let's think about this a bit. For each particle we are
calculating an influence value, which we could draw as a height, and here we can of course see the
shape of our smoothing function emerge. Now we're effectively just adding all these heights together
to create our density value, but it's kind of helpful to note that if we were to first also
multiply the heights by the width and breadth of these little boxes I've drawn here,
what we'd actually be doing is estimating the volume of the smoothing function.
So with that in mind, I think it's reasonable to say that if we want the density to stay the same
as we change the smoothing radius, then what we'll need to do is make sure that the volume
of our smoothing function remains the same when we change the smoothing radius. That means we're
going to need to calculate its volume, or make Wolfram calculated for us at any rate, and that
has come out to pi times the smoothing radius to the power h divided by 4. We can then just go back
to our smoothing function and calculate the volume in here, and then simply divide the output by the
volume, which means that now the new volume of the function will always be 1. Let's quickly make
sure this is working, so the density is 187 at the moment, and now if we change the smoothing
radius, that should stay the same, which it does. Of course, if we make the radius too small, the
results will get a little dodgy since there just aren't enough particles, but apart from that,
we now have a nice way of determining the density at any point with whatever smoothing radius we
choose to use. Okay, so let's return to our random arrangement of particles, and we can now properly
visualize the density values here as we increase the smoothing radius. Now we're claiming that this
represents a fluid, so one would probably assume it's a gas at the moment, because we have all
these regions with different densities. But I'm more interested in simulating liquids today,
which in practical terms are incompressible, meaning their molecules are packed together
as tightly as they can be, and so we'd expect the density to be the same everywhere. For our
simulation to behave at least somewhat like a liquid then, we're going to need to rapidly
correct these density differences by moving particles from areas of high density towards
areas of low density. So we need to figure out how to calculate that, but I started to get a bit
confused at this point while I was doing my research, so I'd like to take a step back for a moment
and just play around a bit with an abstract example to try and wrap my head around some stuff first,
and then we'll come back and apply what we've learnt to our actual problem.
So here's a simple little function that takes in a point in 2D space and outputs a single value,
which looks like this. And what it represents is nothing at all, it's just a made-up function
that we're going to try and represent with particles to hopefully gain a better understanding
of this whole smooth particle business we're working with today. So I've now added some code
that spawns in a bunch of particles at random positions, and each of these just looks up the
value of the example function at its location, and stores that in this vaguely named particle
properties array. Now we're going to pretend that we no longer have access to that example
function for whatever reason, so we only know the values at the particle positions, and our first
goal is to simply approximate the missing values. To do that, we'll use the same smoothing idea
from when we calculated the density earlier. So I've made this little calculate property function
that takes in a point in space, loops over all the particles, and just adds up the values of their
properties multiplied by the smoothing function, since again that just tells us how much influence
the particle has at the current point, and then also multiplied by the mass, since that effectively
scales how much influence the particles have. Let's see how that comes out. So here's the
original function again just for reference, and here's our approximation. Obviously the shape
isn't perfect, but we could simply use more particles to improve that. What's more concerning
though is that the values are clearly being greatly exaggerated. Now we could try to correct this by
reducing the particle mass, but that just reveals a deeper problem, which is that the values are
being particularly exaggerated in regions of high particle density, since obviously more values are
being added together there than in regions of low density. So to fix that, all we actually need to do
is calculate the density at each particle, using the function we wrote earlier of course,
and then divide each particle's contribution by its density. Now our approximated result looks
like this. We're not needing to make any adjustments to the mass, which is a whole lot better,
and it's reasonably close to the original function. So what we've arrived at here is actually one of
the core equations of this whole technique, which says that to calculate some property a at any position
x, we just need to loop over all the particles and add together the value of that property
that's stored in each particle, multiplied by the particle's mass, divided by its density,
and finally multiplied by the smoothing function, given the distance between the particle and the
sample point. What's interesting to note here is say that the property we want to calculate
with this equation is the particle's density. In that case we replace a with the density,
which then cancels out with the density over here, leaving us with just mass times the smoothing
function, which is exactly what we came up with in the beginning. So that bit of math seems to
check out at least. Okay, that's nice and all, but what we're more interested in right now than
calculating the value of a property at any point is calculating in which direction it's most rapidly
changing, since that's essential to our problem of correcting the density in our fluid. So I've
started writing this little calculate gradient function to do that, and all this does is define
a tiny step size, and then figure out how much the value changes if we take that tiny step
along the x and y axes, using the calculate property function we just wrote. Then the
estimated gradient is just those two changes, each divided by the size of the step that we talk.
Let's try it out. So I've drawn in some little arrows to visualize the gradients at different
points, and just visually it looks like these are all correctly pointing along the direction
where the values are most rapidly increasing. So that's great. What's less great is that it's
taking almost 20 seconds to calculate all of these, which is ridiculously slow. Fortunately though,
there is a more efficient approach. Imagine we have just a single particle, and I'll draw in
the smoothing radius here as well, and we're trying to calculate the gradient of whatever
property at this point over here. Well first of all, the direction in which that property will
most rapidly be increasing is either directly towards the particle, or directly away from it
if the property is negative, so that's easy enough. The gradient doesn't only tell us the
direction though, but also how fast the property is changing, and that depends purely on our smoothing
function. At the current distance, we can see that the smoothing function isn't very steep,
which means that the property will be changing quite slowly over here,
whereas of course if our sample point was over here for example, then it would be
changing a lot more rapidly. So after struggling to remember how basic calculus works for a few minutes,
I finally figured out the equation for the slope of the smoothing function,
which I've just translated into code over here, and that means that we can now easily
look up the slope value at any distance. So let's return to our fast attempt at the gradient
function, and I'll delete the old code and replace it with our calculate property code,
since that's almost exactly what we need, except since we want to know the gradient now,
we'll multiply not by the smoothing function, but by the slope of the smoothing function,
and then also by the direction towards the current particle.
By summing up all these individual gradients, we should logically get the overall gradient.
Then if we return to our little visualization and just run it again, it should look exactly the
same as before. Which it doesn't, I guess I got the direction back to front, so I'll just stick
a minus sign in there quickly. I come from the trial and error school of mathematics,
but now it does look the same as before. This optimization has taken us from 20 seconds down
to about 5, which is still uselessly slow, but headed in the right direction at least.
Okay, I've just been having another look at our gradient function, and we definitely need
to stop calling calculate density all the time. I somehow forgot already that that's also looping
over all the particles. No wonder this is so slow. So what we can do is just create an array of
density values, and then pre-calculate those for each particle, so that we can just use those
cached values in our gradient function. That brings our computation time down from 5 seconds to 18
milliseconds. I probably should have started with that. Anyway, it's still not fantastic,
but it's at least usable for now. So let's return at last to our little density test over here,
and see if we can apply this gradient stuff to make the density be the same everywhere.
So in the code, I've defined a target density that we want to aim for,
along with a pressure multiplier, which is just how strongly we're going to push the particles
to try and reach that density. Then I've also added this little function for converting the
density to a kind of pressure value, and this just looks at how far away the density is from
what we want it to be, and then multiplies that by the pressure multiplier. From what I understand,
this isn't really a super realistic way to calculate pressures in a liquid. It more so describes
the behavior of gases, but it still seems to be a popular choice for its simplicity,
so let's stick with it for now at least. I would like to quickly visualize these values,
so I've set up three different colors over here, one for the regions where it's negative,
just meaning that the density is lower than we want it to be, another for where the value
is positive, meaning of course that the density is higher than we want it to be,
and finally one for the boundary between them, where the density is just right.
I'll also change the particle color to black so that it stands out a bit better here.
Okay, so let's finally get these particles moving along the pressure gradient,
and for that we can just use the gradient function we wrote, which I'll rename to
Calculate Pressure Force, and then the property we're interested in here is of course the pressure,
so let's substitute in our little pressure calculation.
Then our simulation update loop now looks like this, we still have the gravity, position,
and collision stuff from before, but I've added in the density caching we decided to do.
We still need to actually apply the pressure forces here though, so I'll make another loop
quickly to calculate those for each of the particles, and then we know that force equals
mass times acceleration, so acceleration is force over mass. So my first thought was to just calculate
the acceleration like this, but actually we're thinking about the movement of tiny volumes of
fluid here, and density is the mass per volume, so it's in fact the density that we want to use
instead. Alright, all that's left then is to just increase the particles of velocity by this
acceleration, and we can finally try it out. This has been a long time coming, so let's get a little
drumroll going. Ah, the cuss of the drumroll continues. Okay, the positions are all not a
number I see, so most likely we're dividing by zero somewhere. Oh, of course, we're being given
the position of a particle here, but then we're also looping over all the particles and finding
the distance between the two, and that's where everything's going wrong. I guess what I'll do
is just have this function take in the particle index instead of the position, and that way we
can very easily just skip over the case where the two particles are the same. Okay, I just need to
fix this up quickly, and I suppose it is technically possible for two different particles to be in the
same position, so if that edge case occurs, let's just pick a random direction then. Alright, let's
try this out again. Well, at least everything hasn't blinked out of existence, but the particles
are getting more dense, which is the opposite of what we want. I guess I need to stick another
minus sign in there somewhere. Let's see if this works now the third time.
Okay, that was looking promising for a moment there, for a brief instant, I thought it was working,
but there's still a lot more red areas than I'm hoping to see. Ideally, the whole screen should
turn white, since that represents our target density. So to try to figure out what's going on,
I want to see what happens if, instead of adding the acceleration to the velocity, we just assign
it directly, so we're removing any inertia from the particles, they're just purely moving based
on the current pressure force. Okay, if we run this now, nothing happens, but that's fine,
we aren't accumulating velocity anymore, so I guess we just need to turn the pressure multiplier up
really high. Alright, that looks interesting. I am a bit surprised by how close together some of
these particles are, although they seem to gradually be pushing each other apart. And I actually
remember one of the papers mentioning this potential problem with the smoothing function we're using,
since its slope becomes very shallow as the distance becomes small, meaning that our pressure
force will also be small when the particles are close together. That seems odd, so let's maybe
ditch this nice smooth curve for the spiky version instead, since of course the slope of this one
just gets steeper towards zero. So I had to do the volume and derivative calculations again,
but ended up with these two functions here. Plugging those in, we can see our little map
looks just ever so slightly different, and then I'm going to turn up the pressure multiplier again
now and see what happens. Okay, that's looking a lot better actually. The question now though is
what does it look like if we put the acceleration back to how it's supposed to be? So I've changed
it back, and I'm going to try running this again. Let's maybe try increasing the pressure
multiplier a bit, so that the particles can react more quickly. That's looking reasonably good I
think, although maybe I'm imagining this, but it seems to be getting worse over time.
Okay, I am definitely not imagining it. So another thing we need to think about is Newton's third
law of motion. Every force has an equal and opposite reaction force.
So when we're adding on this pressure force between the current particle and some other
particle, we want to make sure that the other particle experiences the same force, just in
the other direction. I've seen a bunch of different suggestions on how to actually do this,
but a nice simple version is to calculate this shared pressure, which is literally just the
average of the pressure values calculated at both particles. So let's try that out quickly,
and I'll just increase the pressure multiplier again.
And this does seem to have made a pretty big difference. I guess maybe that Newton guy was
onto something. Now we're only dealing with a few hundred particles at the moment, which is not
very many, so let's ramp this up to a few thousand instead. And this is running at five
frames per second. So we'd better start optimizing, and by far the most critical place to do that is
when we're calculating the densities and pressure forces, we should really avoid looping over all
the particles that lie outside of the smoothing radius, since those don't contribute anything,
and they're slowing us down immensely. To do this, we're going to need to chop space up into
a grid, and we'll choose the size of the grid cells to be the same as our smoothing radius,
since that means, if we imagine there's a bunch of particles on here, that means that to find the
particles inside of the smoothing radius, we only need to consider the 3x3 grid of cells around the
center of our circle. And in that way, of course, we cut out a huge amount of unnecessary work.
Now to actually implement this, we could say that each cell has its own list that grows
or shrinks to hold however many particles are currently inside of it. But we're probably
going to want to convert the whole simulation to a compute shader at some point to run on the GPU,
and there we need to be able to specify ahead of time how much memory we're going to use.
So I'd like to experiment with a different GPU friendly approach, which I've been reading about
in this paper here. I'm going to modify it very slightly though, so that we don't need to know
the dimensions of the grid ahead of time, meaning that particles can travel anywhere in the world,
and it'll still work. So what we'll do is create a single array with at least as many entries as
we have particles. So here it has 10 entries, meaning in this case we could have at most 10
particles. Then for each of these particles, we're going to calculate the coordinate of the cell
that it's in. So for example, particle zero, which happens to be this one over here, is in the cell
2,0. We need to turn that coordinate into a single number to make it easy to work with though,
so we can just do something like multiply the x and y by two different prime numbers,
and then add them together to get some arbitrary hash value. We can then wrap that around the
length of the array so that it becomes a valid index, three in this case, and let's call that
our cell key, not to be confused with the seal people. So since this was point zero,
we'll store the cell key over here at index zero in the array. Then the next point it turns out has
a key of six, and so we'll record that in the next place. And so on and so forth for all of the
particles that we have. Now we want the points that share a cell to be next to one another in
this array so that we can efficiently loop over them. Of course, if they're in the same cell,
they're going to have the same cell key, so we can simply sort the list based on those keys to do
that. And now we can easily see from this array that particles two, five, and seven are all together
in the same cell. Particle zero is in a cell all by itself, and so on. Anyway, let's call this array
our spatial lookup, because that sounds nice and fancy. And then the final thing we need to do is
create a second array of start indices, which looks like this. To understand this second array,
let's just do a quick example. So say we want to know which points are in this cell over here.
We would first calculate the cell's key like before, which is nine in this case,
and then we'd proceed to look up the ninth element in the array of start indices,
which is this last one over here, the number six. That lets us know that we need to head over to
index six in the spatial lookup in order to find the first entry with the cell key that we're
interested in. We can then simply loop over all of those to get the indices of the particles that
are in that cell. Unfortunately, it is possible for different cells to end up mapping to the same
key, which would mess with these results, but we're anyway going to need to do distance checks to
see which points are actually inside the smoothing radius, and so that'll get rid of any mistakes.
Obviously, having to check extra particles from some other random cell that just happens to have
the same key does waste time, but that's what we get for trying to implement an infinite grid
with a sadly non-infinite amount of memory. Anyway, turning this concept into code didn't go
as smoothly as it possibly could have, but after a bit of frustration, here's what I
finally ended up with. We have a function for updating the lookup whenever the points have moved,
and this just calculates the cell key for every particle, and records that along with the particle
index. The array is then sorted based on those keys, and lastly the start indices are calculated,
simply by testing if each key is the same as the key that came before it, because if not,
then it must be the first occurrence of that key, and we can record its index as the start index.
Here are the little helper functions, by the way, for calculating the cell coordinate,
hash, and key. Then finally, there's the function that allows us to actually find all of the points
within the radius of some given sample point. This works, as we've seen, by just looping over
the 3x3 block of cells around that sample point, and calculating each of their keys.
Each key is then used to look up the start index for that cell, so we can loop over all the points
in the cell, and of course once we reach a point that has a different key, we just exit out of the
loop. All that remains then is to do a quick distance check to make sure the point is actually
inside the circle, and then we can do whatever we want with it. Trying this out now, we've gone
from barely 5 frames per second up to 120, so that was a reasonable success, but I'd be a lot
happy about it if our simulation wasn't in total chaos over here. One clunky way I found to improve
this is to simply start off with a really low pressure multiplier. This way, the particles
don't have such a huge initial burst of acceleration, and they can spread out a little,
and then we just gradually increase the multiplier, and it seems to work a bit better at least.
That's not really a usable solution though, so I've just been implementing an IGRI
read about where we basically predict what the next position of each particle is going to be,
simply based on the current velocity, and use those predicted positions when calculating
the densities and pressure forces. I guess this could help the particles to better react to
upcoming situations, and maybe compensate a bit for the fact that time is obviously not continuous
in a computer simulation, but rather broken up into discrete steps. Okay, let's try it out,
I honestly don't see it making a big difference though.
Never mind, it's actually making a pretty massive difference I'd say. Well, that's a nice surprise.
Just for fun, I've quickly gone into the particle rendering code I have here,
and just set it up so that we can visualise the speed of the particles with a colour.
Then here's a little gradient I made for that, so the slowest particles will appear blue,
fading to red for the fastest particles.
I also added in some simple controls for things like pausing the simulation,
stepping through frame by frame, and resetting it.
Alright, I've been playing around with this some more, and one thing I've noticed
is that it behaves very inconsistently at different simulation frame rates.
Here's a little grid of simulations I set up to observe this problem, so we're going from
60 simulation steps per second on the top left, to almost 1000 steps per second on the bottom right.
And as we can see here, if the number of steps is higher, meaning the time step is smaller,
and so we're predicting less fine to the future, the particles take longer to settle down.
So even though this feels a bit wrong to me, I'm going to try just removing the delta time here,
and use a constant look ahead factor instead.
Let's then run the same comparison again, and interestingly, it is actually behaving a lot
more consistently now. Well okay, I guess we'll go with that then.
Now, I think it'd be fun if we could interact with the particles in some way, so I've written this
little function that basically just pulls nearby particles in towards the mouse, or pushes them
away if the input strength is negative, which is controlled by left or right clicking.
So let's give it a shot. I'm going to start by pushing these particles outwards,
and then let's try slicing through the fluid.
Alright, I feel like this is slowly starting to get somewhere. Clearly, we haven't really succeeded
in our goal of making this fluid incompressible, it's certainly compressing and expanding all
over the place, but the density does even out over time, so that's something at least,
and we can look into fancier methods to try and solve this better in the future.
Anyway, now that this seems to be somewhat working at any rate, I think it's time we
brought gravity back into the mix. So I'll reset this quickly, and let's bring in our settings
window. I feel like the density could maybe be set a bit higher, so I'll turn that up,
and then let's get the simulation going again. Okay, I guess that's a little too high now.
So I'll dial that setting back down a bit.
Then let's turn on the gravity. Wait, that's upside down, let me make it go the other way
instead. The particles are quite wild at the moment, so I'll also increase the pressure
multiplier to try and drain them in a little. Okay, let's try picking up a ball of water,
and dropping it back in. Splash. This is actually working surprisingly well, I'd say.
I mean, I realise I've been droning on for over half an hour already,
but all that we've really done is made a bunch of points that don't like to be too
close together, but not too far apart either. And while this is obviously far from being
super realistic or anything, I think it's still quite fascinating that this fluid-like behaviour
has already arisen from just the few little things we've implemented.
Anyway, let's see if we can still improve this at least a little bit more today,
and perhaps even venture into the third dimension. So a few issues are jumping out to me at the
moment. For example, there's the fact that the particles are really tightly squeezed together
along the edges here, and that's causing a gap between the rest of the particles since they're
trying to get away from that overly dense region. And a similar effect seems to be happening along
the surface of the fluid as well. Another thing is that when we have fast-moving particles,
such as when starting up the simulation for instance, the fluid seems to be overly chaotic.
For example, if we zoom in on a single frame here, we can see from these colours how the
velocities are all over the place, even between nearby regions. For this last problem at least,
I think it'd be a good idea to try add a bit of friction between the particles in the fluid,
more commonly known as viscosity. So let's actually take a moment to look at the famous
Navier-Stokes equations for incompressible fluid flow, which underpin everything that we've been
doing. First of all, this equation here just says that the density of the fluid must remain the same
everywhere, and I mean, we're trying. Then the other equation tells us that each tiny little
volume of fluid is accelerated down the pressure gradient, and that it responds to external forces
such as gravity and mice in our case. So we've done both of those terms.
But then this slightly scary looking term here is the viscosity, and essentially what it does
is cause the velocities of nearby regions of fluid to become blurred together.
Now we could implement it this way, but for today at least I actually want to go with a
different approach I've seen that seems much simpler, but still achieves the same sort of thing.
So I've added this little function here, which just takes in the index of a particle,
and loops over all the other particles within the smoothing radius.
For each of those, it then calculates the difference between the velocities of the two
particles, and adds that on to the viscosity force, meaning that over time each particle's
velocity will become more like its neighbors, and nearby neighbors have more influence as usual,
which is done using this viscosity kernel, for which I've just repurposed that function that
we were originally using for the pressure force. Okay, let's try it out. Oh, my settings have been
reset, so we're back to no gravity at the moment, but let's see what that looks like.
Currently our viscosity is at zero, so let's turn it up, I'm not sure what a good value
would be, let's just try five maybe. Nope, definitely not, that looks very strange.
My guess is that the viscosity is just way too high at the moment, and so some of these particles
are almost exactly matching one another in velocity, and that's causing them to clump
together weirdly. So let's reduce it to maybe 0.5 instead, and see how that goes.
Okay, this is looking pretty good actually. We can see how the particle velocities are more
smoothed out, and so we no longer have those few particles with super high velocities shooting off
on their own. I want to see how this looks with gravity enabled again, so I've set up a quick
comparison here with a range of different viscosity values, and let's see how it goes.
I think the one on the top right looked best to me, but let's see that again quickly.
And I'll freeze it here actually, because this gives us a nice view of the increasingly smoothed
out results we get with this new artificial viscosity term. Obviously we don't want to
smooth out too much detail though, so I'm going to keep that value pretty low.
Okay, now I'm not quite sure yet how to tackle that boundary problem I mentioned earlier,
so I'm going to just ignore that for now, and instead work on something else that's bothering me.
If we lift up a bunch of water, and then let it go, we can see how it quickly splits up into
these little droplets of just a few particles each, which looks a little strange.
We could get rid of this behaviour by simply clumping the pressure values that they can't
go below zero, meaning that the particles won't pull each other together anymore.
So let's try that out.
But now the particles are just raining down individually, which doesn't look right either.
I guess allowing that negative pressure was giving us a very crude kind of surface tension effect,
and so I think until we implement a more accurate version of that in a future video
perhaps, we should probably hang on to it. So I'm going to undo that change, and instead I want to
try an interesting workaround one of the papers suggested, which is to simply have a second
pressure force, purely for pushing apart particles that get too close together.
So this is the shape of the smoothing function we're using for our density calculation at the
moment, and what the paper recommends is to use another, even spikier version, to calculate what
they call the near density. From this near density, we calculate the near pressure simply by multiplying
it by some constant, meaning that this will be a purely repulsive force. So let's try it out quickly,
and just for fun, I'm going to see what happens if we make the near pressure multiplier negative.
Okay, they just collapse in on one another, which makes sense. So let's then try a positive value.
And now I want to try picking up a ball of fluid again,
and dropping it. And as we can see, this time it's able to hold its shape a lot better,
since the particles are no longer getting pulled into those tiny clusters we saw before.
So I think we've succeeded in improving the fluid a bit with these last two
changes, although I'm certainly not entirely happy with how it's behaving yet. For example,
something that bothers me quite a lot is how it often appears to sort of bounce more like a jelly
than a liquid. This is happening pretty much all the time, but we can see a dramatic example
if I just let the fluid come to a rest, and then change the target density for example.
Now we could get less jiggly results simply by increasing the pressure multiplier,
which is why it's often actually called the stiffness constant by the way. So here I've
set up a little test where it has a value of 1000, and if I change the density now,
we can see that it does settle down a lot more quickly.
But that doesn't come for free though, because the greater the forces in our fluid are,
the more simulation steps we need to run per frame to avoid things devolving into chaos.
For example, if I just lower the number of steps here slightly,
we can see that already we're on the brink of pandemonium.
Anyway, I'm sure we'll learn about ways to overcome or at least improve this problem in the
future, but for right now what I'd like to do is finally convert the whole simulation to a
computer shader so that we can run it on the GPU, which excels at doing loads of tiny tasks in parallel,
which should be a perfect fit for our particle calculations.
I doubt that'll take very long, so I'll see you in a minute.
Okay, I kept finding new and creative ways to mess everything up, but this finally seems to be
running properly in a computer shader. I'll still need to test the performance with more
particles of course, but just glancing at the FPS counter looks promising so far,
hovering at around 500 frames per second. By far the trickiest part was translating just
one line of code, the array.sort, from our neighbourhood search. I ended up spending
quite a while trying to figure out how to implement a parallel sorting algorithm
called bitonic merge sort to replace it. In particular, I was trying to generate this pattern
of lines and generalize it for any number of inputs. The inputs here are represented by the
horizontal lines and we have 16 of them in this case, meaning that this network can sort 16 values.
Let's actually assign a random value to each input so we can see how this goes.
Then each of these little vertical lines represents a pair of inputs that we're going to compare
and potentially swap around. So to start with, we're going to look at each of the eight pairs
that we have over here, and let's say we want to sort from high to low, so in the class pair we
have 5 on top and 3 on the bottom, which we're happy with, so that can stay unchanged. In the
next pair though we can see 7 on top and 8 on the bottom, so the bottom is a higher number which is
not okay, and we'll need to swap them around. So we can look at all these pairs in parallel,
figure out which need to be swapped and then swap them. Of course this alone is unlikely to sort
the list, so once that's done we'll need to continue to the next stage. Here the pairs are
arranged a little differently, but the operation is still exactly the same. We can see this first
pair has 5 on top, 7 on the bottom, so it will need to swap, as will this pair with 3 on top
and 8 on the bottom, and so on.
This pattern has been carefully devised by some clever person, such that following it will do
all the comparisons required to guarantee that the result is fully sorted by the end.
For anyone interested I'll quickly show the implementation I came up with,
so this part runs on the CPU and is responsible for simply looping through each of those patterns
and telling the GPU to sort the pairs. And then here's the code that actually does that
pairwise sorting, so it starts by just figuring out which pair of numbers it's actually looking at,
and then it compares them to see if they need to be swapped, and if they do it of course swaps them.
Alright, I've been doing some testing with different amounts of particles,
so here is 100 particles for example, and I think it's kind of cute watching these little droplets
wobble about. Then after that I tried 100,000 particles, but my computer was not happy about that,
so there's definitely a lot of room left for optimization.
Here's a test with about 40,000 particles though, which seems to be running okay,
although I'll have to fine tune the settings of course, because at the moment there are some weird
tendrils shooting out of the liquid, and I really don't know why. Or perhaps we could call this a
speculative simulation of how liquids might behave on an alien planet.
The settings are definitely quite finicky at the moment though, so that's something else I want to improve.
Here's another little test I've set up by the way, and this one has an obstacle over here with
a gap beneath it, because I just want to see if this simulation is able to keep the height of
the liquid the same on both sides. So I'm just going to start bucketing some of this liquid over
to the other end here, and then let's grab another blob, and another, and then let's just
wait a bit for this to settle down, but already we can see the height gradually leveling out.
So even though our simulation is far from being super realistic, it's nice to say at least that
it's not entirely unrealistic either. Okay now as always there's so much more I still want to do,
but to end with for today, let's see if we can get this working in the third dimension.
This basically just means replacing a bunch of float twos with float threes in the compute shader,
as well as updating the scaling factors of the various smoothing functions and their derivatives,
and making sure our neighborhood search is aware of this brand new dimension as well of course.
I've also updated the collision function to work in 3D, and I tweaked it to account for the
bounding box being moved or rotated as well as scaled, simply by transforming the points and
velocities to its local coordinate system, then resolving those the same as before,
and then finally transforming them back into world coordinates.
My first attempt at running this did not go particularly well, but after some trial and
error with the settings I managed to get this rather goopy looking result, and with a few more
tweaks from there I was finally able to get something that I was reasonably happy with.
So let's just play around with this a bit. I'm going to try squeezing it together,
and what's nice about how we implemented the neighborhood search stuff is that we aren't
constrained to any predetermined bounds, so we can stretch this out however much we want as well,
and it should still work.
Those little waves were looking quite nice I think, so let's actually smush this together
again, and then try that out once more.
Now another thing to add to my list of a million things I want to improve is how the
fluid is actually rendered. These little balls are good for seeing what's going on of course,
but it would be nice to make it actually look more fluid like, and I guess some sort of ray
matching is probably a good way to approach that, but we'll have to see.
So let me actually make a quick note here of my sort of wish list for this project.
I want the simulation to be more stable and performant so that we can have many more particles,
and I'd like the parameters to be less finicky so it's easier to get good results,
and also for the particles to behave better along the boundaries because it looks really odd at the
moment. Another thing that'll be really nice is to be able to do stuff like put little boats or
rubber ducks in the water, and just watch them bob about. Then finally of course there's the
rendering stuff I just mentioned as well. So plenty of work for the future, but until then
I hope you've enjoyed following along with the process so far. Okay that's all for today,
let me know if you have any suggestions for this project or for anything else you'd like to see.
Alright, thanks for watching and goodbye.
