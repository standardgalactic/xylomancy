One of the areas of computing that I'm really curious about and I think the software world has a lot to learn from is
Game programming. I mean probably not on a surface level. I've never worked for an e-commerce company that needed collision detection
But get below that surface and a lot of modern games, especially once they go multiplayer
They're dealing with things like global networking issues
multi-user concurrency
competitive concurrency
Massive data volumes under brutal latency requirements
They have a lot of the programming issues that we're familiar with but under much harsher conditions and being a somewhat separate world
They tend to approach the solution from a novel angle. So this week
We're going to go digging for system design ideas in the gaming world. And my guest for this is Tyler Cloutier
He's got a background in distributed systems and data science for the gaming industry
And he's currently building bitcraft, which is a massive multiplayer open-world game and to support it a really interesting
flavor of database called space time DB from which we're going to mine some ideas about concurrency
transactions
Data security query management lots more a lot of juicy ideas
Solved from an angle that I'd never considered. So let's get going. I'm your host Chris Jenkins
This is developer voices and today's voice is Tyler Cloutier
My guest this week is Tyler Cloutier. How you doing Tyler? I'm doing well. How are you? I'm very well. I'm
You're gonna take me to a new world for me because I
Have a long history in programming, but one thing I've never done is
computer game programming and
Along with that the one thing I've always wondered is they must have a lot of the same problems
The the rest of us industrial programmers have not like they're dealing with graphics and story and stuff
But then there are data problems everywhere, right?
That's right. Actually, I would say
What I have experience is that they have the normal problems that everybody else has but times a hundred because not only do
They have to build the thing
But it has to interact with all of it the data in the program besides just sort of individual parts
And then it has to go really really fast
Yeah, yeah, all our problems except at 60 times a second. That's right. Yeah
So your background is
Originally in game design or data science for games or what's your origin story?
My original background is actually in chemical and biomolecular engineering, which is completely unrelated to games
And then I did my masters in computer science focusing on distributed systems and machine learning
Okay
After that I did some time at Bloomberg and then Apple and then a company called machine zone
Which is a game development company, right? And what did you do for them?
So there I worked in their data science and engineering department as a data science engineer
And there we were building
Two things one pipelines for data
So making sure that we got the real live data as quickly as possible into a form that we could then
Feed into our models. So then the second part of what I did is also build those models
Which predicted various things about how players are likely to behave so like
How likely is this player to turn how likely is this player to spend money will they give us a good review that kind of thing
This is a pay-to-play game. This is a free-to-play game actually that is quite expensive
ultimately
Because it's the business model where like most players don't pay anything but some pay for like
Cosmetics upgrades that kind of thing and they spend a lot and no, no, it's much worse than that. So it's a mobile game
and
it's the the
whole idea of the game is it's supposed to simulate what it feels like to be a king and so
What that ends up being is that you have this little city. It's called a 4x game
which is for the four different types of play that you're gonna do and
You build the city up you upgrade your buildings
and then you can start sending marches out to attack other players and
Ultimately, you want to capture a what's called a wonder which will give you make you the king of the kingdom and
The process of capturing that wonder is quite an expensive endeavor. So
The way it works is that
They sell you speed-ups so upgrades take time you can speed things up by paying for it
And some people pay quite a lot. There were individuals who spent
Upwards of several million dollars in that game
Several million you heard that correct if I if I did not see it myself. I would not have believed it
gee, I can't I
Struggle to compute why someone would do that and how they can be rich enough that that's their disposable income
There were Saudi princes. There were people of that kind
I mean it was a global game and so it attracted a lot of people who were interested in
Simulating what it felt like to be a king. There was one person who?
was rumored to have hired at least one person or a team of people to actually
purchase and open the packs because
It's actually mechanically a lot of work to open up
One million dollars worth of a hundred dollar packs, right? That's 10,000. That's 10,000 packs
So there's that there was another person who used to fly his entire
Alliance out to the Las Vegas to be closer to the servers so that they could do the Super Wonder event
more effectively
That's I mean
Hey, that's really weird
But B is it that much weirder than traders putting their computers right by their main exchange?
I don't know. I
Don't I suppose not. I mean these people really cared about the game that the I asked players
You know, why are you so interested in this game? And I remember one told me
I open the security guard at a place or something to that effect
And I just sat there all day and I downloaded this just to pass the time but over time I found that
I had like real actual friends in this game and
When I would log on they'd say oh my god this person's here and he felt like somebody
Whereas in real life, he did not really feel like someone and that that was important to him
Okay, I can see that
but okay, so
Curious game mechanics, but that's not why I want to talk to you
the shooting the the the thing that's
The reason I get into that is because you're there clearly in a background where there's serious amounts of data
coming in live and
Serious money it to be made in
Understanding the flow of that data certainly. Yep
Tell me about that and how it led into what you did next
sure, so
now this is an interesting story because it's sort of
Obliquely leads into what we actually ended up building
Because certainly my time at machines and inspired it
But it's not the way I would explain exactly what we're doing, but let me tell you I suppose the origin story so
While I was at machine zone
Always we wanted historical data, so we wanted to know not only this is the current power of this individual
Or this is the current set of items that they have
but
What is the full history of what they have so we can predict for example? Hey look?
This person was attacked they got zeroed out and now they left the game and they're not likely to come back
We always want to know that data and machines. I didn't have that data because the traditional
infrastructure of companies is
To have their game data or their really website data in normal
Relational databases like in this case. I believe it was my sequel right and the problem is
When you update someone's power in those databases
The old power goes away
So you need to have some kind of a way to actually get that historical data
And what they started to do was they were snapshotting their databases every 12 hours
and
We would then get that snapshot data and we tried to piece together a historical data
but that was very sad for two reasons the first reason is that the data itself was awful because
Lot can happen in 12 hours that could cause you to leave the game
Right, so you don't really have that information and I should also say there was another stream of data
Which was just event data, but it was very loosey-goosey event data that was sort of whatever people had slapped together
Right, so you tried to build up a picture of what had happened historically from these two sources and
The other reason the snapshotting data was bad was that
It was enormous because if you think about it
99% of the data in a database does not change in 12 hours if 99% of your players have churned
You're just copying this old data
Every 12 hours and so eventually they had to purge the old data so they couldn't keep it forever
and
They spent millions of dollars trying to clean up this data and get it to a form
We built a system which was on based on the lambda architecture
And if you're not familiar how the lambda architecture works
You send you set up a streaming part of your data data
Pipeline and you set up a sort of a batch part of your data pipeline and you try to weave those two together
So you might put
All of your big well-formed data in hive
Which is a a
Right append-only database made by Facebook
For large data and then you would have like something like flink or
Patchy spark taking your real-time data and trying to make decisions based on that and bringing it in with your batch process data as well
Yeah, it's a huge amount of work and I would say
95% of the data science was actually just getting the data into the right form in the right place at the right
Time yeah, that's a very familiar statement that spans way past gaming, right?
Absolutely, so when we began to build our own game
I decided I'm not gonna have it. We are going to have
The full history of the data so I want to be able to go back to any point in time and actually
See what the game state was but more than that
I want to actually be able to replay it at that time so that you could hop into the game at that time and actually see it being replayed
On that level of granularity on that level of granularity, right?
So you're not just storing events, but like player thumbstick movements and stuff correct, you know and actually I saw
On an earlier podcast that you had I think it was maybe two weeks ago. You're talking about event streaming
and
The guests there said at the end
You know, this doesn't always work for for everything
It doesn't work for example for games and I thought ha ha how wrong you are in fact. This is exactly what we're doing
So event sourcing is a is essentially what space-time to be does
Okay, that's
colossal amounts of data very widely distributed user base
high
Sponsed times required because you've got to deal with things 60 frames a second ideally
That's a big challenge
How do you start to break that down and so what's your approach?
Let me I think the best place to start is to first understand what the game is that we're trying to build and then
From that you can see why space-time to be is a necessary requirement. So we have two products
We have a game called bitcraft online, which is a
massively multiplayer online role-playing game
You can sort of think of it as like a combination between
Runescape if you're familiar with that and Minecraft. So there's this very long-term
Skilling and progression in the game, but at the same time you can actually change and edit the world
And build your own things within the world, right? So that's the game that we set out to build and
in order to do that
Notably the first thing you think is well, we need to put everybody in a single world logically because you can't have people
Occupying the same space in the way that you could in a normal MMORPG because they actually are editing the world
So if I was a normal MMORPG, I put many many instances all in the same city, right? It doesn't matter
Yeah
In our game, it certainly does because you actually need to do that
So now you have a very interesting distributed systems challenge on your hands. Yeah, you've got a large global mutatable state
Correct, and it has to be persistent. So if your servers crash people want to have their buildings that they spent their time building and stuff like that
Yeah
So that's that's the first thing you have to understand about how we came at this problem
And so in order to do that we realized okay, well, we need a system
Which is built around the persistence right because
If we're gonna be making these permanent changes to the world and it is everywhere either we're going to be
Doing the normal architecture of games which let's take a brief aside to explain so normal architecture is you'd have a game server
You'd have your databases the game server itself unlike a web server would have quite a bit of state
Right and you at period at periodic times or when people did important events would write to the database with a transaction
And then you get that back, but you as the developer are doing a lot of work to
Maintain I
Suppose synchronicity between your database and your game server state because for example if I
Kill an enemy
Yeah, there's a lot of there's a lot of things you can do that make things
Pretty crazy, but if I kill an enemy
that enemy is probably not
Their position is probably not stored in the database, but they that there was an enemy might be
Or that you picked up items probably is because if Susie enters your inventory, you don't want to lose that
Or you could do it periodically and then they could do replays and stuff
What you end up getting to is a place where you're spending a lot of your time as
The game developer not thinking about the actual gameplay programming and rather thinking about the distributed system
Environment in which you're actually building this game
Yeah, I can believe that
So what we decided to do is say we are gonna make that all I suppose opaque to the to the game developer
And we're gonna put them in a context where they're operating inside a transaction already
That transaction is going to be manipulating in-memory data
And then we are going to do all of the necessary things to persist that data to disk so that the
Gameplay programmer does not have to think about that at all
What's that look like for the programmer? Are they just
They're treating their local client side instances though. It's a relational database. Is this what you say?
That is one consequence, but then the main point of what I'm saying is that on the server
all things inside of
bitcraft happen
Within a database. So let me explain just a little bit about about how space time to be works and what it is actually
So we built this game and we wanted to do this in this way
So we built a system called space time to be which is fundamentally a database. So it's very focused on on persistence
The way it works is you take bitcraft you compile it to a web assembly module
You upload that into the database and then clients connect directly to the database
And now I hear a lot of people in the audience screaming. Oh, you can't do that
You couldn't do that and it maybe was a bad idea for databases like Postgres and so forth
but
We have built a permissions model around space time to be that allows you to do that safely and so
The way that works is
You as a client call what we call reducers on the database, they're very similar to store procedures
Okay, and then those store procedures which are written in whatever language you want that compiles the web assembly
Will access things from the database and write them back to the database. So just as an example
let's say we had player move and
Notably everything in bitcraft including all the player movement all the chat all the trees all the ground everything is stored within the database
So if we want to move a player what we do is we call a
Reducer called move player on the server that updates some rows in the database and then commits those rows and that's it
then
Clients other clients will subscribe to the database state. So they'll say I want to select star from
player position
Where they are near me basically would be what that word clause would say and then all connected clients that have subscribed to that
When that player moves we'll hear about those rows in their updates and then automatically updated in the database
I'm sorry on their local client
So hang on. Where is the database? The database is on a server stored in this case. I believe in New York
Okay, so how on earth does that possibly work when I'm moving and expecting things to update 60 times a second
So, okay, this is the first thing that's interesting about games
You would not have a tick rate on the server that's 60 times per second unless you were making a game like counter strike
So typically I'll give you sort of a range
Minecraft updates 20 times per second. So every 50 milliseconds
Runescape updates, I believe four times a second. So every quarter of a second. So it's
There's a variety of different levels that you can do
Generally speaking the larger your game is
Obviously the the fewer updates per second you want to be doing because there's so many entities to move within a within a time frame
Yeah, but I mean I'm in London. I'm not sure I can guarantee four frames a second to New York and back. I see so I
understand your question now
With any game like this you do not wait for the round trip. So
How long would the round trip be from New York to London I actually happen to know it's about 80 milliseconds or 70 milliseconds something
Okay, so it's it's actually not crazy
You can you can play it without what's called client side prediction
But the typical way that you would actually do this is you'd run client side prediction. What does that mean?
that means that I as a client have some subset of the server state and
When a player my player decides to do something I
Can predict what the server is going to do to my local state
Assuming that it will work. So based on the state of the world as I know it. Yeah, if I try to move I should be able to update my local state
Assuming the server will agree with me and so I will do that and then I will immediately see the results of that on my own local client
But I will send something to the server now if the server agrees. We basically come back. We reconcile
No problem. If the server disagrees, let's say somebody exploded a bomb that your client hadn't heard about yet, right?
right on top of you and
The thing you try to do is invalidated by that. Maybe you're dead now. Yeah, what will happen is
You will have sent a request to the server that says I want to move the server
Interjackson says actually you died
What will happen is your client will say oh
I understand it will roll back to the point at which you were going to move
And it will then play forward the updates as they actually happen from the server and then try to replay your move
So it would go
Originally before you heard about from the server it would go
You're standing here. You move you actually move then what happens is you hear about the bomb you roll back to the point at which you
Were about to move
You then blow up because of the bomb and then you find out then at that point you try to move
But you can't move because you're dead right and that's how that reconciles
This sounds very like transaction on the client side. Yes, it does. So is there a database on the client side?
Well, I believe basically everything is a database. I have a more I could talk about that
But essentially yes, although typically people don't think of it that way
So typically the way that people think about it
first of all in games is with a tick so
on the client you would have a
Frame essentially that happens. They would call it like a server frame if it's not the actual render frame
So the render frame always happens at 60 frames per second or sometimes now like 120 or 144
Whatever your monitor actually has yeah, a server frame typically doesn't go beyond 60 frames per second and
And
It assumes there's a loop and basically we're gonna update all the state once a frame
Space IDB actually doesn't make that assumption. You can do that with space IDB, but it's not a requirement
So I'll just say that and there's latency versus throughput trade-offs with that
That's essentially what that that will end up right because if you have something taking 60 frames a second the minimum latency that you can have is one
60th of one second
Because it could you could have the wrong time you could have tried to do something just as the frame was starting and now you have to wait the full frame time
Before you actually that effect is applied right. Yeah
So now yes, is the is the client a database what is happening on the client is
There's really two ways of doing it and so I want to be careful
In the one way of doing it the client has a
Deterministic simulation of the game world so that means that all of the inputs
That are that are going to manipulate the game state are being sent to the server and replicated out to the clients
those clients then receive that input and then they
Run the game forward a little bit like one frame
hmm, and they will find out what
Actually has changed in the game state and they move their state forward that requires having total knowledge of all of the state
Because if you don't have total knowledge, you're you're non-deterministic because you no longer know what you don't know
You don't know that that bomb might come in from from out outside and actually
Yeah, if you want total knowledge, you have to have the entire world so you can see events that might be coming over the horizon
metaphor this yes this type of
Server synchronization really only happens with
match-based games
so
Games with a sort of small state so like League of Legends that kind of thing
Or like RTS is kind of which is a sort of another match-based game
Where the inputs are quite simple, but the outputs are quite complex
So you might click here to move a group of guys
But 500 guys might move and so that's actually a lot of data to say where all the positions of them are
But you don't have to do that. You just have to replicate I clicked here or this player clicked here
And thus when I play my deterministic simulation forward all the guys will move within my simulation
I don't have to communicate that data over the network. Okay. Yeah, I can see that. So that's one way to do it
For MMOs part of the reason they're so difficult is you can't do that because I cannot possibly have the total state of the world
On my client. It's too big
Sort of fundamentally by by design
I can't put the whole of world of Warcraft and all its players on every single machine. Correct. Alas, you cannot so
instead what they do is
Typically the way this would work is you have your game server that game server knows what a game client is and when they connect
They know where the player is and they have a bunch of special logic to say, okay, I know what this player is
I know what they need. I'm gonna send down that data to the client
And then I'm gonna send down that data to the client
Let's say once a frame. So so every frame I will compute
Okay, what has changed on the server and I'm gonna send a bunch of messages down saying these are the new positions of all the players
That's the typical way of doing it now notably
This means that you have baked in
What your client wants to know about into your server code
Because you as the server need to know what they need to know because you're gonna do this streaming update to them
Yeah, so it's more complex than first for example, let's say a web site with a GraphQL query
Because with a GraphQL query you can say oh, I'm this client of client and I want to know all about this data
And I'm this kind of client. I want to know about this data
But because games are streaming and they need to go fast and they have this tick-based thing built into it
Historically people have built them so that
You write all the code for synchronizing the clients and you build in some concepts
Like you probably build in the concept of positions and of players and that players want to know about things that are around them and all of that good stuff
So if you were to then go build an AI that doesn't care about where certain players are maybe it's trying to regrow the trees or something
And it wants to listen to the data
No can do you've already built in the particular query that that wants to be done on that game server state
right, so
So we're inverting the controls so the server
The server knows what kind of things you would want and pushes those to you correct that really bakes in
Then the server then has to have very fixed ideas about what kind of people connect and what they might want to do
Absolutely, yeah, right
What space time do you does is the opposite we actually treat it sort of from a formal database perspective and say
Actually clients are just going to write queries which they're which are going to be executed with a query engine
In a subscription based streaming way so first
We connect and we send a query and we say I want to listen to all of these players in this
Region or whatever we are interested in and then that data will be
Incrementally streamed down so as the data changes in the database we compute that query for all the subscribe things and we send it down
To their clients then you can think of their clients as having a replica of
The server database now that replica is a subset of the data and it is only prefix consistent
So it's not strongly consistent
You would mean by prefix consistent
You have the database state as it existed at some point in time in the past
So you have all of the updates in a prefix of the message log if you are of the of the right-ahead log
Okay, up to a certain point. That's what I mean now. It's a subset. So it's not I have the whole database
I have some set of the data as it was in time. So it's not eventually consistent time. Yeah, correct
I don't see any weird things about it
I will see the database state as it was maybe like five milliseconds ago or if I'm far away a hundred milliseconds ago, right? Yeah
And so what that allows us to do is then you can query your local database as
Though it were the actual database and so you can get this this information out
from your local database
much
More conveniently and faster than you might otherwise do in a normal game server
You'll forgive me being really boring here, but I'm translating this into a non-gaming world and I can see I can imagine I
I I as a as a client of the second kind of a bank or a trading platform I
Might want to have all the data relating to my accounts and maybe some of my counterparties
but not the entire banks data and
then I want to be able to
Optimistically make transactions on that data they get sent back to the central server and I get told if that worked
But I can progress as though it did
Yes, and that would be exactly the same architecture. We're talking about in the gaming world 100% yes, so
What we are in sense trying to do is unify across both of those things a lot of people in why why is that important because?
Many people have tried to make a a game
Service game server back-end kind of thing like in like a game engine, but for the server, right?
So there's unity you've got unreal
Wouldn't it be nice if somebody made that for the back end?
the problem that people have is that
When you think about what a game is on the client, it's the same across all games if I'm playing chests or solid hair
What I want to do on the client is very similar to what I want to do in World of Warcraft, right?
Let's say I'm making a 3d solid hair, right?
I am rendering objects on a screen and all I have all of that stuff
It's all kind of the same across both both games, right? I want to render a 3d world
I want to loop that apply some logic to the state of that world
And then I want to yes, and I want to turn it into
3d objects and I want to project them onto a screen and I want to do lighting effects and I want to do
Sound effects and I want to do all of that every game from the client perspective is not identical
But they are they rhyme they have a lot in common that an engine could do that we don't have to write over and over and over again essentially
On the server if you think about what chess versus World of Warcraft is those architectures are
They share nothing. They're there. They might as well one is like a web app kind of right like a chess move. I
Could build that with a web server and no JS and all that and the other one is a very complex
Multi-user
Fast fast changing state thing which synchronizes data persistently the database and updates positions and all of that
So what we're trying to do in some sense with spacetime DB is close over all of those things
And you really have to go all the way back to the database for it to be general enough to actually apply to both of those scenarios
Yeah, okay, I can see that
Sounds like a colossal amount of work to do well though. It does
Nobody knows this better than than I do
I'll let me put it to you this way though with respect to that
When we decided we were gonna make bitcraft we were committed to making such a system
The fact that it's available as its own standalone thing is
Not really that much more work every MMO that you have ever
Seen has an architecture
which is at least as complicated as
spacetime DB and
I
Actually know that some of them I can't necessarily name them
Hmm
Operate in the same sort of stored procedure way because it's the sort of convergent evolution that they arrived at
But they just didn't formally call it a database
So we it's in some sense an easier problem because if you if you treat it as a database formally
You get to use all of the research and
Learnings that 50 years of database research has brought about
You do not have to reinvent the wheel is what I'm saying
on a lot of these things and so
We were always destined to create a system that's like this
As soon as we decided we wanted to actually create create this kind of thing
Okay, ours is I arguably just not sort of shoestring and duct tape not to
Disparage anyone else. It's very hard to build an MMORPG. But yeah, yeah, that's kind of how I would think about
Let's say rather than that. It's not an afterthought not an afterthought. Yes, correct
Okay, so
What we've got here is a system where I as the game programmer
Updating a row in a date someone moves the joystick up
I update the Y position of their players row in a database correct
Magic Clity that's going to be synchronized to the server without me worrying about it and
Throw back if it turned out it didn't work and then I just have a rendering function
That's also looking at my local database and
Draw the screen that is correct. Yes, that's essentially correct
Okay
Let's start with the first objection that's going to be too slow even
Even if you don't have to do the serve around the trip every time
So let me ask a follow-up question to your question
What specifically would be too slow because there's a little what I want to ascertain is
Exactly what you're talking about. There is a perception that databases are slow and may perhaps that's
What you're driving at I think because
Okay, it's got to be transactional
It's
Probably iterate once you get into things like all my bullets flying across the screen and hitting people
It's updating a considerable amount of data
And if collision detection it's got to happen a lot of times a second
I won't give you the number you can give it to me, but
that feels like
That feels like that's going to grind on a transactional database
Okay, so this is a great question and I understand where you're coming from
and
You had to we had to be a little bit crazy to think that this was a thing that should be done originally
But for several reasons which I'm about to outline
I think you will come to agree that actually that's completely possible and plausible to do within a database context
So the first thing I will draw your attention to is that we're not by no means the first to do things like this
In history there is a database called times 10 which was developed in the 90s
I thought it was bought out by Oracle wasn't it? It was bought out by Oracle, correct
Yeah, and it actually has a very similar architecture to space under the so couple of things one. It's fully in memory. So
The whole purpose of that database was that for certain very high throughput low latency applications
current databases weren't hacking it not even that currently
Server architectures weren't weren't hacking it. So what they decided to do is to
Have a database
Have in-memory state in that database
Put the logic of your program
physically within the same process as that database and then
Have you access the data within the same process?
So you're you're literally reaching into your current program memory
You're treating your program memory as though it were a database and then with they do is all the updates that data
They append in an append only fashion to a write-ahead log
Okay, and this was developed for like
telecom
processing like routing calls
These kinds of very very low latency high throughput things
Yeah, that's the almost identical architecture actually toe space time to be operates. We have just modernized it for
Use with web assembly and whatever language you would like and some nice things on top of that including
Subscribing to the database, which I don't believe times and actually provides that that information
Okay, but that's
That right-hand log
That's there we've got into persistence, which you said is important. Yes, isn't that a blocker to the performance?
not not typically so
first thing I would say is that
Appending to a write-ahead log is
Actually quite performant on modern hardware. So that's actually how Kafka works and it's how it's assumed to work
Right in Kafka is known as sort of a low latency streaming thing. It's not that low latency because of details
But it's relative to what a lot of people use very low latency
Yeah, okay. Yeah, the other thing that's important to know about Kafka and systems like that
Is that you can trade off?
throughput for latency so in the case of Kafka you can batch more things up
Which will cause the latency to increase but will cause a throughput to go up
You can always say I care about latency more than I care about throughput. So I will
Decrease it down to just one transaction. So that would make sense for I want a really high fast-paced game
Yeah, where I really want the lowest possible latency or you know, I don't really care if things come in late
So that's that's one thing. The next thing I would say is that for games
Or really any application
Choosing the level of durability that you want should be configuration and not code. So what I mean by that is I
ought to be able to decide that I want to listen to data that might not be persisted to disk
Because I don't actually care about that right for a player movement if they if my server crashes and they move back
10 feet
Don't really care about that if I'm running a bank transaction and it rolls back the last 10 seconds or whatever of
Bank transactions it could be a problem because I might have already they might have already given away the item that the guy bought, right?
Okay. Yeah. Yeah, is that so you when you say that's configuration. Are you configuring it on a per?
Object type basis. So could I make some match levels of
Persistency guarantees you actually configure it on a subscriber basis. So you would say hey, I'm gonna subscribe to this data and
for this particular subscription
I want to see the data as soon as it updates. I don't care if it's ready like I
Want to hear about so there's sort of levels at which you can listen in so there's a there's a pipeline of data that comes in
My message happens. I update the data that changes the stuff in memory
I write it to disk I replicate it to other machines all this and at any point in time you can decide like you know what?
It's good enough. I want to listen in here, right?
So I want to listen and after it's been updated memory versus I want to listen after it's been persisted disk versus
I want to listen only when it's read been replicated to five machines. That's a sort of a different level of
Listening if that makes sense. I'm jumping around trying to get my handle or my hands all over but okay
So how does that work programming? I
Let's say the score player score. Sure. It's gradually ticking up. It's not the end of the world if it maybe rolls back a little bit
Am I writing some code that just subscribes to the score changing and just renders that corner of the screen?
You certainly could do that
Typically what a client will do is they'll subscribe to all the data that they want right up front
So they'll say like let's say it's a match chess match
You'll say I want to subscribe to all the peace positions or I want to subscribe to it depends on how you program that match
But let's say you're gonna do it in a certain way
I'm gonna listen to all the peace positions and I want to subscribe to the score
You don't actually a lot of cases you can actually compute the score on the client based on the state of the game
But let's say you can't it for some reason in this game
You would subscribe to the score as well, and then that will be updated in a row and you'll just say from the score table
subscribe
Select off star from
Actually, okay, am I doing like a am I joining those data sets a select all from pieces union select all from score
Yes, so in this case you're you're going to basically
Select a subset of each server table. We do not yet support
Subscription joints
We do actually so we support
what's called a
semi-join, so
You may filter out rows from a table
Based on a joint from another table. So for example, I might want to subscribe to all players
Who's who are friends with this other person so I would write a join and
I could but I would always get the whole player row and
I'm not gonna get any like player plus other data
If you want to do that you would subscribe to the other table as well, and then we you know all those together and send them down
Okay, and are we writing this query in sequel sequel
Currently we there's no reason we can't also support other query languages like GraphQL in the future
It's just for right now for building an MMO RPG. We need sequel
Okay, so as a game programmer, I'm writing
Like you say very much like stored procedures that have a mixture of SQL and coding and like what's the language?
So the language is
The the module that you're writing is a web assembly module
So it's any language that you want that compiles to web assembly
notably
We support rust and C sharp in terms of building a library of nice things for you to use in those languages
in principle anybody else could
Do whatever language they want that compiles to web assembly?
But yeah, those are the two that we support right now. Okay, and I
I
Risk framing this all as objections, but I'm trying to think sure no no
There is it is an objectionable idea that happens to work and so it's it's
It's quite exciting. Okay, so the the other thing that people always complain about the store procedures
I mean a lot of people dislike store procedures and I think the reason is I
Think there's two reasons one is the language can be weird for store procedures personally
I reject that one if it's valuable enough, you'll learn the language the real one is management of store procedures is
It's a misery. Correct. Yes, it is and I think these are the so I would actually go a little bit further to the permissions model of
Store procedures at times can be
Arcane as well
so I
Believe it's really to your point
fundamentally a user experience problem
not a theoretical or
Technological problem if that makes sense. Yeah, it's like developer experience rather than this simply doesn't work
Yes, I mean why it's a if you actually think about store procedures as they were it's a nightmare
You have data that's in your database operating
That's opaque because somebody updated it, but you know, it's not in version control. You don't have any idea like yeah
What was running? Did somebody change it? Oh, it's like where is it stored? It's just a nightmare. Yeah
It's a great point
What I will say to this is actually we didn't set out to build the database in store procedures
What what actually happened is we built a system that had the the right UX for what we want our developers to have and
Then looked at it and said like oh from this angle. Actually, this is just a database with store procedures
So it was very much a we backed into it. We didn't arrive there
Right, so that's number one developer experience is the most important aspect of space time DB
And if it is bad, there's no point to doing it. That was why we created it in the first place
The way we solve these problems are number one is we put all of the store procedures
As like the the root of your database. It is all in a single module
That's based from a single repo in this case
That you can version in version control and then you can see the versions of it the thing I would
liken it to
from a developer experience perspective and now I'm going to say something that will
maybe trigger a lot of people but
is it's similar in principle to smart contracts, so
Okay, it's right. You you and nobody thinks the developer experience of those is bad except the fact that they have to deal with the blockchain
But ultimately the programming languages can be pretty terrible and the programming language can be pretty terrible
but fortunately we've solved both of those problems by removing the blockchain and
Making it so you can use whatever programming language you'd like, right?
And so but it's the same idea right you do not need a dev ops team to maintain or an operations team or any of that or
AWS credit or any of that to run your
Smart contract what you do is you say publish you said it you forget it you walk away like you don't have to deal with that ever again
It's running. Someone's running it for you. You really truly don't care
And that is the promise of the developer experience that I think we can provide with store procedures
And it's very easy in the case of smart contracts
To keep them in sync normally actually in a lot of systems you can't update your smart contracts
So that's one thing
But in our case you can you can update a space-time-due module
And it comes from a database and you can see the version that was up there and the version is stored in the log so
The fact that you're updating your whole database and you could do migrations within your
Module and you're doing the whole module at a time
Vastly vastly improves it then you have your the language that you want to work within which is a normal programming language
And then on top of that we have built a permissions model that allows you to
Have complex
logic
Which is easy to understand by the developer if that makes sense
Okay, let's go through the permissions thing for instance
If I've got access to subscribing to data from the server, I would very much like I wouldn't
Hypothetical black hat me would very much like to use it to cheat on the game
Absolutely, so I'm describing to other people's data. Okay, so first thing I'll note
all games
Of the first type that I described where they have a deterministic client and the replicating inputs
Must know about all data in those games so League of Legends you can cheat in fact
They have they're doing like a kernel extension to prevent people from cheating, but that's beside the point
They
Require you to see all data
So if you see fog of war in an RTS you could get data everything under that fog of war is there
You could remove the fog of war on your client and see all of the units so sad times so first of all they're they're just right out
They don't provide that to you at all
in our case
what you can do is
There's two types of permissions as there's sort of right permissions, and then there's read permissions, right?
So if you're
Want to update the database clients are only allowed to update the database through the module
And so what that will be is like let's say I wanted to move a player, but I try to
Move a player in a way that's illegal like I'm trying to go into this level this place where I need to be level 56
And I'm only level 50
What the server will do is it'll check the level of the player because you just writing the logic and you'll just fail the
Transaction, so you'll just say no you can't do that. We roll everything back, and we throw it away
All right, so that's the first thing the way that works is each client has an identifier, which is called the identity makes sense
It's kind of like an ethereum address if you want to liken it to something in that regard you can see who the person is
okay, and
Then you can say can that you do all the checks all the procedural checks you want in the whole world
Is this player friends with that or do they know each other?
Whatever it is and then fail the transaction if it's not allowed, so that's that's the right so right is super simple very very easy to do
From a read perspective
There's a couple layers that you can do so first of all what we implement today is private tables
so that's just hey this this table is only viewable by the owner of the of the
the module so based with the database creator and
We would like to add so we have not yet added because it's not yet
1.0
both
column permissions and then column read
Permissions and then row-level security so what that means is
You should be able to write a function inside of your module that says
Well in the case of column you're just going to annotate columns as being private right and that's that's pretty sure for
Row-level security that means like can this person see this row so if they subscribe to these players
Maybe this player is invisible and I shouldn't be able to see them right now, right?
So you want to be able to write a filter function on a table
So so a filter function that applies to a table that allows you to do arbitrary procedural logic
That basically says whether or not this player should be or this row in this table should be visible to this subscriber
So if I had like
Hypothetical card game of some kind where I have cards that only I can see cards that all my teammates can see and
Cards that the opponent can also see would I be able to model that you certainly would so you'd be able you'd what you'd do
Is you'd say let's say you just have one table called cards and you'd write a
Function that says this is the subscriber
Which is like this is the identity of the subscriber
Do you want to show this row or these batch of rows or however we end up ultimately implementing it for performance reasons?
And you would look through the row and you would say is this who is the owner of this card?
I am the owner of this card. I can see it. Oh
I'm not the owner of this card is the owner of this card my teammate
Okay, I can see it. I am you know and so forth and whatever. Yeah, that's logic you want
Okay, and I'm writing those functions in the same language in yes in Russ or whatever language
Okay, so so the language to define security rules is the general purpose language
The general purpose language and it's it's a procedural language. We know not going very fancy. Obviously you couldn't do you can do what for example?
Superbase does which is they have you write those row level security rules in
sequel
so we may also support that I'm not sure right now, but
Boy, it is a lot easier to write rust than some arcane sequel query about row level security. I'll tell you that okay, okay
Right, where does that leave us so?
Is my experience programming the server side similar to my experience program in the client side
Okay, this is a fantastic question
Let me tell you where we are today
And the the vision for where we want to be with with space MTV
so where we are today is
You write your server module that runs on the server. It's written in let's say rust
You write your client. We have a rust SDK and what that does is
Gives you a bunch of functions that you can use like
Subscribe function where you can pass in all your sequel queries and then you can get all the data back
The rust SDK currently stores that data internally
So it has this like data little mini database if you will like a little mini memory and you can query that data
The querying of that data is relatively rudimentary. It's based on
Code generation that we do so
Your module has a has a has a bunch of types right and a bunch of schemas and all that stuff
you can take a module and then you can
Extract the schema from that module and then you can code generate whatever type of clients you want
so for example
You can call a particular function from the client you can
Get the type the so if you have a rust module and a c-sharp client as we do
You can get the c-sharp equivalent type to the rust type on your client if that makes sense. Okay
Which is important because that's another thing with with store procedures is that like oh the type
Like you hopefully the types work because it's like dynamic. It's who knows. It's just crazy
The way they do things or you have to sort of like apply a type and you have to maintain the types we are
Code generating a lot of it's like protobuf, right? So you you have your schema
We scoop that out of your module
It's like a protobuf representation of your schema
You can then code generate on whatever client you want whatever types you need
So type script we support for right now type script python
Uh rust and c-sharp for clients
Okay
Yeah, but when I call those functions, they're still going to the local
space time tb
client instance, okay, so
They do and then they they get sent out to the server
We don't automatically do client-side prediction right now. That is something that for example in bitcraft. We have to replicate the
The uh logic of so if you move a player you have to move them fit like yourself
Is to rewrite the logic in c-sharp and then you have to write the logic in rust
That's typically how a lot of people do this these things and it is a huge pain
They duplicate the logic and they have to do this thing and it's a huge pain. Yeah
Some more clever people actually I know of some that are developing
An rts
Use web assembly and they
Run the the server both on the client and the server and they do that
And so that's ultimately where we'd like to go with this
So ultimately we want to run space and to be not only in the server
But also in the client and have them synchronized between each other automatically based on your subscriptions
And then you have a fully running
Um module so the same module that's running on the server is running on the client
And when you update when you do a call actually we run the actual server logic on your client
Update that and then that does the whole reconciliation. So you automatically get client-side prediction for free
I can see that really a pain. How far away do you think that is?
It's a good question. So in a sense, we're already doing it
on the
What we call space and to be cloud which is our cloud office. So we have okay. There are two versions of space and to be there's space
and to be
standalone which is the open source version that's
On github you can take a look at that everything that'll run like a single node
clustered
as though
it were
Your own personal instance of space and to be we also have cloud which is a distributed system
Which will run many machines in coordinate between them all
And the way we replicate from one to the other is sort of the normal way in which you would replicate
A client so they're all just clients of each other is an interesting thing
Right and that has a lot of implications for strong consistency, but I don't think we have time to get into that but either way
um
We're working towards that. I suppose on the server and then
Um, we will do that as soon as we can on the client. We're also building an mmorpg. So we're a little bit busy. So
Uh, I'm not sure exactly when that'll be but it is still useful in the way that it is right now
That is to say not automatically doing client side prediction
Um, but we will we will eventually do that. I envision world. So here's the secret. Here's the real secret to what space time to be is
Actually, it's not really a database at all
What it really is is a distributed operating system
In the spirit of plan 9 which has never
Sort of taken off. Let me explain. Okay
briefly so
Space time to be cloud as I mentioned runs over let's say 100 computers, right? So you've got this this thing that's running
From the outside it looks like just one instance of space time to be
So you can't really tell that it is made up of 100 computers
And what you're doing is you're taking a program and you're running it
on that distributed computer
So it looks again like a single
Computer um
And you're running a program on it and we're abstracting away the hardware boy. That does sound like an operating system, doesn't it?
um, and so
That is really ultimately where we'd like to go is is a is a place where
The cloud is not this collection of hardware and services that you have to piece together in this
grotesque fashion, but really
Um, it is just a giant computer
And you're going to take your program and you're going to run it on that giant computer and that's it
This is going to be even more blurred when you've got a series of clients connecting into that who are themselves similarly programmed
Correct. And so what you might say
is
That you're building a gigantic
distributed, um
operating system that the whole world runs on top of
right
You could you could say that if you were so bold
And I don't know that we are yet, but but one day perhaps we will so the idea would be that you're all operating on the same
Protocol uh to speak with each other and that you can't really even tell
I mean, there's a lot of details in in this one and to be quite honest. I haven't thought through all of it
But if everybody's speaking the same language, you have all of these modules subscribing to each other
It's just the actor model. You know what it is. It's very similar to Erlang, right? It's got the same kind of spirit
You've got these actors and they are sending messages to each other and they're listening to
Um messages that are being sent to them and they're updating their state and they're moving on so it's it's um
very much in that spirit
Okay, let me ask you this and you may not like this question
But I'm going to ask it anyway. Sure. If someone thought this is a great idea, but I'm not waiting for you to do it
I'm going to build this on Erlang myself. Sure. What parts would they be missing and what parts would they find hard?
Yeah, so the whole database part, right? So don't forget about that. So I've thought about this. Um
In a sense, so let's say you want to build this on Erlang. Cool. Uh, what is Erlang missing? Well, it's missing the persistence
I know they have persistent actors
but
The performance of that is key
The size of each actor is key. So within a space on db actor if you think about them as actors
We also do
Multiversion concurrency control
So that we can run
As many transactions as possible within one machine as sort of one actor as you might possibly be able to do, right?
So you want each actor to be as large as possible
Before you start going into other actors because as soon as you go into distributed systems, it's complicated
And you can do a lot with a single machine. It turns out
Although each actor could in principle be more than one machine, but that I digress that's another direction to go in down in the future
And then there's the whole relational model
So you need to build on top of Erlang the ability to
Do queries on the rows and get the actual row data out all of the type system stuff
You'd want to be able to run in whatever language you
You would like to because maybe
Your programmers are familiar with C sharp because they're unity developers and all that
Let's say also now. What about the subscriptions?
So actors in the Erlang model as I understand you can send messages to other clients
But that's kind of like the old way of doing it with the game servers where I need to know what this other actor wants to know
Or build a subscription system where they send me a message, which is their subscription and then I
Run the whole query engine and then I send them what they need to know
Which is what we have done. So you have to build that whole query subscription system up
From the ground as well. So good luck to you and I would love to see and use your system if you do that because
We wanted to make a game we
Yeah, we are doing this because we must
Okay, then um, perhaps we should wrap it up with the last two questions. If someone decides they don't want to do that
What state is space time db in for me as an as a user can I go and play with it?
You absolutely can so you can go to spacetimedb.com
You can play with the demo. It's right there
You can also
Very quickly go to our quick start guide install space time to be get a local instance of it running space time standalone
You can upload a module to that you can connect to that you can call functions on that
You can also upload to our test net. So our test net is a version of space time to be cloud
which is
relatively nascent
But it's meant for you to play around with what the cloud version will be. It's completely free
We give you sort of a a free amount of energy
And energy is sort of what powers these things. It's not actual energy to be clear. It's just points
Uh credit you can give it a ws credits. We give you a ws credits, right? Yeah
And you can go go to town on that
and then
Notably for the test net we reserve the right
monthly to
Wipe the data because we're still updating the abi
And we don't want to be locked in yet, but um early this year. So
We're trying for let's say april
To move into 1.0 and the main net so the main net of space time to be will be the
Version of space time to be where we guarantee that your data is going to be there forever
And it will be uh persisted and replicated and all that good stuff
And so um, you can begin building your applications now for a launch
post april
Okay, um, and this here's another dangerous question because there's only really one right answer
Is your game bitcraft going to be running on that test net on that main net?
Or it already is so we yes a hundred percent
And we are working on so a lot of our focus right now is getting the performance
To where it needs to be so bitcraft used to run on what we called jank time db
Which was like space underb, but it was the thing that we built first and it was not its own product
and
That works quite well
But it actually was more like the traditional old servers where the server knew what the client wanted
And it was relatively performant and we're now getting back to that point that
Right around now. We had the same performance of jank time db and now
As we gear up for the alpha which by the way sign up for the bitcraft alpha. It's happening
Early this year as well
Yes, and
We are getting to the point where we are at that performance level that we need for that alpha so that's like
Well, I don't want to I don't know how much I can say without upsetting the bitcraft team
But it's many more users than we had previously concurrently running in the game
Right, cool. Well, you've got a busy year busy few years coming up. We surely do we surely do awesome
Well, good luck with space time tb. I hope it takes off good luck with bitcraft
I hope that takes off and if they both take off you're going to invite me to your private yacht for a follow-up
I don't know that'll have one of those. I'll be too busy. Uh on the next part of space time to be so good luck
I need satellite from there
You'll be able to afford it if both of those work. I I guess so I guess so
Tyler thanks for joining us. Cheers. Thanks for having me
And that's all from tyler. Thank you very much
You know in among all the things we discussed in there
I think tyler must be something like our third guest to reference the plan nine operating system
And I don't know much about plan nine except it never took off
But it was a huge influence for a lot of people
I think we might have to have some kind of
retrospective what we could have learned as an industry episode on plan nine one day
So if you're a plan nine expert or if you know one
Please get in touch
And the way you get in touch is the same way you send us any feedback
My contact details are in the show notes. If you're on youtube, there's a comment box just down there
Spotify has a q&a thing for each episode these days and so on and so on check your app
On the subject of feedback and the future episodes if you enjoyed this episode
Please leave a like or a comment
If you think other people should find this podcast, please rate it or share it with a friend
And make sure you're subscribed because we're going to be back next week with more interesting voices from the software development world
Until then I've been your host chris jenkins. This has been developer voices with tyler clute here. Thanks for listening
You
