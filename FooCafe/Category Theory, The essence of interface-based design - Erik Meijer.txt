What we're going to do tonight is to celebrate, of course, the three-year anniversary of Foucaf√©.
And also, we're going to give a tribute to Joachim Lambeck, who is a kind of category
theorist that kind of made the connection between the lambda calculus and category theory.
And, funnily, his name kind of, you know, has the same prefix as the lambda calculus.
That isn't that a coincidence.
I don't know.
But anyway, so just in the spirit of deliberate and continuous learning, you know, like, who
here uses Java 8?
A few people.
Who here uses Java 6?
A few people as well.
So it has taken, like, many, many years before Java 6 became Java 8 and added lambdas.
Now, if the language designers would have practiced deliberate and continuous learning,
it would have happened, like, you know, decades ago.
Because all this knowledge was already developed by people like Lambeck.
And tonight, I'm going to tell you the tricks how you as a developer can tap into the brains
of mathematicians and kind of steal their ideas such that, you know, you can become
a better developer and then go to your boss and ask for more money.
Because you're an awesome developer.
All right.
Let's get started.
Oops.
So one of my guilty pleasures is I read language specifications.
So some of you kind of, you know, might read novels or newspapers, maybe I read language
specifications and for a while I was collecting them.
I had a whole bunch of, you know, going all the way back to, you know, the early Lisp,
1.0 manual, Pascal, everything.
So whenever there was a new language, I would read the language manual.
So I read all of them, Visual Basic, C-Sharp, ECMAScript, Swift, Dart, you name it.
But there's one language specification that even for me was too strong.
It was impossible to read.
And that language specification is Java 8.
Now I don't know, anyone has anyone here ever looked at the Java language specification?
Okay.
Did you fall asleep immediately?
I mean, you open up this thing and you fall asleep.
I mean, it's like, you try it, you know, some, you know, and you kind of cannot sleep at
night.
Your kind of mind is wandering.
Just open that thing up.
It will work better than any pill.
And this one in particular is really weird.
So when Java 8 came out, and there's this kind of weird thing with magic references,
so I thought, I really want to understand this.
So I started to read the language pack.
It doesn't, my goodness, it's just way too complicated.
So what do I do?
When something is complicated, I'm always listening to this guy.
This is Leslie Lamport, and he won the Turing Award last year.
Okay.
Well, if you win the Turing Award, well, that means something.
And one of the kind of advice that Lamport gives us is that we should kind of do more
math.
We should use more math.
If you're like a mechanical engineer, you build, or like a civil engineer, you build
a bridge or something, you use math, okay?
If you're a chemist, you use math.
But we as computer scientists seem to be afraid of mathematics.
And what Lamport says, and what I will tell you, is you shouldn't be afraid.
And I think a lot of people here, I don't know, maybe, you know, in Sweden, it's different.
You're not afraid of math, you know, you, instead of language specifications, you read
like books on calculus before you go to bed.
I'm pretty sure.
And typically, when I meet developers, they are kind of afraid of mathematics.
And I think there's several reasons for that, and those are good reasons.
First of all, in mathematics, most textbooks are really bad.
The notation is weird, it doesn't even type check, you know, if you're trying to kind
of, you know, look at it, it doesn't work.
The lingo is weird, they have all their own terms.
They often, you kind of end up in a rabbit hole, you know, you want to kind of know a
little bit, and before you know it, you know, you're kind of, you know, deep into all kind
of Greek symbols and other dirty pictures.
And last but not least, often mathematics is taught in a bottom up way, okay?
So you cannot say, I need to solve a particular problem, and I need a piece of mathematics
for that.
No, instead, they start bottom up.
So you have to first know a whole bunch of mathematics before, finally, you can apply
it to your problem.
Whereas with computing, we typically teach the other way around.
Who here has a computer science degree?
Okay.
I would say about half.
So the other people don't have a computer science degree, they still know how to program.
But they didn't start by studying, you know, big O, they didn't start to study a touring
machines.
No, they just opened up an editor and started to hack.
They did it top down.
And of course, at some point, you will feel that maybe you need a little bit more theory,
but programming is typically taught top down.
So you don't start with all the theory, but no, you start by solving a particular problem,
and then you go down.
Let me give you a really good example of that.
Linear algebra.
When most people teach linear algebra, they talk about matrices and then you have to multiply
matrices and then you have to kind of do all kind of mechanical, stupid things.
And then you use it to do graphics.
But you know, instead of knowing why you do it, you're kind of manipulating this kind
of low level representation.
Now if you know that a matrix, an m by n matrix is really the representation of a linear
function from a sequence of numbers of length n to a sequence of numbers of length m.
And matrix multiplication is function composition.
So really, when you're doing matrix manipulations, you're doing assembly language programming.
This is completely nonsense that we as humans have to do that.
If instead they would teach linear algebra as a restricted form of functional programming
with some special functions that are linear, which means that they have nice properties,
everything would be easy.
But these are the stupid mathematicians that are too smart for their own sake and they
teach it bottom up.
And then in the end, you know, we scratch our heads, I scratch my head way too often.
And then we ask ourselves, why is this useful?
All right.
So linear algebra is really easy.
It's just functional programming with linear functions.
Matrix multiplication is function composition done.
Same is true with category theory.
If you look at category theory, it looks scary, just like linear algebra, but it's
really easy.
So let's start looking at that.
So mathematicians often call, this is kind of weird, right?
Mathematicians that give us linear algebra, they look at category theory and say, this
is abstract nonsense.
And the reason that they say it's abstract nonsense is because in category theory, proofs
are done in a very abstract way.
So it's, look at what it says here.
It's the study of the general form of mathematical theories without regard to their content.
What that means is that all intuition is taken away.
And you look at the pure, you know, pure general form.
Well, as programmers, we recognize that because whenever we do, whenever we program against
an interface, that's exactly what we're doing.
We're programming against a thing without regard to their content.
We're not programming against a concrete type.
We're programming against the abstract interface.
And then there can be many concrete types that we can plug in, but the program is still
the same.
The other thing that's interesting is that here they talk about proofs.
So you build your proof on these kind of general theories.
Well, there's a very, very interesting thing.
It's called the Curry-Howard isomorphism.
People heard about the Curry-Howard isomorphism.
It's one of the most beautiful ideas I've ever seen.
So Curry-Howard isomorphism says that a type is a theorem and the program is the proof
for that theorem.
Now what means that whenever we're kind of writing code, we're really proving theorems.
So we are like mathematicians.
Or you can say, mathematicians are really developers, that program really, really slow.
Sometimes it takes them like two decades to kind of write a small proof.
But this Curry-Howard isomorphism is really beautiful.
I don't have time today to talk about it.
But if you take that a little bit further, that's what I'm going to do here, is that
you define your theorems in terms of these abstract structures.
And then you write your code in terms of them.
So you do your proofs in terms of them.
And so let's continue with that.
And as I said, this is really not foreign to, for us developers, because we do this all
the time.
We do this when we program against interfaces.
We do this when we use design patterns.
I'm pretty sure that most people have that book on their bookshelves.
And I'm also sure that nobody has ever read it.
Because when you read it, you get the feeling, what's going on?
This is all kind of, you know, how did the mathematicians say this?
This is without regard to any actual content, because these design patterns are very abstract
and you can instantiate them for specific purposes.
But that's the beauty of design patterns.
Now you can talk about concepts in a very abstract way, without kind of, you know, being
tied to a very concrete implementation, okay?
So that's, already I give you a couple of tricks, how to think like a mathematician
and profit from that.
Now, what is category theory?
Well, category theory is embarrassingly simple.
It has two, well, three concepts.
First of all, there's a notion of a category, but a category consists of objects and morphisms.
Now, as I said, mathematicians are weird people.
They use strange lingo.
So let's translate this into programming terminology.
So a category is really a programming language, okay?
And a programming language has types, okay?
Like in Java, there's types, Boolean, strings, lists, those are the types.
And then there are morphisms, well, that's just a fancy word for static method.
So morphism from A to B is just a static method that takes a argument of type A and
returns a value of type B or equivalently, you can say it's a property.
Now you can ask yourself, well, if you're saying that we're doing programming, why do
I use static methods?
Because we also have instance methods, well, we'll come back to that later.
So the whole point of this talk is to kind of, you know, fix this and make this precise.
So mix this notion precise that morphisms in a category are just static methods.
Now look at this.
This is, again, mathematicians.
I told you, they're slow programmers.
So here's an example of a programming language.
It's a programming language that has three types, A, B, and C.
So it's like characters, integers, and Booleans.
That's it.
And then, well, if you have three types, then you can define some functions between them.
So for example, I can go from Booleans to characters, and I can have a function from
characters to characters.
Now for these mathematicians, this is so special that they give this language a name, and it's
called bold three.
Okay, now imagine if you want to draw this kind of picture for Java, you know, it wouldn't
fit, you know, you would need all the walls here, and maybe the whole city with graffiti
like this.
Maybe it would look quite nice.
It's like an art project.
But this is kind of a mathematician.
So they are kind of proud that they understand this programming language with three types.
Okay, now, of course, once you have types, you can create other types.
And everybody these days seems to want to have tuples.
And Java doesn't have tuples, but there's many libraries that provide tuples.
Anybody here does Android programming?
A few people, no, what are you, a Windows phone, maybe?
No.
But if you do Android programming, you know, and even if you don't, this might be interesting
to know is that in the Android library, there is a type for tuples.
That's so important that even on your Android phone, you need tuples.
And here is some category theory that defines what tuples are in mathematician speak.
Now you will ask yourself, oh my goodness, where's my beer?
The next beer, this looks kind of horrible.
Okay, there's like all kind of weird stuff, commuting diagrams, canonical stuff.
I don't even understand this.
So let's take this Greek and let's try to translate this into a language that we all
understand.
Okay, so here's the first sentence of that definition of tuples.
And it says, let's see be a category with some objects X1 and X2.
Well, as I said, a category corresponds to a programming language and a object corresponds
to a type.
Now often people confuse objects and instances and whatever.
So let's not be confused.
So that's why I call them types and types have instances and whether you want to call
the instances objects or the type objects, I don't care.
So that's why I call them types.
And also then it doesn't clash with the objects in the category.
Okay, now what can I do when I have two types?
Well, I can form a tuple.
They don't call it tuples.
They call it a product, okay?
So they are going to take these two types X1 and X2.
They're going to create a new type X, which, you know, they can also write as X1 cross
X2 and then blah, blah satisfies a universal property, blah, blah, blah, blah, blah, blah.
Do you understand this?
No?
Yes?
Good.
There's one person that understands it, great.
So let's go and drill down a little bit into this because I think this picture said it
much better.
So if I have a tuple or a product, I have two functions that I can use to project the
values out of this tuple.
So I can select the first element and I can select the second one.
Now you can ask yourself, why do they start counting at one?
Because we as developers always, now our index is zero.
But again, these are mathematicians.
They probably never done C programming or whatever, so they can start their counting
by one.
Anyway, so this is the kind of thing, but then there's all the rest of this.
What we see here is, well, how on earth do you get an instance of a tuple?
Well, you need a constructor or a factory function.
These mathematicians are not stupid, right?
They know that when you create a type, when you have a type, you all you have to have
a way to create it.
We call it constructor, well, they have here some function that kind of allows you to kind
of create a tuple.
And then they say, well, if you have such a function, which you create from two morphisms,
then if you kind of start with the value here, you apply that to this function.
Now you get this guy.
That must be the same as kind of projecting the first value or applying this function.
So it all must kind of commute.
And that looks quite nice in that diagram.
Now if you don't like diagram, then you can translate it into equations, whatever you
find easier to read.
Now, except for this gentleman over there, what's your name?
Oh, I cannot pronounce that, but generic, good.
Mr. generic over there, he understands this.
That's kind of, you know, for the rest of us, you know, whose brains are the size of
peanuts or smaller, that's kind of, you know, continue to put this into our language.
So if we go on with this translation, we say that a type A, B is a product of A and B or
a tuple of A and B, if it satisfies blah, blah, blah, there exist two properties, underscore
one and underscore two, that return an A and a B respectively.
Any Scala programmers here?
You recognize this?
Yeah, look at this, I see a smile.
Yep.
So this is Scala.
You can project the first and second element.
But then there's also, if you have two methods, the factory function for this thing takes two
methods and it gives you a function that given a C returns this pair of A and B and
it does that by kind of applying that C to F and G respectively.
So this is a little bit different than in Scala because the constructor function behaves
a little bit different.
But we can, from this, we can create the normal constructor function too.
Okay, let's go look at this commuting diagram and it's kind of the same.
Now as I said, if you look at Scala, I don't know, I think this mathematics is actually
clearer and shorter.
Because look at this, trade, blah, blah, blah, extends, blah, blah, blah, blah, abstract
this, abstract that, curly, open, curly, close.
Now you see why these mathematicians have their strange lingo.
Because maybe we have editors and we have autocomplete, but look at how many characters
we need to write down kind of something simple like this, okay.
But here is you see that this is the definition in Scala of a product.
And I think this is, now you can ask yourself, what the heck are those pluses there?
Am I going to kind of, you know, is this, I don't know, is this unary plus or no, no,
no, that's co and contravariant.
But that's way too complicated.
But this is actually the way that products are defined in Scala.
But what Scala doesn't have is this operator to construct a product.
Now the reason why Martin cannot do that is because if you would do that, you would already
need the notion of functions as objects.
And that was the whole point of this presentation to figure out, you know, how can we make these
morphisms into first class things, okay.
So really, you know, if we look at this simple example where we took the idea of tuples and
we have seen how the mathematicians do it and we do it, it's really the same, except
that the mathematicians apply a little bit more rigor, they use weird notation.
But the nice thing that they do that we never do is when they define a type, they talk about
properties of the type, what properties should a product have?
Because if you look at this definition in Scala, right, from here it says nowhere that
when you create a tuple out of two values and you project from that tuple the first value
that you actually get the value that you put in there, right, nothing says this here.
It can return null for both sides and it's still kind of according to this type definition
a valid implementation of tuple.
Of course, you would not accept that, but the type itself doesn't say anything.
So if you're a smart programmer and somebody gives you this trait and you have to implement
it, you can just return null in both cases.
Nobody can complain.
If they file a bug, you immediately file the bug back and say you didn't specify this
thing properly.
This is another tip.
You just return null, your colleagues complain, you just say sorry, specify it better.
And then you can go have a drink, a beer, kind of go to another meeting, put that on
your resume, get even more money, look at this, all right, good.
And here is the, again, a slightly different way to do this function.
I'm going to skip this for lack of time.
Now Mr. Generic here says, oh, I knew this already, but this is old stuff, right?
Here is John McCarthy, the inventor of Lisp, and he says, well, come on, I could define
all this stuff with tuples and so on in 1960.
And then Church, Mr. Alonso Church, who invented the Lambda calculus, he did this already in
1928.
Now look, this guy here came up with this in 1928.
If you read the papers from Church, he was doing this kind of tuples.
In Java 8, it's 2015, last time I checked, there are still no proper tuples in the language.
Look at this, I don't even know, it's like 2015 minus, that's nearly a century, okay?
And we still don't, this thing still doesn't, we are, and why is that?
Because we are afraid of these mathematicians, whereas we should steal their ideas and profit
from them, okay?
That's really my message today.
These people are smart, look at the size of this brain here.
If I put my head next to it, it's like 10 times the size, we should leverage that.
But what do we do instead?
Well, first of all, we are proud that we don't do theory.
So if you look at C-sharp, C-sharp has delegates, and it's like, we don't need any of this theory,
we have delegates.
But where do these delegates come from?
What are their properties?
We don't know.
And then, I don't know if anybody is old enough, probably most of you were not born yet.
But when C-sharp came out, there was a little fight between C-sharp and Java, where the
Java folks said, we don't need any of this lambdas or delegates stuff because we have
virtual methods.
And so this is another lesson, never say never, okay?
Because I think, because they didn't want to lose face for the longest time, Java could
not add lambdas because, you know, James Gosling said in public that lambdas are unnecessary.
So then you're not going to kind of turn around and add them, no.
So first of all, he had to kind of retire, kind of join Google, join whatever company
is now at.
I think he's doing self-driving cars at Stanford.
And finally, they could put delegates lambdas into Java.
But the other thing is also, you should not kind of downplay and be arrogant and downplay
theory, okay?
You should always stay humble and hungry.
You always want to learn.
If these mathematicians come up with something, you know, but you better have a look at it
because maybe it's something that you can use.
All right.
But then you can say, come on, Eric, what are you talking about?
Mathematicians and categories represent mathematical objects, whereas we as developers, we deal
with objects that represents real world things, okay?
Like customers and orders and all kind of other boring things that we have to do in
our day jobs and rather not do, okay?
But that's also not true because most of our programs that we like to write, when we
don't have to do customers and orders, our data structures, list, trees, those don't
represent real world objects.
I've never seen a list.
I've seen trees in the real world, but they are not like the trees that I have in my
code, right?
And maybe lists a little bit, although, you know, the lists that I have on my refrigerator
never gets garbage collected.
They never get finished.
Whereas the lists in my computer always kind of, you know, end up kind of disappearing.
So, all right.
But anyway, I so I think that this whole idea that objects represent real world things is
nonsense because most objects that we deal with in programming don't represent real
world objects.
And the other thing is that what we can learn.
So what we can learn from these mathematicians is that we should be more careful in formalizing
the things that we deal with.
For example, if we write code in Java, we deal with methods, but these methods
themselves, you know, we don't have an object that represents them.
Is that true?
Well, that's what we're after, but I'll say something more about it later.
But the other thing that we can learn from the mathematicians is that we should also be
more careful that when we define a type that we think about the properties, because otherwise
some smart as colleagues of you can always return null and then claim that this is a proper
implementation, because you have not specified with that type what the properties are.
Okay.
And the good thing is that we don't have like weird terminology, although if you use UML and
all that stuff, I guess there's plenty of craziness there.
Um, now this is, I'm a big fan of Bertrand Meyer is not related because his last name
is with a Y and mine is with IJ.
Um, but he has a great saying where he says that, you know, objects don't really represent
real world things because you're always kind of removed.
Even if you have a person object, it doesn't really represent a person because it's something
in the memory of your computer that represents a person.
So you're all kind of ready twice removed from reality.
Okay.
So let's just forget about that and just look at objects and programming as formal things
just like mathematical objects.
All right.
Now I've been talking about programming.
I thought this was about category theory.
Um, now the thing before we go there is we do have a way to talk about methods as objects.
And that is with reflection.
Okay.
Because if you do reflection in Java, you can kind of, you know, go to a type gets his
methods and you can even invoke that method using reflection and reflection.
If you think about it is super complex because it's a program that can reason about itself.
Most of us are not even able to reason about ourselves.
You know, when we are acting foolishly in public after we've been kind of, you know,
partying, are we reflecting?
No, typically not.
Or maybe we do.
Um, sometimes, but with code, it's amazing that we can write code that kind of reflects
about itself and the mathematicians cannot do that.
Um, but reflection is kind of a cop out because with reflection, we're not really kind of having
an object that represents a method because it's kind of, you know, in the, in the kind
of, you know, dream world of reflection.
And what we're trying to do here with lambdas or with method references, we're trying to
represent methods as normal objects, not as reflective objects.
Oh, my goodness.
This has to come.
Okay.
Dave Thomas.
Small talk.
Did everybody knows Dave Thomas?
Okay.
Small talk guy.
Of course, what do small talk people say?
When I was a young boy and we were the small talk was still popular.
That was a long time ago.
Um, we already had blocks that blocks are things that represent.
Methods.
And that's quite remarkable, but because if you look at small talk, that is very much
has the flavor, this anthropomorphic flavor where objects represent real world things
where you send messages to it.
But still they already knew that they had to represent methods as objects themselves.
Okay.
But don't worry.
I won't talk about small talk.
Um, and the reason is that in small talk, like what we saw here in mathematics array
indexes start with one, which as a Dutch person is unacceptable because the big
extra dextra has told us that indexes should start at zero.
And you know the reason why?
Because when he is kind of, you know, that's why I'm kind of doing this papers.
The first paper, there are zero papers here.
So that's why it's zero.
And now the second paper.
Now it's two.
So you see that's how he can because he always wrote his, his papers by hand.
And so he counted like how many papers were already there.
Okay.
So now you know why you should be counting that with zero.
Okay.
Um, now let's kind of talk about why we are really here is how do we represent methods
as objects.
And again, category theorists have a fancy word for that.
They call it exponentials.
And then you can ask yourself, why do they call it exponentials?
Why don't they call it lambdas or anything normal?
Like in, in, in TypeScript, you know, arrow functions or I don't know blocks.
Well, there's actually a good reason.
But if we look at this, I don't know.
I see people already except for Mr. generic here.
He's like, yes.
This is like, you know, beautiful.
This is beautiful for the rest of us.
It looks a little bit like, look at this.
There's even now two diagrams here.
Okay.
But I see a lambda.
Can you see that here?
It's like, you know, the font is not so sharp, but there's a lambda.
We're in the right direction.
So let's decode the Greek and let's zoom in.
So it says, let C be a category with binary products.
So that's the reason why we started out with tuples, because in order to do
functions, we need them.
That was a little bit of the foresight of me and let Y and C be objects.
The exponential object Z to the power of Y.
Oh my goodness.
Why?
Why?
This is why they called exponentials because they write it as an exponent.
It's defined and blah, blah, blah.
And then there's a new word, functor.
Oh, I thought that we were ready because I kind of cheated by doing these
products first, but now we kind of have another hurdle here.
I have to explain to you what functors are.
But first, let me kind of explain a little bit why this notation of
exponentials makes sense.
And the reason is that if I have a function from a type Y to a type Z,
that there are Z to the power of Y possible functions.
So if I have two types, Y and Z, and I take all the functions from Y to Z,
then there are Z to the power of Y of them.
Now how can I remember that?
I see somebody here puzzled.
Now let's do the simplest case.
Let's say that Y, so this is a function from Y to Z.
So now let's take Y to be unit or void.
So there's only one value.
And let's take Z be booleans, true and false.
So how many functions are there from void to boolean?
Only two.
I can go from void to true and from void to false.
Now how many functions are there from booleans to unit?
Well, there's only one that maps true to unit and false to unit.
Those are mathematical functions.
Now you can say in Java, how many functions are there from bool to unit?
How many?
Because I can do print line of that boolean and that returns unit.
And kind of send it with an HTTP request to whatever, get it back.
That's another function.
I can do reflection over the boolean.
So there's many functions.
And this is why in Java a method, so I'm a little bit lying,
because a method of bool to unit is not really a function
because there can be side effects.
There's a lot of context that's hidden in Java that you can use as a programmer
to kind of cheat and don't show that, you know, that doesn't show up in the signature.
Now if you're, I don't know if there's any kind of, you know, fundamentalist,
functional programmers here, people that, crazy people that like Haskell,
no Haskell programmers here.
There's one Haskell programmer.
Now he's smiling.
He says, yeah, look at that.
And Haskell, this is true.
Not in your crappy Java, right?
Because in Haskell, Haskell functions are really mathematical functions.
So everything is explicit.
But, you know, that's why, you know, what is your name?
Oh my goodness, even more complicated than Mr. Generic.
Let me call you Mr. H.
Mr. H there.
His code is like probably 10 times longer than the Java code
by the time he's kind of done all his monads and whatever.
So, you know, again, maybe it's good to have him as a colleague
because then you can, you know, you can learn from him
and then write all this code implicitly.
And then he will say, oh, but I can do now my kind of monad transformer
with the state monad and the maybe monad and the list monad.
And by the time he has figured out how to compose all these monads,
you're already here at Foo Caf√© listening to your next talk
that you can put on your resume and you get ahead.
Isn't that great?
Okay, good.
Let's translate this into normal language.
Let L be a language that supports tuples.
Okay, that's already kind of a big step.
But let's assume that Java has tuples.
And let A and B types in the language, a function A arrow B,
I'm just using normal notation now, can be defined as a factory method
from the functor.
Okay, so we're nearly there.
But now I have to explain what a functor is because I've removed all the Greek
and I say there's a factory method for functions.
But in order to do that, I need to know what a functor is.
Now, what is a functor?
And again, this is why most of us hate mathematics so much
because I warned you that you often go into the rabbit hole.
Okay, and now we're going into the rabbit hole a little bit
because when you look up functor on Wikipedia, it's even more Greek.
Oh, my goodness.
Ah, does it ever stop?
Well, let's look at it and it's not that bad.
Let C be a category of functor, blah, blah, blah, blah, blah, blah.
Okay, let's translate this into normal English.
And now we simply understand it because since Java 6,
and when did Java get generics?
Was it Java 5?
Wow!
Okay, that's a long time ago.
The way they did it, yes.
So here, a functor is a generic type that associates with each type A,
a new type, C of A.
So list of T is a functor because I can instantiate it with another type,
say integer, because generics in Java suck,
that you can only instantiate them with reference types and not with base types.
But yes, and then on that type, there must be a function map
that goes from C of A to C of B.
Now think about this.
What does this thing do?
It says that if I go, if I can go, say from integers to string,
because I have two string, right, that goes from integers to string.
Now if I have a list of integers, I must be able to kind of, you know,
do two string on every element of that list.
And that's all what this thing is saying,
that if I can go from int to string,
then I must go from list of int to list of string.
That's quite reasonable, right?
But when we define generics, so again, here's a trick.
Whenever your colleague defines a generic type,
probably they don't specify that this should hold,
that if you have, if you instantiate that generic type with one type,
you instantiate with another that you have to be able to go between them.
Well, they should have a map function.
Now the thing with this map function is that it should have some properties too.
Say that, you know, I'm going from list of int to list of int.
Well, how do I do that?
By doing the identity function.
I'm doing nothing on each element.
So that should be delivered the same value, right?
That is kind of reasonable.
The other thing is that if I do a map and then another map,
that must be the same as doing the map with these functions combined, okay?
And this is like an optimization trick,
because instead of taking a list of int,
going into a list of string and then say taking the length of the string,
and now getting a list of int again,
I don't have to build that intermediate list,
because then I can just map this function over that list.
So these category theorists also are efficiency freaks,
because they say that this map must have these properties
so that they can optimize their code, okay?
So a functor is just a generic function that has a map operator.
Now, in normal Java generics,
most functions, most types, most generic types,
don't come with a map.
Finally, in Java 8, when they introduce streams,
streams have a map function.
You can go check now.
If you Google Java 8 streams,
you will see there's a map function.
So finally, after like decades and decades,
sorry, 20 years of Java,
and finally, you know, they have map,
whereas if they would have listened to the mathematicians,
when they designed generics,
that should have been built in,
because, you know, that gives you again,
that is this thing where, you know,
a type doesn't come by itself,
it comes with properties that it should satisfy.
Okay, hey, great.
Now we know what a functor is.
Now, the other thing, if, you know,
if there's category tier is here in the room,
I have to be a little bit careful,
because what I said is a category was a programming language,
and a functor is really something
that kind of goes between two categories.
So a functor can go between two programming languages.
For example, if you have a Java array
and a small talk array,
then one starts indexing at zero,
the other start indexing at one,
and now say that I have a method on arrays
that sums up the values,
when I go from Java to small talk,
I have to adjust that sum function
to start kind of indexing at one.
Okay, that's another example of a functor.
But for today, we're only looking at endo functors.
Ah, doesn't that sound cool?
Endo functors.
But an endo functor just means
that it stays within one language.
It doesn't go between two languages.
Okay, good.
So this is the Greek decoded.
Now I've cheated a little bit already,
because in here,
you will see when I defined map,
I already used the fact
that I have a function that I can pass into map,
and before Java 8,
you couldn't do that, right?
Because there were no functions up there,
there were no lambdas,
so you could not even define map.
So we had to wait until Java 8
in order to have functions
such that we can define map.
But we're not there yet,
because we were trying to kind of come up
with how do I represent methods
as first-class objects,
how do I do lambdas?
Okay, and lambback reminds me
Eric, yes.
That's what exponentials are for.
Okay, let's go there.
Okay, here was the Greek.
Okay, blah, blah, blah.
There's this object.
There's a morphism eval.
Blah, blah, blah, blah.
Okay, now then this diagram
has to commute,
and there we see our lambda.
So we're getting close.
So let's turn this into reality.
And of course,
Church, or this is Haskell B. Curry,
will say, oh, but this is currying in Haskell.
If you look here, you know,
what this is doing here,
this gold eval, blah, blah, blah,
that's just currying.
And Mr. H. has seen this already,
and he thought, yeah,
when did I start doing Haskell in 1986
when Haskell won't come out?
I already did currying,
and all you Java guys can only do it in Java 8.
And most of you,
oh, most of you were on Java 8.
This is very progressive,
because I know a lot of companies
that are still doing Java 6,
most of the time.
Okay, now here's,
you're not Danish.
I'll go to insult you.
But here is Mr. C++.
And he's a smart guy,
because in 1979,
somewhere, you know,
you can find that on the web,
he explained that there are no instance methods.
Okay?
An instance method is just a static method
that takes the dispointer as an additional argument.
He said, remember that in the beginning,
I said, we're only looking at morphisms,
aesthetic methods.
I'm going to ignore instance methods.
It's because Bjarne told me so.
Bjarne told me it's safe to ignore instance methods.
So an instance method is just a morphism
from the tuple of the disparameter
and returns a value.
Okay, so that's where the tuples come in.
And guess what?
Even C++ is lambdas these days.
Isn't this amazing?
I don't think there's any kind of programming languages
out there anymore
that we all use that don't have lambdas.
But it took many, many decades.
And why is that?
Because we didn't listen to the mathematicians.
All right.
Now, it might be the case that in C++
that Bjarne says there are no instance methods.
But let's check what Java has to say.
So if you want to have an even more boring document
than the Java language specification,
you should read the Java virtual machine specification.
Okay.
But in the Java virtual machine specification,
if you browse around a little bit,
and that says when you call a class method
or an instance method here, local variable zero,
they start to count at zero.
Good boys.
Okay.
It's always passed to an object that represents the instance.
Okay.
Any subsequent parameters are passed
in subsequent local variables starting at one.
So also in Java, there are no instance methods.
It's just a static method where the first parameter
with index zero is the disk.
Okay.
So we can simply forget about instance methods.
Now, of course, there are a little bit things
that I kind of put under the carpet.
There's no carpet here,
but imagine there was a carpet.
It's things like inheritance and so on.
So inheritance is an interesting thing
because inheritance is quite useful,
although some crazy people say we shouldn't use inheritance.
We should use composition.
If you have any colleagues that say that,
make them look bad and have them fired
because they are making your life miserable
because inheritance is a good thing.
But the thing with inheritance is that usually
it's explained in terms of the implementation.
You start to talk about V tables and whatever.
And the reason is because inheritance is a dirty
implementation trick to make it easier to reuse code
and to model inheritance mathematically is not easy.
And people write PhD thesis about it.
William Cook, maybe you know him,
wrote his PhD thesis about the semantics of inheritance.
So I'm not going to talk about that today.
Okay.
But let's continue decoding the Greek.
And now we are somewhere where we can understand
what's going on.
So just to remind you,
here's the category theory with the strange notation
with the kind of exponentials.
And there was this lambda, blah, blah, blah.
I didn't even bother to go through that
because everybody would fall asleep
after a few hot dogs and hamburgers.
But now we are something that we can understand.
So here, a function type here,
together with a method apply,
is a function.
We call that a function type.
If given any type A and a method M,
that takes an argument of type B and returns a C,
defined on A, and remember that if I have a method
that's defined on A,
it's really that M has type A as the first argument
and B as the second argument.
Okay.
Now what we can do is there's a factory method
that takes an A,
and that factory method looks like colon, colon M,
and it returns a function from B to C,
and that function object itself has an apply method
such that when I apply that to B,
that is the same as calling M on A and passing it B.
And then here I just cast to C
so that you can show that it's the same.
Okay.
So anybody here has used method reference in Java.
If you use IntelliJ, it will tell you all the time, right?
You write something and it says,
I can refactor this into a method reference.
Do you use that?
Anybody here uses IntelliJ?
What is your name?
Paul?
Ah, finally a name I can pronounce.
Paul, do you ever use the refactor
change into method reference?
Yes.
And do you recognize this kind of double colon crazy thing?
So you have been using exponential objects.
Did you realize that?
So now you can go to your boss and say,
in full cafe, I learned that I'm freaking using exponential objects
from category theory in my coding.
I need a race because that son of a bitch next to me
has no clue what they're doing.
They're still using whatever virtual methods,
but I know exponential objects.
Good.
But it's amazing.
Function references, method references.
In Java are exactly the same as exponential objects
in category theory, because the only thing I've done here
is translate the Greek into Java code, right?
So why did it take so long?
They could have sat down, done the same thing as I did,
came up with this, said, hey, dude,
let's hire somebody to implement this in the compiler
and we're done.
But I must say I find this pretty amazing,
because I'm 100% sure that the Java language designers
had no idea of category theory,
but yet they came up with exactly the same solution.
That is the amazing thing.
So there must be some universal truth here
because otherwise you would not two completely independent
people, one from theory, one from practice,
come up with the same idea.
So if you look at here, if I have a method reference
and I call the apply method on that with argument of type B,
that is the same as calling the method M on A, passing it B.
That is how method references work.
This is how category theory works.
This is how exponential objects work.
Isn't this, I mean, this is a miracle.
I don't know about you, but when I discovered this,
I don't know, I drank a whole bottle of this stuff.
I mean, I don't know what this is.
This is rum.
I drank a neighbor.
That's the Dutch vodka.
But this is great.
Now you can say, great, we now know that method references
are exponential objects.
So tomorrow when you go back to work,
you're saying let's introduce some exponentials
and IntelliJ can help us with that.
No, don't say that.
We're going to use that.
But here's Eric Meyer and he has not mentioned the M word yet.
I have not mentioned monads yet.
So I'm going to do a little bit.
Yes, now I have before as well.
When I was talking about Haskell, yes, that's true,
but it was more like a joke.
Now, let's look at this thing.
So if you look at this exponential object, blah, blah, blah,
there's a right adjoint and there's home sets.
Now home sets have nothing to do with fish eggs.
I don't know, is that the same in Swedish?
Home in Dutch, that's kind of the eggs of a fish, like caviar.
This has nothing to do with caviar.
It just says that if I have a function from X to Y to Z,
that is kind of isomorphic to having a function
that takes X and Y and returns Z.
So this is really saying that you can curry and uncurry
and go in two directions.
And a home set, home A, B, is just a fancy way of saying
all morphisms from A to B.
So this is just a fancy thing.
And the magic of method references is really what it's saying.
It's saying that there's an isomorphism between the lambda expression
B arrow A method reference B and this method call here.
So there's nothing kind of really fancy about this.
And then, you know, we can kind of talk about adjoins
because that was the other thing in there.
So an adjoint, I have to have two functors.
And in our case, it's this.
And to really prove that I'm not talking nonsense, you know,
here's some real code that actually executes if you use Scala.
But now, here's the thing, that if you have two of these adjoint functors
and these are the conversions between them,
that gives rise to a monad.
So we came from exponential objects.
There came this notion of adjoint functors.
And once you have adjoint functors, you get monads.
So there's no escape from the monads.
So in the end, everybody will be like Mr. H.
Because, you know, now that Java 8 has exponentials,
the next thing it will have are monads.
Because that's what category theory predicts.
And I went through this real quick.
But I tell you, 10 years from now, 20 years from now,
this will be the case.
Java will have monads because monads are related to adjunctions
and adjunctions come from exponentials.
Now, the funny thing is that the state monad comes from this adjunction there.
But that's a topic for a different talk.
So here's the next thing.
When you have a lot of beer tonight, this will be your next tattoo.
Okay, category theory here directly corresponds to Java.
And if this is like, you know, a little bit too dark for you,
what about this one?
This one looks cute, right?
And I made a special deal with Liz Tattoo Parlor,
where if you show your Foucaffet t-shirt,
you will get a discount on any of those two tattoos.
Thank you very much.
