Wow, let's see. It recognizes me even with this fancy mic on. So, Windows Hello, yay.
Doesn't it? Or did it just like turn off? It wants, no it didn't. It wants a pin. At
least it's not showing you my pin. There we go. Okay. This is my intro slide. My name
is Maes Torgerson, or Maes Torgerson, or Maes Torgerson or something like that. I don't know
we didn't friends out there are going to kill me. They're going to take a blue sharpie to
that one after. So, I work on the C sharp language every day for Microsoft. It's a great
job. I wish you could all have it, but it's mine. So, and I've done that for a very long
time. And so that means I remember things that nobody else remembers almost, except
for Anders who was there from the beginning. I was not. I was a latecomer. I've only been
there for 17 years. But it is an old language. We are now working on C sharp 11. And there's
a whole another talk about C sharp 11 a little later today. So, I decided I want to talk
about C sharp 1 through 10 today. It's from the angle of how has functional programming
influenced C sharp over the years. And I'm hoping that's interesting to you, otherwise
that's a lot of people I'll be disappointing today because it's a very full room. I don't
know how many are out there, but you can still run without me noticing unlike these people
in here. So, I think it's interesting because C sharp started out as a fairly typical of
its age, fairly straightforward object going to imperative programming language. That was
how it started. They didn't kind of just pull that out of the blue, of course. There were
other languages around at the time that were similar. That C sharp might happen to look
a little like by accident. But that was sort of like the game of the day. So, C sharp was
typical of the day and kind of pretty much took almost all the functional things in along
the way as they became relevant to how we do programming. So, I'm going to go through
that same evolution essentially today and point out some of the different ways. I'll
try to make some general points about programming language paradigms and so on along the way.
But it's all going to be a little bit, I'm going to do it all in Visual Studio. I'm just
going to code along. And I forgot to print out my demo notes. So, may I go astray? It'll be a
little bit of a one-off. We do have an hour, which means that there's time for a few questions
along the way, not like a million. But I don't want you to say, oh, I want to ask a question
about that when he's done talking. Because by then, the code will look different. Nobody
will remember what I was talking about. So, if you have a question, raise your hand and ask it,
and I'll try to keep us on track. And hopefully, I'll succeed. And that might mean that I will
have to be a little rude and say, sorry, no more questions, come back after. So, just don't be
offended when I get to there. But until then, please just raise a question and ask. So, with that,
without much further ado, let's start out with C sharp one and just kind of, for those of us
who were around, remind ourselves of the state of the art of programming, at least in the industrial
space in around the year 2000. And for those of you who weren't around, you can just go,
thank God I wasn't around. I mean, you were probably around most of you, but maybe you were
like still doing Legos, aren't we all really? So, what I have here is a fairly simple,
it's a C sharp one program. I'm cheating a little bit because when it comes to features that aren't
part of this talk, that aren't functional, I'm just going to use them a little bit anyway. For
instance, my code is not in a main method. You don't need to do that anymore in C sharp. And
if it fits better on a screen, if I don't. So, I'm not going to stick religiously to
only C sharp one features. But in terms of functionality, I am. So, one thing to,
talking about functional, C sharp started out with just a tiny little hint of,
tiny little concession to functional programming languages compared to other
languages at the time. And with something that they slash we call delegates,
which is sort of kind of like a function type. They were actually part of some of the,
they were, the need for delegates was part of the reason why we couldn't do some other
programming languages and got dragged into court and stuff. So, C sharp back then already had
like a notion of a function type called delegate. And those are still the ones that we use for
function types. They're flawed in various ways, but you know, once you got something
throughout the whole core libraries and so on, you don't go on and change it. So,
delegate types were function types. It's like, you know, this is the type of a function that
takes an int and returns a bool. And it's a name type like a class. It is in fact a class.
And we call it predicate. And now we can use it as a function type. So, I can have a method here
or a function that takes, takes a predicate. And it can call the predicate as the, you know,
according to the function type. But, and when I want to pass an argument to it, well, we don't
have anything like lambdas yet that we're going to get to that. We don't have like anonymous
functions of any kind, but we do have, we, but you can sort of just mention a function that happens
to have the right signature like great than five. Hang on a second. Is it going to be like this
all the way? How many, how many typos are we going to have in here? There we go. I did get the word
this morning. So, I'm not like totally, there we go. So, you kind of have to declare a function,
then pass it. You have to declare the function type, then use it. Like it's all very nominal and
declarative at this point. But it gets the job done. Like pass the predicate in. Of course,
there's no such thing as generics yet. They're the first thing we're going to learn from functional
programming languages in a minute. So, you know, this was the name of the game. In order to filter
this, I need to gather up the results. The only, like I really wanted to return an array because
that's the only generic type I have. It's the only type that actually has an element type. So,
that's, so you kind of, you kind of encourage to trade in arrays, horrible as that is, because
otherwise you have no type safety. But we do have other collections. They just all over object. So,
and, and I need to create one of those to gather up my elements because I don't know how many are
going to succeed yet. I don't know what size of the array to allocate. So, first I gather them up,
then, you know, I know how many I have, then I can allocate an array that's strongly typed to int,
then I have to stick all the elements that I found into the array. And as I'm doing so, I have to cast
them to int because I know they're all ints, but the Kamayla has no idea. It's like you stuck,
you get, you give me a bunch of stuff, you're taking them out. All I can see is object.
So, you know, you die a little inside every time you have to cast things coming out of
collections. How many people in here remember that from like either C sharp or some other like Java or
yeah, ouch, yeah. So, what I think what we very quickly felt all of us was, and with C sharp,
it was already like coming to version two, which we're coming to version two now.
We felt like, okay, this is not, this is not like a satisfactory state of affairs.
It's not the abstraction capabilities aren't good enough here.
There's some other languages that had been around for longer. It took them a little longer to get
to that point. So, it ended up that, for instance, Java and C sharp got generics, which is where we
coming to now at about around the same time. And I was actually back then, I was on the other side
of the fence helping out with generics and Java. So, I saw it from the other side. I still think
Microsoft and C sharp did it better. So, and this really comes down to sort of one of the
fundamental differences between functional and object-oriented programming. In classic
imperative programming, there really is no polymorphism. There's no way that you can write code
that applies to more than one type. Object-oriented programming and functional
programming to a large degree are two different answers. At least when they're typed, they're
two different answers to how do you get polymorphism? How do you write code that works for more than
one kind of thing? In object-oriented programming, we went with what's often called subtype polymorphism,
which means everything is a subtype of something that's a subtype of something that all goes back
up to object. So, that's what we're seeing here. Now you can write a collection like ArrayList here
that can contain anything. So, there's polymorphism in that sense. And the great thing about
subtype polymorphism is it's very easy to have heterogeneous collections, for instance. You
can put, like, all kinds of things in the same collection. As opposed to functional programming,
they went with what's called parametric polymorphism, where you have an extra type parameter on
things that, you know, sort of like a placeholder for one type. So, you don't get to mix and match
the types inside. You get to say that there's this one type that I'm going to give you later,
and then it'll work for that type only. But it's still polymorphic, because you can give different
type arguments in different places. And that has the benefit that you can, because that type
parameter has a name, you can have things sync up so that the same type name, the same type
parameter appears in multiple places, and you can sort of say, well, the same, whatever it is,
the same kind of thing that comes in is the kind of thing that comes out, for instance, which is
exactly what we need here. We need a collection, for instance, that has the same stuff coming in
that's coming out. Enter generics, which is parametric polymorphism. Most object-oriented
programming languages with types at this point say, okay, let's embrace that too, so we have both kinds
in the language. So that's sort of one of the first big imports from the functional space.
So let's do that. Now, let's see, where do we start?
Now we can have, well, instead of ArrayList here, we could now use the new fancy generic
collections that we have. I'm cheating and having the imports in another file, so either
using so you don't have to bother with that. So we can say list of int here instead is a new list of int.
And now, as I'm gathering things up, it should be graying out this. I know that my
destination here is actually a list of int and not just a list of whatever,
and so I can now get rid of this cast of death. Okay. Back in business. Somebody wrote a generic
collection for us. We can use it. But, of course, now, there are other, I can write generic things,
too. Maybe I want my predicate type to be more general. Maybe I don't actually want to write
new delegate types for everything all the time, so maybe we could say predicate of t and have it
work for all t's and not just for ints. It still returns a bool, but I now have a generic predicate
type. And I can then here say, well, actually here it's a predicate of int that I want. And boom,
things don't work. Or we could actually go a step further and say, well, filtering isn't really
particularly about ints, is it? And now we can write our own generic function, a method,
that is a filter of t, and now we get to, say, t in all the places. It's actually a predicate of t
coming in and an array of t, and I'm returning an array of t, and in all the other places where it
says int except one, so you have to be a little careful. Here, here, here, here. Where else?
The int result, of course. And, you know, so now I've completely
generified the thing, and this is the int I shouldn't replace, because that's the counter for the,
you know, filling out the array. So that's why I didn't just do a search replace here.
So there we go. Now we, all of a sudden, we've generified a thing. It's fully strongly typed,
as if it was for a specific type, but now you can apply it everywhere. And a full, like,
generification is a strong, strong tool. And there were some, like, choices made in the different
languages at the time that actually were imbued with destiny, even much more than we realized at
the time. In Java, we, I was over here, in the Java side, sorry, camera person. We decided we
couldn't change the JVM that was runtime under Java, because it was, you know, too entrenched,
and how you couldn't control, like, what Java runtime they had out there. So all the generics
in Java was done in the compiler by erasure, which means, you know, there wasn't any generics at
runtime. It was just there in the code for as much type checking as you could get. But that
meant that there were some things, like reflection and so on, that didn't embrace it. And there
were certain holes in the experience, essentially. And whereas in .NET and C Sharp, we went all out
and said, yes, generics goes into the runtime and is shared across all the languages at target.net,
and it's a real runtime thing. Question. So, to repeat the question for the mic,
when did we know that we wanted generics in C Sharp? So, I wasn't there, but I kind of was,
because in 99, I was an intern, I was doing my PhD, I was an intern at Microsoft Research,
Cambridge, which is where Don Simon is, if anybody's heard of him, the father of F Sharp.
And there were a bunch of language people there. So I got actually to be privy to decisions that
were secret for a number of years, and I was under NDA until things came out. And they were
already talking about .NET, they weren't calling it that at the time, and they were already talking
about generics for it, and decisions were made that it would take too long to make it work right,
and we should have a version without it first. So, yeah, that answers your question precisely.
So it was always felt that we're going to need to do this. And indeed, generics was
pretty much the almost the only and last thing, language feature that was added to the runtime
for a very long time, because after that, .NET became popular, it was Windows component,
and so we had the same problem as Java, as the one causing Java to not do it in the runtime,
which was too many people have it installed, we don't know which version of Windows they have,
we have no way of making sure that they have the right runtime features that we are compiling for,
so we stopped doing language features in the runtime after that for a very, very long time.
Now we're doing it again, and we might get to one at the end. So that's generics,
and let's see if I can get back on track here. So, well, that's not generics,
that's not all there is to say about generics, because once you get these very lovely
generic collections, for instance, they can have smarter methods as well,
they can have generic methods. So instead of doing this, building this result array myself,
I could just actually take that DST thing and just call to array on it,
because now it knows its element type, and you can build an array of the right
type, namely T. You also notice, so which means I can delete these two lines of code,
I don't need that anymore. So many more utilities now, strongly typed utilities become available,
and one last thing to notice is that when I'm calling the generic method here,
I'm not passing a type argument. You need to pass a type argument to generic types,
but not to generic methods, and that, again, is a thing that type inference is something that we
start stealing from functional programming languages. We can't do as much type inference
in object-oriented programming languages as you can in a functional language because of the
subtype polymorphism. It means that you can't actually, there are many places where you can't
know the exact type, where you could if you didn't have subtype polymorphism. So we can't go all out
on type inference, which is probably all the same because it's confusing to a lot of people,
and it's a quiet taste. So we kind of, we have to strike a balance there, but it certainly makes
sense here. So with that lovely generics, we can also get out of this addiction to arrays as kind
of like the currency of collections being passed around, because arrays are, you know,
the very low-level fixed size, they expose too much. They're unsafe in various ways because
you pass your array to someone and they're messing with it while you're watching it somewhere else,
and you know, that's just, you know, nasty. So we can start having other interfaces, for instance,
that are, that are more suitable. So innumerable of T is a good one. I can return innumerable of T
as well here. And, and I don't even have to say to array, I can, but I don't have to say to array
because, of course, a list of T is also an innumerable. So, you know, things get simpler.
We could do one better, actually. We, we also, oh, it was because I'm saying in the array here.
Yeah, yeah. I have to, I have to just make all the changes. Okay. So,
oh, thank you. Say, are you developers or something? It's like you, it's like you understand what I'm
saying. Hey, I also debugged something once, you know, it's fun. So, so, so far so good. We,
one thing we actually decided was now we have innumerable of T, it's like a very in abstraction
over just sequences of data. We're going to meet this a lot more in C sharp three, but already in
C sharp two, we were like, actually, the compiler could help a lot with this kind of work here
of producing innumerables because they don't have to be produced eagerly. They don't have to have all
their elements pre computed. They can actually sort of be lazy and compute things along the way.
And we can build a language feature to help with that. And that's what we call iterators in C sharp.
They're called generators in some other languages, which is essentially write a function. And then
once in a while you say, oh, here's another element for the result. And then you compute some more.
And then, or here's another element for the result. And it actually gets executed lazily up to every
one of those points. You just pause and give the result back. And then the next time the consumer
asks for a result, they come, you know, execute some more. So that's iterators in C sharp. That
means we don't even need like an accumulator. We can just say if that thing, you know, just yield
return the value. I'm not super excited about the syntax we chose there. I will just say I was not
around. We liked keywords a lot still back then. We kind of do still a little bit. And now I'm,
you know, that's it. That's the filter method, you know, you cycle through, you yield return
something if you decide that let me do that. And that's it, right? So boom, very nice.
Also in C sharp too, we're like, hey, we've heard about lambda expressions. Let's do not that.
Something similar. Let's have anonymous functions. Why do you have to declare all the functions that
you want to pass? That's just like a pain. Let's get rid of all these declarations and stuff.
So instead of saying greater than five here, what if I could just write the function with the body
and everything in place here? So we come up with an elegant syntax saying delegate, delegate all the
crap. There we go. Beautiful, right? It's, well, we can laugh now. But, you know, it's certainly
an improvement. Now, you know, I'm free to just come up with functionality and pass it along.
And of course, the compiler generates something under the hood that's similar to before, but,
hey, all languages do it like that pretty much. So great. Our first take on anonymous functions.
Now C sharp three. Now we have big ambitions. This functional thing has really gotten into
our blood. And this is where I'm starting to be around. So I've witnessed more of this firsthand.
So in C sharp three, we want to, we want to solve querying once and for all. The functional
languages can do it. We can do it too. So we want to mainstream functional approaches to solving
querying. Let's do that. And we have, filter is a great example. Like it's a function that does
querying. One aspect of querying. We kind of have the generics in place to do this.
Why don't we, why don't we actually declare an even more general library of function types?
And then we also declare a library of, of querying methods. And, and get all that stuff working.
So we, so instead of just having predicate of T, we create a family, families of functions called,
called funk and action. Funk for the ones that return stuff. So funk of T1, T result or something
like that. That take a T and return a T result. So that's what the funks look like. Take a T1 here.
And we just declare them in the core library. So I don't even have to do it here. They're
available to everyone who wants to be a little bit functional. And, and we can just
here, actually it doesn't predicate itself actually in the core libraries from back,
back way, way back when. So it doesn't give me a red squiggle here, but let's say funk of
T comma. Boo instead to describe the function we're passing in here. And then instead of me writing
the, the filter method as kind of a, one thing that you quickly find out when you want to,
you want to query things is, hey, I want to, I want to filter some more. For instance,
I want to call query methods on top of query methods. So I could call filter twice, you know,
I could say filter on the result of the first filter comma, you know, some other delegate thing.
And, you know, it quickly becomes long. I should probably done lambdas first, shouldn't I?
I'm going to be doing more typing. Okay. Hold that thought. Let me do, let me switch to lambdas
quickly. We get, we get better syntax. That's actual lambdas. You can do this. It's a little
shorter. Or we have, so this is still a, like a statement body there. Or we can actually do
just an express, a single expression. And now it starts, it starts being a little expression
oriented like the, like the functional languages. That's kind of, kind of exciting. But, but we
still have the problem now. If I want to filter that one some more, I can say int, y, arrow,
some things, stuff, oh, it needs to be in parentheses here. Actually does it, you know,
a lambda you can, you don't actually have to say the type. If it's given from the, from context,
you don't have to say it. That's kind of cool. But so why, I want to get the ones that are even
stupid example, but just, you know, equals zero. You know, I can, I can compose my,
my query methods, but it sucks. Right. I'm composing sort of inside out, like this first
stuff is in the middle, and then I'm slapping stuff on both sides of it. And it's completely
unreadable. Well, what do the functional people do when they, I mean, they're doing this stuff.
How do they do it? Well, they have pipelining operators. You can call functions like this,
but you can also pipeline. So in a functional language, what you would do is you would start
out with the array on the left side, and then you would, so let me, let me do some horrendous
doctoring here, you know, start out with the array, you would have some kind of pipeline operator,
which we don't have in C sharp, and you pass it into filter, filtering the first thing.
Uh, and I, that's just the implicit first argument for it there. And then you'd pipe that into
filtering the second thing. And now you have things in the right order. They're sort of
cascading beautifully, uh, in the order that you're doing them. It's, it's kind of fluent man, as we
said. So, um, so that's, that's, can we do something like that? And that's where extension
meant we come up with extension methods, which is essentially just to solve this little problem
in the beginning where they turn out to be like extremely useful and extremely many scenarios,
we're still being inspired by them and we want to do more with them. Um, where what you're saying
is we're just, what if you just pretend that the static method or this function is actually like a,
and, and, um, it's, I can't do it with a, um, I can't do it with just this, uh, this method here,
because it's not actually, um, it's not declared in a proper space, but we can do the syntax is
like this. Uh, we just pretend it's an instance method on the first, the first argument. And now
I can go and add method is what looks like instance methods to other people's types. Ha, ha.
Um, and that kind of gives you that flow. Um, so luckily I don't have to like go and, and do it
properly here because it turns out that method just like filter is being added to the libraries at
the same time. And now we can just do the where stuff. Uh, so we can get rid of our own filter
method and use the one that's part of the query library that we are now providing. Okay. So
we can break it up a little here and now it starts to kind of look decent. Right. Now we have a
select for projecting because why would we call it project? Um, we have various methods. I'll tell
you why we call it select. That's because another place where you do querying is, um, is in, um,
you know, SQL, which is also kind of functional, right? It's, uh, it's also just, um, you can,
there are aspects of SQL where it can mutate stuff and actually get things into the database,
but the actual querying is functional too. And so we want to provide syntactic sugar for,
for querying on top of methods like this, where you can say, um, from, uh, from value
in, I should call them X. I like X from X in array, where the keyword where, um, X is greater than
five, um, and where something else, where, um, why let's call it X again then, because we are now
using the same variable name all the way down, select something. So we now have query syntax,
select, you know, maybe just X. So, and, and the point here is it looks like SQL. It's a little
different because in SQL, they start with a select clause, which means we don't like that in programming
languages because they start out by describing the result. And what you want is to start out by
describing the, where the, the source, like where do things come from? So you can get types going
and have your tooling kind of help you out as you, as you type the code from one end to another.
So we want to start with the array, figure out what its type is, get completion in our, in our
clauses, uh, and so on. So that's, that's a programming, proper programming language way
of doing it. Sorry, SQL folks, but you, you got it wrong. And you didn't think about ID,
you didn't think about IDEs back in 1970, I went out. ID focused, uh, language design, that's,
that's the way. That's why we have TypeScript. So, um, so great. But now that actually just
queries my in-memory data, like wouldn't it be cool if I could actually use the same syntax and
both the syntactic sugar and actually also the method called syntax to query actual SQL databases
that, and with this, you know, no difference in syntax. And that's where we get to another
functional, uh, yet another functional, uh, loan, which is, um, code quotations. So, uh, in, in Lisp,
for instance, it's, it's all based around the fact that code is data, like code and data are no
different. And you can always easily take code and represent it as a data structure. Well,
that's kind of cool because then you can do metaprogramming. You can take that data structure
and do stuff with it. And one of the things you could do with a data structure representing a
query is you can translate it to SQL and send it to a SQL database and have it run a SQL
and have the result come back. And then you do a little translating back. And now you have an
object oriented, uh, an object relational model. Um, so if we take that, um, um, let's just say var
here, more type inference, if we take that array and say, um, is it too queryable or as queryable,
isn't as queryable? There you go. And say, ask queryable. Um, I'm sort of cheating a little
and I'm representing it as, uh, now a queryable is like a representative of some other data source
that uses quote quotation in order to, um, to, um, do the querying. Um, so when I do that,
what changes is, well, not much, you know, it's, I get a queryable back instead whoop to do.
But if we go in, um, and look at, um, if we go and look at that query, um, query dot,
you can see that it has something inside called an expression. And that expression,
in fact, represents the, the data structure of all this query. Okay. So we're building up,
instead of having the code, just code that we can run, instead we build up a data structure
with exactly the same syntax. Um, and now querying of in-memory data and querying of,
of, um, of SQL databases look the same just like, uh, you can do in, um, in, in many functional
languages that have code quotation. So yet another loan there. And I just, uh, I just cheated a little
bit and showed you var as well, which is like the last, um, one more concession to type inference,
like very simple one is like, why do I have to say the types all the time? It's really
bothersome to have to say int. Can you let me say a three letter keyword instead? Um,
um, obviously that's not the best example. This is the best example, right? I don't want to have
to write a query of blah, blah, blah. I want to, I want to just say, Hey, the thing, you know,
give me the thing. If it's clear from context that it's what kind of thing it roughly is,
you know, who cares? So that's, uh, that's functional up until C sharp three. It's a good,
a good time to ask for questions. We're about halfway through the story and about halfway
through the hour. So it's still in track. Anything, any thoughts coming up here? Questions,
meta questions, programming questions, meta programming questions. Yes.
What made me decide? And it's Heilsberg made me decide. Um, it, okay. I'll
short, short version of the story. I was, I was a professor. I wasn't liking it too much.
I was collaborating with the Java team at Sun Microsystems then had a great time doing real
world, you know, re, you know, real world language design for real customers. They got to do it all
day. I got to do it like whenever I could get away from teaching and stuff. And I just like,
well, I have great time when I'm working with them and they make twice as much money as me at
least, I think. Um, it's just like, maybe I'm not in the right career here. And as I was thinking
that there was a conference in Ohos, um, Anders was there talking about how they were going to do
generics and C sharp. I was there talking about how we were going to do generics and Java.
You know, the rest is history. He, he had money. I didn't. So he hired,
he hired me not the other way around. Um, actually also, I liked how he talked about
language design. Whenever, when I was involved in Java language design, it was always like a,
there was always a lot of stop energy is like, we can't do this because and we can't do this
because and he had a bunch of can do attitude, you know, a small example, the, uh, now the,
the generic method has gone from the screen here. But in Java, they said, oh, we can't put the type
parameter for generic methods after the parameters because that might be a syntactic ambiguity
in rare cases. And in C sharp, when he showed examples, that would also be a syntactic ambiguity
in rare cases in C sharp because syntax is a little bit of like, um, but they just put it
there anyway. And I asked him after like, how, how do you do that? He's like, we just do some,
we just do some tricks in the compiler. It's not like LR one or whatever. We, it's fine. We figure
it out. And, you know, and, and who cares about those rare cases, you know, we, we, we come up
with a rule that works 97% of the time. If you run into it and does the right thing mostly.
And we get, it was always like a, we can probably solve that problem attitude. And that spoke to
me in a way. And that's, uh, still the case. And I said, that's still why I love being there. So,
oh, thanks for that question. Now I'm going to have a tear in my eye for the rest of the day.
Anything else? I want to hear about my childhood. Yeah.
Why? Oh, great question. So why, why are the delegate types that have the same shape,
like the same signature? Why, why aren't they interchangeable?
Um, so that's, so there used to be predicate of T and then, and then it turned into, we, we started
using funk of, um, T come a bull and they're not actually interchangeable. You can pass the same
lambdas to them. Um, but you can't pass, you can't assign one to the other. They're not structurally
equivalent. So that comes back to, you know, I kind of hinted that I'm not a super fan of delegates.
Um, and one of the problems with them is that they're a nominal type. They have a declaration
and just like classes that look the same, you can't take an object of a class and duck type it to
another, uh, class that happens to be the same. Uh, it's all based on the declarations. It's very,
very nominal, as we say. And the same is true for, for the, um, the, the delegate types. There are
actually classes and they are nominally tight. Now in visual basic, for instance, um, VB.net,
um, they paper over this by inserting implicit, like wrapper functions to translate from one
to another. So there you get the great experience of it all just assigned to each other. It looks
extremely structural, but the problem is it isn't like it comes with a cost, like you're
wrapping more and more. If you keep, if you, if you keep passing back and forth, you get
like layers and layers of, oh, here's a predicate of a funk of a predicate of, you know, all the way.
So, um, uh, so we don't let you, we don't let you go down that rabbit hole and C sharp. Um,
we think about it sometimes. And we also think about, well, could we just do better function
types? But then you have a library that is gigantic and that is using delegates everywhere.
And you look at that and you go, hmm, I wonder how we could do this and not mess up a million
customers, you know, or, you know, we choose not to roll it out in our big library and just
make it, you know, an option for new code. And then it doesn't really, there's no bang there,
right? You know, you don't get enough value. So that's a tough problem. That's, you know,
the problem of legacy code and the problem of, of compatibility shoots down a lot of good feature
ideas. And, um, and, uh, we haven't found a way around this one. We, we are, it's one of several
interestingly, uh, functional and functionally inspired topics that we'll be discussing this
summer. We're having sort of a series of summer camps on the team where we'll discuss topics
that are normally out of bounds because we don't know how to deal with them. Um, and this is one
of them. So maybe one day we'll figure out a way to make that good. Yeah.
Yeah. So the question is, um, is the, um,
is, is the sequel style syntax still in broad use? Um, and, and it's true. It does feel very
different from the rest of the language. It's, yeah, it's just, it's like you enter another world.
Um, yeah, we have to maintain compatibility with it, but also furthermore, I think it is still,
it is still used a bit. Now, a bunch, not more than a bit actually, a bunch of people actually
do prefer the method call syntax, even when they are using the query methods. Um,
I find that if I have to do more than one from, from X in blah from Y in X dot or something
like that, then writing the corresponding query with method calls becomes, um,
becomes mind-blowingly hard. And if you have to use select many and select many is mind-blowing,
and so, uh, I always, if I have to, if I have to like do more than one from, if I have to like
dig into data with froms, I switched to query syntax and let the compiler figure it out for me
because I, my brain can't handle it. It's all actually, it's all down to monads. So how many
people here know about monads? Yes. That's more than I would have expected actually. It's this
concept that is super central to a bunch of functional, a typed functional programming.
And nobody understands it. A bunch of people claim that they do, but they're actually just,
you know, it's, it's a collective kind of like, it's, it's a hoax. Um, they don't, not for long
anyway. I've, I've understood it many times. And then, you know, the next day I was like,
what was it again? Maybe I was just dreaming it. It made, it totally makes sense at the time. But
query, query expressions, they are a monad. They're a language support for a monad. And, um,
and when you use more than one from, that is where you get into monadic territory where the,
that the select many is the thing that makes them, makes them a monad. And that's, that's
exactly why it gets mind blowing to do it directly. It's because it's monad and you want syntax for
that. But other than that, people have different styles. There are also people who work on low
level code that would be like, this is way too inefficient. Um, it does you, there's all this
laziness, right? The, the iterators are generating things along the way, which means you have all
this, like you have a bunch of structure. You have all these calls through interfaces and so on.
And so if you're doing performance intensive code, one of the things that people look for in code
we use is, oh, oh, you have a query there. Well, fix that, you know, go back to ugly array based
stuff because then it's going to be faster. So, um, I will, I will say that entity framework,
live and kicking, um, offers up, um, you know, a query provider implementation and people do
use that and they do use the query syntax when they're interacting with that because it is a
database, uh, technology outside of that, maybe not so much. Okay. All right. Uh, one more.
So that's a great question because, um, and we might touch on it a little bit later. Um,
a, so let me repeat again. Um, the, uh, one thing you can do in the query syntax is you can use
let to actually, uh, introduce more temporary variables inside of the query. I haven't done
it in many years. Actually, let's see if we can do that. Let y equal x times two or something like
that. Yeah, it worked. At least it compiles. So, so now, so now the rest of the query has access to
x and y. Um, and, um, and that's really useful because you have sort of like variable declaration
inside of an expression rather than as a separate statement. And that has continued to doggers that
statement based, um, approach to variable declarations has continued to doggers and in later
versions of C sharp, there are more and more places where you can now declare variables inside of,
um, inside of an expression. We haven't done it completely generally. We had a proposal for it,
but we never went that far. But there are many situations now where you can declare an inline
variable, particularly in pattern matching, which we're going to get to soon. So that even provides
like a, a good segue for that. Um, so, you know, at the, another like big difference is,
functional languages tend to be very expression based. Typically a function, um, doesn't have side
effects, right? In a pure, uh, function, uh, functional, uh, sense. So you don't, you really
need statements. You just need an expression saying what the whole thing is, you know, and then you
stick it together, you put sub expressions inside and it's all expression based. And so you need
things like variable declaration to be expression based. And the more expression based, the more
we get inspired by that and C sharp, the more of a shortcoming it becomes that variable declaration
isn't one of them. So great, great point. And this is the way to sneak it in. You can't do that with
method call syntax because it does sneaky things under the hood. It builds a little like tuba
like things to keep track of all the variables under the hood. Okay. Yep. Okay. Let's, uh,
let's fast forward a little bit. Then we did dynamic. That was certainly not very functional
to sharp for C sharp five. We did a sync, which was potentially very functional. F sharp already
had a solution to a sync, which was also sort of monadic and which is beautiful, but is very
ill suited for a predominantly, uh, imperative language. So we went in a different direction
with async and the F sharp and the generally functional approach to async is quite different
from, from, uh, the imperative approach that we use in C sharp. Essentially they use an approach
where they built up the whole control flow of the async ahead of time and then you kind of pull
a handle in and, uh, and it runs. It's like you built all the pipes and then you turn on the water.
And in, uh, in, in our async, we sort of more like, um, laying out the pipes as the water's
coming. It's, uh, we sometimes call it cold and hot async. Like we work with tasks, which are,
which are, uh, that's our currency and async, which are things that are already happening,
things that are already concurrently operating. And then you can take a task and then you can say,
well, I'm ready for you. Are you ready for me and get a result out of them? So that's all
much more imperative fits better with imperative workflow. So there we didn't go the functional
way. We don't always do it. Um, in C sharp six, we started like getting interested in the
expression based stuff. Again, no, so I'm going to switch to a different, a different file here.
Um, so one thing that, you know, we really liked the expression bodies of lambdas were like,
why should only lambdas be allowed to have expression bodies? Why can't all our functions,
all our function members have expression bodies and we're like, okay, C sharp six,
we did kind of half of them. And then C sharp seven, we did the rest. So now, um, all function
members in C sharp can have a expression bodies where you just put that lambda arrow there,
the fat arrow, as we shouldn't call it. Um, and, um, and, uh, you get it, you know,
you don't have to say return. If you, if your only statement is return something,
you know, cut the boilerplate, but it's just in tactic sugar, right?
Um, so, but coming to C sharp seven, uh, we're starting to think about more fundamental things
again. So not, not so much in the syntax, syntactic sugar, you know, as feel kind of,
of layer, but really like, uh, object or in a program is kind of screwed in these new scenarios
that are becoming very predominant and, and, um, and widespread. Essentially, when it comes to
cloud programming, history is on the side of functional programming. I'm sorry,
object-oriented programming is not good for that. If you think about, and that comes down to how,
how you describe operations over types of data in, in both, uh, object-oriented and functional
programming, there are ways that you can write functions so that they have appropriate behavior
for each shape of data for each type, but those ways are very different. They're like actually,
I think probably if Eric Meyer was here, he would say that there's a duality, like they're completely
like, um, the opposite of each other. Um, what we, what we do in, in, in classic object-oriented
programming, we love encapsulation. We love saying the data is actually secret. I'm not even,
I'm not exposing it because then I can change it whenever I like. And then I just offer up some
functions and I can have a class hierarchy with virtual functions that I can then describe for
each type of data what it does. So, so the super like, uh, idiotically simple example here is the
two-string virtual method, right? Where I'm, I'm, I am describing the string representation of the
object as a, uh, by overriding the virtual, uh, method two-string. Great. You know, that means
that whenever I, I write a new derived class from person here or from objects actually in this case,
you know, I can just overwrite that behavior, um, to suit whatever my shape is and somebody else
can call it on the base class and not even know I exist, but still get the right behavior. Um,
excellent. Except when you have a world where data is long lived in the cloud, maybe, or on
databases and whatnot, and different people are writing different functionality over the same
data models, well, oops, now it's not so good to encapsulate those, those behaviors with the data
model, right? They, they, you want to independently be able to express behaviors over the data model,
um, that, that still depend on, like, still type specific, but that, uh, the original type knows
nothing about and that the different domains of, of behavior have no idea about each other.
So encapsulation is dead, right? You need, for those scenarios, you need the data to be public,
um, and luckily we have, you know, uh, auto properties to make that easy, um, but you, uh,
and you need, uh, the functions to work from the outside, but in a, in a C sharp six setting,
so let's, let's say we're still in six doing something. Let's say I want to, let's say I want
to write the two string method from the outside. That's actually fairly hard. That's annoyingly
clunky and, and that you get back to that dying inside feeling. Um, so, uh, so let's try to do
it. I'm making you all die a little bit inside. I'm sorry. We'll, we'll revive that part and
there'll be flowers and it'll be good, uh, in a minute, but you know, um, so let's say two string,
string, uh, let's call it, um, let's call it something else to render. Um, and, uh, you take,
um, uh, you take a person. It's not even generics involved here. You take a person P and then you
want to render it according to which kind of, you know, which person, uh, derived class it is.
Um, so we could do that. We can say, you know, we have type testing in C sharp. We can say if
P is a student and that's the only derived class that I actually put in here, but you know, imagine
there are dozens, um, for each of those you say if P is student, then do at least we have
expression body, uh, members here. No, I can't do that here. Return
whatever the student does. Okay. I'm cheating a little using interpolated strings here. Um,
return that, except of course, um, I have to dot my way into that public data. No problem,
but as I get to the student specific property here, oh, oh, you know, I, I, I already, I just
asked, but I already forgot that it was a student. So I don't get to, oh, if only we were type script,
you know, type script, it, it has flow based typing, you know, a variable, you know, if you
figured out it wasn't something on this branch, then, then, you know, it'll know you're something
else and it's beautiful, but we can't, that's always super breaking in C sharp and also their
compiler is, uh, you know, just thank God that they don't promise type safety. Let me just put it
like that. So, um, so that is kind of annoying. What to do? Well, you know, in C sharp six,
your best option is to, you know, cast P to student knowing it will succeed because you're
smarter than the compiler. Um, until you maintain your code a little bit and I know somebody else
takes over and they, they do a refactoring manually and stuff blows up. Um, but that we can do that
and then there's an else, you know, else return that other stuff. Let's just get it in there so we
can, um, so we can mutate the code a little bit, um, return that stuff. Um, and of course there
would be else ifs, um, for every other like derived class here. So here we, here we get, here we get
to do p dot this and p dot that. So far so good, but functional languages, they do this all the time.
Um, and it's interesting to note that there's a fundamental difference in how the, um, how the,
you know, what kinds of, what kind of contracts you have here when you use object-oriented
programming, as I said, you can add a new class whenever you want and you can just
overwrite that virtual method and everyone's happy, right? Cause the code and the class are
together. If you add a new type, like in the, in this functional setting, you, you are explicitly
in the function, you are mentioning all the different shapes that you care about. Um, and if
somebody adds another shape of data and you, you know, your code is no longer handling that.
So there's a different, you, you can't add new data with impunity, but you can add new functions
with impunity, which you can't do in the, in the, in the object-oriented world. You, you can't go,
without going back and editing the original, right? You can't independently add new functions in
object-oriented programming, but you can add new types in functional programming. You can't, uh,
you can't, um, uh, independently add new types, but you can add new functions. I said, this really
is a duality, but they do the other things so well and what is it they do? Well, they do pattern
matching. So the first step there is, let's, um, um, let's actually let you declare a variable
inside of this expression, you know, like after this is expression that's already, that's actually
that you put a variable name and say, okay, I just checked. Can I just get a name for that? Can I get
a receipt? Um, and you, and you use that, uh, throughout here and that is your P typed a student,
uh, with its own name. And now we can, we can use, you know, we're not dying inside anymore.
If I can, at least if I can, well, what? Oh no. Um, what's that? Yes. Uh, it was the wrong
preventant. No. Yes. Thank you. Thank you. I'm code blind. Thank God I only have six minutes left.
Oh my God, I only have six minutes left. So, so what we're getting into is pattern matching and
pattern matching is this whole, it's this whole new concept that we're adding to C sharp at this
point, but it's not new in the, in global sense. It's a well trodden path in, um, in functional
programming. We just have to adapt it to an object oriented context and, and this is a pattern.
A pattern is something that had, that can either succeed or not when you apply it to a value.
And if it succeeds, it can extract some extra information and put it in variables for you.
That's what a pattern is. And we have a few patterns from the beginning in C sharp seven
and then we start adding some more along the way and we keep, we, we're still adding patterns to
this date. Like C sharp 11 has list patterns, which you will, if you go to the other talk,
you'll get to see those. Um, but it's still like the, the, the shape of the code, like we, we solved
the micro problem, but the larger problem of if, you know, having a very imperative way of checking
that's also very like, um, uh, kind of fraught with danger in terms of maintenance and so on.
Um, what we want along with pattern matching is we want, uh, what functional programming
often calls matching pattern matching. We have a keyword already called switch. So we're using
that one. So let me go and, uh, let me go and just, you know, do this again. Um, so I'm going to do it
in a functional way. Let's just, uh, we can, we can comment this out. Uh, so we're going to do just
an expression body. We're going to take the person and we are going to switch on them,
but not with an old fashioned clunky switch statement from C in the early sixties that we
have in C sharp, but with a switch expression, you know, like the cool kids. So this is an expression
body. That's a switch expression. It's empty right now. Uh, that's actually okay, but you get a
warning saying you're not handling all the different kinds of input. Yeah. Okay. Thank you.
So, and now we can write patterns directly here, student S arrow. Um, and now we can just put an
expression for the result that you want in case it's, it is a student. Right. So I can, I now have
like a, a clean structure within which I can just list comma separated patterns and results. Um,
and I, right now I only need the two. Um, so we're going to take, we're going to just do this
for now. And then, uh, just quickly touch on the fact that patterns can be pattern matching is
smarter. Right. We saw that it said that you were not handling all the cases. It still did that
when we only had the, um, when we only had the student, but when I do a catch all, which I can
do with a fancy modern discard, um, then, uh, it says, Hey, you're handling everything. You're
good. No more warning. Well, what if I go the other way? Like, let's just, let's just swap the
order of these two. They, they are in order. Then I actually get an error saying, Hey, you handled,
you handled this case already. So, so you can see how maintenance of these things becomes much,
not only is it clear to read, but the compiler is helping you much more, keep your logic straight.
So it's beautiful and it's safe. That sounds like functional to me. Um, so, uh, so you can do that,
but you know, I'm, you're noticing, I'm actually writing out just the first letter of the first
name in this case here. Actually, what if, what if the, what if the first name is empty? I'm not
going to talk about an all right now. That's a whole nother talk, but what if it's empty? That's
kind of, you know, I should probably do something else if it's empty. So let's, um, let's use just
to show an example of a recursive pattern. I know now that it's just a person, but what if the first
name of that person actually is an empty string? Um, I want to do something else. Then I just want
to write out the last name. I don't want to like do the whole abbreviation thing, uh, uh, p dot last
name. Um, or, you know, I could actually, so this is a property pattern. I can dig out specific
properties inside of the pattern and recursively apply a pattern here. I'm just applying the pattern,
I use this constant, but I could also say last name, colon, and then apply a var pattern, which
always succeeds, but which, uh, will give you a name. So that's your let, that's your pattern let.
It's the var pattern. Um, and, um, and then instead of saying p dot last name here, I already dug
out the last name and I gave it a name. So I can just say L here. So, and, and these things compose,
you know, if I wanted the actual, uh, if I wanted a new name for the, the person object itself,
I could put it here. Uh, let's call it P two or whatever. So, so patterns kind of compose and,
and over time we've added more and more kinds of them, um, that essentially make them more and more
expressive and allow you to put more and more of your logic into patterns so that your shape dependent,
uh, code is now as beautiful or some would say even more. I, I, I don't, but, um, but you know,
it's a great, beautiful first class alternative to virtual methods when you, when describing the
functionality on the outside is what you want to do. You do pay something. You pay the fact that,
um, you can't willy-nilly add new types. You pay the fact that your data has to be public
so that it can be operated on from the outside. So encapsulation is out the window,
but you get this other beauty. So, you know, pick your poison depending on the scenario.
Now you have both obstinacy sharp. And I also wanted to mention immutability, but I just did.
We did work for immutability. Um, first we let you have, uh, auto properties without setters,
but that wasn't so good for the, um, for the object initializers. Now there's a more, um,
that now you have a new kind of setter. It's called an initter, which is the setter that
can only be called from object initializes. And now, so that means we made immutable objects
more first class. You don't need to initialize them with constructors. You can use object
initializes for those as well. Immutability is another functional concept that we're,
we're starting to support more. So, um, I'm going to stop here, um, with in the C-sharp sevens.
Um, and if you want to see some C-sharp 11 functional influence, uh, you know,
there's another talk in just an hour and a half or whatever. And, uh, for now, thank you very much.
