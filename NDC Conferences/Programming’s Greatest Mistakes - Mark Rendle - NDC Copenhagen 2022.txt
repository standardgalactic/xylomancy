It's wonderful to be here. Has everyone had a fantastic week? Yes. Excellent. Glad to
hear it. I would just like before I start to say thank you to Jacob and Kirstie and Steiner
and Henriette and all the volunteers, the people in the green t-shirts who've been
sort of marshalling the rooms and gathering the feedback and everything. There's a lot
of work that goes into these conferences, so can we have a round of applause for all
the people who make this happen? So I'm going to finish things off. You're all tired. It's
been a long week. You've got loads of information to process, and so I'm just going to basically
share some very silly stuff. There may accidentally be some lessons in there that you can learn.
I apologise. But this is all about some mistakes and the kind of mistakes that are made by
software developers and engineers. Before I start content warning, there is going to
be swearing. I am going to say fuck quite a lot just in the next segment, but it is
relevant to the plot, and so that is justified. What I am not going to be talking about in
this talk, because it's light-hearted, it's designed to make you laugh, I'm not going
to be talking about any situations where software errors have actually killed people. But software
errors have killed people, okay? So yeah, but there's none of that in here. This is all just,
it basically cost a lot of money, for the most part, or it cost me my job in what some
cases. So yeah. And this is me. This was one of my biggest mistakes. I worked for a software
company, and this was when I was in my 20s. I was young. I was arrogant. I thought I was
like a 10x developer and hot shit and all that sort of stuff. And I worked at this company,
and also in my defense, before we get into this, I was already spiraling into what would
eventually become a full-on nervous breakdown. So I wasn't necessarily thinking straight.
Our company, we sold event management software and membership software, and it was very complicated,
and you could build these huge complicated queries across the database, and you could
save those queries into a file, so you could load them again the next day. And those files
had a med extension. I can't even remember what it stood for, but we called them med files.
And we released an update to the software, and it corrupted. When you saved the med file,
it corrupted it. And so the support people came to me, and they said, and I quote, Mark,
the med files are fucked. Can you write something to unfuck the med files? And so I went into
Visual Studio, and I did file new project, and it said, what's the project name? And I went, oh,
unfuck. And so I created this little Windows application, Windows Forms application, and it
displayed a dialog box, and it said, choose file to unfuck. And you clicked a button, and it went
off, and you browse, and you chose your file, and then it had a button that said unfuck now, and
then it ran it through its thing, it did its thing, and then it displayed a message box that
said med file successfully unfucked. Close. And it worked. Well, I thought it worked, but, you
know, support had a bunch of support, or also QA, it was that kind of company. And so I gave the
application, which was called unfuck.exe to the support person who had reported this to me, and I
went, can you test this out and make sure it works, and then we can clean it up and send it to the
customer? I don't know if he tested it. I can't imagine that he did, because then without coming
back to me, he shipped it to the customer. And they ran it. And yeah, it doesn't look particularly,
these are the kinds of customers who are paying you half a million pounds a year on a sort of
support subscription basis, and we send them a file called unfuck.exe that says your file has
been unfucked. And at the time, I was in such a bad place mentally, I blamed the support guy for
this, because I obviously got hauled across the coals for this, and I blamed the support guy for
shipping the thing, whereas obviously it was actually my fault. I should never have created a
program called unfuck.exe. That was just not a good idea. It's okay to swear in comments, as long
as you're never going to open source things, but don't actually put unfuck. On a slightly related
note, by the way, very early in my career, did anyone, any Windows 3.1 veterans in the room? So
Windows 3.1, it was a file called win.com, and every message and every piece of text that could
be displayed in Windows was embedded in win.com, just as text. And if you used a hex editor,
you could open it up. Interesting trivia, the phrase general protection fault has one more
character than the phrase Mongolian clusterfuck. And so if you put two spaces in the middle,
you can edit someone's win.com file, and then you can run away. And then the next time that happens,
they will get a message box that says a Mongolian clusterfuck has occurred, which has caused your
application to terminate. One of the worst things about Windows 11 is you can't do that anymore.
Okay, let's talk about Y2K. Everyone knows about Y2K. That was probably one of the
biggest mistakes in software. But it wasn't that we let that happen in the first place. It was
really to do with how slow we were in fixing it, because what you have to understand about the
people who wrote the code that then caused the Y2K problem was that this is what data was stored on
at the time, punch cards. So every column on there is basically a byte of information. And so those
extra two digits on the year would have been an extra two columns on there, multiply that by a million
bank customers and 100 million transactions a day. And those extra two columns add up to a lot of
extra punch cards. And memory in those days. This was what memory looked like in those days. This
isn't under a microscope. This is just a photograph. That is core memory. And it's lots of magnetic
poles. And through each pole, two pieces of wire have been passed. These were made by usually women
with microscopes and needles. Memory in the 1950s was knitted. And core memory cost about a dollar,
a bit. So a byte of memory would cost you $8. You think like that means a kilobyte of memory
would cost you $8,000. So memory was really at a premium. And this is also incidentally why
UNIX still says core dump to this day. It's because it was the core memory that was being dumped.
And of course, in those days, it was just a kilobyte. And it was quite easy to read through.
So early programming languages like COBOL, they didn't think in bytes. They thought in bits.
And so this is the definition for a date variable. And we say this is a string type variable. But
the nine means it's a number character. And so it can only be naught to nine or some of the other
like hyphen and comma and dot and things like that. So that would fit in six bits instead of eight
bits, which meant you saved a couple of dollars every time you were putting one of these things
into memory. So it was quite reasonable to shorten the date and only use the sort of decade and the
year. This is, I've forgotten his name, Bob Beamer. And Bob Beamer in 1954 was the guy going, I
realized we have to do this, but as soon as memory becomes cheaper, we really should change that to
a pick eight, pick nine eight, because this is going to cause a problem. 1954, he said that.
In 1964, he started saying it with a little bit more emphasis. In 1974, he started shouting about
it. In 1984, he was giving talks at conferences going, guys, we really, really need to fix this.
In 1994, after Bob Beamer had retired, we actually started work on fixing it. And by that time,
all this software had carried on you. So you wrote new bits of this software and you carried on
using that. And so the effort to stop the Y2K bug from happening was ridiculous. And it took an
awful lot of people, an awful lot of time. But we did it. And then the year 2000 came. And there
were very few big computer crashes and no aeroplanes fell out of the sky and all this other stuff.
And the whole of the rest of the world went, well, that Y2K thing was a lot of nonsense,
wasn't it? What a fuss. And people like me who'd rewritten COBOL systems in Infimix 4GL to fix this
went, no, you're welcome. Yeah, it's like, yeah, thanks to me, your hospital still works. But no.
Bob Beamer died in 2004. So he did actually get to see the problem being fixed. But the estimated
cost of fixing the Y2K bug goes from, some people say $300 million, some people say $800,
so let's put it somewhere in the middle and say it cost half a trillion dollars to fix the Y2K
bug. And you'd think we'd learn from that and we wouldn't set ourselves up for any other Y2K
bugs. Particularly if you're like one of the biggest software engineering companies in the
world, you wouldn't put something into, say, your flagship email server that was going to break at
a, no, no, no, no, Microsoft, this happened this year. A thing that Microsoft was storing in an
integer ticked over. I don't know exactly what the number was, but suddenly we couldn't convert
this number to a long, because it was too big, and exchange servers all over the world, including
Office 365, just choked and died. And Microsoft had to hurriedly roll out a fix for that.
In the year 2038, there's the apocalypse is coming. Unix still stores the system date and time as
the number of seconds since January 1, 1970, in a signed 32-bit integer, and that's going to crash
in 2038. And you'd think, well, that's an easy fix, change it to a 64-bit integer, but no, they've
patched it with an extra bit. So now they've got a 33-bit integer, which kicks the can down the
road until like the year 42 something. But you know, Linux going to Linux. My favorite one of these,
though, is the dog 38 bug that the Kennel Club of the United States of America have. So the
Kennel Club, your dogs are categorized by their pedigree breed, and then your dog has a name,
and it's one of those big, long show names, like I have a pedigree dog and her, I can't remember
her show name, it's got something, sugar, cookie, something, something. And so if they already have
a dog with that name, which is obviously a big country, 300 million people, lots of dogs,
it happens. And so they number them. And so yeah, one, two, three, four, five, six, blah, blah,
37. And if you go to had a dog, and there are already 37 dogs of that breed with that name,
and so this is dog number 38, it crashes because it can't write the number into the database.
See if you can anyone guess how they're writing the number into the database that would cause
37. And all the numbers up to 37 to be okay. And 38 suddenly crashes.
Roman numerals, they store the Roman numerals in a char six field. And every number up to 38.
So 38 is x, x, x, v, 37, sorry, is x, x, x, v, i, i. All the numbers before that fit in fine,
but 38 is x, x, x, v, i, i, i, i. And this one, I really don't understand, it's going to the
database, change it to a char eight, or you know, God forbid, an integer, and just format.
Someone just went, I can't write the algorithm to format a number as Roman numerals. Let's just
store it as Roman numerals. So yeah, that's fun. I would like to thank Stand Up Maths on YouTube,
great channel, and I found that one on there as I was writing this talk. So that was interesting.
A lot of this actually comes down to one of our biggest mistakes in programming, which is just
enterprise programming generally, enterprise software. It's just, you know, the processes,
and the procedures, and the waterfall, and the project planning five years in advance,
and all this sort of stuff. And it causes problems. And you can see the kinds of problems that it
causes. So yes, enterprise, a business plan or project, especially one that is difficult,
or may fail, or lose money. And everything in enterprise development is based around this.
It's nothing to do with building good software. It's nothing to do with working efficiently.
It's all to do with covering your ass so that when the thing goes wrong at the end of the day,
you still get paid because you can prove it was somebody else's fault, which is why you get agile
development posters that look like this. This is the scaled agile framework for enterprise.
This is the simplified version. There are worse versions than this. And you get things like this,
auto scrum 1.1, which is Accenture's. This is still claiming to be agile. This is Accenture's
agile framework that they use. And somewhere in there, we have a program backlog. We've got a
we have a sprint. Right down there, there's a daily scrum. And I think they've allocated
some time for people to write code. But I'm not sure. People have probably seen this. This is
Deloitte's agile landscape, version 3. The terrifying thing with this is that this and
this are just single dots on this. And we wonder why so many enterprise projects fail.
Quick story about enterprise. I was hired by one of the national agencies, the quangos as we call
quasi autonomous non-governmental agency organization in the UK. They had an API end
point, only had one thing, and it just returned a list of the amount of energy that was being used
in the UK right at that second. And that is very useful information if you're investing in energy
futures, you want to watch those patterns. And so people just kept hitting it, and hitting it,
it didn't have IP throttling, it didn't have any accounts or anything like that. It was an
anonymous end point, and you hit it, and it did a quite complicated database query against an
Oracle database. And did people put a thread dot sleep 10 or a task dot delay 10 in between? No,
no, no, no. No, they just get it, hit it again, hit it again. They had this running on one 32-bit
server, it was written in .NET 2.0. I had been brought in to look at this in 2014,
and yeah, it was 32-bit .NET, so it didn't have much memory. The Oracle database was also 32-bit
running on an old server. The servers had been there since like 2005, so they were well past
their death time. And yeah, they said, can you take a look at this code and tell me what's wrong
with it, and tell us how to fix it? And I went, I could just fix it, and they went, no, no, no,
don't fix it. We give you two weeks to write a 20-page document telling us how to fix it.
And so I took it back to the office, and I loaded it into Visual Studio, and Resharper
actually started crying, and then uninstalled itself, and went, no, you're on your own.
Just don't. And basically, I don't do planning, I don't do documentation, I don't do that sort
of thing. I'm getting better at it now as I get older and more responsible, but back in those
days, I'll fix it, and then I'll just write down what I did to fix it. And actually, the main thing
I did to fix it was where they said var connection equals Oracle database connection, new Oracle
DB connection, I just added using because they weren't disposing their database connections,
so it crashed every 20 minutes because they exhausted memory, and the app pool had to recycle.
And so I managed to write 20 pages on why using statements are important,
sent it back to them, didn't hear anything from them for nine months, and then they came back to
me, and they said, can you come in for a meeting to discuss your findings? And I'm kind of like,
you haven't done it yet? So I go up, and my boss goes up, and he's charging them 2,000 pounds
for me to be there for the day. Lord knows what he charged for him to be there for the day, I'm
guessing about 5,000 pounds. We get there, there's 10 IBM consultants sitting around this table,
and I know that IBM consultants are about 10,000 pounds a day. So this is a 100,000 pound meeting
that's happening right here. And I go, look, I can give you the code, I've brought it on a
USB, if you want the fixed version of the code, it's here. And I would recommend running it in
64-bit on a server that isn't 10 years old, but this will probably still work even if you don't
do that. And they went, yes, we can't just go in willy-nilly and fix it and put it on new servers.
This is a critical system. Yes, it's a critical system that crashes every 20 minutes,
and is costing you an absolute fortune. And just buy a new server, just put it on a new server,
and it will be better. Give it 64 bits and give it like 16 gigs of RAM, and it will run smoother.
Well, we can't just, you know, that has to go through a whole process. And I'm like,
this meeting is costing 100,000 pounds. And for 100,000 pounds, you could buy a data center
and run this thing on a server farm, and it would be fine. And my boss went,
Mark, why don't you go outside and get some fresh air?
And so I go out and I wait by his car, and he's kind of like, oh, I'm in so much trouble.
I'm going to get sacked again. And I'm smoking a cigarette because I smoked at the time.
And he comes out, and I'm like, I'm really, really, really sorry. And he went, no,
don't worry about it. I don't have to fuck off. We don't need that shit, he said.
Okay, this was a fun one. So problems in software, they're easy to fix. So you ship
some software that doesn't work, and they are, it doesn't work. And you go, here's a new version
of the software. Intel managed to get a software bug into their processor. So the Pentium chip
was the first Intel processor that actually had a floating point unit built into it. Before that,
we had the 486, and there was a 487 co-processor that did floating point. But Intel had combined it
into the actual chip itself. And the Pentium floating point unit accelerated floating point
operations. There you go. That's what it looked like. So what is 4,195,835 divided by 3,145,727?
It's 1.33382. Except according to the Intel Pentium's floating point accelerator,
it's 1.33374. And there were a few instances where this would go wrong. And people noticed.
And Intel went, okay, if you can prove that you are actually affected by this bug,
we will just send you a new Intel Pentium processor where it is fixed. And then so many
people came up with these torturous, this is why it's not working for me, which we're largely to
do with Microsoft Excel. And so Intel ended up going, fine, just if you've bought a Pentium,
we'll send you another Pentium. And that ended up costing Intel $475 million to fix. I'm not
sure anything like it's happened since. I would imagine they probably run every possible floating
point calculation as part of their unit tests. Null. This is quite famous. Null. And we actually
have a fairly easy value to assign to Null because Tony Haw, who was the guy who invented Null,
has called it his billion-dollar mistake. So Tony Haw is a British computer scientist,
hugely respected. He's like a knight or a KBE or something of the British Empire.
And he was working on Algold W. And Algold W was the first programming language that introduced
the concept of records, what we think of as like classes or structs or whatever. And so you had a
record that was a person which had these things in here. And so when you've got records, you need
references to where that record is held because now it's a collection of data stored on a heap.
And so you can see here, person has a reference to another person, which is their
father, mother, youngest offspring or elder sibling. And so where you've got references,
what do you do if there is no father, mother, youngest offspring or elder sibling? And so Tony
Haw went, well, we'll just call that Null. And so we say, if P equals Null, then M. Otherwise,
if M equals Null, then P. Otherwise, do something with P and M and we'll return that back. And at
the time, that probably seemed perfectly reasonable. But ever since then, hands up who has not ever had
a Null reference exception in .NET or Java or any language they've ever programmed in
or JavaScript undefined does not have a method index of or whatever it is JavaScript says.
So yes, and Tony Haw calls that is billion dollar mistake and will quite happily
tell you all about it. There's a video on YouTube of him doing a one hour talk
at a conference about how Null happened and why it was a bad idea.
Hartford Center. Sometimes software problems actually cause other problems in the real world.
So the Hartford Center was built in the 1970s. It was one of the first buildings that was designed
using a software CAD package, a computer aided design package. And back in those days,
there was no auto CAD. There weren't these high level things. A CAD package, the engineer
and architect using it would actually program in the algorithms, the formulas for the stresses on
various beams and all this sort of thing. And they built the Hartford Center and it was fine.
But the Hartford Center, I think it's in Connecticut or is somewhere in the United States,
it snows. It snows a lot. And the Hartford Center was fine until one night it snowed a lot.
And this happened. Fortunately, no one was in the building at the time. There had been a concert
and everybody had left the building about four hours before this actually happened.
And the problem was that they'd put in the calculations for the beams on how much the
stresses on them were going to be. But what they didn't account for is that the roof is slanted
like this. And you people in Scandinavia, you'll know what happens to snow when it lands on a roof.
It kind of evenly distributes itself like this. And then it warms up a bit and it goes boom.
And they hadn't accounted for the horizontal tolerances on these beams. And so it did that
and a beam sheared sideways and then that beam sheared sideways and then the entire roof collapsed
just because of one error in programming a CAD package. That cost them 90 million dollars
to put a new roof on the Hartford Center. That's not too bad. This one's fun. Night capital.
I like this one because night capital are a hedge fund and they don't like hedge funds.
Although if you work for a hedge fund and you need some consultancy, I will happily come and
consult for you. And my rates are very reasonable by hedge fund standards. Certainly compared to
night capital. What you have to understand about hedge funds is the stock market, the first stock
market was created by the Dutch East India Company. They needed to raise money to build ships, to go
to India to steal stuff and bring it back to Europe to sell it. And so the way they did this was
we'll sell shares in the expedition and then we go and we steal the stuff and we bring it back here
and then we sell it and then how you get your percentage of our profits that we make from
doing that. And then other people went, that's a brilliant way to raise money to start a company.
I'm going to do that as well. And then 400 years later somehow that had turned into highly optimized
programs running in dark pools, trading with each other at microsecond levels, skimming fractions
of a fraction of a cent off the top of the transaction to try and make rich people richer
while the rest of us got poorer. And this is what night capital were doing. And in 1996,
this was all happening in these things called dark pools. So the hedge funds and the investment
banks and everything created their own shadowy stock markets where they could do this. And the
New York Stock Exchange went, we are missing out on so much commission. We're going to create our
own light pool. And so they did and they called it the retail liquidity program. And so everybody
had to scramble to get their algorithms and their programs that were running in the dark pools to
run on the New York Stock Exchange's retail liquidity program. And so night capital basically
copied and pasted a bunch of code around the place and dragged in some modules and all this sort
of stuff and threw it into this new retail liquidity program with about two weeks notice.
And it went in there and it started running and within four minutes it had spent a billion dollars.
And when they deployed it, it was running on eight servers and the deployment rolled out,
but it only worked on seven of the servers and the eighth server continued running this old
code that was the buggy code. And so they went, oh no, it's spending too much money. A failsafe that
was supposed to trigger wasn't working because it came from a different system and the flag wasn't
getting set and whatever was going on. And they went, well, it must be that this new code has
got a bug in it. So we'll roll it back and they said copy the code from the eighth server
onto the other seven servers, that'll fix it. By 28 minutes past nine on the morning that this
thing went live, their algorithm had spent seven billion dollars and night capital didn't have
seven billion dollars. And the rule is you have to settle within 48 hours. And so they had to
essentially bail themselves out. So they sold all their positions, this entire seven billion
dollars worth of positions to Goldman Sachs for $450 million. $440 million. So yeah. And then
the following year they were acquired in a hostile takeover by Goldman Sachs who kind of went, yeah,
you really shouldn't be allowed to do things. That's fun. I like it when a hedge funds lose
money. How are we doing? Halfway through, good stuff. So bugs in space, like it pigs in space
from the Muppets, but bugs in space. There have been lots of bugs in space and bugs in
space are difficult because you can't sort of attach, you can't go, how is this going to work
in space? I know. I'll go into space with my laptop and set a break. You can't do that.
Laptops don't do well in space for a start. So yeah. So just a few of these. Mariner one.
This was one of NASA's very first missions and the computers in those very, very basic.
And so programming was taking mathematical formula and turning them into machine code.
I don't think there was even assembly language really for these guys. And so they would take
the mathematical formula and literally kind of just go, okay, so that would be this and this
and this. And this is what Mariner one would have looked like if it had ever made it to space,
but it didn't. And it wasn't the programmer's fault. It was the the mathematician's fault.
He gave the programmer a formula that had an R in it. And it should have been the R on the left
with a hyphen over the top of it. And what the hyphen means is smoothed over a period of time.
So we sort of, it's going to spike up here and down here and down here and it, but what we want
is kind of the average over the previous like 20 samples of whatever this is, but he just left out
the hyphen. And so they used R. And so if you've got a value where it's supposed to be zero and kind
of plus one or minus one is probably okay, plus two, minus two is probably okay, but plus eight
is a very bad idea indeed. And you're not smooth, you know, so eight and then back down to zero
and then minus eight and back up to zero is probably okay. That's probably normal. But
they thought what they were getting was the average smoothing. And so when it came through as eight,
the guy in mission control went bang and hit the button that blew up the rocket on purpose. So
yeah, if anyone was in Martin Thwaites' talk on open telemetry or any talks about tracing
or metrics or anything like that, it's really important to make sure that the data, your telemetry
data is accurate and that you're getting out the number that you think you're getting out.
Because otherwise you blow up your spaceship and then you have to build another one for
$18 million in 1960s money, which is closer to $80 million today.
You think, actually, the Mariner 1 mission is credited, that missing hyphen is credited
with the creation, the inspiration of software engineering as a discipline. That was the point
at which people went, hey, maybe we should do like what those engineers do when they build bridges
of collapsed and stuff. But that was when we kind of started applying engineering principles to
building software, which did not save the Mars climate orbiter, which had a similar experience.
Although it did get most of the way to Mars, to be fair, the rocket took off, it got it into orbit,
it set its engines going, and it got to Mars and then it crashed into Mars, crashed into the surface
of Mars at a very, very high velocity. And there's still a scar that you can see from one of the
other orbiters that went up there. And the reason for this is incredibly simple. It's because Americans
are stupid. And Americans insist on using inches instead of centimeters. Now NASA are not stupid.
NASA use centimeters for everything. Actually, they use millimeters for everything.
So NASA is like millimeter scale stuff. So they don't say a centimeter, they say 10 millimeters,
because they work with the European Space Agency, they work with Roscosmos, they work with the Chinese,
they work with space agencies all over the world. They work with suppliers all over the world.
You have to be using the same units. And everyone on the Mars orbiter mission was using the same
units. Everyone was using millimeters and centimeters, except Lockheed Martin. Lockheed Martin
were using inches. So to give you a visual idea, if this is me at five centimeters tall, then this is
me at five inches tall. It's quite a big difference. Inches are not centimeters. And so when the Mars
climate orbiter arrived at Mars, its planned trajectory was that it should have gone into
orbit at 226 kilometers above the surface of Mars. And what it actually did was go into orbit
57 kilometers above the surface of Mars, which meant it got caught in Mars' gravity and smashed
into it. So yes, units are important. So one of the good things about F-sharp is the whole
units of measure thing. Can we get that in C-sharp 12 or something, Mads? You're copying everything
else from F-sharp. So awesome having in the room to say that. It's not just NASA, though. So yes,
327 million pounds, dollars for the Mars climate orbiter, plus the 18 months that it takes the
thing to get to Mars. And then kind of going, that didn't work. Should we build another one? Yeah.
But the French, the European Space Agency has problems with their own. This is the Ariane 5
launch. And this is the first ever launch of Ariane 5, and it was a mission called Cluster.
It had four European Space Agency satellites on it. And the tests had all gone perfectly,
the pressure testing and everything. And then it took off and it soared majestically
into the sky. And then some code that they had copied and pasted from the Ariane 4 control
software tried to write a 64-bit floating point number into a 16-bit integer variable.
And this caused the boosters on one side to adjust their vertical, their horizontal thrust
a lot. And so the boosters split off the rocket and that happened. And yeah, this was spectacular.
There's actually, there's a talk kind of similar to this one by Kevin Henney, where he goes into a
lot more detail and he has the code and it's on YouTube. So you can track that down if you want
to know exactly what happened there. But basically, they had seven variables that controlled the
flight path to get into orbit. And four of them were guarded. So if you try to write the wrong
kind, wrong type of data into them, you wouldn't be able to. That one, the one there that caused
that, that wasn't guarded because guarding a variable uses quite a lot of something and they
didn't think they could spare it. And so yes, spectacular. Ariane 5 though, I mean, you know,
since then Ariane 5 has been an absolute workhorse and it's put so much stuff into orbit.
And it's going to have to keep doing it for quite a while because Ariane 6 has just been
delayed again. Enterprise. Half a billion dollars, the Ariane 5 disaster. That's kind of
probably exaturated. But yeah, it's sort of including missed missions and people saying,
oh, no, you're not launching our satellites. We're going to take these to NASA. You can sort of.
So yes. The big rewrite. This was me. This is another one of my mistakes. Same company with
MedFile, actually. We had a product that was written in a language called Goop to Sequel
Windows and it was dying. And I was, can we rewrite it in .NET, please? I've got this new .NET
thing. It's brilliant. Can we rewrite? And they said, yeah, all right. And so I started
rewriting the entire application as a Windows Forms application. And they had four people working
on the old application and me working on the new one. And so they were adding features and doing
all that. And I was trying to catch up to them. But I was getting there and it was okay. And then
2005, 2006 came along and Microsoft released WPF. And it was new and improved. And I was like,
oh, no, it's a new thing. Windows Forms is dead. WPF is so much better and the binding works better
and the design is lovely and all this sort of stuff. It's a shiny thing. I want the shiny
thing. And so I decided that I was going to throw out all the Windows Forms code and replace it with
WPF. And that did actually cause me to have a nervous breakdown and take six months off work.
And then when I got back to work, they did a performance review and they gave me a five,
which was the worst you could get. And I went, why? And they said, well, you just took six months off.
So yes, new and improved. Do not just go, ah, shiny thing and rewrite everything
because you think it looks cool. Probably it only cost them 100,000 pounds in terms of
what they'd paid me to achieve precisely nothing. But it did also cost me my sanity.
And the main sort of thing I got out of it is I know not to do that again.
Recursion. This is just a little bugbear of mine. I happen to read something about
recursion and how recursion is a better pattern than loops. And I just, it's a lie, effectively.
Recursion is loops. It's just a different way of doing it. So if you recurse in a normal application,
you will end up getting a stack overflow error because things go round and round in circles.
And every time it pushes something onto the stack until there's no room left on the stack.
And so to avoid this, there is a thing called tail call elimination, where the compiler recognizes
that that's what you're doing and eliminates that tail call and makes something happen in a different
way. So to avoid this stack overflow exception, so if you look at this, this will eventually
cause a stack overflow because this is 32-bit.net. x86.net framework doesn't do tail call elimination.
And so the jit just produces this code here, which calls countdown and calls countdown.
So if you call this with a big enough number, like in 32.max value, you will get a stack overflow
exception. With the 64-bit jit, they introduce tail call elimination. And so that produces this
code. And you can see that L0014 jump L007. So every time someone goes, all recursion is a far
superior and computer science-y and functionally way of doing loops, point out to them that that's
a go-to. And I can prove it's a go-to because there's the same code written with a go-to.
And yeah, look, there you go. We've got jump, short, L00. It's a little bit different,
but it's one less instruction than the recursion version. And we do our jump,
short, L007 at the end there. And yeah, so recursion can go jump in a lake as far as I'm
concerned. I would like to thank Andrey Shekin, AshMind on Twitter for sharplab.io. If you've
never seen sharplab.io and you do C-sharp development, it's brilliant. You paste some
C-sharp code into it. It'll show you the C-sharp compiler's sort of the C-sharp that it generates
for your properties and async methods and the state machine and all this sort of stuff. It'll
show you the IL that's generated, and then it'll show you the actual machine code that's generated
by the JIT. It's fantastic. JavaScript. Any JavaScript fans in the room? I'm about to upset
anybody because this really was. It was a mistake. That was one of the biggest ones. And the thing is
it was Netscape version 2. And somebody stuck their head around Brendan Eich's door and went,
Brendan, can you knock up a quick language that we can stick in the next version of our browser
so that when you put the mouse over an image, we can change it to a different image?
All right, cheers. How long? A week. Cool. And so a week later, Brendan goes back with scheme,
basically, because if you need to implement a programming language in a week, then you write
a lisp because they're the easiest programming language to implement. So we went, hey, we've
got scheme to run in the browser. And they went, oh, no, no, nobody does lisp anymore. No, we don't
like all those parentheses. You know what's really hot at the moment is that Java thing. Why don't
you make it look more like Java? And so rather than sort of patch the holes and the problems and
everything else, Brendan made his scheme look like Java, which involves changing prefix operators to
infix operators and that sort of stuff. And the other thing was they wanted it to be possible so
that the kind of people who were just hand coding HTML and creating personal home pages could hand
code some JavaScript to achieve these effects. And so they put all sorts of things in there to try
and help these developers. Like if you said if this thing is equal, equal to this thing, and they
were two different types, then JavaScript would go, well, what if I made them the same type? And
then that would work, wouldn't it? Yeah, yeah, that would work. And we ended up with this absolute
abomination of language. But the biggest problem of all is that it's shipped. And then people started
using it. And they can't, you can't fix it. You can't fix double equals in JavaScript. So we have
triple equals and bang double equals. And apart from anything else, that's wrong. So it's just,
it should be bang triple equals. Or I don't know. But anyway, I just think if someone had poked their
head around Brendan Eich's door and said, hey, Brendan, can you create the language that will be
used for 90% of all programming over the next 50 years and run on everything from SpaceX shuttles
to the internet, to watches, to smartphones, to everything else, how long? Brendan would probably
have said, oh, two weeks. What's a smartphone? So yes, here are some JavaScript-y things.
An empty array equals not an empty array, according to type coercion. No idea why that is,
but those two things are the same. I think it's that empty array becomes object, which is not
null, therefore it's true. And not empty array, it coerces the array to zero, which is the size of
the array, and then knots it so it becomes true. So that's true equals true equals true.
Who can spot what's wrong with this line of code? Or why it does what it does?
So in the middle here, plus, plus. So because JavaScript does type coercion,
what it's actually trying to do here is B plus A plus, and then we've got this plus floating here,
and it goes, well, I'm already here. So this must mean plus A. So we're doing the positive value
of A. I'll try and coerce A to a number so that I can, oh, no, it's not a number,
so it becomes nan. Type of nan, incidentally, is number, so not a number is a number.
And then we add the other array onto it, and so B plus A plus plus A plus A is banana,
because, of course, it is. And Douglas Cropford wrote a book called JavaScript,
The Good Parts. Have you ever seen the photograph of JavaScript, The Good Parts,
next to JavaScript, The Definitive Guide? I took that photograph, and I put that on Twitter,
and this was back in 2012 or something, and it got 45,000 likes, and I was, yeah, I'm famous.
But yes, the difference between JavaScript, The Good Parts, and JavaScript, The Definitive Guide
is basically the DOM. It's the document object model that is the bad parts of JavaScript,
according to Douglas Cropford. And he's kind of got a point, because document.all, which is all
the elements in the document, is an instance of object. But if you do type of document.all,
it tells you it's undefined. So you go, all right, does document.all equal, equal, equal,
undefined? And it says, no, it doesn't. And then you go, does document.all equal, equal, equal,
null? And you go, no, it doesn't equal that either. You go, well, if you type coerce it,
does it equal, equal, null? And the DOM goes, yeah, yeah, it does. And they can't fix it.
There is code in the world that relies on that behavior. And so Java, I mean, I don't know
what the cost of JavaScript is, but the fun we have with it is priceless. And yeah, I'm just
quite down with that. So I would like to have some honorable mentions here. Heartbleed, that
popped up a few years ago. This was a serious bug in OpenSSL, which essentially rendered the whole
thing completely vulnerable to attack. And of course, OpenSSL is used by everybody, Google,
Microsoft, Amazon, Facebook, Apple, everybody uses OpenSSL. And everyone was like, how could
this be allowed to happen? And the, you know, that XKCD cartoon of the entire modern infrastructure
of the world, and a random open source project somebody in Nebraska has been factlessly maintaining
since 1996. That was OpenSSL. It was just like this one guy who was maintaining this thing,
that multi-trillion dollar companies were relying on, and there was a bug in it. And none of them
had thought to kind of give this guy's code a read or check it out or anything like that. And in
this year, we had log4j, because it turns out that one of the things you can put into log4j is,
hey, log this. Log this call to another service. And while you're logging this call to another service,
pass it some information. Again, Martin's thing earlier on about baggage. And log4j was, so you
could put something into a text field, and then log4j would log what you'd put into that text
field, except it was a URI that said, execute a Java enterprise bean, there's that word enterprise
again, on this other server, and just pass it all the data that we've got attached to this log while
we're at it. And there is not a single Java application in the world that is not using
log4j. So that was fun. And then they fixed that one. So that wasn't in Java. It was in a library
that every Java application uses, but it wasn't in Java itself. So Java looked okay for literally
two weeks. And then somebody looked at Java's actual, in the box, ECDSA implementation. So
ECDSA is a very complicated algorithm, and it involves three numbers. And one number is the
result of a sum. And the other two numbers, if you multiply the first number by the second number,
then it should equal the third number. And so that was fine. But it turns out that you pass
these three numbers along with your ECDSA token. This might be a JSON web token or a SAML token,
something that you've encrypted using the ECDSA algorithm. And if you pass it in, and so you've
got the numbers, I think they were P, R, and Q, P, and R. And so it's like P times R equals Q.
And so if you set Q to zero and R to zero, then it did P times Q. And does that equal zero? Yes,
it does. And so literally just by sending a malformed ECDSA signature with these two values
set to zero, you could get Java to go, yeah, that's fine. That was in the actual, that's like
the base class library. That was in the JDK. But that one came along. That was fun. So we've seen
some fun examples. We've seen some very, very expensive examples. I would like to finish off
with one example where we basically got lucky that, yeah, programmers make all these mistakes.
We're fallible and we're sort of hubristic and we're arrogant and we do stupid things.
Fortunately, the rest of the world knows that and they don't trust us as far as they could spit a rat.
And so the Soviet early warning system in 1985 was switched on and almost immediately reported
that America had launched five missiles against the USSR. It hadn't what the image recognition
software running on, I don't even know what kind of computers the Soviet Union had in 1985.
I'm guessing they probably involved rocks and bits of elastic. But you know, it wasn't great.
But when they've launched five, it was actually the sunlight glinting off clouds,
but that was incorrectly identified as the rocket trail from intercontinental ballistic
missiles. And this man, Stanislav Petrov, Lieutenant Colonel Stanislav Petrov, on the 26th of September,
sorry, 1983, not 1985, was told that five missiles were inbound to the Soviet Union
from the United States and he should immediately launch the Soviet Union's response. He should
immediately launch what turned out to be all four of their intercontinental ballistic missiles.
And if he had done that, then the American early warning system would have seen those,
and America would have launched all the Minutemen missiles that Eisenhower had built because he
thought that the Russians had 4,000 ICBMs, they didn't, they had four, but he thought they had
4,000. So America had 5,000 and they would have launched all of them. And that would have been
game over, humanity, most life on this planet. And then in another 50,000 years, maybe there'd
be a building here with a software conference with highly evolved cockroaches talking about
programming's greatest mistakes. But Stanislav Petrov said, no, I don't believe that.
I'm not launching missiles based on what a computer says. It can go stuff itself. And so we
did not get World War Three on September the 26th, 1983, because there was a human between the
computer and the missile launch system. And thank God for that, because that very nearly cost all
known life in the universe. And that's how serious some of this stuff is. So yeah, think about that
as you go back to work tomorrow or next week, and maybe just be a little bit more careful.
Thank you very much for listening to me, and I will see you next time.
