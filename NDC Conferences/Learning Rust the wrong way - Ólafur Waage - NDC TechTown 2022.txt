In Sundarst, in 1853, a boy named Vincent van Gogh was born.
In 1880, at the age of 27, he decides to become an artist.
In his early years, he taught himself to draw and paint, but his style changed significantly
under the influence of Impressionism.
His career was very short, lasting between 1880 and 1890.
Quoting the Britannica biography on Vincent van Gogh, his palette at last became colourful,
his vision less traditional, and his tonality lighter, as may be seen, is one of his first
paintings of Montemarte.
By the summer of 1887, he was painting in pure colours, using broken brushwork, and
at times what's called pointillistic.
Finally, by the beginning of 1888, van Gogh's post-impressionist style had crystallised.
The main painting technique associated with van Gogh is something called Impasto, where
the paint is applied directly onto the canvas and then spread around.
It can even be mixed together, using other paints and sometimes your very own fingers.
Very pretty.
This gives the painting a thick three-dimensional texture, and the paint itself is undiluted.
A common practice is to work the paint as little as possible, because the more you
touch it and move with it, the duller and flatter it becomes with each stroke.
The most famous example of this is Starry Night, 1889.
Coding again the van Gogh experience, had the painting been done with flat paint, it
would not have been the memorable piece that it is.
Okay, now I have taught you something.
It's time for a quiz.
It's ready.
Lock the doors.
Is this a painting by van Gogh?
Give me hands for those who think it's a painting by van Gogh.
Nobody.
I have taught you well.
This is Adamorne Breen skating on the Frossel armstead river, even not even the same centuries.
Still dots though.
Still dots.
Is this a painting by van Gogh?
Give me some hands.
Oh, again, I have taught you very well.
This is Vincent van Gogh, the farmhouse in the province, 1888.
Is this a painting by van Gogh?
Any hands?
Scattered hands.
All right.
I mean, yeah, could be early work, could be like inspired by other painters.
That's fine.
No.
No, though.
Still touch.
But in the area.
So Jonathan Bartholth, town path.
All right.
Is this a van Gogh?
Again, scattered.
Okay.
Yes, this is van Gogh.
You can see the brushwork on the head of the crab is disjointed, if you think of it that
way.
Crab on its back.
Poor crab.
1888.
Okay.
Good work.
So hi.
My name is Ola Favore.
I'm a senior software developer at Turtlesack AS.
If you don't like this talk, you can yell at me on Twitter.
I seem to enjoy doing that.
So I work for a company called Turtlesack here in Norway.
We are a consultancy and teaching training company.
So again, if you like our work, please hire us.
We do training as we did here at this conference.
Good stuff.
So this talk is titled learning rust the wrong way.
So the reason why I named the talk that way is, yeah, it is in part about rust, but it's
in part also about learning.
So I hope you will enjoy.
So what's wrong with knowing what you know now and not knowing what you don't know until
later, right?
I love coding philosophers, which is Winnie the Pooh.
Good.
Good stuff.
So what's going on here?
So yeah, as you get my guest by the title of the talk and the introduction, this, yeah,
this isn't one of my normal talks.
The structure itself is a bit of an experiment on my end.
So let me know how you think about it.
Yes, you will learn some rust.
It's kind of enough for me to make a point, but you will also learn about learning the
wrong way.
And yeah, the talk might have a point, but we will go places before we get there.
Everybody ready?
Accepting?
Wonderful.
Wonderful.
So since the title was wrong ways to learn rust, let's do actual wrong ways to learn
rust, right?
Because let's be literal here.
So at least we will have that covered.
While skydiving.
No.
You will not learn rust while skydiving, even though this person might be having fun.
No, I do not recommend learning rust while skydiving.
Next example, as an 18th century aristocrat, since we will be talking about the paintings
from the 18th century, no, not with this.
But for some reason, they have Windows 11 on their laptop.
So not recommended.
All right.
Just to give a talk at the technical conference.
Now we can skip this one.
All right.
So what is rust?
Let's begin with that.
So it's a programming language that focuses on performance, safety, and productivity.
That's kind of their guiding light.
It looks kind of like this.
So here I'm defining a function.
Here's the main function.
Here I'm defining a variable.
How is the visibility for those in the back?
Okayish.
Good.
All right.
So I'm creating a variable called float.
It is of F64, which is the double from us in other languages.
The value of 42.
You don't have to put an F score.
Here I'm creating a variable.
So I'm saying let the mood.
So it's a value because in rust, it's cons by default.
So you have to say that the value is mutable.
So you have to say let mood.
I can ask a question about the float.
No parentheses needed.
Very good.
I can then mutate the value.
And then I can call print line exclamation point and similar formatting style.
So the print line with an exclamation point is something called a macro in the language.
So if you see these, there are macros.
They are defined in a little bit different way.
A way of thinking of them is like what if C macros had types and also looked more like functions, but anyway.
Yes.
Good.
So 2006 personal project by a Mozilla employee called Graydon Hor.
2009 turned into a Mozilla sponsored project.
2011 we have the first bootstrap version, which is rust compiling rust.
And then version 0.1 in 2012.
So it is a new language, but it's again, not that new.
Like when you think of new languages, that's like stuff coming out yesterday.
So at least the idea has been around since like 2006, seven, eight, nine, that kind of thing.
Right.
Good.
So more code examples here.
I have men creating a value.
Here's an integer.
I 32.
So the language talks a lot about borrowing and what is alive and what is not alive and what can you mess with while you are programming.
So here I'm going to borrow my value into the function borrow value.
All right.
So I have the little reference value there.
I can borrow it again.
That's fine.
And I can print out those two, those two values.
So notice that I'm borrowing into the function, but I'm getting a value out of the function.
So the function looks something like this.
So here we define a function borrow value.
Again, the type is on the end is the reference of I 32 and I'm returning an I 32.
Good.
I can create a mutable value within it, which is a copy of the borrowed value.
I can change it in some fun ways.
And then returning a value from a function usually looks like this, which is like the last expression or last statement within the line and with no semicolon.
You can do the return.
So for things like early exits, like if you do an if something, something you want to return out, you can do that.
That's fine.
Good.
What happens if I do this?
So here I am borrowing the value mutably.
So at the mutable reference to the value or as in C++, just a reference, because the thing we had before is a const reference.
All right.
What happens then?
Any hands now?
Since I've been training you on the hands.
Doesn't work.
Does not work.
So here's the main thing.
We're looking at line 11 there.
New value, borrow value, and we're sending in reference types differ in mutability.
The blue line might not be visible.
I can read it out.
Arguments to this function are incorrect.
We expected a mutable reference to ref mutify 32, but we found the regular reference.
So this has to match.
Okay, which is like one of the early walls you will hit with the language.
Good.
So if I have another main, I have my value and how much so my value is mutable.
How much is not mutable?
So here I am sending in my value into the function as a mutable reference.
You can now mute the mutate value is allowed to change the value and how much I'm just sending it by reference.
By the way, I don't have to send it in as reference.
I can send it in a copy, but I'm just showing you the referencing referencing part of it.
And then I can print out the my value and it will have changed.
I take value in as mutable at 32.
I take in how much as a reference to 32.
I changed the value.
We are happy.
This is fine.
I mean, fine, not fine, but but as the language is happy with you, basically the sentences.
So what if I change this to this?
So this is a thing in C++, which is the.
This is a problem people have and we have to learn like in what order things are evaluated.
Like, oh, it's from the left from the right to the left for the arguments and all these kinds of things.
So here I'm sending in mutable a mutable reference of my value and then I'm also sending a reference to my value.
But in within the function, they are different variable, but the referencing the same value from the outside.
So again, hence what's going to happen?
Yes.
Compiler error.
That's right.
So you are asking for mutability from one variable.
You're asking for a non-mutability from another variable, but it happens to be the same variable.
So think of the single writer, multi reader locks that we have where you connect when you can have only have one writer to a variable, but you can have many readers.
So imagine a programming language where every single variable is an MSRV lock, not the actual lock, but the language feature.
So yeah, an immutable borrow occurs here while we have a mutable borrow for the first argument.
This won't work.
Cool.
Let's talk about baseball.
Who likes baseball?
More for American sport maybe?
So hitting a baseball is a relatively complicated skill.
You need speed to recognize what kind of ball is being thrown at you.
You need precision to hit the ball and strength to make sure it goes as far as possible.
In 2018, the batting average was 0.248, which means that the average baseball player had a 24.8% chance to hit the ball.
Okay.
This is not per ball thrown, but for the entire attempt.
How many balls are being thrown at the person?
Some of them can be strikes.
Some of them can be what's called balls.
So there is a bit more to it, but that's the general idea of ball on the way.
So Cal Poly Mustangs are a baseball team that represent the California Polytechnic State University.
The team was founded in 1948 and have competed in what's called the Big West Conference since 1997, and they even won it in 2014.
In 1994, the university published a paper by Hall, Dominique and Caravazos called contextual inference effects with skilled baseball players.
And the reference is also down there if you're looking at this later on.
The study took a group of baseball players and measured their batting averages.
The idea was then to give them extra batting practices for six weeks.
So the baseball study.
They were split into three groups.
One of the groups got thrown balls in a structured order.
15, first of them were fast balls.
The next 15 balls in the practice were curve balls.
The next 15 are change-ups.
A change-up is a ball that starts out looking like a fast ball but becomes a curve ball the other way around.
The idea is that it changes halfway.
They were always thrown in this order and the players always knew what type of ball was being thrown next.
This is sometimes called blocked practice.
So you split the exercise into similarly structured blocks.
The second group got the same number of baseballs.
I keep saying basketballs.
Maybe I should change this now.
They get the same number of baseballs.
But the order, so it's still 45, but the order was random.
So they had no idea what ball was next.
Maybe they knew the last one, but if they were counting, but anyway.
And then there was a control group who did not get any extra practice.
So let's look at the results.
What do you think happened?
Think about what kind of practice this was.
One group got, they knew what they were getting.
So I can know I can practice for one of the balls.
So I will then practice for that.
The other group had no idea.
There's a ball happening.
Then the third group got nothing.
So we have a control group.
So after the six weeks, there was another test.
So we had a test at the beginning, six weeks, and then another test,
where they got 45 random balls.
The control group improved by 6.2%.
I mean, people are getting better or there's some random variation in how you're testing.
So you can ignore the 6%.
Or you can reduce the results by 6%.
The block group, which is they know what they're getting,
they improved by 24.8%.
It's pretty nice.
What do you think the random group hit?
Any guesses around the block?
The same?
56.7%.
What?
They don't know what they're practicing for.
They get some stuff.
And it's like they practiced for twice the amount of time
than the block group.
What's going on?
So this is weird.
So some might say, shouldn't the block practice help more?
Because in the random practice, you don't know what you're practicing for.
You have no way to prepare any sort of mental model or muscle memory
for the throws that are coming.
So we'll get into this a bit later.
So what's going on here?
I wanted to learn Rust, the programming language, not the chemical process.
I had the idea that I am a programmer, right?
I have certain skills.
I had some experience with programming, I think.
Those skills should transfer.
Learning another language, like really learning it, should be easy.
Because I have no C++.
I know JavaScript for crying out loud.
So doing the next one should be easy, right?
So this is not a jab at the idea that Rust is difficult.
Because I don't think that matters.
That's not the point here.
This is a jab at my hubris.
So if you want to do a jab at my hubris, you can do that.
Enjoy it.
So I found that I actually didn't learn that much of Rust
until I really sat down and I really sunk my teeth into it.
Doing a tutorial here or there, doing a video lecture.
No, didn't help at all.
Why?
So as a curious person, I wanted to know why.
So instead of learning more Rust,
I wanted to learn about why I wasn't learning more Rust.
I think this is called yak shaving for some people.
But at least you will enjoy the fruits of that labor.
So I sat down and I read books and I studied papers like these ones.
I wanted to know why when you have a skill beforehand,
it doesn't transfer that well.
Or it's not until you actually sit down and work on it,
only then it actually works.
Let's talk about Pokemon.
Okay, okay, and Rust, and Rust.
So after going through these exercises that cover the basics of Rust,
I used that exercise called Rustlings to begin with.
Very good to recommend them.
I started to look at my older project that I had made in C++.
So with the idea that I would just convert them over.
I have a skill here.
I want to see how this looks in the other language.
I can compare and contrast.
Very scientist.
So, and yeah, this is a great technique.
If you're doing this, if you have an older project,
if you know another language, you should convert stuff over.
So now you have to take a Pokemon quiz.
No.
So the general idea, the only thing you have to know about Pokemon
is that they are of a certain type.
Pokemon look, there are probably thousands, hundreds, whatever.
But they are of a certain type.
There could be a fire Pokemon, a water Pokemon, yeah, yeah, that.
And if a fire Pokemon attacks a grass Pokemon,
they do twice the amount of damage.
If an electric Pokemon attacks a, let's say, a dark Pokemon,
which is one of the types, they do half damage.
And for the black squares, they do no damage.
That's the only thing you have to know.
Now you are a Pokemon expert.
Enjoy.
So what this means is, so I made a project,
I think now 10 years ago, that takes where every pixel on the grid,
I will show you a grid in a bit, is a Pokemon of a certain type.
It will look around the grid, look for other Pokemons,
and then do an attack, do some damage.
And if the Pokemon you attacked dies,
and let's say you are an electric Pokemon,
they will then turn into an electric Pokemon.
Just kind of like this.
Happy how well the GIF looks in this.
So this is the C++ version.
And this is also, I'm going to show you the Rust version later on,
but it will look quite a bit different,
but I had a different parameter for the GIF that I had,
but yeah, it looks pretty, right?
They're growing, they're shrinking, yeah, Pokemon attacking.
So let's look at the C++ code.
And yeah, this is from 10 years ago, so you can totally make fun of me.
That's fine.
So you have an X coordinate, which is the where you are on the X grid,
and the Y coordinate, same grid size, because it's a one by one grid.
The idea is that you have an array of a ray of Pokemon,
you will then get the attacker, which is the first Pokemon,
you get a reference to it,
and then you find out who your weakest neighbor is.
So you create a position out of your position,
you have an out variable, yes, out variable, 10 years ago,
of the enemy position, you have a function called weakest neighbor,
you take in your position, the enemy position, and the list of the Pokemon,
then you will get out the weakest Pokemon around you.
You get the position for that Pokemon,
let's then get that Pokemon itself, and then you fight.
Simple enough, right?
Where you are, who is the weakest, get a reference to it, fight.
Cool.
This is the Rust version.
So in the Rust version, the colors are correct.
So yellow is lightning, the purple one is dark, I think.
I don't know the other.
Green is grass, maybe.
It's very pretty.
Yeah, it has other parameters, I think it's running faster.
So these are more generations than the other one.
Okay, so let's implement that in Rust.
So a Pokemon is you have certain health,
and you can do a certain amount of damage.
I think in the tests I had, they all had the same damage,
but then you had the multiplier,
but it's nice to have a variable for it.
So when you want to implement functions onto a class in Rust,
or struct in Rust, they are separated out.
You have the struct, and then you have the implementation for the struct.
So this is a, what we might think of as a static function.
So this is to create a new Pokemon.
It returns a type of itself.
So here we just create a Pokemon.
You might think of this as an R value that I return.
So remember that I'm returning, it doesn't have a semicolon,
so I'm actually returning the Pokemon out from the function.
So I'm just creating a Pokemon and returning it.
It has 10 health and it does five damage.
Then I have a function.
So you can say it's a function take damage.
It has a mutable self.
So this is a non-const function.
And the amount of damage that I want to take,
and you look here, I'm not taking in reference of anything, just a value.
And yeah, simple as that.
Simple as that.
I reduce the health.
So a battle is then a container of Pokemons.
So Rust has container stuff.
We have here vector.
They work generally similar as the vector that we have.
So I want to implement the battle in the same way I have a static function
to new the battle.
For this example, I'm only going to have two Pokemons.
So I'm not going to have the full grid just to simplify the code.
So I just say Pokemon new, Pokemon new,
and I have a vector from two Pokemons.
And again, I have a battle and I'm returning the battle.
So now I have a battle of two Pokemons.
So let's fight.
Cool.
So because we, when we're fighting, one of the health of one of the Pokemons goes down.
So I want to mutate the, mutate whatever's in the Pokemon.
So this is a way of doing a loop if I want the index for N in I dot dot dot self,
so I can have some length, so self Pokemon length.
So again, same way I'm doing a C++ since I was converting stuff over.
I get a reference to the attacker.
I get a mutable reference to the defender.
And I say fight.
Okay.
Sounds good.
I have the rust teacher shaking his head.
No, this doesn't work.
Okay.
So this is another thing.
So here we have cannot borrow self Pokemons as mutable
because it's also borrowed as immutable there.
What?
So the idea that I had in the C++ version actually has a problem
because in one sense I'm having a non-mutable borrow to a value
and I'm having a mutable borrow to another value,
which is something that C++ doesn't care about.
But here they're like, no, this is scary.
This is dangerous.
Don't do this.
So how would you fix this, right?
Well, what do I actually need from the attacker?
I don't need the actual attacker.
I only need the damage.
So the solution in this case is we just get the damage.
And then we do the attack.
We don't need the actual, we don't need the entire structure
to do a combat when only one parameter of the Pokemon actually matters.
So here's the language and telling you you're being silly.
You should rethink this.
This is not, you're not programming in the wrong way.
The language is saying, please rethink this, right?
So in the actual version, that's what we do.
We just take the values we need out and we use them.
Cool.
Let's go back to paintings, right?
Beautiful paintings.
So in 2008, an experiment was conducted at the University of California.
The goal of the research was to detect the difference between two teaching methods,
masked versus spaced.
They were asked to study paintings grouped by the artist,
what's called masked.
You get a bunch of paintings by one artist.
And then you have to have a quiz after that.
Or they were interleaved by other artists.
So you have artist A, artist B, artist C, and then mixed together.
So each masked participant would get a set of paintings by the same artist,
and you would spend time looking at the style, the next painting,
since it's by the same artist, and look for similarities.
Like look at painting A by artist A, looking next painting by artist A,
like, okay, what is this similar thing here?
It's by Van Gogh in the beginning.
But the spaced participants would get a mix of artists all over the place.
Okay?
So what they would then have to ask, the quiz was basically,
like we did in the beginning, is this a painting by artist A?
Is this by Van Gogh?
In the actual test, they used, like, non-famous artists,
or like they wouldn't have Starry Night, right?
They would have just some artists.
So the results were counter-intuitive.
Because the spaced version did better.
Always better.
Never, like, there isn't a variance here.
So the people who did not get to focus on one artist, the next one, the next one,
they did worse.
Yeah, the people who did not get to do that, they did better, sorry,
all the way around, my brain.
But not only that, yeah, the spaced version with the participants
are not able to study a single painter at a time
and focus on their styles got a better result.
So, and even if the masked version did worse,
they liked that way.
They were asked afterwards, even after they've known the results,
which one do you like?
Do you like to learn one painter at a time to focus on the thing?
Or do you want it spread out and randomly selected?
Even if they knew the results, no, they still like learning one at a time.
They did worse.
They didn't care.
So, quoting from the test,
in experiments 1A and 2 combined,
85% of the participants did at least well in the spaced condition,
as well as the masked condition,
but 83% of the participants rated the masked condition
as equally effective or more effective than the spaced condition.
It's not even slight difference.
No, most people wanted the one same artist.
Strange.
Looking back at our own inability to foresee the benefits of spacing,
perhaps we felt victim to the same illusion
that we have railed against.
So these are the testers, Bjork and Cornell.
And this has been done over many years,
so 94, 99, and 2007, different types of studies.
Namely, the illusion that a sense of ease and fluency
accompanies effective learning,
whereas a sense of difficulty signifies ineffective learning.
In the case of the induction,
in the case of induction, as many as other types of learning,
spacing appears to be sometimes, if not always,
a desirable difficulty.
So this is the word, desirable difficulties.
This is 94.
And this is the concept that's used,
the concept that you see here is the important point,
desirable difficulty.
We don't want things to be hard just for the sake of being hard.
The next slide is not a better version of this one.
I can tell you that this is a Caesar cipher of two.
Now go read the slide.
It's not better.
So this slide is more difficult than this slide.
That does not mean it's better.
So the key concept is desirable difficulty.
So sorry, man.
So quoting Elizabeth Bjork and Robert Bjork again
about desirable difficulties,
they trigger encoding and retrieval processes
that support learning, comprehension, and remembering.
So this is kind of my summary for this.
Practicing easy things is fooling your brain
and thinking that you're doing well.
Okay, good.
So empirical studies have looked at the different learning methods
and strategies that have a positive impact on your learning.
So spacing that we talked about before.
Also interleaving.
So spacing is like spacing out the different types you have.
Interleaving is different kinds of learning,
doing different methods of like,
I want to learn in one style and then I'll learn another style.
Yeah.
Variation, like learn different things as well.
And also this thing, generation.
So what generation is, at least what they were thinking,
is you will be taught something
and now you have to create questions about the thing that you learned.
You will not be given questions.
You will not be given material.
You have to form your own thoughts about this thing.
Which sounds difficult, which it is and that's good.
So that's what generation is.
So there was even a study done.
Cat and Poth, 1978.
So kids were supposed to throw bean bags at a target.
Group A practiced by throwing at a single target,
like these things here.
Group B practiced by throwing at many targets,
either closer or further away,
but never the same distance as group A.
Then a test was conducted to throw at the same target that group A used
and group B did better.
So here we have variation.
Practice different things.
So let's go back to Rust or any language.
So what does it actually take to learn a new programming language?
So is it enough to watch a YouTube video?
Good.
To read a blog post-tutorial?
To watch an hour-long conference talk?
To sit down and program?
More hands, more nods?
No, but you need all of these and more
because mixed together over a long period of time.
This is kind of the key that I've been seeing through obsessing about learning
is watching a YouTube video is one style of learning.
And then reading a blog post-tutorial, watching a talk, doing a programming.
You're interweaving everything that is happening here, different learning styles.
And this also adds time.
So what I've been seeing through all of the studies is it takes time
and different things that you do,
and then at some point you will learn something.
But it is difficult and that is good.
Not the first is difficult.
Maybe it is, but that's another point.
So let's learn programming in 10 days, right?
Or 10 hours or 30 days.
Who has seen the books?
Have they become less common, right?
Learning Java in 30 days or whatever they're called?
There's a blog post by Peter Norwick, which he's very angry at these books.
And rightly so.
So yeah, I don't think you learn programming in 10 days.
So remembering.
So what I can see from the literature, mixing up practice styles,
waiting between study sessions.
So now you have an excuse, right?
I'm not procrastinating.
This is the waiting period.
This is the incubation period between the study sessions.
Don't cram.
That's another thing they've shown.
Cramming has no point.
They've been doing tests on students that,
and I don't have the example of some of them had to really cram before a test.
The others were not allowed to study before the test,
and there was no significant difference between them.
There's even like the, what's it called, the cue cards,
that they would like really learn through the cue cards,
and yeah, there's no difference.
But don't cram.
So, and this is a re-wording of one of the quotes.
Difficult to remember in things,
and then finding the right results strengthens the memory.
I told you something, and then you had to recall it again.
An anecdotal evidence, or anecdotal story,
that I heard about something like this is,
the memories you have of when you were a kid
exist as pictures in your parents' house,
because you go back and you look at the pictures.
So you remember the time you went to the theme park,
or you remember the time you climbed that hill,
because you see it again and again over time.
There are other memories,
but the ones that are pictures in your parents' house,
those are the ones you remember.
So, in 1950s and 60s,
the concept of errorless learning was advocated by B.F. Skinner.
Yes, that's Skinner that you might be thinking about.
So the idea was to give you the information
and then immediately a quiz.
So who remembers what I was doing in the beginning of the talk?
Right.
So we are fetching information straight from the short-term memory.
That was the big thing.
If I tell you something and immediately quiz you on it,
you won't fail the quiz, and then you are an expert.
Right? No.
Yeah, the opposite has actually been shown to be true.
To quiz people later.
So there was a case of,
and I think, yeah, there's another thing I'm going to show you.
There's a case of the,
a class has been taught in multiple ways,
where there was a bunch of quizzes during the whole session.
Wow.
Not seminar, during the whole year,
half a year,
where they were given a bunch of quizzes along the way,
and there was no final exam, and then just a grade from them.
Or there was no quiz and one big final exam at the end with everything.
But then they tested the people again, I think a year later,
and the people who had the one quiz at the end still remembered more
than the people who just, because that's what you're doing.
You're, I learned A, have a test on A.
I learned B, have a test on B.
Then I don't have to think about it.
But those who have to learn everything and take a test on everything,
they had to really sit and, yeah, remember everything that was happening.
So they were given kids a set of hard puzzles, like the anagram puzzles.
Half of them were just said, yeah, it's going to be hard.
Difficulty is just a part of it, and that's okay.
Don't worry about it.
The other halves were asked to, like, explain how they would solve a puzzle.
Like, yeah, you have to solve this.
Tell me how you're thinking about the problem.
The first group did better.
Yeah.
Just saying, like, it's going to be hard.
That's okay.
You're going to fail something.
That's fine.
Just let's go through this.
The other one, we talk about, like, how are you doing things,
or I'll give you a little tip on how to solve these puzzles.
No, no, it's fine to be hard.
There is a festival of errors in, I think, Paris from the 90s.
Where they're just celebrating that we're going to fail.
And it's like a festival for school kids, and it's going to be okay,
and we're going to fail things, and it's going to be hard, and, yeah, it's kind of fun.
So, a question I might throw out there is, isn't this how we learn as programming also, over time?
So, blocking versus spacing.
So, we might think about a specific feature, or we might learn about a specific feature,
but then, like, we don't learn about the vector, and then only use vector for a long time.
No, we learn about vector, and then we learn about algorithms,
or then you learn about, I don't know, something else, right?
So, we do this blocking versus spacing.
Like, we don't, there's not a class on vectors, I don't think.
Variation.
We learn about different programming languages, programming language styles,
different libraries, we're reading other people's code, yeah, all these kinds of things.
Generation.
I mean, we write our own code, we read code by others,
we form questions about the code that needs to be answered.
So, we are, again, not doing this, but over time.
And quizzing.
I mean, I'd argue that code reviews are quizzes that we take every day,
that is the question, is this block of code okay?
So, we take a bunch of quizzes.
All right.
How are we on time?
Good.
So, how are we learning rush the wrong way?
In the same way, we're learning everything the wrong way, basically,
by looking for the easy way out, like I did, my hubris.
And we also fall into the curse of knowledge while teaching,
because I find this easy to explain, so it must be easy for others as well.
I know what subsumption is.
I can explain to you what subsumption is, right?
No, that doesn't work.
So, what is the rusty key to all this?
I like this one.
Oh, I was so happy when I found this image.
Get a bask in this image, right?
All right, good, thank you.
It's going to take time.
That's the key.
It's going to require practice.
It's going to feel difficult.
That's good.
Not because rush is so difficult,
because that's how you get the best results.
I mean, we as programmers are min-maxers.
We think about what's the best way, the optimal way.
And I'm sorry, but the studies show that the best way is the hard way, in a way.
I mean, it's not like learning C++ was easy, right?
Yes.
So, now I'm going to be mean to myself as well.
Unfortunately, in this case, there's considerable evidence that in many situations,
this strategy, which is the one-hour lecture, is rather poor.
From 71.
What are we doing?
What are we doing here?
Just go home.
A lecture may inspire, motivate, and inform,
but rarely fulfills the principles for effective learning.
It's certainly inadequate for developing high-level skills.
71.
Oops.
Students who study the topic and then generate their own questions
score an average of 14% higher than on a test,
than students that use passive strategies like studying the notes
or rereading classroom materials.
Creating questions, researchers found,
not only encourage students to think more deeply about the topic,
but also strengthen their ability to remember what they were studying.
Yes.
When Pablo Casals, the cellist, was asked why he continued to practice,
did cello three hours a day at the age of 93?
He answered, I'm beginning to notice some improvement.
And because, like I talked about, the one-hour lecture is not good enough,
it's 15 minutes until, I think I should be safe, right?
So, thank you.
So, form your own questions, please.
Yes.
So, it needs to be restructed, reconstructed,
that the thing that is going to do the mutation,
the value is not the same thing as the class.
Because the key of the issue, which I think is correct,
is because the self is mutable, that means that the vector is mutable,
and I'm asking for a mutable value of the vector,
that means that I'm asking for the whole vector to be in a mutable state.
So, take it out of the class, because we are asking the class to be mutable,
when we actually don't need it to be mutable, and that's it.
We don't really need that one value to be mutable.
So, I can show you the actual Rust code, it's on GitHub.
I can show you the actual Pokemon code, then.
It's a bit, it's a, it's oddly structured.
But yeah, we don't do the compact there.
That's basically the case.
Any other form questions?
I know it's hard.
I was before here.
Have I found?
The thing I feel I still haven't mastered is the lifetime part,
where you do the lifetime annotation.
I'm still in the area where I will just put the lifetime annotations until it works,
which I don't.
Yeah, exactly.
Which is, which is the, if you do the rustling exercises,
that is what that is, is you have a compiler error,
and it will tell you, like, fix, fix the error in file number one,
and then you fix the error in file number one.
It will read through the tests, and then it will say fix the error in file number two,
and it will go into file number two and read about it.
And the first errors are like semi-colons missing, or the if statement is wrong.
But then it's like, I think it's like 40, 50 exercises.
But, and what I found from the rustlings when I was doing those,
there are no exercises about the lifetime,
because you can do so much with the language without even thinking about that.
Because a lot of the times, if there is, I think it's, if it's one argument into the function,
the compiler will do the lifetime thing for you correctly,
because there's only one way to do it, I think.
So yeah, the whole lifetime thing is weird.
It actually, I found, again, the language kind of guided me in the right direction,
which was I had, I was doing some web stuff,
where you can write rust and compile to WebAssembly and then run that.
And I wanted a callback to the JavaScript code,
and I wanted the callback to be a lambda within rust.
But the thing is that the lifetime of a lambda that is capturing variables
cannot be static or cannot be like globally alive,
which is kind of what is necessary if you want to be callable from outside.
Because you always need to exist, because you never know when you're going to be called.
So in other languages, I might just get a function pointer and just hope that works.
And probably 99% of the cases, yeah, that works.
But actually, like, that doesn't work, and the language will say no to you.
Yeah, one?
On a scale of, I think the entire Rust language is lava, and it's a halo for me, too.
I'm going to be at Rust Fest next year, and I'm sorry everyone, this is my laughing question.
Where are you on that scale?
70% towards the second one.
I like Rust. It's fun.
Yep.
So here's the thing about learning that I, because I learned this way.
So this is the path that I've learned.
Do you recommend learning wrong and then doing a conference talk about it?
In the same way that people sometimes ask me, like, how did you learn C++?
I'm like, yeah, I went to university for four years, and studied there for four years.
So you should also go to university for four years.
Do you recommend this book? I've never read it, so I don't know.
I do recommend the rustling exercises that I've mentioned.
I do recommend doing things in smaller incremental steps.
I do recommend moving projects you have, like smaller hobby projects over,
because there's a lot of walls you will hit along the way, and it will be hard.
Also find a good Rust community to chat with.
There are a bunch of them on Twitter, probably because a lot of them migrated from C++.
But yeah, at least start there and then, yeah, time.
Yeah.
Any more well-formed questions? Yeah?
Yeah.
Yes, yes.
Yeah, like an example I had with the Pokémon code, like I was doing in-out variables.
I was taking references to arrays and stuff.
I have done smaller projects where...
So there's another teaching idea that I've had is to create limitations for yourselves.
And an example is you can write a small hobby project or do a small thing,
but every single variable you have has to be a unique pointer.
All of them have to be unique pointers.
And that creates a bunch of problems, but that also teaches you a lot about unique pointer.
So I've done that kind of thing.
I haven't taken my own older project and done a modern version of them.
Maybe I should, yeah.
Yes.
I think I've done that with TypeScript.
I think that would describe my TypeScript initially when I learned it,
because it was a serverless AWS project with all sorts of...
Everything was async in the code.
It took me a long while to get used to how things worked and how things looked.
I also had to learn AWS at the same time and how this whole...
You have to upload the lambdas up to the cloud and stuff.
So I've done that.
The main issue is, I guess, it's hard, which I think is why last year I did a talk on TypeScript,
because I think I knew it pretty well.
Maybe that was the reason why I knew it that well.
But yeah, I think that's how I learned that.
So if you can, you should try it, because it is difficult.
It is very, very difficult.
And I think it will take a while for you to feel productive.
And for some people, that might feel uncomfortable.
Then thank you.
