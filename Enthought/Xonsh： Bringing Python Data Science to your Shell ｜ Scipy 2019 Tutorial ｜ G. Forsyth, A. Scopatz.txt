Welcome, this is the tutorial for a conch.
If you're not here for a tutorial on conch,
you're really in the wrong room.
But we hope you're in the right room.
Yeah, we think this room is the best, actually.
You made a good choice.
You can introduce yourself.
Hi, I'm Anthony Scopatz.
I work for Quonsite.
And according to the slide, I am both a madman and a poet.
So I hope that this inspires you in some way today.
I'm Gil Forsythe, not Gorsythe.
I am also a madman and a poet, according to the slide.
I currently work at Capital One.
Yeah, that's what I got.
And thanks for being here with us 8 AM on a Monday morning.
Not everybody wants to learn about new show languages
at 8 AM on Monday morning.
So we have a few bits of, I guess, bookkeeping.
And just want to get everyone kind of set up and ready to go.
If you've been to a lot of, or any slide pipe tutorials
before, sort of the usual mode of presentation interaction
is Jupyter Notebooks.
And those are great.
It works really badly if what you're teaching
is like a show language and prompt.
So we actually just do need you to install the stuff.
And then we will be sort of live coding
and have slides at the same time.
And we'll be running around and helping stuff.
But so if all of you can just take a few moments
and we'll run around to Troubleshoot and install Conch,
we highly recommend using Conva for this.
But there's other options up there.
And there's a new release as of last night at 10 PM.
So if you haven't updated since then, please.
There's a bug fix.
Sorry, the code has bugs, like all code.
So yeah, please grab the 0.9.8 release.
And we'll go from there.
So who has Conch installed right now already?
OK, most of you.
And if you don't, just grab it.
It should take two seconds, because it is pure Python,
thankfully.
So you don't have to deal with weird Fortran rust extension
interactions and stuff.
Or Readline.
Readline.
Oh yeah, we don't have to deal with Readline.
Everyone's favorite library.
Three cheers for Readline?
No, no cheers.
Wow, wow, tough crowd.
One cheer, wow.
Nice.
Input RC, there you go.
Thank you, I'll be here all morning.
What?
I'm showing my agent.
Yeah, no, it's all right.
So oh, and we should send out the link to the slides as well.
So the slides should be at condos.
This is, what's that repo called?
Is it like Conch?
Conch, sci-pi, something, something.
Yeah.
While people are installing Conch,
and for people just coming into the room,
please install Conch, I just want
to sort of do a quick poll of the room,
get a sense of who y'all are and why you're here.
So who here uses Bash on a regular basis?
OK, any ZShell users?
OK, Fish.
One, OK, yeah, one cheer for Fish, one cheer for Readline.
Two cheers.
OK, Fish got two cheers.
All right, has anybody used Conch already?
All right, yeah, cool.
One, two.
No, that's better than Fish.
Yeah, that's true.
OK.
Who here really likes Bash?
That's OK, no, no, there's nothing to be ashamed about.
There's an open question.
We're not here to know.
Who here remembers the syntax for a for loop in Bash
without looking at Stack Overflow?
OK, no, no, some people can do that.
That's totally cool.
Who here remembers how to tokenize a non-whitespace string
in Bash without looking at Stack Overflow?
Bold so, I'll believe you.
I'm not going to call you out there.
That's good, it's good.
OK.
So while we get the slides everybody,
I mean one of the things, conscious for many things,
partially it's to suit our mad desires.
But also it was a lot of these things
which seem like they should be simple and easy to remember
aren't.
And a lot of us are dealing on our daily workflows
with language decisions from the 70s,
which made a lot of sense.
But maybe we don't want there to be a difference
between single and double quotes all the time.
Or maybe we don't want to have that many square brackets
in a row.
And so this is an effort to remove that pain
because this should be a relatively seamless and fun
interaction.
And you should just be able to do the things you want to do
without struggling through it.
I think we probably can.
I don't have the slide link.
OK.
Are people mostly installed and ready to go?
I have contra-running?
Cool.
Does anybody not have contra-running?
That would be, I guess, the question to ask.
OK.
We're still going to be talking for just a bit.
And we can catch up as we go.
Also just a quick sanity check.
If you can run, every time we say the sound like co
or something, it's always going to start with an x, just a
fair warning.
So if you can run config, it's x-o-n-f-i-g in your conch
shell, that should probably not say what it says here.
Maybe it should say 0.9.8 at the top just so we're sure we're
on roughly speaking the right versions.
I do have the link, but I don't know of a good way to get it
to you guys, other than I'll just put it here.
So if you want to follow along with the tutorial, you can go
to this link.
So it's conch.github.io, scipy-2019-tutorial, slash
remote.html.
We're sorry about the URL.
Only a little sorry, because it's pretty readable.
But yeah, you can click along and follow.
So you can skip ahead in the slides or go back.
There's some exercises and things like that.
So bring that up now.
OK, I'll let you guys do that.
And then we'll continue.
OK, that seems good.
Yeah, great.
OK, so quickly just an overview of just some things
that you'll see us doing a lot, and you should also
feel free to do while you're interacting with the shell.
We don't have explicit slides about this,
because they're just sort of general overall things
you can do in a shell or in conch anyway.
But if you see us do something, like we obviously hit one key
and something happens, and you want to know what just happened,
please just ask us if it seemed like it came out of nowhere
or we're not trying to make this opaque.
So generally speaking, there's tab completion.
Ah, yes.
Oh, from the tutorial?
There's an L right at the end.
Yeah, so it wrapped a little.
Even the directory itself is not going to show.
Yeah, I was getting, well, the directory doesn't
have an index.html.
I can fix that in a moment, but yeah.
Yeah.
Generally speaking, there's tab completion for almost everything,
so it'll save you time when you're typing.
Be aware of that.
Does anyone not know what tab completion is?
No, no shame.
All right, great.
This will mean less for you at the beginning of the tutorial.
There's a lot of history search functionality.
You probably don't have much of a conch history at the moment,
so that won't mean that much.
But there are several ways to search up.
We'll kind of touch on those a little bit later.
Control R is your friend.
That will kind of give you an anywhere line search back
in your history.
If you start typing a command, you can press up,
and it will do a prefix search match.
So like any line that started with that initial bit
will show up in the results as you arrow up.
And you'll see this sort of ghost text showing up
if you're typing the same command,
this sort of a history match autocomplete thing.
And you can just hit right arrow, or I think Control E,
to sort of expand out to that if you want.
Don't worry about taking all that in at once,
but we'll come back to it.
Ah, yes.
For all the pythonic bits in conch,
and we'll find out what those are a little bit later,
you can always append a question mark to a command,
and it will bring up a little help screen in the pager,
or you can do a double question mark for super help.
For even more, if you've used ipython a fair bit,
this will maybe be a familiar pattern.
Yes.
Probably not alone about not knowing what the Wi-Fi faster is.
I don't think there is one.
It's a UT guess.
UT guest, and should just be an open, wide open network.
Yeah.
Is there another question over here?
I think the SSH doesn't work on the UT guess network.
I think we did discover that, yeah.
Someone posted something on the Slack general channel
on using two-factor authentication to get around that.
Get it as a offensive SSH.
OK.
Yeah.
OK.
Not going to do that live.
We are going to ask everyone questions about that
during the break so we can fix something that wasn't working.
But that's good news.
Awesome.
OK.
Are there any questions?
OK.
Great.
All right.
So yeah, there's, oh, was that a question?
No.
All right.
So everyone has counterworking.
If you ran the config, let me just go into the, OK.
So you should have been able to run the config command
and see some output like this.
So is everyone kind of at that stage?
Oh, yeah.
It's config with an x.
Going to love that x key in the next four hours.
All right.
So we've got our agenda here.
We'll be taking some breaks in between these things.
And we're going to be building up to sort of greater and greater
capability over the time.
These are links.
So if you have the slides up, you
can jump around if you want to.
And there are exercises at the end of each little section.
So let's going to do the shuffle here.
So conch is a superset of Python 3.
So what that means is that all of the syntax that's in Python
is also valid conch.
So if you know Python pretty well or really well
or extremely well, everything should be familiar to you.
And so you can do basically everything
that you would be able to do in Python, right?
Define classes, functions, modules, et cetera.
So we can go ahead and do these along with us
when they come up.
So let's try some in the mount.
These are our first exercises, actually.
So the first one is to compute the product of 2, 3, and 7.
The second one is to import numpy or import sys
if you don't happen to have numpy installed.
And then also define a function.
You can do all this right at the command line.
You don't need to go anywhere else.
You don't need to do this in a file.
So try these out.
You can click on the details to get the answer.
And we'll give you guys a couple of minutes
to try this stuff out.
Also be solving it very slowly in real time.
I think you can go.
Wow, 42.
What an auspicious number there.
My goodness.
Yeah.
Can we import a module, Gil?
Yes.
Wow.
That's pretty impressive.
I want to just take random numbers.
Yeah.
Oh, we're in a redline.
We should probably get a redline.
Yeah.
Sorry.
We're not out.
Nope.
I'll still in redline.
Are you doing that random start like again?
Yeah.
There we go.
Somebody stop and close this one.
Sorry, I was in developer mode right there.
There we go.
So you're saying, yeah, you should
see there's a lot of tab completions available.
So if you import, or I'll do sys actually too,
because that's one of them.
You can just hit tab after the dot,
and those will be all of the attributes and modules
that are available in sys.
Yep.
I forgot the last one.
The function.
Oh, cool.
Does anyone have any problems or questions with these?
Pretty simple, right?
So this is just to prove to you that Kant really is Python.
So can you find a function that's already in the system?
Yes.
Yes, you can.
Well, we will get to that question.
Later.
So Dhar Haas's question for those of you
who are listening at home was, can you define a function that's
command on your system?
And the answer is yes.
And we'll get to how all that resolves and works later.
So great question.
OK.
And we'll get to it pretty soon, I think, actually.
So Kant is a shell.
So Kant is also a shell language.
Or more precisely, it's really a scripting language
that is mostly shLing compatible, which if you go back
to the 60s and 70s, sh is a shell language
that we all have inherited, a la, bash, and zshell,
and other languages like that.
But unfortunately, it's actually impossible.
The syntaxes collide, and it's impossible
to be both a Python and shLing compatible language.
And so you have to kind of choose.
And in Kant, we have chosen that Python will always win.
There's a couple of reasons for this.
But mostly, it's that Python is the same language,
and sh is not really sane in some ways,
like the splitting strings on non-white space characters
and the machinery for how all that stuff works
is kind of crazy if you dig into how the shLings work.
But Python always wins.
So if you've found a place where Python syntax isn't working,
that is a bug.
You should please report that.
Should we do an L, shL?
Yeah.
Yes, sure.
Just as an example of this, there's issues where,
so this is a command that you may be familiar with.
But this is also a valid Python syntax,
if L, shL are defined.
So the rule is that if one of those things isn't defined,
it'll still function.
You can just delete the variables.
But it is possible to overwrite those built-in names.
And there's a way to escape that, which will.
This is just a convenience, but that we'll get to in a bit here.
So the purpose of the shell is to run commands, obviously.
And so we've got some commands here.
So we just saw L, s, dash, L. A simple one.
Yeah, please type this out if you want.
Just prove it to yourself that this works.
You can do echo.
You can make directories and cd into those directories,
touch files, do all the kinds of normal things
that you would want to do.
And I think I actually have all the test code here still.
And the other thing that you can do is you can pipe.
So if you're familiar with piping from other shell languages,
you can take the output from one command
and make that the input to another.
And so that all works normally like you
would expect in conscious well.
And basically, under the covers, this
is a horrible abuse of the sub-process module,
as you would expect, with a lot of fancy features added to it.
OK, so the next bit of kind of basic syntax in the language
are environment variables.
So these function a little differently than other SH
languages, but similarly.
So you can refer to any environment variable
by prefixing a name with the dollar sign character.
So if you want to look up a variable in the environment,
you can say dollar sign that variable name.
And then you'll get back the result.
So the environment is this special namespace
that processes use to communicate with each other.
And Conch gives you access to that.
And you can set and delete environment variables
more like you would do in Python than you
would do in other shell languages.
So these are just normal variables
that happen to live in a special dictionary mapping
somewhere.
And so because of that, you would set them with an equal sign,
and then you would delete them with the Dell operator.
So shouldn't be anything too out of the ordinary there.
Anyone have any questions about that?
So any difference between this and OS environment?
Is there any difference between this and OS environment,
OS.environ?
And the answer is yes, there's a lot.
We'll get to that in a section coming up.
And yeah.
The first one is will export still work for environment
variables?
No.
Export is not a feature of Conch.
Or so exporting.
So OK, this is getting into the weeds a bit.
But I think export is a bad idea.
You shouldn't need to explicitly export things.
You're already doing that with the dollar sign.
So shlangs, when you export or when you define an exported
variable, actually don't put the dollar sign.
So we've collapsed those seven characters, export plus space,
into just the dollar sign.
So we can assume these variables are full?
Well, they're process-wide.
Yeah, they go into the environment for the process.
Yeah.
And the other question is what about dollar zero?
So the question is what about dollar zero?
Dollar zero is how you refer to arguments,
or you get the command that you run.
We use dollar args for that when you're running a script.
It's an environment variable.
It's in the docs, which we'll have a link for very shortly.
So OK.
I just realized this screen, we're standing in front of it.
Yeah, OK.
But we'll maybe fix that during the break.
OK, yeah, this is pretty normal.
The other thing that you can do is
you can do environment lookup with Python expressions
using dollar sign curly brace.
So if you want to compute an environment variable arbitrarily,
you can use dollar sign curly brace.
So this is a little different than how other languages do it.
But for example, say you have an x variable that
equals a string in your namespace, so your user.
You can do dollar sign curly brace x,
and then that'll look up the user environment variable.
So that looks up the name.
Oops.
Sorry, I skipped ahead.
And or if you want to compute it with some other expression,
you can just stick that right in there.
In most SH links, these are actually dollar sign
and dollar sign curly brace have effectively the same meaning,
but they have distinct meanings here.
Effectively, there are subtle differences, I know.
But they're very different here.
OK, the source command.
So is everyone familiar with source and other languages,
like bash and things?
OK, yeah.
So if you're not, what source does
is source takes a file that's written in that language.
So if you're in bash, you can source a bash file,
and it will run the commands as if you had typed them
into that session.
So it's just a shortcut for executing everything
in a file in your current interpreter session.
So conch, the source command does basically the same thing.
It reads in the contents of a file,
and then it executes them.
And it brings all the global variables
and everything in the environment, et cetera,
into the current execution context.
But of course, this doesn't work on bash.
This works on conch code.
So if you have a very simple example file.
Yeah, sorry, this is.
Yeah, you can do that.
So here, what we have is we're setting an environment
variable in this file.
We are setting a password, which is a terrible thing to do.
And then we're defining a function.
You can install VAM right now if you want.
Go for it.
See if I care, Gil.
Yeah, I can't do that to your laptop, but it just seems main.
How do I do this?
Well, I mean, we're talking about sharing passwords.
So I'll just say my root password out right now.
Yeah, so you can then use this function in its scope.
So basically what you do to use source is you just say source
and then the file name.
So here, source example.xsh.
And then you'll see that those variables that we had,
like $email, are available, as well as the combined function,
has been brought into your current sessions execution
context, and you can run it.
You can also import .xsh files as well.
So if you want to write Python modules as conch files,
you're totally welcome to do that.
And you can import them even in other normal Python projects.
I'm not going to show that here, but if you're interested,
that's something you can do.
OK, any questions on source?
Pretty simple.
All right.
The thing that you can't do in a lot of other languages
that you can do in conch is that we
have a notion of sourcing files from other shell languages
that we call source foreign.
So imagine you have some bash script somewhere,
and you want to bring that in and execute that in conch
and bring all the things into your local execution context.
You're able to do that just by saying source bash
and then the bash script.
So if you've got 100,000 lines of Z shell, well, one, I'm sorry,
and two, you can still use that.
So this is a way to slowly integrate with other languages.
Which is pretty cool, actually.
So that's pretty nice.
And by default, sorry, we have a source foreign
is a generic infrastructure for doing this,
but we have shortcuts for doing source bash, source Z shell,
and also source command or cmd.
So if you're on Windows using the Windows batch processing
language, you can source that stuff too, which is madness.
But I mean, we've got a core Windows developer
for the past four years who's like, it works pretty well.
I mean, I imagine there's folks here using it on Windows, right?
So are there any Windows users in the room, actually?
OK, cool, let it.
I mean, who are on Windows right now?
Please let us know how it's going.
I mean, seriously, I think the biggest problems are usually
just that our examples are very like Unix-y.
And so we say, run this command, and it's like, what command is
that?
That's often the problem.
Oh, OK.
Well, so we found with that, if you're on a base Windows
install, and you just install git bash,
then you get all the Unix-y commands,
and everything works normally.
And supposedly, it works really well on Windows subsystem
for Linux, but I have not tested that.
Since I'm on, I'm in the same situation for WSL2.
Do you want me to just try to run everything with all of this?
I mean, you can.
We would be very happy for you to do it.
We may not be able to help if it goes wrong, but we'll try.
OK.
I saw another question over here somewhere.
All right.
OK, so source foreign, really nice capability, really helpful,
especially if you're just getting started.
The other thing, like most shell languages,
we've got a configuration file that lives in home.conchrc.
And this is just a particular special xsh file
that's loaded before basically everything else is loaded.
So this is where you can stick all of your customizations.
Mostly, a lot of people just stick environment variables
in there.
If you're a condi user, conda, activate or whatever,
and it will throw some stuff in there as well.
And yeah, but basically, if you want
to read about all of the customizations,
they're in the doc.
So every environment variable that we touch
has documentation associated with it.
And there's a lot of tweaks that you can do if you need to.
All right.
So here's some more exercises.
So let's go ahead and take a few minutes to do these.
So the first one is to just set a random integer
to the environment variable $secret.
The next is to print the secret value.
And then the third is to put a generating,
just some generating code for that secret value
into your conchrc when conch starts up
if a dollar sign safe variable does not exist.
So we'll give you all a couple moments to try this out.
And if anyone's having problems,
just raise your hands right now
and Gil and I will walk around and help.
The next thing, or for part two,
there's actually a couple different ways to do this.
The first is that you could either echo that.
So if you're thinking more in a shell language,
you could echo that.
My secret value is $secret as a string
and that will all push out normally.
Or if you're in more of a Python mode,
you can just print it like you would print anything else.
Both of those are totally valid.
And then the last one is if you wanted to,
this is getting cut off I guess,
but this is why you have it on your own machines too.
You can say in your conchrc,
because it's Python, you can import random.
Because it's conch, you can set the environment variable
to whatever random value.
And then, oh, we actually didn't cover this in text
in this exercise.
But, because we've moved around some slides,
but we'll get back to that last one soon enough, so.
Okay, so very briefly.
So remember how we said dollar sign curly brace
is an expression, you do look up by expression.
So this dot, dot, dot in Python
is the syntax for the ellipsis object.
So we use that, numpy uses it too.
So we use that to be a reference to the environment itself.
So if you do dollar sign curly brace, dot, dot, dot,
you get back the environment object.
Because dot, dot, dot is obviously not,
or an ellipsis is obviously not any environment variable.
And it's a big mess,
which is why we didn't wanna cover it this soon.
But there it is, and we will get back to it in a bit.
Okay, so yeah, the goal here is like,
because it's just a mapping,
you can test if things are in the environment
through the self lookup.
Okay, wow, a break already?
That can't be right.
No, probably not.
Okay, so we're not gonna break,
yeah, because it's too early.
I built up your hopes,
and then I'm just crushing them right now.
Crushing it, yeah.
Okay, so Gil's gonna take over for this next part.
And maybe.
I'm not gonna move this one.
Yeah, yeah, it's impossible.
Okay.
Okay, so we've sort of looked at,
you can still run sort of a sub process command,
like a regular terminal command, shell command.
And you can also run Python modules and functions,
and you can sort of set them to environment variables,
and then use that.
But where this really starts to come into play
is when you wanna be able to start mixing
those two things together
to sort of get the best of both worlds.
So the idea here is that,
in a lot of ways, conscious makes up,
using sub process really, really simple.
Instead of trying to remember,
wait, you set this sub process.pipe thing somewhere,
and how are you gonna parse the output and all that.
We just, all that's being handled for you
in sort of a more intuitive way.
And we have a number of operators we've added
to sort of help with this interaction
between sort of sub process mode and Python mode.
So the first of these is dollar curly brace.
Or parentheses.
Parentheses, yes, sorry.
I do remember what these are, sort of.
And what it does, actually similar to bash,
is it captures the output of a command,
but then it returns it as a string.
And it really does return the whole string, right?
So the output of LS has a bunch of line breaks in it,
so there are a bunch of line breaks in the output.
What that means is that if you print it,
you actually get what the output of that was.
Similarly, it is a string, right?
Like a Python string.
So if you type X dot and then hit tab or something,
or just like you have all of the Python string methods
available to you.
So if you wanted to split that, say on new lines,
which might be a useful thing to do with LS,
or you really like uppercase letters,
and you wanna do that,
or however you want to mutate and parse and change
that captured output,
all of sort of Python's built in helpers
are already there for you.
You don't need to sit there
and like try to write these things yourself.
Okay.
Okay.
So the second is bangParent,
and this does the same thing,
and then also other stuff.
So what it actually is returning,
if you run a command with this,
is a command pipeline object,
which is sort of a const thing.
And it includes the output of the command as well,
but also a bunch of information
about like the PID of the process,
what the return code was,
what the actual argument you ran was,
if it was an alias,
what did it expand out to,
what are the starting stopping timestamps of that command,
and also this object itself is truthy.
So if the return code is a success,
then you can actually say like,
if bang this command,
like print this command,
and if it's successful,
then you can use that for control flow.
So there's sort of a way to easily figure out,
like I tried to do this thing,
was it successful, yes or no?
What was the output if it was successful?
How long did it take?
Like all of this is just available to you
in sort of the command pipeline object that's returned.
I think this is what I just said.
Yeah.
I didn't do a failed command, but that's okay.
That's all right.
Does anybody have any questions about those?
I am ready to choose the negative condition.
Yes, in some, although in Python, it's a tilde, yeah?
Yeah, yeah, that's right.
So in Python, if you wanted to negate something,
you use not or tilde,
or tilde is the invert operator, but yeah.
Yeah.
Oh yeah, also so you can iterate over the output
of these commands line by line.
In bang exclamation point.
Yes.
In enumerate ls and then print, what is it, f string?
Mm-hmm.
And then just i and loke.
Oh, probably should have stripped loke, but that's.
That's okay.
That's okay.
We can do it next time.
Yeah.
Or this time.
For example.
Right, so the new lines are still in that loke,
in that object, that loke object that ends up there.
And this is streaming, by the way.
So that if you wanted to stream through your command,
right, if you got output that's larger than memory,
this is how you would bang parentheses for that, so.
Also in the list of things that we may have not mentioned,
there is this multi-line prompt thing that keeps happening
that we've just sort of been using without mentioning.
But yeah, so it's like in the same way
that I Python functions,
this is a full, you can just keep,
as long as your, you can either shift return to maintain,
like to force a new line,
but as long as the command isn't complete,
it'll just keep adding a new line for you to type on.
Two entries at the end will run the thing,
and then when you arrow up through your history,
it will load up the full command,
like the full command block for you,
you don't need to like go and hit arrow up
for each of those individual lines you were doing.
Right, so I just hit arrow up there once,
and I returned the whole input, so.
And arrow down, returned.
Okay, thanks.
So we just went over those are captured sub-processes,
and then there are uncaptured sub-processes.
So here again, we're using dollar sign and bang,
but this time using square braces.
And they function the same way as the captured ones,
except they don't capture.
And so the output of the command
still goes through to the screen to standard out,
or standard error depending,
but you can still capture that metadata along with it.
So in the case of dollar sign square braces,
it always returns none, actually.
And so this is more for forcing sub-process mode
where a context may be a little ambiguous,
and you wanna say like don't try to interpret this as Python,
just run this as a command instead.
The bang bracket there.
So the output gets streamed to standard out still,
so you see it and it runs as if you just ran
the command regularly, but at the same time,
similar to the information from the captured sub-process
about the starting and stopping times,
the arguments that were passed in,
if it was successful or not,
all of that is returned as a result of that operator.
So you can have the output still showing in front of you,
but still be operating on what were the conditions
of that command that it executed successfully.
Should I stop?
Should I continue?
Right, so you get this rich command pipeline object
back out that you can manipulate.
And this particular bit of syntax
is the thing that really underlies a lot of conch.
So if you just run LS here, what conch is doing
is it's secretly adding in a bang square bracket
around that LS.
That's it.
Yeah.
Okay, right column tight, good.
Oh, good, yeah.
So now, I would suggest we just take a few moments
and just to play with each of these a little bit
to get a handle on them.
This is basically the end of new syntax
that we're gonna introduce largely.
Wait, except for one big one coming up.
But just to kind of get a sense of how they work,
make sure that they match your expectations,
like what should be captured, what shouldn't be captured,
how do you interact with the attributes
of these returned command pipeline objects?
What is in there?
Is there something you would like to be in there
that's not, we can talk.
You can definitely work on that.
And just as a general mnemonic for this,
because it's a bunch of stuff,
I've sort of come up with curly captures in square streams.
And it's a bit misleading
because it's all sort of streaming in one sense.
But like if you want output to not show up,
use the curly things.
If you do want it to show up, use the square things.
Does anyone have any questions about this stuff?
No, we just threw a lot at you.
Yeah, back there.
So the last one, we put bang-square-bracket,
but that will print it and not save anything from the variable.
Almost, so bang-square-bracket prints it,
but does save it to the variable.
And then bang parentheses prints it,
but then doesn't save it to the variable.
I know, yeah.
So basically what's going on here is that
dollar sign parentheses returns a string, right?
It doesn't print it.
But if we wanted to stream that, so we use bang,
what should that return?
Command-punch-line, sorry, is that all right?
Yeah, so what should that return?
None, right?
Because, oh, no, it's not none here.
Did I do something wrong?
Yeah.
What did I do?
Did the guy-
No, it's not.
That was, no, not, no, it's not.
Oh, it's still, maybe it's not,
it's like when you do a sign,
no, that's still the thing, so.
Oh, no, sorry, ha-ha, I did this wrong.
Yeah.
So if you do dollar sign,
if you change these to square brackets
because you want to stream,
because square brackets kind of look like pipes,
that should return none rather than a string
because there's nothing to return.
You're already, the output that's coming in
has already been consumed and printed,
and so it's been streamed
and there's nothing left to return.
Which is why you see like,
because we did this is none,
we actually got this true printed behind us
even because the command actually printed, right?
We didn't capture it.
If you wanted to capture it,
or if you wanted to do bang parentheses,
the bang is what gives you the object back,
and whether it's streaming or not
is determined based on whether it's square brackets or not.
Yeah, so the way to think about it,
this is dollar sign, return strings,
and bang will return something else,
and then square brackets,
or in parentheses we'll capture,
and square brackets will stream.
Nine, yeah.
So what is then the difference
between bang with square brackets
and just typing the LS command?
There is functionally no difference
between bang with square brackets
and just typing the LS command
except in ambiguous cases.
So in cases where you have both a Python function
and a system command with the same name
or a Python variable
and a system command with the same name,
like say I just said echo equals wow or something,
right, if I now went to run like echo
hello world,
well that'll work because the syntax is not ambiguous,
but like let's say I went to write like echo
like dash,
what's another echo minus echo for example,
which would be totally normal?
Well, okay, but wait,
we would want to print minus echo, right,
in a normal shell,
but both of these are variables.
And so if you need to,
you can always explicitly put it in bang square brackets
and then it'll run.
So I can escape from sort of the Python?
Yeah, so there's two things going on here.
So, or there's one thing going on here, one or two.
So there's many things going on.
If you're observing it, there are two, and then.
Yeah, it's complicated.
Basically what's happening is
there's a formal conch language
that always uses bang square bracket, okay?
And then we have what we call,
so there's a context free grammar that we use
that always uses the square brackets.
Then we do this context aware grammar munging.
So we know, because we know what commands are available
and what your execution context is,
we can, we actually go back and rewrite the AST
of your code in such a way that we think it will execute
before we try to execute it.
And that's what's going on.
And so if you need to,
you can always go to the formal grammar.
And you can even turn that off
in the exact, we're definitely not doing that
in this tutorial, but you can turn that off
and make sure it's always formal.
That's a terrible way to live
because you always have to type this bang exclamation point
and the whole idea behind conscious
to make the things as easy as possible
and match what your brain thinks it should be doing.
Like your brain thinks, you know,
LS-L should be a command.
And just because that's not a Python variable
doesn't mean it shouldn't be something that works.
And so we have a lot of like heuristics
that are relatively simple that get you incredibly far.
But if those heuristics fail for some reason,
which they are, they, it's very, very infrequent.
You can always go back to the formal grammar.
So.
Yeah.
Yeah, I should maybe say curves,
mnemonics are hard.
So the curly braces are for,
like with the dollar curly braces
for like an environment lookup
or for accessing the environment.
Whereas these are more just generally capturing
a command that you're running
and capturing the output of it.
Right, so this looks up a variable in the environment.
Yeah, rather than, yeah,
rather than running a command.
So, yeah.
Okay, so the question is,
what's going on here?
So you're saying LS equals.
So if you say LS equals one here.
Okay.
And then you say LS,
then you were saying LS.
Right, so why does this happen?
Well, this happens because L is not a variable
in your Python context.
If you just do LS and then we dot it, right?
This is a LS itself is just the integer one.
Right, the, the, the, the bang square brackets
are capturing the whole thing.
So yeah, so if I set L equal to one
and I do LS minus L, you'll get zero
because they're both variables.
Python always wins, right?
So the Python invi, the Python context always wins.
Yeah.
Your system is whatever.
Nothing.
All right.
Okay.
Having thoroughly confused everyone,
I think now we can just take a few minutes
for people just to play around with these a little more,
get a sense of what's capturing and what's not,
what comes back from these commands,
what's returned and what's printed,
just to build up a little familiarity with it
and then we'll continue on.
And feel free to raise hands
and we can either circulate or just answer from the podium.
And we can fix this curly captures thing.
Yeah, yeah.
That's mnemonics.
Is anyone having issues with their system still
or, or installing or anything?
Yeah.
Or do you want me to come over?
Just really quickly, we had a question about,
for people who have used VI mode in terminals
or in shells before and want to do that, you can do that.
You just need to set VI mode equals true.
Yeah.
And then you can bounce around your current line
using, you know, zero G, whatever.
Yep.
And then we'll just load it by default.
Yeah.
All right.
So I think Gil, you want to take it away?
I will take it away.
Are there any lingering questions
from our, our personal explorations?
Great.
You can also ask us later.
That's fine.
Yeah.
So the, I think this is really the last bit
of new syntax we're going to introduce,
but I could be wrong.
I'm wrong, but for a while it'll be fine.
So this is the, the Python mode operator.
So we've been talking for the last bit
about how you kind of capture sub-process output
and then, you know, turn it into like a Python string
of this command pipeline object
and then how you can play around with it
and inspect it and do things with it.
But the, the at paren operator lets you go the other way.
It lets you insert things from your Python
sort of scope or environment into a sub-process command.
So what we mean is generally conscious,
like parsing is pretty clever at this stuff.
So if you give it, for instance, this command,
like for something in range two
and then just run echo high underneath that,
it will do the right thing, right?
You can put your like echo or LS
or whatever sub-process command you want
in the body of a for loop
and it will just execute as many times you tell it to do.
And you don't need to do anything special.
That actually just works.
What does not just work is if you do this.
So you want to instead, you know,
iterate over the value in the for loop
and have it be printed.
You just get I twice, right?
So because it runs that command twice.
And so what the at parentheses operator does,
it lets you capture that Python variable
and insert it into that command.
So what it does, what it's actually doing
is it's evaluating an arbitrary Python expression
and then returning that value as a string
and that can be fed into the sub-process command
in this case echo.
And if the output is not a string
in case of like lists or sets,
it just gets joined and returned as a string.
So that's what that would look like.
So it's a little different than that actually.
Sorry to want, want, want.
Each element of the string is actually getting
passed in as its own argument to the command.
So each of these are their own command arguments.
So, and it's just that echo happens to join them together.
Yeah, thanks for closing the door.
We're gonna close it.
Okay.
Any questions about this syntax or what it's doing?
Yeah.
So if you didn't use echo,
we said echo runs together,
if you use something else, what would it look like?
Yeah, so like if we did LS,
LS would try to search for all of these files individually.
So it's running it on each?
Yeah, it's running it for each, yeah.
Cause LS takes a big argument list like that.
How does it know when it can iterate and when it can't?
If it's iterable and not a string.
Right?
Yeah, the normal way.
Okay.
Yeah.
Just to clarify, echo here and LS,
the book I called once.
Yes.
Yep.
And it just, right, echo put them all together
because that's what it does.
That's what LS does.
Yeah.
Yeah.
It's just passing each Python thing as its own,
each element of the list in its own argument
or tuple or whatever.
So.
So it's essentially echo zero one two.
Yes, exactly.
It's essentially echo zero one two or echo, you know,
or LS zero one two.
Yeah.
Okay.
Oh yeah.
So if the result of the operator two is in the first
position, it gets treated as an alias.
So you can actually have this execute commands.
Probably like not something you want to do.
Don't do this.
Mine is a really bad pattern, but it does that.
Right, but this is different because if you,
I've got my trace back printing on,
but you can see if you try to just print this
or if you try to run it without splitting,
that is treated as the command,
the name of the command spaces included.
And so then it can't find the command because hello,
hello there, echo, hello there is not a valid command.
Okay.
Your promise for more syntax is already broken.
You should just stop.
I'm going to stop saying it now.
So with apologies.
So you can wrap a regular expression in back ticks.
And what it will do is return a list of every file or,
you know, thing in that, in a directory that matches
that regular expression as a list.
And it's a Python list, which means you can iterate over it.
You can, you know, like stick it in a list comprehension
and, you know, like mutate all the names.
And you can actually do even more stuff with these things
as you kind of go along.
If you're, oh, sorry, yes.
Yeah.
So, what's the next thing you're going to do?
What's the next thing you're going to do?
What's the next thing you're going to do?
Oh, sure, yes.
It's the Python regex, yeah.
Yeah, it's just the RE module.
Yeah, just a handy way to get into RE.compile.
Yeah, yeah.
No, no, these are not globs.
Dot star is a regex.
A glob would just be star.
Any dots and then XSH.
Yeah, anything.
So, maybe a better example would be what's a...
Oh, it's...
What can I do?
Okay, so we've got some pings in here, right?
So, like, what if we wanted to,
if we wanted to, like, grab,
I guess we don't have a lot with anything with...
I want pngs that have the letter O in them.
Yeah, so, like, that's right, yeah.
So, do dot star O dot star dot,
or slash dot png.
But also, regular expressions are hard.
So, if you wanted to use globs,
let's just say somebody had mentioned that,
then you can prefix the backticks with the G,
and then it is glob matching.
So, you don't need to do the dot thing,
that's just, you know, like star dot md,
star dot png, star whatever.
And as an extra special bonus in Python,
I think three, six and above,
this supports recursive globbing,
the way that the glob library does.
So, if you do, like, star star slash star dot md,
that will recursively glob through the entire directory
structure from where you are,
and find every single markdown file in that whole chunk.
This can take a long time.
Like, use this, you know, like,
if you run find at your root and it takes forever,
like, same thing.
But it's really, really handy for finding
all the sort of files or patterns
matching something in a large area.
Any questions on this before we go on?
All right.
So, I'm curious as to the use cases
of letting you guys to create all of these.
Yeah, so, we can't, we can't,
I'll say this, so the question is like,
what are the use cases that led us to create all these things?
And just as a general, like, cont creation story,
almost everything in here is something we were like,
you know what we really need to do,
thing we need to do today is this thing.
And then we did that.
So, they were all created from actual,
and us and other contributors,
people who were like, I really need this to do thing X.
And then what we discovered along the way
is that a lot of it tied in together really well,
without us having to do anything extra.
We'll come up on some of that stuff around the way,
some of the string matching and string literals work.
So, like, one thing I just showed,
for the globs in particular, right?
Like, being able to loop through a glob list is,
with this syntax is a lot nicer, right?
Yeah.
You're doing that a lot.
Yeah.
So, at what point do you switch between writing a script
and conch through just writing a Python module with a CLI?
Like, is that a size?
So, yeah, so the question is about trading off
between Python module CLI and writing something in conch.
For me, it's really about how much you're hammering
sub-process, so if you're interacting with sub-process
a lot, like, do not write it in a Python CLI,
write it in conch.
If you want some of these extra fancy features,
like, you really just want to be able to globtick things,
like, very quickly, or you want to, like, search through,
whatever, then, like, do it in conch as well.
That's my kind of, we'll see some other syntax later
where there's conch-specific things,
but at this point, it's kind of like,
if you're doing a ton of, like, basically scripting,
you know, like, then you should be using conch,
because it's actually meant as a scripting language
unlike Python.
Do you have examples of, like, CSD pipelines
and stuff like that?
Oh, yeah.
Yeah, yeah, well, we can talk about those afterwards.
Yeah, yeah, yeah, for sure.
Yeah, for people who work at a certain institution,
they can also use all my internal ones, just saying,
like, sorry, everyone else.
I'll show you other things, but, yeah.
Tom, I think you're next.
Can I import conch and grab some of this stuff
directly in Python?
Yes.
Yep.
So the question is, can you import conch code
and use some of this stuff in Python?
I mean, like, can you, personally,
like, if I just want this, like, nice,
some of this, like, string matching,
can I do, like, conch.giv me the list of files
and have it.
So we don't have a, so yes-ish,
we haven't, we don't have that particular use case
lined out so much, but,
so I would say there are two things there.
So one, we have a quote unquote standard library
where we have sort of extensions and updates
to standard library things to make it easier.
So you can do, like, import conch.lib.os
and you get some, like, you get a remove tree
that actually works on all platforms
and you get, like, if you do, like, sub-process,
you get a version of run that uses our thing
and returns the command pipeline object.
And you can also just get an executor back
and then you can, like, you would run conch code
and, like, you would run Python code
through a normal, like, exec thing
and you can do that.
That might not be what you want exactly,
but I like the way your brain is thinking
so maybe we should talk more about that afterwards, yeah.
So, and there was another question back there, I think?
Yeah.
Yes, for, if I wanted to find files like .conch.giv,
how do I, how do I, how do I,
.conch.giv list in regg.giv?
I can log load, I can get it, but,
is there a way in regg?
Yeah, in reggx, right, so it's just a normal,
you just have to do, right, like, say,
let me just go back to my home directory.
So the question is about how do you get your .files
with a regex?
Well, you just use backslash. which is the regex,
regex escape character for the .character.
So the, oops, let me go back up and show you.
Currently, I've got a lot of configuration going on.
So you would do, are we,
shh, don't tell anyone.
Yeah, I'm secretly a bash user.
The, so you would do backslash. and then .star
to match anything, right?
So the, the backslash. is a literal period.
Okay, yeah.
Since we have batch history there,
how does conch deal with multi-terminal history?
Is it sane or not?
So I would argue that it's more sane than a lot.
So the question is about history.
How does conch deal with multi-terminal history?
So conch sort of cribs from the Jupiter playbook a bit.
So by default, all of your history is stored per session
in a JSON file in the standard,
like configuration location.
So you can go back and get each session's history.
And then the terminal application itself
will present that to you in whatever nice way it needs to.
You can also switch to a SQLite history backend
if you wanna store a SQLite.
There is tons of, there's basically as much metadata
as you want in the, in the history.
And that's very configurable through environment variables.
Not gonna go through that right now, but.
That was the thing that sold me on conch initially
was like, I was trying to figure out
how I'd compile the certain version of Petsy
and I couldn't remember which environment variables
I had set when I ran the thing.
And like, you can't figure it out.
You look at your batch history,
like, well, it was one of these seven.
Because then, you know, you do this in conch,
you're like, oh, it was this term,
it was this session when I ran this thing in the tests past.
Those are all the environment variables I need
because they're just in one self-contained file.
Did you have a question over here?
Is there really important alias for the batch?
Yes.
If you run source bash,
you'll get the aliases from bash.
With one caveat, you might have actually seen this
pop up on the screen, which is that if there are,
there are collisions in certain aliases
and also there are things the Z-shell especially does
is they have like their own built-ins.
And if the alias refers to those built-ins,
we don't pull them in because it'll just break
when you try to run it.
Cause it's gonna look for a command that doesn't exist.
Can I get the history of a batch into?
I think there's some experimental,
some people have done that.
But yeah, I don't use it.
But yeah, there are people who do that.
We're happy to help try to figure that out though.
Well, I am anyway.
Okay, move on, but cool.
So next up, this is not new syntax for const anyway,
but it's for Python.
So formatted string literals are great.
And they're part of Python,
which means if you are running punch on Python three six
or higher, which you should be, then they just work.
And they're really fantastic.
If you haven't played with these,
I think they're my favorite simple thing
that should have always been there, I think.
I really enjoy them.
And yeah, the way they work,
if you have a variable defined,
then instead of doing a dot format
or doing like the parentheses argument,
you can just have a string prepended with an F.
You wrap curly braces around the variable
and it just gets evaluated at that time
and then prints the results.
So it's very handy.
We also have a thing that is not in Python,
which is called a path string literal.
And this, if you prepend a string with a P
and then you have a quote,
what it returns is a pathlib path object
of the string that's there.
So for instance, if you were,
I went the wrong way.
If you do like path equals thing,
you got a, you know, on Linux,
you got a POSIX path on Windows,
you got something else,
but it's just using pathlib under the hood
so it'll work.
If you save that to a thing,
you can also then use tab completion on this object.
Like check, does that folder exist or not?
You could then create that folder or, I mean,
pathlib, this is just using pathlib.
Pathlib is great, but we have this sort of
shortcut syntax to get into it.
Oh, and just a little great thing about pathlib
is that you can do path joining
using the, they overloaded the division operator for this.
So you just do like,
pathlib object divided by thing
and it does the join correctly
depending on the underlying operating system.
So it takes like all of that deep pain out
of like trying to get stuff to work on Windows
and Linux at the same time.
Yeah.
So there are F strings from Python.
We've added P strings.
The natural question is what does a PF string look like?
And it looks like awesome is what it looks like.
So you can define variables
and then you can say PF and then the string.
And then you can treat it like an F string
in the sense that you can put curly braces
and it will fill in the value
of those variables in the string.
But it's also saying this should be a pathlib path.
So it returns you a pathlib path
of the result of the F string.
If you've ever done a lot of painful DevOps,
this just might seem appealing in some way.
And the other really handy thing here
is that the environment variables,
they are also Python objects.
So you can evaluate those in F strings,
which means you can evaluate those in PF strings,
which means you can start chaining together
environment variables and other values
and other things to sort of construct paths and folders
and file locations programmatically.
And then once you have the pathlib thing,
you can start saying, does this exist?
Great, if not, touch it.
Like now add it over here and now move it over here
and now do this thing.
And all of these things will be cross-platform
because it's just using pathlib under the hood.
So it doesn't, you know, you don't have to worry
about which slash you're using
or what's being escaped appropriately.
Hopefully your eyes don't bleed.
Yeah, hopefully.
Any questions on this stuff?
Are you not too bad?
Okay.
Okay.
So we have a couple of exercises here.
The first one is to look up the absolute file path
of every markdown file in the tutorial repo.
Just, you know, you can use whatever you want.
You can use bash if you want to too, that's fine.
But PF strings and glob ticks
are probably your friends here.
And then a phone here is to load up a dictionary
of every conda package you have installed
in your current environment.
If you're not using conda, you can just skip this one.
That's okay.
If you have questions, of course,
just ask us and we'll all come around.
Yeah, so load it up as a Python dictionary.
What's the name of the conda package?
Well, the hint is important.
Yeah, run that conda list JSON command
and then I would go from there.
All right.
Okay, well then I think we'll go on to the next section,
which is the environment.
So we touched on this earlier just for a moment,
but this will be a little more of what's going on
and what you can do with it.
So the environment actually lives
in dunderconch.env, everything in conch
is living in this dunderconch thing.
That's where all of the various bits and pieces are,
if you want to explore and play around, it's all in there.
But the dollar curly brace ellipsis
is a shortcut to that object.
So you don't have to always just type dunderconch.m
to get there.
As we mentioned earlier,
you can check for membership in the environment
just using string in environment.
And you can also ask for help for environment variables.
So there are a lot of different modes
and kind of extras are enabled via environment variable.
So if you know the name of the environment variable,
you see it, they all have default values.
So if you see something that is in your environment,
you're like, what is auto CD and why is it false?
You can ask for help and it will tell you
that if you turn it on,
then you can just type the name of directory
and if it exists, it'll just CD into it
without you having to type CD.
Huh?
Yeah, the help is a method.
Yeah, help is a method.
Yeah, and also the docs will tell you
if something's configured a month.
There are a few environment variables
that you are not allowed to configure.
We don't let you.
So also something that's very different from Bashland here
is that contra environment variables are Python objects
and that also means that they're typed.
You can have arguments about typing in Python,
but not now, please.
But they do all have types
and sometimes those types are actually imposed
based on a variable name, particularly
and the important ones are anything that ends with path
is going to automatically be converted
into what's called an end path.
And if you've ever had the scenario,
let's just, we can do a show of hands or not,
but where you've like sourced your Bash RC twice
and now your path is your entire path
and then your entire path and then something else again.
Wow, we've got four.
Wow, that just, that was a raised hand, yeah.
So many of us have been in this pain place before.
That's terrible.
So in conch that is not,
this is not a colon delimited string
and which comes back to how do you split a non-whitespace
delimited string, but yeah, anyway.
You don't because it's terrible.
But so path is an end path,
which just means that it's a list of the items on your path,
but this acts like a list,
which means you can do things like pop individual elements
at arbitrary positions out of the path
or you can insert directories into arbitrary positions
in the path, which is great, really, really great.
Sorry, one question.
Yeah.
So if I do this and then exit the conch,
so that stays the same in my path?
No, so just in this,
if you're mutating your path in your session here,
it will last for that session until you exit out.
It won't like also, it will not like translate
to like a separate terminal when you have opened.
Those are gonna be totally separate.
So I think the question is if you start conch,
manipulate the path and then exit it
and you're back into the root of the path shell.
Yeah, yeah.
But if you wanted to do path manipulation
for all of conch, you would put that in your conch Rc.
But can I push this back up to the bash
that I launched conch from?
No, because.
Why are you launching conch from bash?
Just that is your new conch.
I mean, that's the real answer,
but the reason you can't do that is it has to do
with how processes communicate.
And so if you want to push environment variables
into a parent process,
the parent process has to source
something coming from the child.
And so you have to be able to source,
like you would have to get conch to dump out the environment
in a way that like bash or something could source.
But it's mostly because it's obviously so much easier
to manipulate your environment as a project,
but maybe that's not always how you will be
if you have, let's say, some protected environment
that you have to work in, some other place.
All right.
It'll manipulate it very easily.
So it'll be an environment export?
So we do that, yeah.
Yeah, okay, so maybe there's a solution for you.
It'll be ugly, but it'll work, maybe?
We'll find out.
It's a sub-process.
Yeah, all sub-processes get this path.
How are you supposed to stock conch?
Sorry, the question is how are you supposed to start conch?
So there's basically two ways to do it, maybe three.
I'm gonna say two.
One is you open a terminal,
it's running some 1970s piece of software
that doesn't work really well,
and then you type conch
and then you're in something better and newer.
The other thing is, depending on your operating system
of choice, you can just have it start as your default shell.
On Linux, this means adding it to Etsy shells
and then setting it on, if using I term,
you can actually just have a profile
that you can say like,
I want you to launch this executable
when I open a terminal or this profile.
Yeah, basically any terminal emulator
in the Unix land will let you set the launch program.
So you just set that to conch.
Or you change your Etsy shadow.
Or you change your Etsy shadow
if you want it to be a true login shell,
which conch can be, so.
Right, so yeah, in conch back to-
There's docs, also there are docs on that on the website.
There's platform-specific docs,
so if you want to go look up that, you can see that.
It's right at the very top.
So the paths are nth paths, sorry, back environment stuff.
Other variables are booleans or they're ints.
Whatever they are, like when you grab
that environment variable in conch,
it will be its true type, you know, it'll tell you that.
That said, if you need to,
like some subprosk commands require, you know,
these things to be fed to them to strings,
and so conch does that for you by de-typing it.
And you can also explicitly request these de-typed things.
So you're asking like, how do you manipulate your path
and then do it?
You could, I mean, like de-type it,
overwrite your bash rc, exit out, and then source again.
That would be moderately terrible,
but it would work, as long as it was an absolute path
and you weren't like recursively sourcing it,
it would probably work, yeah.
Yeah, you can also do de-type your path.
Yeah, and so that will, depending on what it should look like
in the base environment it'll do, you know,
give back zeros or ones, not trues,
and paths get turned into colon delimited strings.
Yeah.
There's a couple of other handy methods
on the environment itself.
In particular, one that's very handy is swap.
And so what swap does is what swap does with,
in general, actually, but so you can swap in a new value,
and basically overwrite something,
and it's a context manager.
So only for that block of the context manager,
you can mutate certain elements of your environment,
and then they will get undone
as soon as you are out of the context manager.
Like, that.
And then if we try to access this down here,
it doesn't work,
because some of our has been removed from the environment.
So this is really useful for like,
temporarily modifying your path,
or temporarily entering like a new context
that you need to run something in,
like say you want to switch between
a million versions of CUDA for some reason,
like this is a way to do that.
No one would ever do that.
No one would ever do that, yeah.
Come see my tutorial tomorrow at ABM.
Okay.
Yes, question?
Maybe one question about this.
So traditionally, the way you would do this
is you would sort of prefix the command
that you enter on the command line
with sort of the environment variable
and the version to use or the value to use.
Does that work in conch as well,
or do I need to use this context manager?
So the answer is both yes and no.
So we don't have a particular syntax for doing that yet,
because that turns out to be pretty complicated
in some edge cases that we'd like to work in conch
that don't work in bash,
but that's a whole separate thing.
But you can always run commands through nv.
So if you wanted to do nv,
some var, you know, equals 10 echo,
some var.
Well, actually that, so that doesn't work in bash either,
I think is the thing.
Yeah, that's one of those.
This is one of the things that doesn't work in bash
that we would like to have work in conch.
And so this is why this,
this is why this, like we really want that to work.
And the fact that that doesn't work
is why we have swap and other things.
But if you wanted to set other environment variables
and things like that, you can.
In bash, I mean?
Well, yeah, so that's a different line, right?
So export will export it to everyone
and then you have to unset it, which is annoying,
if you want to remove it afterwards, right?
Yeah, so that's what swap gets you, yeah.
Can you just find multiple variables in swap?
Yeah, yeah, yeah.
So then could I have a context,
like maybe like a dictionary or something?
Yeah, yeah, you could,
you could star-star keyword arcs into that.
Oh, definitely.
So that would be really nice for,
yep, that's there.
Okay, so we have a few more exercises here using this stuff.
These are things that I'll say,
like I both do on a regular basis,
like these are true life examples.
So one is use get pass
to temporarily set your password and environment variable.
So this is actually,
so far as I can tell the only way
to securely type your password into a terminal session
without it ever being saved anywhere,
like including in your terminal history.
And the second exercise is,
this also happens to me a lot,
which is like if your native like package manager
doesn't like, like con to curl
and keeps like yelling at you
because like there's some sham is match.
You just want to run an install command
and just for that one install command,
pop like the front element of your path off,
but you don't want to mutate your path forever.
You just want to do that, this one thing.
So just, you know, temporarily mutate your path,
run some command and then return it.
I'll give you guys a few minutes
we can circle around answer questions.
All right, so before we move on,
any questions on the previous stuff?
Now that breaks over anything?
All right, so the next section we're going to be talking about
what we call callable aliases.
So callable aliases are basically a way
for Python functions or Python callables
and sub processes to exchange code
in a more integrated way than what we've seen
through sort of the at operator
and some of these other curvy braces or curvy,
I forget the mnemonic, this is curvy, curvy captures.
That's right.
So we're going to be building up sort of data pipelines
in a more integrated fashion.
And basically what callable aliases allow us to do
is run any Python function as a sub process command.
It's not any Python function really
because it requires a certain set of known signatures,
but assuming you adhere to that
and we're going to be going through what those are,
then you'll be able to run them.
So they're callables, right?
So that part makes sense.
They're aliases because they get stuck
in what's called the aliases dictionary
or the alias is mapping.
So this is something that gets shoved into built-ins as well
and it's just a mapping between all the possible
different aliases that exist.
If you're familiar with other shells,
you sort of know what an aliase is, right?
So, and if you're not, you'll see it's just another way
to look up commands.
It's another dictionary to look up commands in.
Does this need to be plugged in?
No. Okay.
All right.
So the first function signature
is just an empty function signature.
And it can return either a string
or an integer return code where zero means success
and everything else means various degrees of failure.
So you can do this with a lambda if you want.
So go ahead and type this out.
So if you say aliases set item banana equals lambda
with no arguments and then banana for scale new line,
you can then run the banana command.
That is it.
That's the essence of callable aliases
and that should just work.
So this is serverless for your shell?
Yeah. So as Tom Caswell,
I'm going to say his name out loud.
Tom Caswell says this is lambda for your shell.
Serverless for your shell.
I'm going to misquote him shamelessly as well.
So, okay.
Map plot live?
Map plot live, that's right.
Yeah. As long as we're mispronouncing things, I think.
Okay. So you can pipe this into any other command.
So the WC command counts characters and lines and words.
So if you pass the dash W flag,
that means to count the words based on white space.
So you can say banana pipe WC dash W
and that'll tell you that the output of the banana command
has three words in it.
And if you think about what it would take to do this
in using sub-process with streaming data in and out,
this is doing a lot behind the cover,
under the covers to make all of this work for you.
But it feels pretty natural, right?
Because it's just a command,
just a Python function you're running as a command
in sub-process mode.
And of course, if you want to get rid of that aliases,
alias because you don't like bananas,
you can delete that alias in the same way
that you would delete any other item out of the dictionary.
Any questions? Yes.
You can do the swap function on that,
so you're doing the one with the width and everything.
So swap is for environments
and aliases is a totally different mapping.
Yeah. Having a swap is not a bad idea though.
Please open an issue.
Yeah.
There's a banana command on Ubuntu.
I did not know that there was a banana command on it.
I didn't boss do.
I don't know.
What are you doing?
Where do they live, Anthony, if you don't want me to ask them?
Where do what?
Yeah, aliases live in their own dictionary
that gets shoved or unfortunately aliased into built-ins.
So we're not really in this tutorial talking
about how Conch does all these tying of things together
under the covers.
But in built-ins, there's an aliases dictionary
that you can access at any time.
Yeah, and that allows it to persist.
So you can modify aliases or add these commands
in your Conch RC and then they all live indefinitely.
Okay.
The next is that you can take a single argument
which is the command line arguments.
So like sys.rv, if you're familiar with that.
And it comes in as a list of strings.
So if you provide one argument that's called,
it's typically called args,
then you can take command line parameters.
So here's an apple function which takes an args.
It'll look at it and it'll say,
is my args list of length one?
And do one thing and succeed, return zero, right?
Because you can return the return code from these functions.
And if not, it'll,
and otherwise it'll return one.
So yep, and then,
and just showing off another bit of syntax.
If you use this with the at Python mode operator,
you can, you don't even need to stick this in aliases.
You can just call it directly
because it's a Python object.
So if you put the command,
the function at parentheses function as the first argument,
and then pass in some command line arguments after that,
it'll read it in.
Any questions on how this works?
Any callable will work.
Any callable will work.
So callable classes are?
Callable classes are, yes.
Yes, go callable classes.
Yeah, this is not limited to functions
and lambdas and things.
Okay.
Yeah, and of course there's a formatting bug,
but that's whatever.
Yeah.
I actually have a quick question.
Sure.
So how do you, if you're treating aliases
that do different things,
such as lambda functions,
would you rather do a function,
create a function in your environment
and have it be stored in your building
rather than doing like an alias function
like you would do in bash?
Yeah, so the question is would you just want this
to live in your cont execution context,
the Python execution context,
or would you want this to live in aliases
specifically like you might do in bash?
Oftentimes you just,
you stick them into the aliases dictionary
like you do in bash,
because it's easier to call them,
it's simpler to call them.
It's kind of, that's kind of what that's there for
and where it lives.
If for some reason you don't want to have it there
and you just want it to have it
in your execution context,
that's fine, that's fine too.
Yeah.
All right.
Okay, so let's move on.
So, in the next case,
you can provide in sequential order
any of standard in, standard out, and standard error.
And these are keyword arguments
and they default to none, right?
You may not have one of those streams,
although usually you have standard in.
So those come immediately following
the arguments parameter.
So, here we've got a grape function
or an underscore grape function.
This is actually the most common pattern, sorry,
is you have the function name preceded by an underscore,
and then you put that into the aliases dictionary
without the underscore.
And basically what these do
is these give you file like handles
for standard in, standard out, and standard error.
So if these are present, you can access them
and do whatever you would do normally
with those handles.
So we do some contact switching under the covers too.
So like if you just write to sys.standard in
or sys.standard error, et cetera, that works as well,
but it's usually better to write directly
to those file handles.
So here, if you wanted to implement something
that's streaming, but not asynchronous,
you would do four line in standard in.
You'd be reading lines from standard in
and then we'd be writing them out,
but write back out to standard out,
lowering them as we go.
Okay.
Yep.
The underscore pattern is there
because when you source,
you don't get the underscore variables
in your execution context.
Those don't get brought in automatically.
So it's a way of hiding things from your execution context
if you don't want to pollute the namespace
that you're just working in all the time.
Yeah.
Okay, so usage, here we go.
So this takes a standard in and kind of needs it
because we didn't check if it was none here.
So if we use spell echo rath with,
and then pipe that to our grape command,
it will lowercase that and write it back out.
This makes sense to everybody, right?
So the standard in the output of echo rath
becomes the standard in of the grape function,
which then operates and then writes back out
to what is our terminal's standard out.
Because the grape is being called last in the pipeline.
Okay.
You can use any of these,
but if you want to use standard error,
you have to use standard in and standard out.
Yeah, that's about it.
Okay.
Whoops, yeah.
So next up is you can also get a handle
or a reference to the command specifications.
So this is a specific object
that the command pipeline also has access to.
It's basically how Conch thinks you should be running
the command.
It's how the command pipeline got set up
for that particular sub-command.
So this is a rich Python object.
You can go look at the API if you want to.
But it effectively contains all the metadata
about how you should be running that command,
including what goes in and what goes out.
So that'll come in after the standard in,
standard out, and standard error.
And you can do kind of like funny things here.
So one of the things you can do is you can use this for
is you can check whether the command is meant
to be in a captured sub-process.
So that we talked about that before.
So you can check to see like,
am I running this in a captured sub-process or not?
So this is particularly useful
if you want to know if you're connected
to a live terminal or not.
Or if you want to like,
this is actually used in the which command pretty frequently
where you don't want to append a new line
if you're capturing it.
If you're just printing it out to the screen,
you want the new line to be there
because you want everything to look nice.
But otherwise, you don't want the new line to be there.
So, and you can import part of Conch
to do this check for you.
If that makes it easier.
And here's just our Kiwi.
And this will have output that looks sort of like this.
So if we just run the Kiwi command,
and then end equals end,
but you didn't close the quote.
And then,
yeah, so if you just run the Kiwi command on its own
in an uncaptured way,
it will produce the new line and the extra text.
And if you capture the Kiwi command,
then it doesn't actually have the new line in it.
Okay.
Any questions on this or use cases?
All right, so let's move on.
So the last form of these functions
is you can get back the stack frame
of the call site of the alias.
So if you need to know the locals and global variables,
where the sub-process command was being called from,
you get back the stack for that.
If you don't understand what this means,
like don't worry about it,
you definitely don't need it.
But if you do, this is like a ridiculous tool.
So please stack responsibly.
But it is something that's like,
we don't need to necessarily dive into this,
but it is occasionally useful to know what the variables are
around where the sub-process is being called.
And Conch does that tying in for you automatically.
Any questions on this?
I know this one in particular is a little wacky.
Okay, so we've got some more exercises.
They're all related, which is nice.
So the first exercise is to write a callable alias,
which just pulls down the contents of Frankenstein
and writes them out to the screen.
So if you look at that link,
it's basically the Project Gutenberg link.
And so you can just copy that and provide an alias
that prints out Frankenstein to the screen,
grabbed from the internet.
Or you can grab it and then print it out however you want.
The next is to write an alias that calls upper
on the standard input and returns that as output.
The next one is to write an alias that returns
all of the unique sorted words coming from standard in.
The next one after that is to write an alias
that counts the number of white space separated tokens,
red from standard in.
And then finally combine all of those
into a single command pipeline that executes.
And we will definitely walk around and help,
or you can look at the details.
Each of these is basically a one-liner,
so don't overthink it.
But it's okay to overthink it if it gets the job done.
I think that's fully qualified.
Okay, so for the first one,
you don't need to use Python necessarily
to do this so much.
You can just set an alias to Frankenstein,
that is a lambda that calls curl or wget
or whatever on that URL.
And that will grab that URL that we listed just straight away.
So if you're using requests or something,
you can definitely do that, that's totally fine,
but you don't need to.
So you can use a command here.
Yeah.
So if you're getting stuck on that, that's there.
And then, yep, I'm sorry.
All right, I'll come over.
But we should, should we do the second one too?
Yeah.
So for the second one, if you want an upper,
all you have to do is take both args and standard in,
just read everything from standard in,
and then call, which is a string,
and then return the upper of that string.
You could also do it in this streaming version
where you have lines that you're reading from,
and then writing them back out to standard out.
It's a little more complicated,
you don't really need to do that here.
So for the third example, or the third exercise here,
we do something pretty similar where to the other,
where we want to count of words.
So the way that you do this is you read from standard in,
and then you split those, split based on the white space,
right, we're all pretty familiar with that.
If you want the unique, right,
so that'll give you this big word list in order.
If you want to unique that, you call set around it
to get the unique words, and then if you want them sorted,
you call sorted around that,
and then you join based on new lines
so that you output a string again,
and that's the thing that you return.
Kind of a lot of parentheses,
but it gets the job done in one line.
You could do it in more lines if you wanted to clean it up
like we did in some of the other examples,
but there's no need here.
Do we have the, we don't have these loaded in.
Oh, you do, okay, oh yeah.
Oh, nope, okay.
That's probably in the, yeah.
So for example, if you ran thus,
it's not perfect, right,
because this is text processing,
but there it is.
Then for the fourth example, or fourth exercise,
if you wanted to count the length of that thing coming in,
you'd have to basically do the same thing, right?
So here you'd read it in,
you'd split based on white space again, whoops,
and then instead of calling set or something else,
you call length, which returns an integer.
You don't want that integer to be the return code,
so you have to convert it to a string, add a new line,
and then you go from there.
So that's how you do,
or you can do WC.dashL,
because reasons.
You could also do that, that'd be a better example here.
You could do that in the alias, yeah.
You could run.
Yeah, that's the simplest form of the alias, really.
Then pull down Frankenstein.
Oh, I think we just did.
We really love this Frankenstein thing.
That's my fault.
That's your fault.
Thank you, Mike McCarty.
Yeah.
All right. Let's do it though.
Yeah, do it the right way.
What was it? Upper?
I want you to do this.
Then we'll debug that later.
Oops, sorry, you want the,
yeah, it's just words and then count, the real count.
Then the point here is that you can merge all of
these together in a single command pipeline.
That executes.
Okay. Any questions on this?
All right. If there's no questions on how this works
or what it uses, we'll move on.
Not a break, because we're doing breaks differently.
Our next topic will be events,
so switch with Gil.
Okay. It's hard to actually describe an event,
I discovered this, but it's a trigger that you can fire,
and then if you have something that's
set up to listen to that firing,
which we would call a handler,
it will then execute that thing.
That is a horrible vague description,
but I think it will be a little
clear when we actually go through an example.
I'll just say the events,
a system in Kant was written by one of
our contributors, Jamie Bliss,
and is just an incredible piece of work,
and I can say that because I had nothing to do with it.
It's really incredibly powerful,
and it lets you do a lot of really interesting things.
If you want to introspect your code or
have all sorts of things happen in response to all kinds of events,
you can really start to do
some very interesting, clever, and powerful things here.
Right. So I said this,
a handler is just a function that is called when an event is fired.
So something says event, this kind of event fires,
any handler that is attached to that event will then be run,
and you can have as many handlers as you want on a given event.
So several functions can be executed in response
to something just happening somewhere.
Okay. So one of the events,
all of these live in just the events built in at the base,
so you can say events.
One of the common ones,
there's several that are built in to Conch.
Later we can look at like defining your own,
but there are many that are built in.
The first is on change year,
which fires if you can imagine whenever you change directory.
So this event already exists.
So what we want to do is just create a handler that will
execute in response to that event being fired.
So the way that you do that is with this decorator syntax.
So you just say at events and the name of the event.
In particular, this event hands off
two variables to whatever function is being called as handler.
We'll show you how to inspect that later.
They're called older and newdir,
or olddir and newdir,
depending on your preferred pronunciation of words that aren't words.
Then in this case, just for a simple example,
I'm just printing out a message that says,
hey, we just changed from this directory to that directory.
So now you can just move around in your terminal like do a CD dot dot,
and it'll tell you this thing.
You could go back into the like directory you were just in.
Of course, now your terminal is probably a little
overlever boasts and you don't want this to happen all the time.
So you can always remove handlers too,
because maybe you've made a mistake and it's saying way more than you meant it to say,
and you would just like to have your terminal back.
So the simplest way is just there's
a set of handlers on each event and you can just pop them off.
So in this case, events on changedir.pop,
and then you should see the thing come up,
and then you can just test to make sure that your terminal has recovered by going somewhere else
and confirming that in fact,
there is no longer something being printed every time.
So that was just a quick example to show you what an event will do.
We can now just dive in a little deeper into what's happening and
what all you can do and how you can hook into things.
So as we showed, you register a handler by just using the name of the event as a decorator.
Those input arguments, the keyword arguments that are there,
are being supplied by the event itself.
There are two ways to figure out what an event provides.
You can just do help and then event.name event.
Currently in const, that has the unfortunate side effect of also printing out a bunch of
like metaclass stuff that you maybe don't care about at the moment.
If you just want the simple succinct definition,
the better thing is just to look at the dunder doc of the event you want.
So in this case, you can see that it is specifying
the types of the two arguments that will be provided.
Yeah, and it's returning none.
So you have this type hint signature that describes what arguments will be provided,
their types, and then what will come out of the event if anything.
Is there any way to get a list of events available?
Yes, there are two ways to get a list of events that are available.
Currently, the tab completion on that events shortcut is a little bit
borked, which we're going to fix in a couple of days.
But if you go to dunderconch.buildins.events and then hit .tab, all of those.
And the other way is if you go to the docs, there's xon.sh slash events.
I think it is .html.
But on the website, there's a list of all of them, what they do when they fire.
Yeah.
Also, I should say, if you want to register a handler for an event,
but you don't actually, I mean, it's
going to provide those arguments no matter what you do.
Like, that's what the event does to the handler.
You can choose not to use them, but you do need to say, like, you need to give it
like a star, star, quarks or something to at least capture them,
or it will throw an error because you're
going to pass arguments to a function that doesn't know how to accept them.
So it's just, you know, you can make these future, basically, future proof,
just so long as you always pass it star, star, quarks.
And then you don't have to worry about something firing or, like,
passing unknown arguments to your handler.
So events get fired when we tell them to fire or when you tell them to fire
is effectively the short answer to how these things get set off.
But so we'll walk through an example of setting up our own event
and telling it to fire just to give you a notion of what this all looks like
and how you would put all of this together.
OK, so first, we need to create an event.
And the way you create an event is actually by writing a doc string for it.
It's sort of like the ultimate self-documenting code.
Like, it's impossible to create an event in Contra without it having documentation
because that's the only way to create it.
It's kind of amazing.
So we're going to create an event that just raises an alarm if it's called,
that it's unhappy.
So the way you do this is you say event.doc.
And then the first argument you give it is the name of the event, which,
in this case, is never run this.
And then you give it a doc string, which should be the signature.
In this case, this event takes no arguments and returns none.
So it's just a simpler thing.
So it would just be events, never run this, parens, arrow, none.
And then on the next line, you can kind of provide a description of what
you're expecting it to do.
That's more for other users or other people.
So if you were writing a plugin and you wanted to have some events,
you would kind of try to put your explanations in here
so people understand how they can use the events you provided to full effect.
OK.
OK.
So now what we're going to do is the way you would use this event is you would,
it's an event that you basically want to never be fired.
So you would put it in a function that for some reason you have,
like, really should never be run.
But you want to recognize that it may exist.
And so you put this event in there to kind of alert you that this thing is happening.
So if you wrote a function that deleted everything on your computer,
I don't know why, but let's just say you did, then what you would do in,
let's say, the first line of that function is somewhere along,
is that you would just say events dot and then never run this,
which we've defined in that previous doc string thing, and then dot fire.
And then what happens is that whenever that function is called and it gets to that line,
the event management system will basically fire that event.
So we can go ahead and actually run, delete my computer, and nothing happens.
So in fact, actually, something does happen, right?
The event fired, but we have nothing listening to the event,
so you don't get anything out of it, right?
So then the final step is to set up a handler to add it.
So we create the event, we tell the event to fire,
and then we have something that listens for the event firing,
that then reacts to it, right?
So these three separate components, and given the fact
that this is an event that's supposed to fire
when somebody has done something horrible to you,
you can make it a suitably chastening message.
And as always, like you have access to the full, you know,
contract spectrum here, so if you want, like in this case,
like the who am I is a nice thing, you can figure out exactly
which user is responsible for doing this horrible thing to you.
That's a good table, yeah, perfect.
So then if you run delete my computer again, then the event fires,
and now you have, you know, you know that it was scope
at the delete of your computer.
I'm sorry.
Can't take him anywhere.
Okay, so are there any initial questions?
Otherwise, there's some exercise here that should help kind
of like cement the general pattern in place,
but we're happy to take questions first.
Okay, great.
So these sort of build on one another,
so I'll like reveal them as we go.
But the first is just to create a handler for the event
that is called onEnvrChange.
This is a built-in event, you don't need to create the event,
you just want to handle it for the event,
and you want to have it print out the old value,
and then the new value, and of course the name
of the variable is just changed.
So you should probably check on the dock, the DunderDock
of the event to figure out what those variables are called,
otherwise it's going to be hard to refer to them.
And Anthony and I can sort of wander and help.
So as Gil showed up here, if you just write a simple
if condition to check if the name, which comes in as a string,
is like the dock string says, is either PWD or old PWD,
and then only print if it's not.
We can check to make sure that it works normally
for most environment variables,
but if we change directory, it no longer gets called.
So.
And then I think we're running a little low on time,
so maybe we'll skip this particular exercise,
but you can go, feel free to do it at home and email us too.
Do you want to just show it or?
Okay.
So one of the really handy ones for doing some control flow,
we don't take time to actually do it right now,
but there's onPost command,
which has a bunch of those items that you get
in the command pipeline object, including timestamps,
the name of the command that was run and other stuff.
So in this case, this is all it takes basically
to set up like a power line style,
like the timestamps of the previous command
and just throw it onto your right prompt over on the side.
It's really just like this three line event handler thing
that you can use and then you kind of set up
this interactive thing to track.
You can also get like return codes
and start coloring things differently.
I mean, it gets really easy to build stuff up there
to get sort of the responsive prompt that you want.
That's all I wanted to say.
Okay, so now we're going to talk about macros.
So macros are syntax that replace a small amount of code
with one of the few things.
So either another expression or a syntax tree
or just a string rather than being evaluated normally.
So basically what happens in Conch is that the parser
gets paused and then we skip the normal parsing.
We gather up whatever macro inputs are going to be,
are handed off, we'll get to what those are in a moment.
We evaluate the macro with however we're told to evaluate it.
And then we resume normal parsing and execution.
So Conch's macro system is more like rusts
than other macro systems you might be familiar with.
So who here like knows rust even a little, a little.
So this gets used all the time in rust.
So if you're from, if you know that,
it'll look familiar.
If not, hopefully it won't be too much
of a learning curve here.
But basically the point of this is that
you're already familiar with macros nominally.
Jupyter magics are just a macro system effectively.
They pause normal execution and do something else.
So in like in rust, the Conch macros
use the special exclamation point syntax.
And there are three types of macros that we have.
So one are sub-process macros, which we'll go over first.
The next are function macros, which we'll follow after.
And then third is context macros.
So we'll see what all of these look like in a moment here.
So let's start with sub-process macros.
So basically if you put an exclamation point anywhere,
a loan exclamation point anywhere in your command pipeline,
anything after that will just be interpreted
as a single string argument to the rest of the command.
So if you say echo exclamation point,
I'm Mr. Meeseeks, for example,
then that entire thing is just a single string
after the exclamation point.
It's stripped, we'll get,
but to show some counter examples,
if you just echo x, y, z, right,
echo doesn't really care about the white space.
So normally you'd have to pass this in as a string,
which is two characters.
But if you use a macro, you only have to use one,
it's echo exclamation point x, y, z in that whole thing.
It's equivalent to having put that everything in the string.
Okay, now this is sort of a contrived example.
Oh, but before we get into that,
it's important to remember that macros pause all syntax,
until you escape the sub-process command.
So environment variables will just be listed
as the string you typed in, not anything else,
because we're not parsing that
as an environment lookup anymore.
So if you want a more extended example,
you can say you're gonna have an environment lookup
on both sides, and you'll see the first one
is the value, and the second one
is actually just the string that you typed in.
Okay.
So this is really useful when you wanna pass in
a lot of string, like a very large string to a command.
So for example, time it.
Time it's like a classic case for this, right?
So if you do time it, and then some Python code,
time it is a built-in alias in Conch,
so you don't need to worry about implementing it.
It's there.
All of that is a Python string that follows,
or a Conch string that follows.
Or similarly, if you wanted to do some bash code,
right, normally you'd have to put that bash code
in a string, and then execute it,
but with the sub-process macro,
you can just type in the exclamation point,
and it's done.
Or you can do this with Python,
basically any of the things that you wanna pass
in a dash C2, it'll work.
Okay.
I think, what did you?
Mr. Burns.
Oh yeah, there you go.
Okay.
Any questions on the sub-process macros?
They're pretty simple.
That's why we did them first.
The, okay.
So let's move on to the function macros.
So these get a little more fun.
So macros don't require a special function definition.
They only require a special function call.
They modify how the function is called.
And it's just normal Python callables.
What you do to call something as a macro
is you stick an exclamation point
between the name and the first, the open parentheses.
And macro arguments are split on commas
like normal functions.
So here's a few simple examples.
So if we had an F function,
if we wanted to call it as a macro with no arguments,
we would say F exclamation point parentheses.
You're used to us, this should look pretty familiar.
If you wanna call it with a single argument,
you would say, you would do sort of the normal
Python single argument methods,
or you can call it with multiple arguments
splitting on those top level commas.
Okay.
How the function is defined determines what happens,
or specifically how the function annotations,
what the function annotations look like,
determine what actually happens in the macro
when you do a macro call.
And that's matched up with each individual parameter.
So here's an example.
So say you have an identity function
that has its annotation for its X parameter set to string,
that X that comes in when it's a macro call
will always be a string,
even if what's normally put into that is not a string.
So here's a comparison between the two different versions.
So in the top, we have the identity function,
we call it with a string, we get a string back.
On the bottom, when we call it with the identity
with a string, but as a macro call,
we get the wrapper string effectively, right, returned.
Similarly for ints, in a normal Python call,
you'd get an int back in the identity,
you always get, or in the macro call,
you always get the string,
and same thing with the others, right?
You get the string form of the argument
rather than the actual object itself.
Each argument is stripped.
This is basically done for consistency,
so that things like 42 and 42 don't end up being different.
They're not really meant to be different.
So in this string one, they end up being the same.
Feel free to raise any questions or deep concerns
or anything as we're going.
Yeah, Tom?
Why?
Well, we're getting to why in context macros,
which we'll see some cool things.
But it's the same underlying infrastructure for functions.
Okay, yeah, wow, so consistent.
Okay, so here's some funny examples
that are really pretty bad.
So if you macro call import OS,
obviously this is not valid Python syntax,
but in any way, shape, or form,
but you can get that code back.
You could embed some C++ because I don't know why.
I forget C++.
Wow, if only I could forget C++.
You don't have to type that.
You don't have to quote that.
No, you don't have to quote that.
It's a way of circumventing that coding.
Yeah, in this particular example.
But there's more things that you can do than just strings.
We just showed the strings here.
So if you said you wanted this to be an AST,
there's kind of flag codes for this,
if you wanna annotate it in different ways,
you can get back the AST of what you put in
if it's Python or Contra code.
So you can get that tree object back out,
which is pretty nice and useful
if you're doing a lot of tree rewriting.
You can get a code object out
if you wanna put in exec or a val or something,
or if you put in the C flag,
or sorry, if you put in compile.
There's six of these, so here are the first three.
The others are a val,
so that would just eval the argument as normal,
so that means that you basically could only
put in Python expressions.
If you wanted to put in exec,
you could put in basically anything that you wanted,
or you could say T and get the type back.
So in theory, this could be extended
if there are other things out there
that people would want to see done,
but this is what's available right now.
Any questions on this stuff?
Okay, so here's an example of some annotations,
a simple function.
So we're annotating with the first argument by default,
since it's got no annotation,
we'll just come back as a string.
The second one will be an AST object,
and the third one will be a code object
because we're passing in compile,
the built-in compile function if we do a macro call.
Yeah, see a lot of pensive people, heads exploding.
Okay.
Is there an example on a user's macro?
Of this one, yeah, so just call it with anything,
or any Python-y thing, exclamation point.
Yep.
I don't know, like, three plus five, I guess, I don't.
Oh yeah, I think you have to do a new line
after the three plus five, right, or after the OS.
I think it's after the OS, because you did a statement.
No, no, no, no, like a literal new line.
I'll do it, it's too...
No, I guess not, string.
Interesting.
I thought there was an example here.
All right, well, this is not working right now.
I don't know what the...
This should know for their code.
Okay, well, it's failing to compile one of these things, so.
Let's maybe just do this.
Nope.
Yeah, I don't know what the problem is.
I'm sorry.
We'll have to figure it out afterwards, so.
We have a parser error.
All right.
Okay, sorry about that.
So, the last bit of macros that we'll get to
are context macros.
So, these use the exclamation point
right after the with word.
So, you can use with exclamation point,
and then everything after the colon will be captured
like it was in a normal with statement.
So, this provides both named blocks and anonymous blocks.
So, if you say, this isn't gonna work
because there's no x to enter,
but you say with x equals 10, print y,
this would come back as a string.
And what this can be thought of really
is doing the follow.
So, you can think of this as saying,
whatever your context is, x dot macro block
equals the string of the code in the block de-indented,
and then assigning the locals and globals
to attributes of that as well,
and then passing for the actual block.
So, it's a bit of code rewriting.
Macro block is de-indented,
and these attributes are set before the enter method is called,
but they're not cleaned up on the exit method,
so you can do that if you want to,
but they live around, they stay around and live
if you need them.
Like with functions, by default,
the contents of the block are returned as a string.
However, they don't need to be,
they could be any of the other special annotations
that we saw before,
and that just lives as this conch block attribute
on the context manager,
so that's how it knows what to look up,
what type to convert it to.
So, here's an example,
and this gets to the use case a bit.
So, we can write a simple XML block.
So, if we say, we're just gonna be pretty explicit,
you don't need the comments, obviously.
So, we say, it's gonna come back as a string,
we write an enter method that takes the contents
of the block as a string,
and we'll parse them into an element tree,
an XML element tree,
and return that as the object in the context manager.
Then, when it exits,
we're just gonna clean up those things,
the things that we had before.
Yeah, I think you need this star or whatever.
Macro locals, yeah.
Okay, and then you can use this,
oh, it's cutting it off a bit,
but by saying, with exclamation point,
XML block, a new object as tree, colon,
and then everything, you can just do a short one,
so just do like, you could even just do, yeah, you,
and then just close out the note, I think.
And now, if we can inspect the tree object,
tree is an instance of, so I think, what is it?
If you do tree.tag, that gets the note,
so it parses that XML.
So, this lets you write documents
and other languages right in Conch,
and then do whatever you want with them,
which is somewhat insane,
but actually kind of useful occasionally.
And you saw, like, writing that context macro object,
that class was actually pretty simple.
It didn't take a lot of lines of code to do that.
So, yeah, that's kind of the scenario there,
and hopefully that answers,
at least partially, the use case question.
Okay, so we have a few exercises.
The first is to use a sub-process macro,
so just run time it on the string
and formatting a string.
The second is to call the import module as a macro,
so you don't have to use quotes.
And the third is to run a,
write a JSON block context manager.
What's happening this?
Oh, yeah, we're not gonna,
then we need to get into our example.
And then we need to get into our, like,
any questions on any of these,
or if there are questions.
Format was 42.
And you see, like, what this really prevents
once time it completes,
is you having to run it with an extra set of quotes,
right, because time it expects
just a single argument that takes.
So this is the same,
this is fundamentally the same,
but you just,
you don't have to type that extra set of quotes, so.
Okay.
All right, do you wanna move on to the next?
Sure.
And then, yeah, for the standard library import lib,
this is just showing you can,
you actually can just use existing functions,
but call them using the macro syntax.
And so in this case,
we're gonna get back the import lib, sorry.
Yeah.
Dot import module.
So if we do sys,
right, because the first argument is a string,
you can just get that.
So it'll take,
it'll turn whatever you type that into a string.
Okay.
And then the third one is this JSON block.
So this should be very familiar to the XML one,
where now we just have,
or now we have JSON,
we don't need the macro block part,
because that's optional,
but we, oops, on enter.
We'll assume that the code that comes in
is part of, is valid JSON.
So we'll return
JSON.loads
of
self.macro block.
And then on exit,
we'll do the same delete portion,
just to clean up after ourselves as well.
And so a use case for this is just with
JSON block
as, let's call it X.
And we can write like,
hello, just some random JSON.
And now X is a dictionary that was parsed from that JSON.
Pretty, pretty simple, silly example,
because JSON and Python are so similar here,
but it's a one way to do things.
Any questions on these exercises?
Yeah.
So where does this JSON block object end up in this case?
What do you mean?
So X ended up as the return value of enter.
Yes.
So where did the JSON block instance?
It's gone.
Okay, so the cleanup is a little,
I guess you can show in the cleanup,
applying these things are leaking.
Well, so the macro block and macro globals
and macro locals.
Yeah.
So this would leak in the case where you instead
returned self from the enter method.
Okay.
Right.
But is that like conjures are keeping a cache?
No, no, it's not keeping a cache.
It would only leak if you,
so the place where it would leak potentially,
where you wouldn't want it to necessarily,
is like if you wanted to have the same instance
of JSON block, be re-entrant,
like that's what this makes us.
So you could like have one instance of JSON block
and then just re-enter it every time
and always get the tree back.
Or if you returned self and we're doing something else
with it later, right?
So yeah, that's where the references get added.
Yeah.
Does that make sense?
Sort of.
Close enough.
Yeah.
I guess the thing is like, if you returned,
so if you said like self dot,
like maybe you wanted like,
like maybe you wanted to keep the J object around.
So you did like JSON dot,
or you wanted to keep the tree.
So you do JSON dot loads.
So you have self dot macro block.
And then you return self.
You know, you might not want to keep the globals.
You might want to keep the macro block itself around,
but you might not want to keep
the other locals and globals here.
And so just using this.
So now X is the JSON block
and then X dot tree is the actual version.
But you still have access to the string
of what the macro block was.
Yeah.
What are the macro blocks and macro block?
They're the local and global dictionaries.
As if you had called locals and globals the Python built-ins
where the macro block was called
where the context macro was, was written.
Yeah.
Yeah.
Okay.
Yeah.
Any other questions on this?
So you're given the use case of writing a different language.
What are the use cases that typically mean use for macros?
Yeah, so the most common use case
is really something like time that, right?
It's really those.
There's a couple of cases where that we've used these things
where like if you wanted to write some bash
and you really needed it to be bash in a local context,
then you would, then you write like a little bash thing.
There's been some other use cases
where we take input or configuration files
in as these macro blocks.
But otherwise, yeah, it's, that's kind of the use cases.
Yeah.
I mean, can you just think of when, you know,
these get this way in terms of what the words
are in terms of where that's especially useful?
Import, sorry, saying?
The second, second example.
Oh, yeah, yeah.
That was, that's just a toy.
That's kind of a toy example to show.
Right, this comes from the standard library.
And the standard library didn't,
doesn't know anything about conscious macro system.
So it didn't annotate these functions
in any particular way.
And this is just showing that you that you can use,
you can use the macros on those functions
if those functions happen to take string arguments.
Okay, so that's more of this demonstrating.
It's demonstrating, yeah.
But the function macro stuff just ended up having to,
it kind of had to be there for the context macro stuff.
That infrastructure all had to be the same.
So it's there and available in the language if you want it.
But I wouldn't say there's like a killer feature for it
unless you're coming from Rust or you,
or you really like doing a lot of AST syntax,
AST tree, like rewriting and stuff,
in which case this makes it easy for you to provide
those rewriters or pattern matchers inside of Conch.
But there aren't, that, that intersection is basically me.
So, yeah, so.
Okay, cool.
Good question, great question, though.
Let's, we should maybe skip this.
Well, except we don't know if we can.
Yeah, well, I can try to upload this stuff.
So this is gonna be interesting as we discover
if this is even possible anymore.
But there is an example here,
which is that we were working in a lab
that had a bunch of MRIs of mouse lemurs.
That's a mouse lemur.
So we had all these MRI datas,
but it was set up on a web server by a postdoc
who disappeared last week.
And we have some other bad news,
which is that he used bash to handle all the data collection.
He didn't know how to make sure
that different data sets were saved to separate directories.
So he just added a random four digit number
to the end of all of these NII MRI image data files.
And he also neglected to do this
with the JSON metadata that was included with it.
So that's all been overwritten and lost.
And then he ran, removed with an overly permissive glob,
deleted all of them.
And the files are kind of big
in the postdoc's web servers at his house.
We don't wanna have to download all of them.
That being said, the web server at the house,
which is on my laptop,
is completely inaccessible to everyone
on this network, it turns out,
which makes this a little trickier.
The data is now on GitHub
in this repo called MRI data, sorry.
And this may not be possible, so we'll find that.
It's gonna be a learning adventure for all of us.
We do know a couple of things about the data.
So this is sort of our exploratory thing.
They all do follow this naming convention.
So you just have like sub-2-digit number underscore
four-digit number dot NII.
The files are large, but the first 348 bytes
of each file is a header.
So you can nominally just pull down the header.
We're pretty sure there are 19 mouse lemur scans.
And the circle spine study going on in the lab next door,
which is mixed in with all of this data,
only has six subjects.
And nominally, this is how you would use curl
to only pull down the first 348 bytes of a file
if there were a functioning web server available.
We're gonna discover together if you can do this
from the raw link on a GitHub repo, but we're not sure.
So having said that, if you would like to even try this,
and we welcome your support and efforts,
you can install NIBabble, N-I-B-A-B-E-L on Contaforge,
which is a nice package for loading in this MRI data.
It's on PIP, right?
I don't know.
Oh, you don't know.
I don't even look on PIP anymore.
Yeah.
And then we are all gonna try together
to see if we can just download the headers
of each of these files,
sort of determine which of them are the ones we want,
so we don't just download everything,
which is never usually the right answer
to these sorts of questions.
Maybe we should see if we can curl one of them right now.
Yeah, let's try it.
Okay.
All right, so it's curl dash R,
and then what, oh, I should have kept that.
And then what's the GitHub URL?
Well, the GitHub API should be,
this feels way too much like real signs right now.
So it would be
github.com, g4sci, MRI data, sorry,
blob, master, raw equals true.
That didn't work.
No, that, I thought there was like a real,
you know, like a raw user data kind of thing.
Where does that live at?
I think usually it's there unless the file is too big.
Oh, okay.
This is why you don't store, you know,
big data on github, this way, it's a really bad pattern.
Let's try this one.
Received.
Received.
No such key.
Or maybe that one's not up yet.
It's another one of these file names that's definitely up.
Woohoo, that worked.
Okay, time to rewrite the slides.
Which you'll be able to reload and copy from.
What's that digital ocean droplet?
I'll put it in this chat.
Sorry about this overall.
You're getting this plus screen by
you're in a Google meeting, sharing your screen.
Yes.
Yeah, no, the network's all kinds of fun today.
Wait, what?
Google, oh, I hate Google.
Don't help me, Google.
I don't want your help.
Your help is terrible and poison.
It's not help, it's spying.
Just stop spying on everything we do.
They're watching us right now.
That's true.
We asked them to.
Can you curdle down a file list from there?
Does that work?
No.
Well, I don't know.
What was the command for doing that?
I don't know.
All right, I think.
What should just be this?
Okay, does it work?
Yeah, that's, the information's in there.
Okay, so.
You have an XML block, right?
Yeah, so you have it?
So you've got an XML block.
We are happy to answer questions along the way.
This should actually work though, which is kind of amazing.
So we have, the postdoc is better than we thought he was,
and has uploaded the files to this digital ocean droplet
that I've just added to this slide.
If you reload the slide deck, you should be able to do that.
Oh, I haven't pushed it up yet.
Oh, okay.
I'm sorry.
I can't push anything right now
because I haven't set up the SSH thing,
and it wasn't working.
Sorry.
But if you curl that URL,
you will get this looking kind of blob,
which does have all of the file names in it.
So you can see there's one, I lost it, there.
Sub-187785.nii.
And you should be able to pull out from this
a list of all of the names that match that pattern.
And then you can pull down only the first 348 bytes
of each of them, load them into a NI babble,
and then inspect sort of the dimensions of the thing
to figure out which are sort of the correct images.
Yes, I can.
No.
Good question.
If I can't install,
will it be reflected on a very conscious environment?
You probably need to, well, actually.
Yeah, it should just work, yeah.
Yeah, it works.
I do that all the time.
All right, kind of install something
and then import it immediately.
Yeah.
Yeah, and if you're having a problem,
or if you're running into issues,
like come, just raise your hand and let us know.
Okay.
And thanks for dealing with our debugging live here.
So for a quick update on our progress here,
is there anyone doing on this, if at all?
Sorry to hear that.
So one thing you can do for some of this
is you first want to get the raw kind of page
so that would be, you could just curl down
that base URL there.
I actually got encoded this as a, yeah.
Can you make the font bigger?
I sure can.
You want to show the other command.
Oh yeah, base URL, yeah.
So then if you have this really long, painful string
like this, but you know that the files look like
somewhere there,
you can try to use XML, but XML is horrible.
So you could also use a regular expression
to scrape over that and pull out any
that matches a certain pattern.
So then that's sort of the list of files that match that.
So now you might want to try just like downloading
one of those, which would be to grab the first 348 bytes.
Let's clear that out.
Save it to the same output file, concatenate,
or just put together the base URL
and then the path of a single file
just to kind of test it out.
Seems to work.
You import Nebabel.
You can load that file.
And then if you explore some of the different options here,
you might see this header thing.
Yeah, back there.
Yeah, so the question is about why shouldn't you use
a path string here?
Well, yeah, so the answer is basically that it's a URL.
So it's not really a path in a normal way.
And the second is that you're just passing it back down
to a sub-process command.
And so it's gonna get turned back into a string anyways.
So you don't really need the path object.
Yeah.
Having said that, as you go along on this,
you might, you would maybe curl it down
using just a string because you want to pass that to curl.
But then in terms of loading the file after you have it there,
you could first make it a pathlib path,
load it from that.
And then depending on the results of how you're inspecting it,
then use pathlib of that file to move it or change it
or mark it or delete it or, you know.
So you can work that into the process.
Probably just close it.
Yeah, I think so.
Okay.
Okay.
I'm gonna keep working on this like at lunch,
so people wanna, on this contrived example that we created,
but you want things to work.
So that, thank you everyone for coming.
I know it's like a lot of information
just to dump into people's heads,
but we appreciate you guys kind of tuffing it out with us.
We also, there's a bunch of stuff we haven't covered.
There's even some more new syntax probably
that I've forgotten about.
But we're here all week and we're happy
to help you answer questions.
If you have a certain thing you'd like to do
when you just want it to,
but you think it could work a little better,
you wanna try, see what it would look like on Conch,
please like stop us anytime.
We have stickers on our badges
and you probably would recognize at this point.
We also have stickers up front,
so feel free to take as many as you want of those.
And yeah, thanks for coming and trying out Conch
and hopefully, you know, it improves your life
in some meaningful way, so.
And then, yeah, we'll be around and open bug reports,
find us on Gitter, open issues,
contribute, we're a friendly community, so.
Thank you so much, everybody.
Thanks.
Thanks.
Thanks.
