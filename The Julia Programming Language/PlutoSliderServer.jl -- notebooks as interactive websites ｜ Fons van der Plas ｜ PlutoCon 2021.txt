Hi, everyone. Welcome to PlutoCon. My name is Fonds and I'm Pluto's main developer,
and my main motivation for working on Pluto is education. I think that computation is an extremely
powerful tool in education, and we have to make it easier for teachers to use it in their class.
So that's why I was really excited to work on a project during the development of Pluto.
During the fall semester of 2021, I worked with the Julia Lab on teaching the course
computational thinking, where we tried to teach mathematics by showing the computation instead
of first showing the mathematics and then the computation. We had lots of cool, famous celebrities
teaching the lectures, and that was awesome. The lecture material is really high quality.
And for example, we had lectures like this one, where it's kind of a shockingly effective way
to do that. So I'm going to get a high level view of how this algorithm. So you have three
blue and brown using Pluto notebooks to show the computations that go behind these mathematics.
So this was really exciting. And for the next semester, the spring 21 semester,
we wanted to do something new, which is all of the notebooks that the lecturers use,
we automatically turn them into the website, and they become like a book, like an online book
about computational thinking. And this used to be difficult in Pluto, automatically exporting in
the book to a web page, because you needed a web browser to generate those files. But now,
over the past months, we kind of changed the internals of Pluto to be able to
take a state object, which can be generated just by Julia, which contains all of the notebook
state, the inputs, the outputs, et cetera, and load that in as if it's connected to the real
server. And so that's our new website. So for a new website, every page is a Pluto notebook.
So here we're in chapter 1.1. And you see that this is Pluto. And actually this window on the right,
it's the real Pluto editor. It's not just an export. The only thing we did was we hired the bar
at the top with the Pluto logo, and we disabled the buttons. So that was the first thing,
automatically using GitHub Action to generate a website out of these notebooks.
And so we really believe in learning by doing, and we want the students to run the code to do
the experiments and discover these things for themselves. The problem was that in the fall
semester, students had to install Julia down with Pluto and then get the notebook from a GitHub.
And it was a long process. And I think we lost a lot of students in that process. So they would
see the video, get excited, but then be demotivated by having to install all of these things.
So the next thing I worked on was to add a button here, which is a binder button.
So MyBinder is a non-profit organization that can run scientific notebooks in the clouds.
They're really great. And we managed to get a Pluto kernel working there, though normally it
just runs Jupiter notebooks. And so it can connect in the background. So when I click,
it will start loading a binder kernel in the background. And when it connects,
it can hold swap the backend. So it will go from a static file to a live binder session,
which is awesome. The problem is, as you can see, it's still loading. It takes quite a while
at these two minutes. And this is mostly because we're using Julia. So when it connects, it will
need to start Julia on everything for the first time, install the packages that we're using in
this notebook. So yeah, it's still not quite to the point where you see some kind of cool simulation
and you start playing with it and discovering things.
We worked on Pluto Slider Server, which is a web server that you can deploy for your website
that will take all the bind inputs and make them work directly on the website
without having to wait for any kernel to start. So for example, right now I'm on the website.
And let's see, there's a slider here, and I can move these sliders and you see that this
pixel changes instantly. It even works with webcams. So here's a webcam input. And when I take a
picture, you see that using Julia codes without JavaScript or anything like this,
I can turn that into a kaleidoscope image. Okay, so let's recap for the website. We have three
things. First one, if we have a static notebook preview for every new book on the repository,
and it generated by GitHub Action. So whenever we push to the repository, a new static preview for
that notebook is generated. Second, we have the Pluto Slider Server, all sliders, buttons,
everything works directly on the website. And then finally, because Pluto can switch
backends dynamically, we can connect to a binder session in the background.
So how can you make sliders and buttons work directly on the website? So the first thought
might be we run just one Pluto server and every visitor connects to the website.
As an example, notebook for today's demonstrations, I have this. I have a slider for dogs,
slider for cats, and here I combined the two into a single text, works like this.
And then I have a text field, and it says I like whatever you typed in. And so if everyone would
be connected to the same Pluto instance, then everybody's sliders would be connected. And you
would see each other's inputs and you would see each other's outputs. So that's not what we want.
Okay, so the next thought might be for every person who connects, we start up their own Pluto server.
But that will take the long and that's the problem we're trying to avoid in the first place.
Okay, so we want to try to get all visitors to use the same Pluto process without these
synchronization issues. So what exactly are the problems? So the first one obviously is that all
visitors can now edit the notebook, even though they're just visiting your website.
The solution is quite simple, we disable the editing, and then nobody can edit the notebook.
All right, next the inputs are linked. So that means that sliders get each other's values.
Also quite simple, we disable this feature, and then it's not a problem anymore.
So the only one that remains is that outputs are linked. And to demonstrate this,
let me show you what it looks like when you disable these two features.
Okay, so if we disable editing, and we disable synchronized sliders,
then you essentially have the first version of Pluto Slider Server.
And right now you see two clients connected to the same website. So the slider is not
synchronized, and you see that it's working. But if I now move the first slider on the right,
you see that it's now telling me that I have nine dogs and seven cats, even though my slider is
solid one. And the reason is the slider server, which is running the notebook,
there cats is still set to seven, because that's the most recently set bond value.
And so to understand this problem, how do bonds normally work in Pluto?
So whenever a bond is set, it sends a message to the server just saying,
for example, if you move the dog slider, dogs is now five. Then the Pluto server responds with
the things that changed after running the cell. So it says cell three is now five dogs and one cat.
Then you set cats to nine, and it says five dogs and nine cats. You set dogs to four,
it says four dogs and nine cats. And now you set dogs to five again, and you get five dogs and nine
cats. The problem here, which is what we were experiencing, is that this is stateful. So this
request bind dogs to five gives a different response than this request. So in both requests,
I'm saying dogs is five, but depending on the things that happened before it, you get a different
response. And so this is the problem. This is what we need to avoid. So the next thing I tried was,
whenever you move one slider, we tell the server the values of all bonds, like as a single collection,
and it will run all of them at the same time. Okay, so this is great. And it actually worked
quite well. But then you get some new problems. A notebook that we come in, like we had in the
course was a couple of starters and a plot, and then a couple of sizes and a plot. And they're all
just like one slider controlling one plot. But with a strategy like this, it means that changing
any one of those inputs will send all inputs, then run all of the plots and send all of them back
to the visitor. So it took more time and it was using more network than we needed. So here comes
graph theory. Instead of sending everything, we use like proofs analysis to figure out just the
variables that we need to send. And in this notebook, you can see that when I'm changing
dogs, the cells that will run is just this one cell, and it doesn't depend on the favorite foods.
And so we create a bond connections graph, which you can see if you open the JavaScript
console on the website like this. The first thing it will print is the bond connections. And for each
bound variable, it gives a list of other bound variables that could affect any of the
things that depend on it. So when I am changing dogs, I should also send cats because they have
an output in common. And you see that favorite foods is disconnected from that other graph.
And so this works really well. But it's still different from the way Pluto normally works.
And it can still happen that you know, when you're running in Pluto, it works really well and it's
super fast. But then on Slider server, it's like more naive, and it's running more,
it's sending more bond values than you think. And it's running more code than you think.
Good example is if you have one camera input, and then two sliders to select a pixel from that
camera input. In Pluto, you just have one, you just like take your webcam picture once and it's
sent to the server. And then after that, it's just the slider values. But with this slider server,
every time you move a slider, it's also resending the picture of your face, because there could be
two people visiting the website at the same time with different faces. So that's a problem.
I have some ideas, but maybe you have some ideas. So this is a problem. I have some
ideas on how we can improve. Maybe we can somehow reuse the previous workspace in case nobody
else is visiting at the same time. And then also maybe we can give better debugging, make it easier
for people to understand how their notebook is connected and help them figure out the best way
to disconnect a bunch of variables. And I'm curious to hear what you think.
Now, because we managed to make these requests stateless, Paniottis had a very good idea, which is
first of all, instead of a web socket connection, each bond request is an HTTP request. So that
means that we don't need to worry about like the web socket breaking down and your open
close and opening your laptop and the connection is lost. It only makes a request when you
move a slider. So that makes things a lot easier. And you can do things like custom routing, etc.
The second thing is now we can cache requests. So because each, like I say, the notebook state
is completely described by your notebook file and your bond values, that's exactly what we put in
the URL. So the HTTP request is a get to slash state request slash then the hash of the notebook
file. So the notebook file changes, the hash changes, and then the base 64 encoded bond values.
So together, this URL will always give back the same response, which is like the state update
to show the new cell outputs. And so we can cache it. So we set the cache headers of these requests.
And so you can see this in action on the computational thinking website. When I first
moved this slider, it takes a little while because it's computing like everything needed to do it.
And then like I keep moving this and every time there's a little bit of lag also because I'm in
Europe and the server is in the US. But then now if I go back, let's see the two was new. So now if I
go back, you see that it's cached. So these go instantly. So first of all, it's cached in my
browser. So now I can move this and get new value super fast. But the second thing you can also
cache it on like your DNS. So Cloudflare, for example, which means that someone else who's also
in Berlin will get these first values a lot faster now. And then the other thing, which is also
possible is to do like a cache on your server itself. So if you have an engine X router, you can
have it also cache results. Right. So to do, we want to make sure that like the difference between
writing a Pluto notebook and having it run on a Pluto site or server is as small as possible.
And we might need to create some new debugging tools so that you better understand the differences.
So the second thing is that we need to make the deployment easier. So we do have a Docker file,
but we should really make like a simple step by step plan. But still deploying like a Docker
container can be difficult. And we're happy to say that Julia computing will be helping us with
this. And hopefully in the future, it will be really easy for everyone to just turn the notebooks
into static websites. But with live sliders and an easy way to like run that notebook directly
in your browser. All right. That was it. Any questions? Let me know.
All right. That was amazing. I think it's so cool that you can publish your websites now or your
Pluto notebooks interactively. There were a couple of questions. The first from Michael is
are there any plans to pre-compile notebook code for faster startups?
Yeah. So that's something we definitely played with a lot, but it's quite difficult.
So first of all, one thing is like if you change the notebook and it redeploys, you just want to
be done as quickly as possible. So then it doesn't make sense to first pre-compile and then
from that pre-compiled system image. But if you deploy a notebook a number of times without
changing your dependencies, for example, there's a big benefit in not specifically pre-compiling
a system image, although that does have a benefit. But just getting the environment instantiated so
that plots is already downloaded on the server you deploy. So yeah, very experimenting. It's
difficult, but hopefully we'll get there and we're happy with your contribution, of course.
So another question. What are a couple of ways that someone might go about hosting their own
slider server Pluto notebook? Right now it's a bit tricky and I know of one other project.
They're using it. They're actually presenting tomorrow and they did it just by looking at the
GitHub repository for the MIT course. That's computationalthinking.mit.edu. And if you look
at the source code, you'll find the docker file. And if you know a bit about docker files,
then you should be able to deploy it. But soon I will write like a one, two, three-step plan
of how you can do it. And it should be easier. And like I mentioned, Julia Computing,
at the end of the last talk today, they will present their integration that they're doing
with Pluto. And in the near future, you should be able to do this directly like on JuliaHub.com.
That's fantastic. I think at this point we'll be moving on to our next talk by Benjamin. Thank you
so much, Vans. All right. We'll start in a bit.
