Okay, so what we're going to do this time is to talk about the most powerful concepts
in category theory.
So to introduce this, I'd like to talk about planets.
You see, planets are very complicated.
I don't think anyone truly understands planets fully.
Nobody's walked all around a planet, nobody's drilled into the center of a planet.
However, it's very interesting that through astronomy, basically by observing the interactions
of many planets and many celestial bodies, we can gain a tremendous amount of understanding
about the nature of planets.
And I think it's very similar with some of these highly abstract structures in category
theory.
So there are certain kinds of structures.
I'm talking about things like can extensions, weighted co-limits, co-ends.
There are these kind of structures which are so general that every other concept in category
theory can be explained in terms of these things.
And this leads to quotes like all concepts are can extensions, which is a famous quote
by Saunders MacLean.
And so it's really remarkable that these kind of highly abstract, super general concepts
do exist.
And in a sense, if we can understand them, it gives us a way to understand everything
else in our theory.
Now the issue, a bit like with a planet, is that when one focuses directly on something
like the notion of can extensions, they can look rather complicated and difficult to understand
in isolation.
And so the approach we're going to take today is to investigate the sort of interactions
between these different concepts.
How can these different ideas be related to each other?
And it's really remarkable how this is going to end up.
It's as if what we have here is some kind of like a family of fractal structures, each
of which is so kind of rich that that fractal contains all of the other fractals in the
family.
So we could, for example, explain what weighted co-limits and co-ends are in terms of can
extensions, or we could decide that we want to explain what things are in terms of weighted
co-limits and weighted limits and so on.
So basically we want to explore how these super powerful concepts are interrelated.
And this is going to be a very, very profitable thing to do.
I mean, in a sense, I view this video as a kind of celebration of how far we've come
because now we can define and explore these super general concepts.
It's kind of as if we've got above the clouds of category theory and we can see these great
peaks, these super powerful structures and how they're related to each other.
And so what we're going to do today, we're going to start by recapping the idea of can
extensions.
And then we're going to get to these fascinating ideas of your need or extension and freco
completion.
And we're going to see how all of these other fascinating concepts kind of spring from there
like a fountain.
Okay, so this is one of the most informative videos I think I've put on YouTube.
And I wanted to give some recommendations about how to watch it.
So my main one would be 2x.
So for the first hour or so of this video, I would recommend watching it on double speed.
The reason is because I like to try and define everything I'm talking about, but when we
get into can extensions and so on, the kind of level of abstraction is going to go up.
So this is sort of the first hour.
And you know, with most people, it gets to a point when it's kind of difficult to understand
on a first viewing.
So I would recommend watching the thing on double speed.
And then once we kind of get through the definition of can extensions and onto freco completions,
like the level of abstraction decreases and we start looking at lots of examples.
And these examples are seriously beautiful.
Like especially this idea of a density theorem, it's basically like the idea that, for example,
you can take a graph and you can make it out of vertices and edges by kind of gluing them
together.
But there's a sort of recipe that works for any graph for doing that, and it just comes
directly out of the maths that we've been looking at for free.
And the same idea applies for all sorts of other structures like dynamical systems and
plus your sets and all sorts of things.
It's it's pretty crazy.
It's it's almost like a universal recipe for making structures that we're going to kind
of get to.
And that's just one of the things that we're going to get to.
We're going to get to understand about profunctals and co-ends and loads of really interesting
things.
And so I'd say that the kind of level of insights which can be derived from this video
is going to sort of go up like this.
And so the the thing really is to get past this kind of hump where we're setting up the
initial structures, and it seems like it's kind of abstract.
And that's why I'd recommend watching this thing on double speed, because, you know, we
can kind of zoom through this on a first viewing and then look at these fascinating applications.
And then that's going to hopefully give you the motivation to go back and watch the thing
again, slowly get the pen and paper, try and follow all the diagrams.
And a lot of this stuff is in Emily Reel's book, Category Theory in Context, which I
highly recommend, particularly in one of the last chapters, she talks about can extensions.
And it's a very nice, clear description of can extensions where you can look at all of
the kind of formulas, details, proofs of things that I've been talking about and dig
into those in more detail.
So yeah, I hope you enjoy.
OK, so let me start with the idea of can extensions.
I have talked about them before, but they're a pretty abstract concept.
And I think they're worth introducing again, especially because I think I might have found
a slightly kind of easier way to introduce them.
So let's start with this question.
What comes next in this sequence?
OK, you can pause the video and think about it.
Now, most people would say the next number in this sequence zero to four would be six.
However, it's important to realize that there are mathematical sequences that don't go like this.
There are some mathematical sequences that go zero to four, five, for example.
And so really this question of what comes next in a sequence is not really usually very well
defined, but it is an instance of something called an extension problem, which very roughly
speaking is kind of like a problem of extending a pattern to a larger structure.
So let's have a look at that.
Here's how we can view that as an extension problem.
Let's take this set here, one, two, three as C and this set here of numbers on a right.
Let's call that E. Now, the sequence that I talked about initially can be represented by a function.
The first number was zero, the second number was two, the third number was four.
And then I asked what should be the next thing in this sequence.
And so a way we can visualize what's going on is to say that what we want to do is we want to extend the domain of this function
or the source set of this function.
And so what we could say is instead of having a function that goes from the set one, two, three, we want to think about a function
that goes from the set one, two, three, four.
But the crucial thing is that that function ought to act similarly on the values one, two, and three.
So a way we can formalize this is as follows.
We know that let's consider this slightly larger source set here, D.
Now, we know that there is a inclusion function like this from C to D.
Let's call this inclusion function K and let's call this thing that we started with F.
And so now our problem is to find a function for D to E, which acts like F does on the values that came from C.
So just like in this case down here, this function that we want to cook up ought to send one to zero and it ought to send two to two and it ought to send three to four.
Now the question we basically want to know is where should we send four?
And like I was saying, there isn't really a well defined answer, but we could send four to six just to finish the pattern.
And so what we're really doing here is we're trying to find an extension of the function F to this set D here that has a larger domain.
And the key property that we want this extension to have is that this diagram commutes.
Okay, so if we call this new purple function G, then the key property that we are sort of trying to get here is that G after K equals F.
And you can see that, right? If you pick anything in C and then you do K upon it and then you do G upon it, you get to the same answer as if you do F upon it.
So this is the extension problem.
But what I've sort of been trying to illustrate with my what number comes next problem is that extension problems involving sets and functions don't usually have unique solutions.
So let's think about this situation I've just described a bit more abstractly.
Okay, we could say that what we've just drawn here is something that's happening in the category set.
All right, so in other words, we could say, well, we have sets C, D and E.
And we are given an arrow F from C to E in the category set and an arrow K from C to D.
And then this extension problem is defined an arrow G such that G after K equals F.
That's the idea of an extension problem.
And you can think about extension problems in any category.
Now, for can extensions, we're sort of going to think about extension problems in cat in the category of categories, but there's a bit of a twist.
You see, you've probably got a bit of a flavor now.
You see, you've probably got a bit of intuition now that's telling you, well, extension problems don't normally have unique solutions.
And this is true.
It's true in set.
It's true in cat.
If you want to get just a diagram that commutes like this on the nose, it's not easy.
Usually there won't be a unique way to extend a particular arrow to make a triangle commute on the nose.
And so the idea with can extensions is that we sort of relax what we're asking for a little bit.
We're not really asking for a G, which is exactly going to make.
We're not really asking for a G that's exactly going to make a diagram like this commute.
Instead, we're going to use some kind of two cells or natural transformations to make it so that this kind of problem basically does have a unique solution, at least up to isomorphism.
So basically, we want to sort of warp this extension problem into something that can be described through universal properties.
And so for the problem of can extensions, well, firstly, it's taking place in cats.
So our objects are going to be categories and our arrows are going to be functors.
But the crucial thing is that we're not just looking for a functor G to close this triangle.
What we're looking for is a pair of a functor G and a natural transformation, which we call eta.
And G here is going to have a special name.
It's called the left can extension of F along K.
And so this is the data that defines a can extension.
I'm just going to talk about left can extensions today.
Right can extensions are very, very similar.
Again, they're talked about in my other video.
They're basically just the dual concept.
But basically what I'm going to do today is look at some really nice structures.
But everything I talk about can be dualized so you can have a lot of fun understanding all the jewels of these concepts.
But basically, the idea of can extensions is like this.
You're given a functor F from C to E and a functor K from C to D.
And what the can extension consists of is a functor from D to E, which is called the left can extension of F along K,
together with a natural transformation, eta from F to land KF after K.
And that kind of data has to satisfy a certain sort of universal property.
What is that universal property?
Well, it's the normal kind of idea that if we make any kind of similar structure.
So a functor H from D to E and a natural transformation alpha from F to H after K.
Well, then there's going to exist a unique way to convert the real deal into this sort of phony candidate.
What do I mean by that?
I mean that there's going to exist a unique natural transformation.
Let's call it gamma,
which is such that if we compose these two cells here, we get this one.
Now here's a place I think some people get confused, right?
Because they would say, well, I don't understand what it means to compose gamma with eta here.
Because this is some kind of peculiar notation and notion of composing two cells in this case,
natural transformations, which is not fully explained in many places.
So what's it mean to compose this with this?
Well, it's illustrated down here.
So basically the meaning of this is this is the composition of this natural transformation here,
shown in green, after the natural transformation eta.
What's this natural transformation here shown in green?
This is gamma horizontally composed with the identity natural transformation of K.
So this is the so-called whiskering of gamma with K.
And it really is just this horizontal composition, which is indicated here.
And you can look back at my video on natural transformations to remind yourself about how horizontal composition works, if you like.
But the basic idea then with can extensions is it's one of these kind of universal constructions.
And what we say is we say, well, I have this function F and this function K.
I wish to find the left can extension of F along K.
That consists of a function like this from D to E together with this natural transformation eta, which has this kind of form.
And this has to and is defined by having the universal property that for any similar such thing, basically for any alpha and H,
such that alpha is a natural transformation from H after K to F.
We have that there's going to exist a unique gamma such that if we compose gamma with eta,
which basically ends up giving this kind of result.
Well, that result ought to equal alpha.
Basically, the pattern is that we want one K F and eta such that for anything similar.
For H and alpha, there's going to exist a unique gamma that makes this a quality hold.
Okay, then.
So this video isn't really focused on can extensions, particularly, and I don't think it's necessary to have a really in depth understanding of them.
But I can't resist just going over the basic sort of formulas for them and things.
So we're concerned with thinking about the left can extension of a functor F along K.
Now, the meaning of that, at least the way I think of it is think that we're trying to extend the domain of this functor F,
and we're trying to extend it to this larger domain D.
So for these purposes, you could think of K as a sort of inclusion functor.
And so sort of F is defined on C, but we want to sort of extend it to a larger domain.
So we're sort of extending it along this inclusion functor.
Although in truth, K doesn't have to be an inclusion functor.
It doesn't have to be a monomorphism or anything like that.
However, we are going to make some assumptions to make it easier for us to think about these can extensions.
So recall that we say that a collection is small when it's a set.
Recall that to set up category theory to speak about things like the category set.
We really have to go sort of beyond set theory, otherwise we run into Russell's paradoxes and things like this.
So we should really say that a category has a class of objects if we want to.
I mean, it depends how which sort of method we want to use to overcome these kind of problems of collections which are too large.
But anyway, so a category small when it has a set of objects or, you know, maybe just like a finite set of objects or it could be an infinite set or whatever.
So the category set is not small, right, because there isn't a set of sets.
Otherwise, we'd be in paradox country.
So set is not small.
It has too many objects.
But we're going to suppose now that C here is small.
And we're going to suppose that D is locally small, which means that if we pick any pair of objects, the collections of arrows from A to B is forming a set.
And we're also going to suppose that E is co complete.
And that means that there's going to be a co limit of every small diagram in E.
So in other words, if we take any small category like C and we do a functor, there's always going to be a co limit of that functor.
So for example, it could be that E is set or E could be any category of pre sheaves.
It could be a category of vector spaces.
There's loads and loads of co complete categories.
And we're going to suppose that E is one of those.
And so with these assumptions, we can really understand the structure of these can extensions.
So in particular, whenever we have these assumptions holding this left can extension here is always going to exist.
And I'll tell you the formula for it.
So here's the formula for it.
This.
So.
Land K of F is going to be a functor from D to E.
And so we need to really describe how this functor works on objects of D and arrows of D.
So what about objects?
So what about if we have an object, little D of D?
What does land KF do to it?
Well, it sends it to this thing here.
And you see that this is a co limit of a diagram in E.
And in particular, it's, it's given by this composition here.
So what we have here is the common category.
So we have this functor K from C to D.
And we're sort of slicing or commering that with this functor.
Little D from a trivial category into a big D.
And so this thing here is a comma category.
In some previous videos, I wrote it with this notation instead with the downwards arrow, but I prefer to slice now.
Anyway, you can see my video on universal properties or the video on can extensions for more details about comma categories.
Here's the very, very brief recap.
The objects of K slice D look like this.
The arrows of K slice D look like this arrow H from C to C dash that should make these kind of diagrams commute.
Okay, so let's write this thing that we get when we do our left can extension on D as LD.
So you see that this is given by a co limit.
And so this thing here is going to be an object of category E, but it's also going to come with this sort of universal cone, which we'll call Lambda D.
So that should, of course, be a natural transformation from this functor here to a constant functor.
So that will be Delta LD.
That sends everything in this category here to this object LD of E.
So we could pretty much define this as to say it's this composition here.
And that's why I'm writing this equals sign here to say that this little triangle at the bottom here to say that this triangle at the bottom here commutes.
So, so this is telling us how this functional here is defined on objects.
How is it defined on arrows?
Well, basically, if we have an arrow G from D to D dash, then this kind of
So I mean, basically, if we have an arrow G, then it's going to get sent by our left can extension of K along F to this arrow Q here, which is going to be unique such that this kind of triangle commutes.
So I don't really want to go into the minutiae of this.
Basically, this is a diagram in a functor category.
And we know that there's going to be a unique arrow that makes this thing commute because this is like a universal cone.
And what we have here is a horizontal composition.
And this functor here works on objects like this and works on arrows like the identity.
I'm not going to dwell on this.
If you watch my video on can extensions, I go through all this in in much more detail.
But I just wanted to quickly show you how you can calculate all the parts of these can extensions.
And so the final bit is how do we actually calculate this natural transformation here?
This eta.
And basically the formulas over here.
So this is the key formula here.
Where this lambda here is our sort of universal cone, which comes from calculating that co limit I was talking about before.
So the point really is that when these conditions hold, we have all these nice formulas to be able to compute this left can extension.
Actually, I should just say quickly that something else really, really nice happens in this case.
In fact, we can think of this land k thing here as a functor, which goes from this functor category here to this functor category here.
And it's actually just going to be the left adjoint of K star.
So let's remember our setup.
We have this functor K, which goes from C to D.
And that means that we can form this functor K star.
And basically this just works by pre composition.
So it works according to this formula here or this expression here.
So if we have an objective D comma E as in a functor G from D to E, then K star just sends that to G after K, which is going to be a functor from C to E.
And you can see that it sends this arrow beta here of this category to this arrow here of this category.
So it's very cool because basically we can also think of these can extensions in terms of adjoint functors.
Basically, we're just computing the left adjoint of K star.
And this is land K.
And then if we take an object of this category here like F, well, if we operate land K on F, then we get the thing that comes from this triangle here,
which is the way that we originally defined this left can extension.
And so it's very cool that when we have all these conditions holding these ones here, like it's not just that we can compute the left can extension of F on K.
We can compute the left can extension of any functor from C to E on K.
And actually that gives us those all sort of fit together to give us this sort of bigger functor, which allows us to go between these two functor categories.
Just to finish, you know, to complete the picture.
For this adjunction, there should be a unit, of course, which should go from this identity functor here to K star after land K.
If we look at a general component of this natural transformation eta dash, well, let's say we look at the F component, it should have this kind of form.
Can you guess what it is? Well, it's just exactly eta.
It's exactly the natural transformation that fills in the triangle from the definition of the left can extension in the first place.
So there we are, a sort of very quick recap of can extensions.
Now let's get on to a really fascinating application of these things where we're going to think about all sorts of things to do with with free co completions and density and how we can make lots of objects by sticking other objects together and co ends and all sorts of really fascinating connections with lots of things in maths.
So let's go.
Okay, and here's one final result, which is going to be really useful for us to simplify things.
And it basically says that in a special case, which is going to occur for us frequently, there's some details of these can extensions that becomes simpler.
So we're going to keep with this assumption here.
And in that case, we have this result holding.
And it says that if this K here is a fully faithful functor, which basically means that it acts like a kind of bijection on Homsets.
In other words, this is going to, for example, send the arrows from C to C dash to the arrows from K C to K C dash.
And it should always do that kind of thing like a bijection if it's fully faithful functor.
Well, in that case, we have that this ether here, this kind of natural transformation that fills in the triangle is always going to be a natural isomorphism.
So the particular case where this is going to occur for us is basically when C is just a full subcategory of D.
In other words, when we get C just by picking a load of objects of D and looking at all the arrows between those objects, and that basically gives us C.
So in that special case where C is a full subcategory of D and K is just this inclusion functor, basically, this result says that essentially, we don't have to worry about this natural transformation, right?
This diagram commutes, in that case, at least up to a sort of natural isomorphism here.
So this is really nice.
Like, remember, the way I introduced Can extensions, I basically said, well, we're talking about this extension problem, but then, oh, we have to add in these high dimensional cells to make things so that we have unique solutions.
And yada, yada, yada.
Well, in this special case here, basically, where K is a fully faithful functor, and we have these nice conditions which give us this kind of co-limity way of describing this left can extension.
Well, in this case, basically, up to isomorphism, we pretty much do have that this triangle commutes, and we don't really have to worry about the form of Ita in this case.
Okay, then.
So now we've got our Can extension ideas ready.
Let's get on with the central idea I want to talk about today, which is something called the free co-completion of a category.
So the easiest way to explain it is just directly.
There's various ways of looking at this notion, but the simplest one is just to say, well, we have a category C.
We want to determine the so-called free co-completion of that category.
And basically that is just the category of pre-sheaves of C.
So that's the category of functors from the opposite of C into set.
And this is something we've seen a lot before.
We've seen a lot of these pre-sheaves.
We've seen that things like the category of graphs and the category of dynamical systems can be thought of as categories of pre-sheaves.
And we're pretty familiar with these ideas.
And you may know that these categories of pre-sheaves are always co-complete.
So in a sense, you can see this free co-completion operation as a way to take a category C and sort of freely add co-limits to it so that we end up with a co-complete category.
Now, there's a bit more to this idea.
Another piece of information which comes along when we make this free co-completion is this functor here, which is called the yonida embedding.
And what this does is it takes an object C to this honfunctor, C of blank comma C.
So this is your contravariant honfunctor.
So when I write this thing here, this is a functor from C op to set.
If we have an arrow in C, let's say from C dash to C dash dash, let's say it's this arrow G.
So there we are.
That's an arrow of C.
It's going to correspond with this arrow G op in C op.
And when we do this honfunctor on it, that's going to give us an arrow like this.
And the way that you can think of this working is that if we have an arrow of C, let's say R from C dash dash to C,
then this is going to send it to this arrow R after G, which is going to go from C dash to R.
So that's basically the nature of this functor here.
However, there's a bit more to this, of course, because this yonida embedding, yes, OK, it sends an object C to a honfunctor like this.
But what about if we have an arrow H from C to D?
Well, that's going to give us an arrow in the target category, which will be called C of, well, let's call it C of blank comma H.
And it's going to go like this.
And how does this work?
Well, if we look at the eighth component of this, that's just going to be a function like this.
And it's going to be sending an arrow R to the arrow like this.
And there we have it.
So that's basically the nature of this yonida embedding.
And it's very interesting is this yonida embedding, it comes up all over the place and it is a fully faithful functor.
OK, so it's sort of, I mean, it's actually it's pretty fascinating if you consider, for example, C equals this category here.
If it turns out that in this case, this category of pre-sheaves, well, it turns out that in this case, this category of pre-sheaves is the category of graphs.
And so that's kind of interesting for several reasons.
One of them is that you can kind of think of this C as something like a graph.
OK, we've kind of injecting this vertex and as a source or a target of this edge.
But then when we do its freco completion, we get all of the graphs.
And in a way, you can kind of think of that as making all graphs by starting with something basic and sticking things together.
Less hand wavy.
Well, we can see that this yonida embedding is basically injecting this sort of basic structure that kind of lies behind all graphs into the category of graphs as a sort of full subcategory of the category of graphs.
Actually, the full subcategory which is on these kind of home functors.
So I sometimes wonder if our universe is similarly constructed if there's some kind of a category C that represents the way that all of the elementary particles in our universe interact.
And somehow that's embedded into our universe.
And then all of the other structures that we have in our universe are sort of, you know, made out of those elementary bits in some kind of a free way.
But that aside, the point here is that we're looking at some kind of a universal construction which gives us this kind of yonida embedding.
And this is called the free co completion.
So again, just to say it briefly, the hand wavy idea between a free co completion is that we take a category C and then we sort of freely add all co limits to it in some sense.
We sort of take the bits of C and we glue them together and sort of freely produce and make a structure in a kind of free way that has all co limits.
Another example we can look at for free co completion is the trivial category one, the category that just has one object and the only arrow is the identity arrow.
In that case, again, we can consider the free co completion of that.
And you see that that's just going to be isomorphic to the category set itself.
Now, what this reminds me of is the idea that we can make all sets by starting with a kind of singleton and then doing things like co products and repeatedly adding this singleton.
And if we have our ability to do injections and whatnot, then we can get all of the structure of set.
OK, so I think that's enough hand waving. Let's actually look at the kind of universal property that this free co completion has.
So recall that we have this category cat, which has objects as categories and arrows as functors.
Now there is a.
Now what we can do is we can think just about the co complete categories.
OK, so they're going to be the categories that are co complete that have all of these small co limits.
And we can just restrict our attention to the objects of cat, which correspond to these co complete categories.
And then we can also restrict our attention to the arrows of cat, which preserve co limits.
OK, so then we can think of this subcategory of cat that will call cat co comp.
So basically cat co comp here is it's going to be a subcategory of cat.
The objects it has are going to be the categories which are co complete.
So the ones which have all small co limits or the co limits of each small diagram, if you like.
And then the arrows of this thing here are going to be the functors.
Which preserve those small or small co limits.
So to say it more briefly, cat co comp is the subcategory of cat on the objects,
which are the co complete categories and the arrows, which are the co continuous functors,
the functors that preserve the small co limits.
So basically, this is the stuff that plays nicely with co limits.
Now, there's clearly going to be an inclusion functor I from cat co comp into cat.
And it's this that we're going to use to find our kind of universal property.
This kind of universal property behind free co completion.
So okay, what's the big idea?
Well, the big idea is that in cats, let's pick any category C.
And let's ask, is there an initial morphism from C to I?
Or, you know, we could also say there are universal morphism from C to I means the same thing.
And what it means is that we're looking for some kind of a universal construction.
And it turns out that there is such a thing.
And what it is is the free co completion of C.
And what it consists of is this category of pre sheaves, the category of functors from C up to set.
And also, there's going to be this arrow in this right hand side category.
I mean, technically, it's going to go from I of this category of pre sheaves.
I mean, technically, it's going to go to I of this category of pre sheaves.
And that's going to be our needed embedding.
Now, often I might just rub out that I because I is just an inclusion functor doesn't really affect the nature of the objects.
Sometimes there's sort of no point writing it, but I'll write it for now.
So the point is that this together with this is going to be forming an initial morphism from C to I.
Now, let me remind you what that means.
What it means is that for any object E over here on the left.
So he's just going to be any old co complete category.
Well, if we have some arrow, which sort of looks like why over here.
So this is just a kind of candidate arrow is going to be an arrow F from C to I of E.
Well, there's going to be this sort of corresponding intermediary arrow, which we're going to call F hat.
And that has the feature that when we do I on it, it's going to make this triangle commute.
All of this just comes from the definition of an initial or universal morphism.
Now, like, there's a lot of things going on here.
A lot of structures just appeared at once.
Let me just point out a couple of things that I'll come back to later.
Firstly, I is just an inclusion functor.
So in a sense, we could just kind of rub out these eyes here and it wouldn't really change the meaning too much.
And now does this structure remind you of anything that we've been looking at?
What about if I wrote this as Lan Y of F?
Do you see that this is the same pattern as we've been looking at with our can extensions?
In particular, this thing's fully faithful.
So this thing which has to fill out the triangle, this natural transformation eater can effectively be ignored.
And so basically, you can see that this kind of idea of can extensions is appearing here.
In particular, just this notion of these universal morphisms is basically forcing us to find a unique way to close this triangle here.
And this is exactly what can extensions do for us.
So it turns out that not only is this category of pre-sheaves together with the yonida embedding giving us an initial morphism from C to I.
But moreover, the left can extension of any functor F from C to some co-complete category E.
Well, the left can extension of such an F along the yonida embedding Y is exactly giving us this kind of intermediary arrow,
which allows us to emulate our kind of candidates arrow F for being an initial morphism with respect to the real deal,
which is of course the yonida embedding.
So you can see that there are lots of ideas, lots of very cool ideas kind of interacting here.
I mean, I'm probably going a bit too fast, right?
There's a lot of things coming out at once, but we're going to get more kind of familiarity with this idea.
But just to sort of finish explaining the gist of this, basically the point here is that when we have this category of pre-sheaves together with this yonida embedding,
that's giving us an initial morphism from C to I.
Now, if you have a look at my video on representable functors, I talk about how this kind of phenomenon appears over and over again in category theory
and how there's several different perspectives to look at the same idea.
So another way to look at the same kind of happening is to say that this category of pre-sheaves together with this yonida embedding
is going to be an initial object of this comma category here, C slice I.
We could also write it like this and then it looks like a category of elements.
Another way to look at this is that this thing here is a functor into set, okay?
It's really a functor from this cat co-comp into set.
And what the yonida embedding really is, is it's just going to be like an object or an element of this kind of set-valued functor applied to this input.
Okay, so when we do this functor on this object here of this category, we get this set and y is just going to be an object of this set.
And so we can apply the yonida lemma, which is telling us that the elements of this set correspond to natural transformations
into this functor here from the corresponding hon functor.
And so this thing here is going to correspond to a natural transformation like this.
Turns out it's actually going to be a natural isomorphism.
And so we get this, which is like a really cool idea.
And just to sort of fill in this dummy variable here, what this is telling us is that if we pick a co-complete category E,
then the co-continuous functors from this category of pre-sheves into E are going to be in one-to-one correspondence with the ordinary functors from C to E.
So this is a pretty cool idea.
I mean, it's especially cool because we kind of already know how this works.
Okay, so if we have a category C and then we have something in this set here,
so we can really just think of this as a functor F from C to this co-complete category E.
Well, how do we get the corresponding kind of co-continuous functor over here?
Well, all we do is we go, okay, we've got a yonita embedding here from this into this category of pre-sheves.
And now let's just do the can extension of F on Y.
The left can extension, 1, Y, F.
And there we have it.
We have F over here and we have 1, Y, F over here.
And so that's how this kind of isomorphism of Homsets works.
We basically just get it using our can extensions and also provided that C is small, we have a formula for this 1, Y, F.
We've already seen a formula for it in terms of co-limits so we can compute all this stuff.
And that's very nice.
So now we can kind of come back down from the heavens for a moment and just think about a particular case to get some intuition.
So we can say, well, what happens when C is 1?
So let's just have a look what we've got here.
We can rub out these eyes, as I say, they don't really change much.
We can put 1 in here.
This is just our trivial category.
And so what we've got going on on the right here is going to be a functor F from 1 to E.
So this is just going to basically be picking out an object of E.
And we can see that this is going to correspond to a co-continuous functor of this kind of form.
Well, the functors from 1 to set basically just look like sets.
So this is telling us something pretty interesting.
It's telling us that the objects E of this category, script E ought to be corresponding with these co-continuous functors
from set into E.
And I think that this is actually kind of intuitive, really, because think about it.
E is a co-complete category, and we want to do a co-continuous functor from set into E.
So what's the first thing that we might ask ourselves?
Where are we going to send the terminal object?
Well, this yoneda embedding is going to be sending our 1 here into the singleton set.
So we better send the singleton set to this object E here, where F sends the object over here.
So the question we're asking here is how do we cook up this functor H, which corresponds to this object E?
And the answer is, well, we better send the singleton set to E.
But then what about the set with two elements?
Well, that's going to be the co-product of 1 and 1.
And the fact that we're forcing H to be continuous means that this better look like H of 1 co-producted with H of 1 in E.
And so you can see that the way that we're acting on all of the other sets, all of the other kind of objects over here,
is fixed by the way that we're dealing with the terminal object.
So you can see that just picking any object of E is really going to give us a sort of co-continuous functor H from set to E,
because any such functors essentially having all its form fixed by the way that it operates upon the singleton set.
And you can kind of think of this intuitively as well, like co-completion is all about taking some initial structure
and sticking the bits together in a kind of freeway.
So you're doing co-products where you're sort of doing disjoint unions and you're doing co-equalizers where you're sticking stuff together.
And if you just start with one dot and you start doing that kind of stuff, you're going to get lots of different sets.
So it kind of seems to make sense to me that the free co-completion of a singleton set.
So it seems to kind of make sense to me that the free co-completion of a trivial category is set itself.
But, you know, this intuition goes much further.
Like if you think about your category of graphs, you can think of graphs as things that you get by sticking together.
Your basic graphs, you know, like your single vertex and single edge.
Again, with the category of simple as your sets, you know, you can make simplices or be simple as your complexes by sticking together these basic simplexes.
And again, you know, it's described by a category of pre-sheaves.
There's co-completions afoot.
And yeah, this is like a really kind of important idea which touches lots of things in mathematics.
OK, then. So basically, most of the rest of the video is just looking at some very interesting applications of the kind of things we've already talked about.
Now, I know it's a pretty high level of abstraction that we're dealing with.
But I just want to sort of urge you to just hold on a little bit longer and soon all the applications we're going to look at.
I'm really going to help you to kind of cement these things in memory and so on.
So basically, just before we start looking at the applications, like the first one I want to look at, I think, is basically the idea that we have a sort of universal recipe for making any graph by looking at the vertices and edges inside it
and sticking them together. And we can see that one of the applications of the ideas we've already looked at sort of tells us how to do that instantly.
And of course, it doesn't just work for the category of graphs.
It works for simplices and dynamical systems and innumerable other cases.
So soon we'll be there.
But to make this more efficient, we're going to do some kind of a little bit of calculation now, which is really going to help us later.
So you can see that most of this stuff to do with free co-completion boils down to this diagram here, which is really representing the left-can extension of this functor F into this co-complete category E along the yonida embedding.
Now, since y is a fully faithful functor, we basically know that this can extension after y is naturally isomorphic to F.
So we don't have to worry about this eta natural transformation.
And really, we're mostly just interested in calculating this land y F thing that we're going to abbreviate to be F hat.
And in particular, let's just suppose that we have an object in this category at the top here.
So we have a pre-sheaf W. Well, how do we calculate F hat of W?
Well, we've already seen a formula for this.
And here it is.
So we can calculate this functor F hat operating on W to be equal to this co-limit here.
But the thing is with this co-limit, it starts with y slice W or y slice or y comma W, this category here.
And it turns out that I don't think that's such an easy thing to understand directly, but it has a sort of equivalent form that's much easier to think about.
So let's think about what this is.
Y slice W. I mean, it's actually just a comma category of these two functors here.
We can see that y is a functor into this category of pre-sheaves.
And so is W. I mean, W is really just a functor from the trivial category.
It's just picking out a single pre-sheaf.
Now, this category y slice W more concretely, its objects are going to look like this.
So they're going to consist of an object of C and an arrow from y of that object into W.
And the arrows are just going to be these arrows in this slice category.
And the arrows in this comma category here are just going to be like this arrow H from C to C dash that makes this kind of diagram commute.
But basically, we can transform this slice category into this one here.
And the key to this is the go needle Emma, because what's an object in Y slice W?
Well, it's basically going to be a natural transformation E from this home functor here into W.
And whenever you see natural transformation coming out of a home functor, you should get a Japanese voice in your head that says,
you'll need to transform this into a form of elements.
So that's what we'll do.
We apply the young dilemma and we see that this kind of natural transformation is equivalent to this element.
E hat of W of C, where this is given by E C of one C.
Now, basically applying this gives us this kind of isomorphism between this category here and this category here.
What is this category here?
Well, what I've written at the top here is the singleton sets.
The singleton sets can be considered to be a functor into sets.
W can also be considered to be a functor into set from C op.
And so star slice W is this comma category here.
But it turns out that we want to take the opposite of that.
So really, this is, well, some people would call this a category of elements for a contra variant functor.
Yes.
But the point of this really is that what we have here is just a category that has objects like this and arrows like this H.
And I'll sort of leave it to you to work out the details of this correspondence here, but just to give a very sort of brief five minute outline.
The idea is that we have an arrow H in this category down here.
So it's going to go from an object like this to an object like this.
But remember that what we have here is really the opposite of star slice W.
And this H here corresponds to this arrow H op that goes from C dash E dash hat to C E hat in star W.
And that just corresponds with this arrow H op of C op, which makes this kind of triangle commute.
So if you apply for your needle Emma, you can see that this basically just corresponds with an arrow of this kind of form in Y slice W.
So I know that's a lot to take in.
Maybe don't worry about the details of this on the first viewing.
And basically is that we can rewrite this expression here in this kind of form here.
So here, this projection function here, that's going to take an arrow C comma Y C E W.
And it's just going to project it to become C.
And this kind of projection functor here is going to work in a sort of analogous way.
So what we're going to have here are objects of the form C comma E hat.
And the projection functor is just going to send those to C.
And then the arrows in each of these categories just look like arrows of C.
And we can think of those at least symbolically as just sort of unaltered by these projection functors.
So this is very nice because the final form of this basically involves a sort of category of elements here.
And then we're just sort of projecting those elements down into C.
So we can almost think of this as a sort of vibration.
We can think of these as sort of fibers above these objects of C in a way which is as described by this kind of pre-sheaf W.
And then we're just sort of functoring these into F.
We're just sort of functoring these into E and then asking for a co-limit of the resulting functor.
I know still this is pretty abstract, but now we're going to start looking at some examples.
And hopefully we'll end up happy that we made this simplification step here because it's going to save us some work later on.
So OK, we've done the hard part.
Now we can start to look at some applications of this free co-completion concept.
So the first one I want to look at is the so-called density theorem.
And so for this, all we're going to do is pick a particular functor F here to focus on.
And we're going to focus on the case where F itself is also the yonida embedding.
So what we're essentially looking at here is the left can extension of the yonida embedding along the yonida embedding.
And if you recall, the idea behind these can extensions usually is that we're to find a two-cell eta that fills in this triangle in a sort of universal way.
However, in the special case where this functor here is fully faithful, as is the case with the yonida embedding,
essentially we're just looking for the unique kind of arrow here, which just makes this triangle commute.
And it's easy to see in this case that there's an arrow that makes this triangle commute, which is just the identity functor, right?
Because identity after y equals y.
And so we already know the form of this left can extension.
We know that it's the identity, but we also have a formula for it from before.
You remember this formula we were just looking at?
You remember this formula that we were just looking at in the general case?
Well, we can just look at this in the case where this f here is the yonida embedding, and this y here is our category of pre-sheaves.
And so what we get, and so if we do that, we see that we have this formula here, which is for this.
But we also know that this is equal to the identity functor operating on w, which is just w.
And so we have this equation here, and this is our density theorem.
Maybe I should write isomorphic here.
And this is quite remarkable because it basically gives us a way to think about this functor w.
So think about w as a sort of structured set.
A lot of these pre-sheaves, you can think of them as structured sets, things like graphs and dynamical systems and things like that.
Well, what this results basically telling us is how we can build this structured set here by sticking together humfunctores.
And think of the humfunctores as sort of like elementary particles or elementary structured sets.
So think about, for example, a single vertex or a single edge in the category of graphs.
Those will correspond to the humfunctores.
And what this result is telling us is how we can glue those things together to make w.
And the reason is basically because this is some category.
Basically, this is going to turn out to have sort of all the bits and pieces that make w.
And then when we do this functor composition here, it's going to replace these bits and pieces with the corresponding humfunctores.
So we're going to have all these kind of, we're going to have this sort of diagram.
For example, in the category of graphs, it's going to consist of a load of lone vertices and lone edges with some maps telling you where to go.
And then when we form this co-limit, we're essentially gluing all of those vertices and edges together to actually give the graph w that we want.
So it's pretty amazing that we basically get this blueprint for building any kind of structured set at all out of its sort of elementary parts.
And the whole thing just is given to us automatically as a fairly special case of this idea of free co-completion.
So, you know, it's stuff like this that like really, you know, it really makes me glad to know category theory because it's kind of like, to me, it seems pretty obvious that this is like the right way to think about.
To think about like how structures are assembled from elementary pieces because it's not like something that people have to figure out.
This is given towards automatically as a small piece of a large, elegant structure.
Okay, so let's apply this density theorem and we're going to apply it to the category of graphs and it's going to tell us how graphs are assembled.
Okay, so for our category C here, we're going to pick this category here.
So it's got two objects, E and V, and these two arrows S dash and T dash from V to E.
And so now C op is going to look like this.
And as we've seen before many times, functors from this category into sets are going to correspond to graphs.
So let's have a look at an example.
Here's a functor W from C op to set and it's going to send E to this set here and V to this set here and S is going to get sent to this function here and T is going to get sent to this green function here.
So we can visualize this in this manner shown below here.
And what we're doing here is visualizing each of these elements of W E as an edge that goes from the place it gets sent by W S to the place it gets sent by W T.
So this is a sort of visualization of the graph W.
Now all we have to do is apply this formula here.
And so we want to be calculating a co-limit of this functor here.
So to calculate this category of elements here, we just look at this picture and then we sort of rub out these bubbles and reverse the arrows and we get this category here.
This is our category of elements.
This is star slice W op.
Now this projection functor here is just going to forget the second entries.
And so it's going to send these two onto E and these two onto V.
And then after that we want to do this yonider embedding, which is going to send this object E to the graph that just holds a single edge between two distinct vertices and nothing else.
And also the yonider embedding is going to send V here to the graph that just has a single vertex.
And so when we compose these, we get a diagram in the category of graphs and that diagram is going to look like this.
And then we just want to calculate the co-limit of this diagram.
And basically all that corresponds to is sort of imagine each of these lines here that are showing how things getting mapped as a sort of thread.
And we just sort of pull those threads tight and glue the structure together.
And you can see that if you do that, you recover the graph that we had originally because this directed edge here has its source and its target as this vertex here.
And this directed edge here is going to be going from one to two.
And so yes, when we do the co-limit, we get this structure.
And it's interesting to see how this theorem basically tells us how we can recover our graph from these kind of elementary pieces.
Okay, so now if we return to the fountain, we return to this expression here for our free co-completion.
Well, this F hat here, this one YF, this is sometimes called the yonida extension of this font or F.
And it turns out that this is related to another of the super powerful categorical concepts.
And that's the idea of a weighted co-limit.
So the connection is pretty simple.
If we have a font or W in this category up here, this category of pre-sheaves.
If W is a pre-sheaf, basically.
Well, when we do F hat on W, we can call that result the W weighted co-limit of F.
And so this is this idea of weighted co-limits.
And they're normally characterized in a somewhat different way.
Normally, one would characterize a weighted co-limit by an expression like this.
And we'd say that the W weighted co-limit of F, where F is a font or from C to E and W is a font or from C up to SET.
Well, the W weighted co-limit of F is defined such that we have these kind of isomorphisms natural in E.
But I think it's easier to think of them directly as just being produced by doing this F hat on these pre-sheaves W.
So we can see that there are a couple of interesting special cases of these weighted co-limits.
One of them is where we take W to be this diagonal functor here, this functor which is constantly equal to the singleton set.
And if we use that as our weight, then it turns out that our weighted co-limit is just going to look like an ordinary co-limit.
And you can check that by unpacking the actual formulas that we've got for F hat as we've described above.
Now, another thing that you could do with this formula is you could instead set C to be a singleton set.
Is you could instead set C to be the trivial category of a single object.
In that case, F is just going to be an object of E, essentially.
And if you look at the meaning of this formula in this case, well, it reduces to this kind of form.
And you see where we wrote a co-lim W of F, we're now writing W dot of F.
And that's because this thing over here is what's known as the co-powering of F by W.
And you can really think of it like if this category E has co-products, then you can think of this expression here as the co-product of this object F with itself W times.
So if we think of W now as a set, let's say it's a set of three elements, well, this would just be F plus F plus F.
So this is basically F co-product with itself once for every element in W.
And you can see that this kind of expression here ought to hold, right?
Because like, let's say W was a two-element set, well, this would be like an arrow from F plus F to E.
And that's going to correspond with two arrows from F to E, or if you like a function from a two-element set, two to set of arrows from F to E.
So this is the idea of so-called co-powering, which is also known as tensoring.
And it turns out that we can get something else out of this kind of idea as well.
So if we then think of another special case, let's suppose we have a category A.
And what we're going to do is we're going to set C to equal A op times A, and we're going to set E to equal set.
And so what we're going to have as F here is a functor from A op times A to set.
So things that have that kind of form are sometimes called bifunctores.
And we'll call this functor H just because it's a bit weird, so we'll give it a different name.
So just write it down.
We're supposing that A, we're supposing that C is A op times A, we're calling this FH, and we're supposing it's going to set.
And now if we look at this particular case, of course, the same kind of result holds.
But what we can do is consider a special case where this W here, so here W is going to be going from C op to set,
or if you like, it's going from A times A op to set, so that's the form that W is going to have.
So we're going to consider the case where W is the humfunctor of A op.
OK, because the humfunctor of A is going to be a functor from A op times A to set.
So the humfunctor of A op is going to have this kind of form here.
And so we'll take that as our W.
And now if we just work out what this kind of thing is, well, what we end up with is this sort of formula here.
OK, so we're doing this arrow here, which we should probably put H here now instead of a W.
We're doing H hat on this hum A op.
OK, so what we have here is that this is H hat operating on hum of A op.
And we can write it directly like this.
Here's the same thing written as a weighted co-limit.
But now what I'm telling you is that there's this other idea in category theory called a co-end.
And it turns out that we can really define a co-end to be this.
So the co-end of this bifunctor H can be defined to be the hum A op weighted co-limit of H.
And we usually write these co-ends with this kind of integral form like this with the kind of thing that we're integrating upstairs.
So there we are. We've just got this notion of co-ends totally free out of this theory.
OK, so now we're ready for the final application of these big ideas.
And that is understanding profunctals.
So a profunctal from A to B is the same thing as a functal P from A op times B to set.
And a good way to think of it is that, well, you can think of it as a generalization of a homfunctal.
That's quite a good way of looking at it.
So, you know, if A equals B and this is a homfunctal, well, that's a kind of profunctal.
Or you can think, well, I'm sending a pair of an object of A and an object of B to this set.
And you can kind of maybe think about something like the set of proofs that A implies B or something like this.
And maybe you can think about something like the set of proofs that the first proposition, the object in A,
implies the second proposition, the object in B.
There's various different types of intuition that you can have.
Now, it turns out that there's a category of profunctals.
And with this kind of machinery we've been talking about today, we can understand it.
So, as I say, a profunctal P corresponds to a functal of this kind of form.
So, we're free to apply a kind of swap of the order on the left and some currying.
And then we can change it into a functal of this kind of form.
So, we'll call that P dash.
That's clearly an equivalent form.
But the sort of maths that we've been talking about today tells us that a functal from B to this category of pre-sheaves here
corresponds to a co-continuous functal of this kind of form.
A co-continuous functal between these two categories of pre-sheaves.
So, this is another equivalent form for this profunctal P.
Now, there's a nice analogy in what's going on here with linear algebra.
I haven't covered linear algebra in this course.
If this doesn't mean much to you, don't worry.
But this is the basic sort of analogy.
It's that if you think about A and B as finite sets, then we could have an A times B matrix.
And that corresponds to a linear map from B dimensional space to A dimensional space.
We could also think of it as just a function sending the elements of B to A dimensional space.
And if you look at this pattern, it's pretty much analogous with this pattern here.
It's just here we have profunctals instead of functions.
And we have co-continuous functals instead of linear functions.
But basically, the idea is that once we start off a profunctal of this form,
we can convert it into this form trivially.
And then this idea of free co-completeness, and in particular this type of diagram here,
gives us this equivalent co-continuous functal, which sort of corresponds with this functal P-dash.
And this turns out to be the key towards defining profunctal composition.
You see there's actually a category called prof, and it has objects as categories,
and it has arrows as profunctals.
Now, the identity arrow of an object A is just going to be this profunctal,
which is just the hom functal of A.
That's, of course, a functal from...
We can, of course, think of that as a functal from A op times A to set.
So it is a profunctal.
Turns out that it really acts like the identity in this category of profunctals.
A more interesting question is, how can we compose general profunctals?
So what about if we have a profunctal P from A to B and a profunctal Q from B to C?
And we want to compose them.
Well, then we want to end up with some kind of thing that we could call a composition,
which ends up being a functal from A op times C to set.
And it turns out that basically we can just define it to be this kind of composition here.
So this LANYP dash is, as shown in this diagram, we know how to compute it.
We've looked at a formula for it earlier and so on.
And if we just compose this after this, you can see that we have something that goes from C to this category of pre-sheaves.
And if we just sort of untangle this, we can put it into this kind of form
and consider it to be the composition Q after P.
So basically that's how profunctals work.
Now, it turns out that the normal way of thinking about this is that one writes profunctal composition with a co-end formula like this.
But, you know, we don't need to do that because we have this way of thinking about it in terms of can extensions and co-completeness.
And by the way, the stuff I just talked about to do with composing profunctals is basically remark 5.1.7 of Fasco's book, co-end calculus, if one wants to dig deeper into this.
So if you want to understand about profunctals, definitely the best advice I can think of is that you should consider what happens when the categories involved are discrete.
Okay, because if you think about it, what's a profunctal from A to B when A and B are discrete categories?
Well, in that case, these things don't have any arrows.
It doesn't matter about taking the opposite of the categories because there's no arrows to reverse, you know, we only have identity arrows.
And basically for every object of A and object of B, we just have a set and that's all the data which goes into defining the profunctal.
And if we think about finite sets, then essentially we can just think of a profunctal as something like a matrix of non-negative integers.
And in that case, if one looks at the way that profunctal composition works, it looks exactly like matrix multiplication.
And this is really beautiful because you'll see that basically if you look at the full subcategory of this category of profunctals on the discrete categories, well, it just looks like linear algebra basically.
It just looks like the profunctals are like matrices and composing them is matrix multiplication.
That's all there is to it.
And so that's kind of beautiful.
The final thing I want to say just to come full circle is that co-ends are another one of these super powerful ideas.
And it turns out that we can express can extensions in terms of co-ends.
So when E here has co-powers, we can express this formula for the left can extension here in terms of co-ends like this.
So now we've kind of come full circle and remember everything I've talked about today can be dualized.
So if we go back, back, back way back in time to our original diagram.
Yeah, you can dualize all this.
So you've got right can extension here.
There's a sort of analog of the yoneder extension.
There's the idea of free completion.
We have weighted limits.
There's an idea of powering, which is also called co-tensoring and so on.
So, you know, there's a very rich web of ideas here.
And in particular, the main sort of point I want to get across and, you know, you can dig into further resources like nlabs to understand more about this.
But the big idea is that like can extensions, weighted co-limits and co-ends are also general that you can talk about the other concepts from inside them.
So we kind of have this idea of these concepts, which is so general that any other concept can be expressed in terms of them.
