Good afternoon, everybody, and welcome to my talk about C, which is a quite unexpected
talk for this kind of conference, right?
You come here to hear all about modern languages like C++, Kotlin, a couple of years ago, nowadays
for us is hugely popular, and you hear about this.
And this is about C, which is like, yeah, this grandfather of languages.
So quite surprising, and I'm happy that you are here also to listen to it.
Now, on the other hand, C is not going anywhere.
It's definitely not going anywhere.
I had a pleasure to attend the conference a couple of weeks ago when there were people
from, lots of people from automotive industry, and obviously those guys only use C and C++
and it's a huge industry, and generally speaking, you know, related embedded industries.
And there were also people from MISRA, C and MISRA C++, people who standardize safety
for C and C++, among others, for the automotive industry.
And then, I mean, there was a discussion in the audience, and what I heard a lot is this
is a billion-dollar industry, and nobody's going to rewrite billion-dollar libraries
and software into Rust anytime soon in any other language for that matter, because they
aren't just not going to drop it at one day.
So C is still rolling there.
So thank you that you are here.
Now, surprisingly, C is not a dead language.
You might think so.
I mean, it's not like, you know, in a rapid development cycle of C++ that every three
years you get a new standard, but it's also not a dead language.
But to the contrary, what you see there is a valid C, kind of a valid C, and you might
be surprised when you look at it, because there are crazy things happening.
Like, if you learned C from the standard C book, the C programming language, you definitely
have never seen bull as a type or true being returned from something or being passed to
a function.
And there is also, that's just because I couldn't fit it on a slide, don't mention it, the structure
definition is in the return type directly.
This is a C feature, so you can do things like this.
It's just I couldn't fit it otherwise.
Anyways, if you go further, there is type of, it's an operator in C that works pretty
much like Dekal type.
It's just much less powerful and doesn't come with all the craziness of Dekal type.
There is constexpr nowadays, at least let's say since two weeks when the C23 was standardized.
There are weird things like indices in square brackets, also something that I don't think
many of you use, especially if you're coming from C++, there is auto.
I mean, it's been there since the beginning, right?
So it's for specifying the storage type in C.
And so it's still there, but what's even more strange is the right-hand side of this expression
where it looks like I'm creating like a temporary structure and taking an address of it or casting
something like into a structure and taking an address of it, something, you know, among
these lines.
And I'm returning, actually, not really this pointer, but the reference in this pointer
later on.
And there is a null pointer, null PTR, just like in C++.
It's a keyword, again, for exactly past week or has been a keyword for exactly past one
week.
So that's it.
This program is valid C and it compiles.
You wouldn't believe it, but it compiles.
Unfortunately, it compiles only a single compiler now.
And that's the trunk of GCC, otherwise, it won't compile.
This is the only compiler that accepts all these nice features because it's so new, it's
just fairly standardized, and they have some special meaning.
So you can compile it using, for example, the compiler explorer.
No problems.
You have to pass in this state is C to X.
It's still not 23 because it won't, I mean, in this compiler, in the trunk version, they
weren't even sure that this is going to be C23.
It's going to compile with no warning whatsoever, and it's going to execute.
What's your guess?
What's it going to do?
I mean, okay, it looks crazy.
I mean, you cannot guess from it what it's going to do.
I agree.
But if you look carefully, in line 15, it definitely tries to print something.
No, line 13, it's definitely trying to print something by using the putString function
puts, and it's casting this array as an argument.
So it definitely is going to print something.
What's it going to print?
It's going to print C.
It's great.
Long live C.
It's unicode characters for a good measure, right?
That's because C is still the language we love for its total lack of type safety.
It's really one of the reasons why C exists, and it's so popular in embedded industry,
in the system programming industry, is that you don't care about types.
You can easily cast from one thing to another, just like a cast set, an array of doubles
into a car pointer.
No problems whatsoever, and if you know what you encode within these doubles, it's going
to work.
And of course, it returns 42, as it should, which you also couldn't see.
So this is a talk about modern C, and I'm going to talk about modern C a lot.
And what people consider modern C is anything starting from C99 and above.
There were a couple of standards on the way, like for example, C17, which added a few things,
and now C23, but this is all modern.
That's generally a talk for everybody who learns C from the old books or who doesn't
know C a lot, who doesn't use C a lot, because I expected half of you don't really use C
every day.
Or maybe you got curious about something, maybe you heard something, and you want to
learn.
Anybody, if I ask now, who's using C, like at least once a week here?
Yeah, two persons, yeah, like.
That's a lot for this.
So I am also using it.
It's like half, half with C++.
So this is basically a talk exactly for you, for those of you who know nothing about C
or learned it a long time ago and think that it's still like in this old prehistoric times.
Now as I said, C is a cool language, and we all love it for its total lack of type safety,
and for the fact that basically you can do everything and express everything with C.
It's just that you have to be very careful not to create a bloody mess when you do it,
which is equally easy as creating a well-working program.
So this talk is going to cover a couple of topics that might be useful when trying not
to create a bloody mess, like how to initialize in modern C, how the initialization works
in modern C, because when you don't initialize variables, bad things happen.
Like C++ has some guarantees about what happens when you don't explicitly initialize,
like default, zero initialization, blah, blah, blah, and so on.
C doesn't.
C just gives you garbage if you don't initialize, right?
We're going to talk about pointers, arrays, and functions because obviously this is a C talk,
so pointers must happen, otherwise it's not going to work,
and about how you can be a bit safer with pointers, a bit safer,
because those guarantees are now built into the language slowly.
We're going to talk about zeroing, assigning, and things basically like what's on the screen,
how to zero the whole data structure again, because it's an important part of modern C.
Finally, if time permits, a bit about fragile resource management, so cool new features in C
that make it very easy for people who deal with hardware to write efficient software,
and how to make dynamic resource management and especially memory management less fragile
and easier to handle, and there will be some macro magic if time permits,
because obviously this is a talk about C, so there must be macro magic.
So that's it.
I will throw for a good measure some C23 pieces here and there,
but this is not a talk about C23, mostly because I just couldn't make it in time,
it was standardized a week ago, and a week ago people didn't even know what would be really there
and what wouldn't be there, so it was a bit too much risk to make a talk about C23,
and the features actually that they put in C23 require on talks on the topic only.
So there will be some 23 and whenever you see this logo it means that there is a C23 feature.
Now the quiz time, it's only quiz that's only in this talk,
and I hope it's a cool quiz and that you can answer the questions that I'm going to ask you,
and you can shout, we are not that many here, you can shout, I have the microphone, I'm louder anyway.
We have a function, it's C, it's not C++.
Print, how many arguments does it accept?
Who's for none?
Okay, who's for possibly many?
Exactly, great, this function accepts possibly many arguments,
it goes in C when you don't put void in between the brackets,
the function possibly accepts many arguments.
Next one, and that's a tricky one.
There is a function, it takes two arguments, A and B, with some types,
the types are not really defined there,
and then it prints the sum of those two arguments, A and B.
And I'm calling this function with two double arguments, 1.5 and 8.5,
and obviously any normal person would say that the sum of those two is 10.
Who's for 10 as the result of what the function is going to print?
Who's for 9?
Majority, great, I like it.
It's going to print 9, you're absolutely right,
because if you don't tell what the argument type is, it's going to be an integer,
because in the old good times when C started to exist,
there were only integers, so everything was an integer.
Honestly, I'm on C23, it's undefined.
Finally, it's undefined because it was a source of many errors,
so it's illegal to do it anymore.
Good things do happen.
Now, that's one tricky, and the question is very easy.
What's the value of number and what's its type?
So it's just one line of code, don't overthink it, right?
And as a hint, the literal is a floating point number,
it's a float on the right-hand side, right?
So you might think, well, it's a float,
because the right-hand side of the assignment is a float,
and the other good hint or good guess would be an integer,
and it would be an integer because, like on the previous slide,
if you don't define the type, it's an integer, right?
And you are right and right,
depending on which language version you are.
If you are on anything below what happened last week,
it's going to be 42, because it's an integer.
Auto, before last week, meant automatic storage duration,
nothing else.
So you could have skipped it, and it would mean, like,
then it's an integer, because obviously,
when you don't specify a type, it's an integer.
Now, you wouldn't believe it, but Auto means the same now
in C as it means in C++.
It's for type inference.
Actually, it has this kind of a dual life now in C23.
It is for type inference or for storage duration
specification.
It depends whether you put the type or not yourself.
So if after the type I would put in,
this Auto would be specifying the storage duration.
But because I didn't, it's for type inference.
Next one, where does compile in C?
OK, this doesn't make any sense now to us,
because I just showed you that it compiles in the first slide.
But I asked this, and there are two different answers to it.
Either it will compile out of the box,
or you have to include something.
Who's for including, that you have
to include some standard headers for it to compile?
You, sir, are absolutely right.
Because you didn't read what happened last week, right?
When the bool and false became keywords in C also.
So they also kind of do the same thing like C++.
They like to do things slowly.
They first standardized boolean with a totally weird notation
underscore capital letter bool.
And you could have the normal bool through a header inclusion,
then it was simply a type def inside.
And now it's standardized as a keyword.
That one, I'm not going to retorture you with this one.
I think it's fun, unless you know what's happening there.
I mean, it was the size of the numbers array.
And I don't want you really to count this one.
Because if you count, I think you're around eight.
So there are eight initializers listed there.
But there are many other options there.
And the correct answer, and we're going to talk about it,
is 12, which is not really apparent when you look at the list.
There is no 12 anywhere.
There are no 12 initializers.
There is no index 11, nothing like this, right?
So it's like, why?
Because it's C, and in C we like doing things our harmful way.
So that's why.
Next one, does anybody know actually what
is the type of PK in line four, if you look at it?
PK has a very specific type.
I mean, you are kind of born with knowledge of C.
It's not that far.
But we learn it when we learn C that pointers are pointers in C.
And a pointer is a pointer.
You can cast it.
It basically doesn't have any further meaning.
It doesn't come along with any further type specification.
It's just a pointer.
It's not true.
This is a pointer to an array of 10 by 10 integers.
Exactly.
It's a strongly typed pointer to an array,
two-dimensional error.
And because of this, when I malloc it and use size of asterisk
PK, I'm going to get enough storage for 100 integers.
Is it integers?
Yes, it is integers.
So the answer is 400, at least on my platform, right?
And I think we are almost at the end of the funny quiz.
And the question is, is this program well-formed?
And I'm not talking about intendation.
It's cool.
I'm talking whether it's going to compile,
whether it's going to be accepted by a compiler.
And there are a couple of answers.
And you can raise your hand if you
think that this answer sounds true.
Like A is no because line 11 is fishy.
And line 11 is fishy because it looks like, actually,
I don't know what I'm doing there.
It looks like an array cussing.
I'm casting actually open curly braces to an array, right?
That's what I'm doing.
Who thinks this line is fishy?
Yeah, it's definitely fishy.
But it's not a problem.
It compiles.
The other answer is no, line 5, the address of a temporary
is taken or something that looks like a temporary.
And I mean, the address is definitely taken in this line.
But again, this is a perfectly fine c.
An answer might be also no, there
is no aggregate initialization or something like this.
No, there isn't, but you can initialize
with designated initializers.
So this is a perfectly fine c, and it's going to compile.
And it's even going to print something.
I think it's going to print today on the screen.
So and last but not least, and that's a tricky one,
what does this function accept?
What kind of arguments does it accept?
Because it accepts a very specific type of arguments.
So this again, type safety, pointer safety.
Do you have an idea?
See, this key, you're right.
Sorry, I first read D, which I also
have an urge to actually directly look at.
You're right, it accepts valid non-null pointers to con-scar.
So it's a contract.
It's basically you're saying it's a pointer to a con-scar,
and it has to be valid.
It's going to be null.
And you would be surprised, compilers, check it.
So that's this.
And we are finally at the core of our talk.
Go on, please.
That one, I don't hear you.
No, no, it's only checked whether it's null or not.
So because it's a pointer, you can pass null as an argument.
So that's been checked.
But yeah, it doesn't look into the string, really.
No, no, it's not that good.
I mean, there is no runtime in C. There is assembly, right?
So I have a vague reflection of what this case was
a runtime super-guaranteed because one or more characters
would do it.
Even if you pass an empty string,
you still have the null terminator there.
So officially, it's valid, right?
I'm sorry, but it's officially valid.
This only checks for null and nothing else.
So OK, let's go.
Initialization, the first topic, an important topic.
And I mean, the quiz was also partially about initialization.
Like you've seen lots of initializers.
Have you ever seen code like this?
Anybody?
Raise your hands, please.
All of you have seen this code because it
comes from this book.
You must have seen it.
So this code attempts to initialize a structure, right?
A structure of x and y, a very simple one.
And that's not how you write it nowadays.
Nowadays, what you would do is, of course,
use the brace initialization.
Like you would do it in C++.
The only difference is you need equality or an assignment
in between.
And that's how it works in up-to-date C. It exists in C.
Brace initialization, exist in C.
And you can pretty much initialize everything like this.
So like an array of undefined size.
And then the size will be calculated from the initializers.
You can initialize a list on an array
with a defined size.
You can initialize structures like this.
No problems whatsoever.
You can initialize pretty much everything with braces.
Just like, basically, aggregate initialization
works in C++ for those of you who know what it is.
But when I mean everything, I really mean everything.
This is legal.
Some people write it because then it's uniform.
And it looks nice.
And it scares people who don't understand.
And that's also good because you don't want people who
don't understand your C code to touch your C code, right?
So you put it there just to scare off people.
That works.
There is also something called empty initialization in C.
It got a name, empty initialization
a week ago, like a standardized name,
before it was known under different names.
Some people called it zero initialization,
some default initialization.
And basically, the trick is you put a single zero
in between the braces.
Nothing else.
This has the effect of zeroing everything, whatever
is on the left-hand side.
So if it's a value, or if it's an array,
or if it's a structure, then recursively
all the fields of the structure will be zeroed.
Nulls will be actually zeros, like a null.
It's a zero, most of the architectures
will be put where they should be put, and so on, and so on.
So it kind of got its name from this one,
because in C23, they removed the need for having a zero
in between the braces.
You can now skip the zero in between the braces,
and it's still going to work.
So that's where it comes from, the empty initialization.
Now, what are the rules?
The rules are very simple.
When you empty initialize something like a structure,
what happens is that all your fields in the structures
are going to be zeroed, including the padding bytes,
not because they have to be zeroed,
but that's because what the compilers will do anyway.
And that's it.
There is no magic in it.
It also works for nested types, so if you
have an array of structures or whatever,
you can just zero it like this.
It's great.
You don't have to use memset all of the sudden,
and we are used to use memset.
I mean, at least I was used to use memset at all a lot when
I was programming C, so we just put zero there.
Now, what if you don't want a zero?
What if you want different values?
Like, for example, you have a bigger structure with five
fields, and two of them should have some values,
and the rest should be zeroed, because why not?
And then you might think, OK, what's my idea here?
I might zero first the whole structure
then set the fields and so on, but do something crazy
like this when you use the brace initialization
and list all the members one after another
at the right positions and initialize with zero
what needs to be initialized with zeros.
Luckily, this is not the way, because there
are designated initializers.
Just like they are in C++, and they
have the same exactly syntax.
So there is a dot, then the designator,
then the equality symbol, and then the value
you initialize the designated field with.
This has the same effect as in C++, almost the same,
because we don't have default initialization here.
It zeros all the fields that are not explicitly initialized.
So those that you explicitly initialize with your designators
are going to get the values, the rest is going to be zeroed,
which is great, because very often it happens,
and especially if you program in C,
in C, people work with all fully long structures that have.
I don't know if you've ever looked, for example,
how file is implemented, how many different fields it has.
It's horrible.
Most of them are usually zero.
So that's great.
Now, what's not so great, or actually maybe what's great,
because C gives you all the powers there is.
There are in this world.
So what's great, you can mix the positions
when you're designated initializer.
So you're not necessarily bound to the order of declaration
as you are in C++.
For C++, it's going to be a hard compilation error
if you try something like this.
See, no problems whatsoever.
Mix them.
What's even, now I struggle to say it's better.
What's even cooler is that you can mix positional
and designated initializer, something that's also
forbidden in C++.
You can freely mix them.
You've seen it already when I was asking about the size
of an array with really weird indices.
This is a mix of designated and positional initializers.
Two positional initializers, the first one and the last one
and two designated.
But you have to be careful about what you're doing
and how you're doing it, because you
have to understand how the logic works behind the initializations
order then.
I mean, the first one is quite easy.
It's a positional initializer, and it goes into the first field.
Then we have a designator status.
It names the last field in the structure.
So the status is going to end up there.
Then we have another designator flex, and it fits in there.
And last but not least, we have one more positional
initializer with no designator.
Now it's going to end up directly after the flex,
and there isn't for it.
Whenever you have a designator in your initializer list,
the counting for the next positional initializer
starts from this designator.
So you kind of have to know what you're doing.
But that's great, and of course, the rest is zero.
If you know what you're doing, you're going to be,
I mean, it's going to work nevertheless.
You can nest initializations just like in C++.
You can nest them, I mean, the designators and initializers
for sub-objects, also with designators, no problems whatsoever.
You can even do crazy things like this,
dot-flux, dot-extended, dot-extended,
designates a field of a sub-object of the structure.
This is also not allowed in C++.
You cannot nest in C++ like this.
In C, it is allowed.
Now, this is also a funny thing, and it's funny
because I don't know really what's the use for it.
I mean, I only know one use that I came up with
when I was working on it once, and it's not even a good use,
so I'm not going to mention.
No, OK.
You can use designators for arrays.
It's absolutely fine, and this works the same way
as for structures.
The designator designates a field, or actually the subscript,
that you're going to initialize with a value.
So this is like an array of 42 numbers.
Three of them are going to be initialized with certain values.
This is a Fibonacci sequence, roughly.
It's a Fibonacci sequence, part of it.
And the rest is going to be zeroed.
So the rest of the numbers are going to be zeroed
in this array, all the 99 of them,
which might be useful, might not be.
The same craziness applies as instructors.
You can mix the order whatever you want.
You can mix positional initializers
with designated initializers.
And again, the same rules apply as before.
So if you have the designator, the index
of the following positional initializers
is counted from this designator.
So there is a designator 10 at the second position here,
which means that 89 is going to end up at index 11.
And because it's going to end up at index 11,
there is nothing actually more to talk about.
But there is something to talk about here,
because this is going to end up at index 11.
This array has a size of 12, because this
is the highest index in the initializer list.
But this is crazy.
Things like this shouldn't be allowed.
Neither should be this, but it's there.
If you look at this, this is fine.
I mean, it's not fine, but you can do it.
You can have an array of structures, for example,
and designate or initialize one of the fields of those structures
at a specific index of the array.
And it's going to work out of the box.
But the syntax, especially at the multiple level
of nesting looks really, you cannot comprehend it anymore,
I think, at one moment or another.
It works nevertheless.
So that's it.
That's the initialization.
That's how we initialize everything in moderncy.
Believe me, people really do it.
They use curly braces even for numbers.
And there are no restrictions.
In C++, they have a lot of restrictions for it.
In C there are none whatsoever.
So you can really confuse your colleagues if you want to.
Now, and since we are talking about arrays,
and there is one very popular topic when it comes to arrays,
we are going to discuss it.
Generally speaking, as all of you know,
there are two types of arrays in this world.
You can have either an array with a static known size,
constants known size, and that's your good old array
as on the left-hand side.
Or you can have an array that you allocate dynamically
on the heap.
And that's something like a runtime thing.
So during the runtime, you can come up
with a value for the size of your array and allocate it.
It's much better today like this because this size should
be somewhere close to your numbers definition,
to the array definition.
Nobody, people don't put defines, hash define,
within the function.
They can, but nobody dares to for some reasons.
They put it somewhere outside, and then you
don't know what the size of the arrays are.
But with Constexpr, it's just more natural to put it
next to the array, right?
So you can do it now.
Anyways, back to the arrays.
Question, is a lot a constant integral expression?
Who's for it that it's a constant integral expression?
Some people have doubts.
Who's against it, like totally against?
Nobody has doubts.
That's also fine.
It depends.
If you're coming from C++, obviously it's
a constant integral expression in C0.
C, no.
Sorry.
That's why we use defines in C, right?
Because we like to confuse people.
This is not a constant integral expression.
So you cannot use it to define an array
with a constant known size.
It's illegal.
However, this code does compile.
It compiles, and many people hate it, that it compiles.
And we're going to talk about why they hate it in a moment.
What it really declares or defines
is a so-called variable length array.
It's an array whose size is determined at the runtime.
And usually, it's allocated on the stack.
By the compiler, like allocated on the stack
during the runtime.
That means also calculating the size,
calculating the RSP register shift,
and manipulating it at runtime.
So this creates an array with an unknown size,
or actually not with a well-known size
during the runtime, on the stack.
And you can only do it within a block scope.
And the reason is quite obvious.
I mean, at the file scope, you don't have really a stack there.
So how do you declare an array there?
It's not really standardized that it
does have to be on the stack, but all the compilers
do it on the stack.
C++ doesn't have this feature.
And for a reason, because there was a big discussion when
they introduced it to C also, whether it's even needed.
And many people said that it's not needed.
I also said before that you can initialize everything
with curly braces.
Well, not this one.
This is the only exception.
You cannot.
You have to initialize it element by element.
Anyways, as I said, some people hate it.
And they hate it with passion, like, you know?
Like Linus said that using VLS is actively stupid.
And for many reasons.
And many other people in the community
actually repeat the same thing, that it's actively
stupid to do it.
Nowadays, nobody's using VLS.
And that's not a joke.
I mean, students sometimes use it because they don't know
that it's a bad code.
Otherwise, nobody's using it.
Why they don't use it?
Well, it's an array on the stack.
You know what's the problem with the stack?
Depending on your architecture, the stack
is maybe four kilobytes or maybe eight megabytes,
if you're lucky.
So when you declare an array or define an array
with a size that's going to be determined during the runtime,
you definitely have to check whether it will fit on the stack.
Otherwise, you are going to blow up the stack
and your program will crash.
So you must build in this check somewhere
before this array even comes to being.
Otherwise, you are in danger zone.
And only then, you can do your array thingy.
So the question is, why would you do it anyway this way?
I mean, isn't it just better to have directly
the array with the myAllowedSize?
And it will fit everything I need anyway.
So just do it like this, right?
And then this.
And I still have to check, obviously.
But now I have an array with a constant known size.
The compiler can see it upfront.
It can optimize for it.
So why?
What's even worse, if you look at the,
it's the same code as before, just without the stack check.
And I'm doing now the n of size 10.
On the left-hand side, it's a variable length array.
On the right-hand side, it's an array
with a constant known size.
It generates much worse code.
The VLA variant is much bigger in the assembly
because these calculations have to be done at the runtime.
So you have to calculate the shift.
You have to move the RSP by certain size.
Whereas on the right-hand side, the compiler
knows it has to shift the stack pointer by 40 bytes
and it's done.
So it's bad.
It's actively bad.
I'm not gonna say stupid, but it's actively bad to do it.
Don't do it.
Now, if you shouldn't do it,
then why am I talking about it?
Unless you are, of course, a teacher
because then you are gonna see students do it.
And you have to correct them.
The reason is VLA's are used for other things.
And some people argue this is the primary reason
why VLA's are in the language.
They are not for having stack arrays with variable length.
They are for doing things like
they're gonna witness in a moment.
This is a function that takes an array of numbers
by a pointer and the size of the numbers
and does nothing special really.
Now, if you have code like this,
you can also write the argument a bit differently.
You can write the argument as the second parameter
or the second parameter being an array of type int
with n elements inside.
And this does something different.
This communicates your intent all of a sudden.
You say exactly that it must be an array of n elements
and there must be enough storage for those n elements.
The previous one didn't communicate it.
The trick is size has to come before the array,
otherwise it's not gonna work, right?
Now, why would you do it?
I mean, you can do it for arrays with known size
like that one, an array of five elements
and it's gonna compile just fine.
Or you can do very nasty things like a hidden bug there
when I'm trying to pass an array of five elements
and pretending it has six elements which is bad,
actively bad and your compiler will tell you
that you are doing something bad.
Compilers do detect those errors
if you pass arguments using the VLA syntax.
At least GCC does.
Clank doesn't really want to do it.
Sometimes it does, but not in this case.
Surprisingly, it even works for dynamically allocated arrays.
If you try to pretend
that a dynamically allocated array is bigger than it is,
GCC will warn you with a string operation overflow.
It's apparently it is a string operation,
what we are doing.
Nevertheless, this is great, right?
It warns you.
And since we are already talking about arrays
and we are all kind of educated in the way that arrays decay
to pointers, unless there are three specific scenarios
when they don't, let's talk about more
about how you pass arguments in modern C
and specifically how you pass pointers in modern C
to functions.
There are four different scenarios that you can cover
when you think about how you pass pointers in C.
The first one or the two first ones are about arrays,
the two second ones are about single objects.
Imagine you are passing an array of n objects
and you have enough storage for n objects,
but not necessarily valid objects in this array.
What you're gonna do then is use the syntax
that I just showed you.
It works and the compilers will check it most often.
So in this case, it's a buffer of n characters uninitialized
and I'm never reading from it.
I'm actually initializing it or putting values
into this buffer, but I have enough storage.
That's great.
Now another scenario, if it's an array with enough storage
for n objects and it must contain n valid objects.
That's like a hard requirement.
There are n valid objects inside.
There is the syntax that you guessed correctly
for something different.
You use the keyword static before the size,
before you mentioned the size.
It's been there since C11, if I'm not mistaken,
and it means something special.
It basically means that those objects do have exist.
It's illegal not to have objects there
and some compilers are able to check not everything,
but some parts of it,
but it clearly communicates the intent at least.
So static communicates the intent.
When it's a single object and it can be a null pointer,
well, you do it the old way, right?
There is nothing special about it.
You are responsible for checking it if it works
or if it doesn't work.
Now the last one is actually the one
that we already showed during the quiz
or I already showed during the quiz.
If you're passing a pointer and it mustn't be null,
it's illegal that it's a null pointer than you use static one.
It's a very common thing, especially static one,
somehow managed to permeate into the code,
into the live code.
People use it because compilers check it and enforce it.
So use it and for a proof that compilers check it
and enforce it, especially when you use the static keyword.
Look at this piece of the code.
It basically tells that there is a function
that takes an array of three doubles
and those doubles must exist.
And I'm trying to call this function
with a dynamically created array
and notice that I'm totally not saying,
I mean, I'm not passing the size of the array here
as an argument, and I'm trying to do it
as a statically created array.
GCC triggers an error for both of them.
GCC without even the static analyzer that it has built in
is able to see that you're doing something very bad
and it will gonna tell you this time
with again with string operation overflow.
The first one with the static array also triggers
an error on the clunk compiler.
So that's very good.
That protects you against very stupid mistakes
that we often do, you know, buffer overflows do happen.
Like there are single most important point of failure.
I mean, in order spaceships that went down, right?
So do it.
It also works amazingly well for this kind of syntax,
which I said that protects you against passing
a single null pointer when you don't expect a null pointer.
And when you try to do something like this,
GCC will again emit an error
and I think clunk also now emits an error or so.
And that's the summary of how you pass arguments
in modern C.
Use the row pointer only if you're expecting one object
and only if it can be null.
Otherwise use the VLA notation sometimes
with the static keyword,
if you expect invalid objects to be in the array.
Compilers do enforce it.
Lots of modern C code is written like this.
And obviously it's not supported in C plus plus
the static notation and the VLA syntax
is also not really there because it's a part of the VLA.
And since we are at the VLA's
and there was, I asked this question before,
I was talking about a PK pointer
somewhere in the beginning of this talk.
As you can see, it's a two dimensional array, right?
It's a beast.
It's a beast, it's a Gaussian filter.
It's a kernel of the Gaussian filter
if I'm not mistaken.
It's a beast and it's a beast
because multi-dimensional arrays in C and C plus plus
are horrible to work with.
So that's like a five by five array.
The size doesn't matter.
What's horrible about it is not what you see on the screen.
It's what you see now on the screen.
Malocating this or allocating this array is still okay.
And by the way, notice that I'm also using the VLA syntax
with the size of operator.
This is also valid.
You can do something like this for the size of,
which greatly simplifies size-offing for your Malocs.
And then when you index into this array,
I don't understand it now, right?
What I've done before, and I always have to look it up.
And nowadays people use chatGTP for this kind of things
before it was Stack Overflow.
And I'm not joking because it's unclear.
You have to remember like what's,
I mean, how is the data laid off in the multidimensional array
to be able to do this magic?
So what we really want is something like PK
and then a first index, second index.
What we get is, yeah, is this.
Luckily, the VLA syntax does this for you.
When you use VLAs with strongly typed arrays,
you can achieve this.
Because VLAs don't only extend to declaring parameters
or to having stuck arrays.
They're also for declaring strong array types.
For those of you who are not fresh with the pointers,
like I wasn't, for example, when I was preparing this talk,
the PK is a pointer to an array of doubles,
to actually two-dimensional array of doubles
with the size as Z, as Z, whatever the Z is.
Because it's a VLA, so it doesn't matter.
It's determined at the runtime.
It's strongly typed.
And that's sense that if you try to do something
with this that's not allowed, like pass it to a function
that accepts a single double pointer,
it's not gonna compile even.
And when you use it, all of a sudden
this kind of syntax becomes possible.
So it's much better.
It's a huge improvement because you can now index
into your multi-dimensional array with this.
Compiler knows it's a pointer to a 2D array,
so it can index into it properly
and translate into the pointer operations.
What's even better, if you don't like the currently,
the brackets Asterix PK, you can also do it like this.
This is a bit of a cheating
because I gave up a bit of a type safety
because it looks like I'm now allocating
like an array, a one-dimensional array,
not really doing it,
but this allows for this beautiful syntax.
And if you don't like PK, so that's what you do.
And I mean, if you really fell in love
with the VLA syntax, notice that what I'm doing here
on the right-hand side of the malloc,
it's not really cool, right?
I'm doing something like size of PK multiplied by size
and it's gonna work correctly.
It's gonna allocate the correct number of bytes,
but some people don't like it.
They say that it shouldn't be like this
and that you should use the VLA syntax
for your size of operators also
because it's much cleaner
and it communicates the intent better
and you cannot make so many errors.
So if you just fell in love with the VLA syntax
and you want to show off, you can do it also.
Using a type of operator.
Because the type of the PK pointer,
the reference is the array of doubles of size size
and then there is another size then
and together they make a multidimensional array.
Think about type of us, a decal type here.
So it works in exactly the same way.
So we just declare a type of an array
of doubles of size as Z.
And you can combine it with index 10,
which is like, whoa, why?
I was pretty shocked when I discovered this, so.
Yeah, and since we are in C plus C 23,
there is a null pointer obviously.
Anyways, that's the initialization and the arrays.
And now we're coming to the worst part of the talk
because it's the most difficult part of the talk.
Actually, it's not difficult.
It's a bit of a crazy part of the talk.
It's gonna be about zero increase assigning
and disappearing L values or whatever you call them.
You remember this slide, right?
This was somewhere at the beginning of the talk
when I talked about the old C initialization
and the new C initialization syntax.
And I said, this is up to date C.
I lied, of course.
This is not an up to date C.
Nobody writes code like this
unless you are born in, yeah, in 2011.
I don't think those people write C.
Might though, you never know.
So you don't write this kind of code anymore.
It's not up to date.
It's modestly up to date C.
What you do nowadays is something like this.
You return these things that looks like casting
and then there is the initializer list
with designated initializers inside.
Now, this has a name.
It's a compound literal.
And this is something that exists only in C.
It has a very simple syntax type in the normal brackets
followed by the initializer in the curly braces.
The initializer is not optional.
You have to put it there.
And it creates an unnamed object.
It's really created.
It exists.
This object has different storage duration.
It can have a static storage duration
if you declare it at the block scope.
For example, I'm declaring there,
not at the block scope, sorry, the file scope.
I'm declaring at the file scope an array of doubles
that doesn't have any name,
but I'm assigning it to a variable of default coefficients
and it's there.
It's gonna exist throughout the duration of your program
or you can do automatic storage if it's in the block scope.
And here it is, I'm declaring a structure
or actually I'm assigning to a structure
with some new values.
So I'm using, I have already a fear for structure
and I'm putting a new value into it with the assignment
with some other initializers and so on.
So two different storage locations
and where the object is created us,
like for any other object,
if it's a static storage duration,
it's somewhere in the global memory.
So my coefficients are in the global memory
and my object on the right have some side of the assignment
because this is what we are talking about.
We are not talking about the fear, FIR variable.
We are talking about what's on the right-hand side
is going to be allocated on the stack for a moment,
at least for the duration of this line.
The unnamed object is an L value
and for those of you who know a bit about value categories,
it means many things like you can assign to it
or you can take an address of it.
It's fully legal, it exists.
If it's declared in the block scope,
it's gonna exist throughout the duration of this block
or the lifetime of this block.
Block and you can legally take an address of it.
And this allows for surprising applications like that one.
Those of you who ever dealt with time
are familiar with the normalizing function,
make time, which normalizes the TM structure.
You can normalize like this now
and get the unix time out of it.
Cool thing, if you ask me.
Now, those are not C++ temporaries.
They have nothing to do with C++ temporaries.
In C++, what's valid in C and looks very similar, right?
Really very similar is invalid.
You cannot do it in C++.
This creates a temporary object,
you take the address of it
and you try to pass it to a function
but when the function starts executing,
actually this object would still exist, I think.
Oh no, it wouldn't.
So it's illegal to do it.
You cannot, I mean, it's illegal
because you are taking an address of an R value, right?
Of a temporary, which is not even materialized yet, I think.
So you cannot do it.
In C, it is valid and you can do it
and you can do crazy things with this.
Crazy like in, not negatively crazy
but crazy in beautifying your code, crazy.
So something like a typical school assignment,
you have an array and you have to declare
and write a function that initializes this array.
And notice that it's a very simple array.
It has just a data field and the size and the count.
Sorry, capacity and the count.
So obviously you're gonna allocate for data
and put some capacity and zero the count.
In the old C, you would do it like this, right?
So you are gonna most likely memset somewhere
or set the fields separately one by one to zero.
You're gonna allocate with caloc or malloc,
doesn't really matter.
And if you manage to allocate,
you're gonna set the capacity also
because that's what you do.
Now, nowadays people write it like this.
So they don't really like zero
before they just write it in one line.
So what happens here is I am creating this L-value object
on the right hand side of the assignment of type arrays
and initializing with it through the designated initializers
allocating memory on the fly or on the go.
And then I'm assigning it to the difference pointer.
So I'm basically assigning a structure to a structure
or reassigning a value to a structure.
And it works out of the box.
The compiler will of course optimize totally away
the creation of the temporary or not so temporary object.
It's not gonna be there.
It's what the compiler is gonna do
is it's going to directly assign to your dereference PA
or sort of PA pointer,
totally skipping all the logic on the way.
So that's how we would do it.
What's even better,
and that's just modernity.
Sorry, I had to put the static one there.
I don't know why.
What's even better, you can use it to zero things.
Now, in the old good times, you would call memset
if you want it like in the array three,
when you first freed the data
and then zeroed the whole structure just to be sure,
you would call memset on anything.
It works, it's everywhere in the old C code zeroing
because otherwise you get nasty bugs.
Nowadays, you can write it like this.
So you just assign a new value into your structure
and it's a zeroed value
because it uses empty initialization.
Now, the compiler will memset it for you actually.
If you write code like this,
what the compiler will emit,
depending on the size of your structure,
is either a few Mambo jambos with the XMM registers
to zero your structure directly,
or it's gonna call memset
if the structure is big enough to call memset.
So you don't have to do it.
Compilers understand what you're doing.
You'll have to express what you're doing
and let the compiler choose the best way to do it.
And that's not it.
That's not the end of the story
because unfortunately I said that there will be some macros
and I know it's late.
I think it's a good time for macros also
because either it puts people to sleep
or it makes them awake.
So let's do macros.
Compound literals can be used as arguments to functions
and for a good reason.
Like, look at this one.
It's a big ugly, right?
And there are even coding styles
which say that if you have to pass more than three
or four arguments, then you should pass by structure.
There are coding guidelines
and so you shouldn't do things like this.
We agree on it, right?
First of all, this first argument should be taken as a erase
of static one size, but that's something else.
Now in this slide it is
because we already did it correctly.
We use the modernity to signal
that you have to pass valid objects to the blur function.
Of course, what you then do is create a param structures
and pass the address of the param structure to the function.
Much, much better, however, still ugly, right?
That's not what you do.
That's not what you want to do.
The first insight that you might come up with
is that the struct can be created in place
because, hooray, we have compound literals.
So why would you even create a structure
like outside of the function call?
Let's do it.
And I don't know if it's more readable.
It's, no, it's not, but it certainly looks cooler.
So your cool factor directly goes up.
That's a good idea to do something like this, right?
And then the second insight,
and this is a really breakthrough,
is when you realize that when you look at it,
some of those fields are actually kind of having
like default values.
Compute hardware is set to zero.
It's a default value.
Type box, I'm not showing it,
but maybe it's an enum or something like this,
also with a default value of zero.
And since we're using designated initializers,
we can skip those because the rest will be zeroed
automatically.
So you can pass only what you want to pass
directly in place.
And that's good.
That's much, much better, right?
Not only your naming arguments now,
named arguments are also cool, by the way.
You're naming it with your designated initializer.
You don't have to pass all the arguments.
Now, and because, as I said,
it's also about macros.
When you add just one single macro magic line
to the mix, you can start writing code like this,
which totally looks like named parameters
or named arguments in C.
And they are, I mean, those look like named arguments.
And of course, the rest takes a default value of zero
of what you do not pass.
The macro itself, I'm now, yeah,
I have doubts whether it's a good statement now
that it's not much magic.
But let's assume it's not much magic.
I mean, it was middle in the day
when I was writing it, so you have to forgive me.
It's hash defined blur, obviously.
And for those of you who don't know this,
three dots in a macro mean variable number of arguments
that you can pass through in your macro expansion.
And that's exactly what I'm doing, right?
I'm just passing it through in my macro expansion
under the name VA underscore arcs.
This is how you pass through variable number,
variable arguments in C.
And it works.
All of the sudden, you can use this beautiful syntax in C,
actually also in C, no, in C++ not
because it doesn't have the compound literals.
So you cannot do this in C++,
but I'm pretty sure you can use other tricks there.
And I already set how it works,
so I'm not gonna repeat it.
And I'm sorry for this slide, but I had to put it there
that with a little effort,
some arbitrary default values are also possible
because up to now, if you didn't pass a value explicitly,
it would get a value of zero,
like it would be empty initialized in your structure.
So only zero default values were possible.
Well, that's a lie.
You can have default values
by just specifying them in your macro.
If you don't specify them,
when you call later the macro with your designators,
the default values will be taken over
and they will be used.
Great.
If you do specify them, like I do with here,
with here is specified as 64,
and by default, it is 32.
Well, the 64 will be taken
because in the initializer list,
it is after the first initializer.
It emits a warning and as it should, right?
The compilers know that we have something bad in mind
and they rightfully warn us about it.
This warning can be silenced
with a couple of pragmas
that you can build into your macro.
And when I do this,
when I later publish this
because you will have access to it,
this slide will be there,
but I knew it would be after 5 p.m. now,
so I skip this slide for now.
But with a bit of pragmas,
you can remove the initializer overwrite warning
and do magic.
So that's compound literals.
They're really cool.
There are L values.
They allow you to do crazy things
like zeroing the whole objects,
initializing objects in a very simple way,
or even create default arguments to functions, right?
And since we are talking about structs, right?
And it's not like my favorite hobby topic,
but I use structs a lot.
I do a lot of what you call
like low-level programming, system programming.
Obviously in C,
when I deal with structs and memory allocations
from time to time,
so let's talk about one less crazy thing,
and this is the real one last crazy thing
that I'm gonna talk about.
Let's make a string.
Something that you've already seen
because we already were doing an array a moment before.
The layout was a bit different if I remember correctly,
but you know, you get the gist of it.
Again, the length, the size of the array,
and the pointer to the dynamically-arrogated array.
And now you imagine that you want to create a function
that creates such a string for you.
And because we are living in a dynamic world,
we want not only the memory that the array
is pointing to be dynamically allocated,
we want the whole structure to be dynamically allocated.
So you come up with a piece of code like this.
You take a pointer to a string,
to the const car, sorry, a valid pointer, of course,
and then you do the first malloc
to allocate the whole string structure.
And if this one is valid,
because you have to check in line five if it's valid,
you do another malloc to allocate
the sub-object of the array, right?
And because this code is very complex,
all of a sudden, you have to, for example,
check whether your second allocation,
so the dot array is malloc, succeeded.
Because if it didn't succeed,
you have to free, again, the whole structure
and you turn it null.
And this is a code that invites errors,
like just by the sheer length of it
and number of pointers that appear there and mallocs.
So you don't want to write code like this.
Not only it is fragile,
because you have to remember about,
and especially if it's like a bigger thing,
you have to remember about freeing,
about checking all the pointers.
It's also not really optimal.
You need twice to malloc, and that's bad.
It's a costly operation.
Depending on your luck or the lack of luck,
you might end up with fragmented memory.
Your data structure might end up
in a totally different piece of memory
than your array that's a part of this data structure.
You don't want something like this, right?
It's expensive, it's bad.
What you want is a one peak nice block of memory
which contains everything.
Array, there is a solution for it.
This solution, and that's actually why I have a layout
like this, why the car pointer is the last pointer there,
is called the flexible array member.
And it looks like this.
Structures in C can have an array of undefined size
as the last member.
And this is not just a pointer,
this signals that at the end of the structure,
there is an array which is a sub-object
or actually a member of this structure,
and you're gonna define at the runtime
what the size of it is.
This string is also an incomplete type, all of the sudden,
because it doesn't have any proper size anymore.
Because the length of this is unknown at compile time,
at the compile time.
You can only set it up during the runtime.
So it must appear at the end.
You cannot basically do anything with this string anymore
that's fancy, like you really cannot make
an array of these strings directly.
It's not gonna work because this doesn't have
a definite size, so that's not gonna work.
But what you can do,
I mean, those are all the things you cannot do,
and I already told you what you cannot do,
what you can do is skip one malloc all of the sudden.
So instead of having two mallocs,
I now have one that takes care of allocating
my base data structure.
And now if you use the size of,
it's only gonna count the members that have a fixed size.
So it's not gonna count the array.
And then you take the size of your string
that you want to put in your array
and allocate it all at once.
There is no free, needed, no checks.
Actually, one check is needed because I mean,
I still need to properly initialize
using the compound literal, of course,
because you already know how it works, so why not?
And then copying the whole struct and so on.
And the layout becomes something like this.
So it's a contiguous block of memory,
much better for your performance,
much better for your sanity, actually,
because the more mallocs, the less sane you become.
Unless you use sanitizers, yeah.
So only one malloc, no wasted space,
and one malloc space overhead.
And still I have, since I still have time,
I'm gonna do this one,
and I'm going to do a very short demonstration at the end
because why not, let's do.
First, macro magic incoming.
This talks and with macros.
So you're shaken awake properly before the evening starts.
And we're gonna talk about function overloading in C,
also known as generic selection,
because that's also a feature of C.
C can overload functions.
You wouldn't believe it.
It just does it in a bit different way
than normal people are used to.
Imagine that you have two different structures,
and there are obviously shapes,
like a circle and a rectangle,
and you want to write a scale function
which takes those structures
and scales them with some scale.
Now, you cannot have something like this in C, right?
Very unfortunately, you cannot because C doesn't know
what's name-mangling is.
So it's not gonna fly.
You need to, instead of having two scale functions,
you need to name them correctly,
like scale, circle, scale, rect, and so on.
And let's be honest, this is ugly.
I mean, I don't like code like this,
and this is not a joke.
I mean, why would I need two different names
for a function that does exactly the same?
I would prefer to have one function name.
And luckily, this is possible.
And as everything that's possible in C,
it's possible thanks to the macros.
C already, again, I think in C11,
if I'm not mistaken, introduced a new macro
called a generic selection macro,
which works on types and switches based on types.
So it's basically a switch statement if you look at it.
So in the first, you have the controlling expression,
just like in the switch statement,
and then you have the cases.
If it's type one, type two, or type three,
not really return everything,
but replace my macro with this,
because macros are about text substitution.
So depending on a control statement,
on the value of the control statement,
actually on the type of the control statement,
you get different things.
You can replace based on the types,
your whole macro block with something else.
There's also a default,
because it's really like a switch statement,
so there is a default clause.
And this doesn't require lots of coding.
If we have two ugly functions,
like scale, circle, scale, rectangle,
we can just do define object scale,
which is going to be our function like macro,
and then do this generic selection,
switching on the object based on the type of the object.
If it's a rectangle as substitute with scale,
rectangles are the right scale, circle,
and basically this whole block of those lines of code
is going to be substituted
with either scale, scale, rect or scale,
circle, depending on the type.
And of course, since it's actually no textual substitution,
you still have to call the parameters
or pass the parameters later on to the correct function,
and all of a sudden this works.
This is so popular that this is now part
of the standard library.
Math functions are already standardized
to use generic selection,
because before you had like,
for every single math function,
you had at least three variants,
or sometimes more depending on the argument type.
So now all of them got macros
to enable this kind of magic.
Doesn't always work that great, must say,
because integer types get confused
with Booleans sometimes.
If you are below C23,
starting with C23, not anymore,
but before they get confused,
that's because a Boole was just a type def
for Boolean and yeah, sorry for something else
and it doesn't matter.
Works great, and I just want to end up with a big bank.
You can also overload on the number of arguments
if you really want to,
and if you really want to, I don't know.
There's no pub quiz, right?
So it's nobody to impress tonight,
but no, no, this is the kind of things
you try to impress your colleagues with during a pub quiz.
You can also do overloading of the number of arguments.
So imagine you have like circle,
just there is one scale, but for the rectangle,
there's either the vertical or the horizontal scale.
So we take a separate two different scales
or just one general scale,
and we would like to again be able to do the magic
that we've done before.
So call depending, use the same name to call both of them.
The bad news is that generic is not going to help you
that much because you cannot put it in,
I mean, it doesn't expand the macros within it.
So that doesn't work like this.
But the good news is that you can do still generic selection
for scale two P and scale one P,
depending on the argument type, just like I did before.
I mean, with a small difference,
there is now a variable number of arguments
passed to the macro to account for one or two arguments.
Actually not, I think I was lazy
because those are fixed number of arguments
for both cases, I was lazy, sorry.
And then you do a classic trick,
once you have those two generic selectors,
you do the invoke or the substitute trick,
whatever people call it,
that's used to select a name from a list of names.
The invoke basically takes a number of arguments,
and depending on the number of arguments
that you pass to invoke,
it will select different names.
I don't want to talk about the mechanics of it now,
mostly because I am not able to anymore.
That's number one reason.
The number second reason is I understand it,
but I will forget it after three days,
and I will have to look at it anyway.
If you want to use it, look it up.
Honestly, I'm really coding daily with this kind of things.
But that's the standard way of selecting a name
from a list of names based on the number of arguments
passed to the selection statement,
and then it will work.
So that was the generic selection,
which makes writing code much easier,
can be nested from multiple selectors
and suffers from all the macro shortcomings.
And generally speaking, this was almost all,
that's the slide that you've seen, it's incorrect,
because I want to do a five minute quick code refactoring
just to wake you up a bit.
And I'm going, you see, I have something like a vector,
so what we've been doing,
and a very deep function vector create,
written in the old style, like the totally old style.
It's taking a double pointer.
So, and the reason it's not why not, there isn't is,
and the reason it's not why not, there isn't is,
because then it can write back to the pointer,
that the pointer points to something like this, right?
Something you shouldn't be scared
when you see the code in C.
I am compiling on the only compiler that accepts C23,
this is the GCC trunk, and it works now
because it's written in correct old C,
with all the warnings, no warnings are popping up,
sanitizer doesn't kick in, good work.
We want to make it modern C,
and there are a couple of things,
when you see code like this, that you have to take care of.
First, let's look at the return type,
which is totally wrong,
I'm using the old style of returning integer,
like a negative is a mistake,
positive is everything is okay,
and since we are on C23,
we can do this out of the box,
we can return, I should return false actually here,
instead of minus one.
So, that's the correct way of doing things, right?
And that one being the last one, this should be true.
Still compiles, out of the box, no warning,
I don't include any header whatsoever,
to enable Boolean magic.
The next thing is actually, I don't accept null pointers,
so maybe fix also that one,
and put static one in here.
And if you do it, all of the sudden,
you won't be able to pass null into the function.
It's not gonna work, because the compiler,
I mean, it's gonna work,
but the compiler will tell you that you are trying
to pass a null to a function that doesn't accept it.
A great thing, you have to pass a valid pointer.
What's next?
I don't like null pointers,
I mean, I don't like null, because it's not strongly typed.
Null PTR, null pointer,
is a strongly typed alternative nowadays in C23, use it.
There's also null PTR underscore T as the type of it,
which is same as in C++.
Define, nah, not really, right?
This is bad, and I don't mean to put it here.
We have const expert, const expert size T,
I'm using capitals, I know it's bad,
but let it be so.
The compiler got a bit crazy,
it doesn't understand really what I do,
because it says set, but not use, which is not true.
I think that's, yeah, that's it, that's just a new,
it also doesn't work with auto, by the way, so,
and it should, but then it totally,
I mean, it goes monkeys.
So let's keep it like this.
We're fine, so far so good.
Look at this, I'm doing the old style initialization,
that's something that's shameful nowadays.
If you do code like this, you should be ashamed,
because you have compound literals nowadays.
They are much better, express your intent better.
Why don't you do it?
Let's do it.
That change is not that bad.
We have to put, I mean, it is bad,
but let's pretend it's not.
You have to put vector there,
and then spell out the names.
We have dot data is equal to that one.
And it's not gonna compile out of the box, of course.
Dot capacity is that one,
and dot, it was size is that one.
Close that, put the commas where they should be put.
And are we good?
We are almost good.
I mean, I did it incorrectly, of course,
but because I should have done that one here.
Small change, don't worry.
I am an expert, famous last words, right?
Okay, so we should initialize it like this,
and the vector itself should be still done with,
malloc size of vector, so let's do it correctly.
This code doesn't compile now without,
I mean, it compiles without warnings.
If I'm not mistaken,
let's compile without warnings.
Control-itress, now it's not true.
Line 30, oh yes, yeah, that goes away, of course, thank you.
So it compiles without warnings, that's fine.
But then you have to notice,
or actually you should think about what you're doing.
You're doing again something that I told is not really cool.
I'm doing a double mallocation malloc,
because my structure is allocated and my data is allocated.
There is first malloc to allocate the structure,
then the second malloc to allocate the data.
It's hidden here, and the cast to double
is not needed, by the way.
In CU, you can just cast without this one.
What to do about it?
Change, of course, the data type to a flexible array member
or the field type.
So do something like this,
and now it's not gonna work like it worked before,
now it's gonna work much, much better.
Because what you can do is malloc size
of the vector itself plus size of capacity multiplied
by size of double.
I'm doing, I wanted to actually double and capacity.
And it has to go, let's put it where it was.
And let's move those up all the way where they belong to,
because now it makes sense.
So I'm allocating everything at once,
the whole array, as it should be allocated.
And then I don't need this one anymore.
I do need to most likely return quickly
if I don't manage to malloc, because that's still needed.
And if I do manage to malloc,
well, all I need is actually that one, right?
So I need to set the capacity correctly.
And that's done with one nine,
and I don't free anymore, because that's also not needed.
So my code now became like, at least twice as short,
I shouldn't return true.
Can I return true here?
Yeah, I can, or I can return just vector
is different than null pointer,
which is a nice way of spelling the same thing.
And do here is vector different than null pointer then.
I'm gonna assign the new capacity to it.
And that's it, if I am not mistaken.
That's the end of the refactoring
of doing it more modern using modern proper syntax.
Is it better?
I think it's more readable.
I think it's easier to maintain
because you don't have so many lines of code
and you don't have so many branches.
There are not so many ifs like before,
not so many else and so on and so on.
And it doesn't compile as some of you most likely notice
because I'm freeing something I shouldn't be freeing now.
I was freeing still the data
and I cannot free the data separately now
because data is now a sub item of my big structure, right?
So that's all.
That's really all.
And that's the summary of it.
Don't be afraid of modernity.
Some features really boost productivity,
especially things like initializer,
designated initializers and compound literals
do boost productivity enormously.
Some of them will really help you
with safety with pointers.
When you use the variable length arrays syntax
when passing things to functions
or when declaring multidimensional arrays
or even single dimensional arrays,
it's gonna help you with safety.
Compilers are getting better and better
like basically every year there is a new warning appearing
that wasn't there before for variable length arrays.
Some features are scary, like using macros.
This is always scary.
What's even more scary is chart GTP is very good at it.
And compilers will understand modernity and help you.
When you zero using the compound literals,
they will do memset under the hood.
They will optimize away all those actually L values.
Don't worry about it.
Like even if you're passing the whole structure
to the function through a compound literals,
some compilers do optimize away a lot of it
and you don't pass what you don't need to.
Thank you very much for listening.
We have exactly 45 seconds left,
which is like perfect timing.
But you can ask me later on questions if you have them.
So thanks again for coming here
and staying with me awake, which is like a huge achievement.
For all of you.
So thanks a lot, guys.
