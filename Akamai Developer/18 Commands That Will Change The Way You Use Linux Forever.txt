Hello again everyone and welcome back to Linode. In today's video what I'm going
to do is teach you guys some command line tricks that I've picked up over the
years, some tricks that I wish I knew earlier in my career, and these are going
to be some command line tricks that'll save you time, maybe help you work more
efficiently, and some are just plain fun. So let's go ahead and get into my
favorite command line tricks for the Linux terminal.
Alright so here I am on my laptop and I'm going to go over some of my favorite
tips and tricks right now. Now I'm going to go over these in no particular order.
So just stick with me and hopefully you'll find at least some of these
helpful. Maybe you'll add these to your daily workflow, that would be really cool.
Let's go ahead and get started. Now what I'm going to do is start off with a
really easy one. So I'm going to go into the Etsy directory, I'm going to change
directory into that directory, and now that's my current working directory. But
what if I want to go back to the previous directory that I was just in? Well
to do that I can actually type cd and then dash and that's it. I'm just going to
type cd dash just like that, I'll press enter, and I'm back to my home directory.
Now of course you could go back to your home directory by typing cd and
then tilde just like this, that does essentially the same thing. But the
difference with cd dash is that it's not specific to the home directory at all.
So for example if I go into the Etsy directory, then after that let's just
say I go into a different directory, cd dash takes me back to the previous
directory like I mentioned, whereas cd and then tilde takes you specifically to
your home directory. And I'm sure a lot of people know about cd tilde, but I guess
if you didn't already know that then well now you do. So what I'm going to do
right now is just clear my screen. So I'll type clear and when I press enter it's
going to clear the screen. Actually I'm not going to press enter, but I am going
to clear the screen, but wait a minute how did I do that? So if you have output
on your terminal and then you hold control and press L, that actually clears
your screen, it's that easy. And yeah you could type clear to clear your screen
that does work, but when you do that you're using quite a few more keys than
when you just simply hold control and press L, which I find to be the easiest
way to do it. So again you have output on the screen, just hold control, press L,
and that's it. You've cleared the screen. Now the screen isn't actually completely
clear though, so for example if I use my mouse and I just scroll up a bit, you
can see that the output that I had is still there, so essentially what control
L is going to do is just move the command prompt back to the top of the
screen, giving you all the space back, but the history is actually still there
if you use your mouse wheel to scroll up. Now alternatively you could also type
reset as well, and that's actually going to reset your shell. And I'm scrolling the
mouse wheel, but I'm not able to scroll. Why? Well I reset everything, so reset is
kind of like clear on steroids. It actually empties out everything and
legitimately clears your screen in every sense of the word. Now for me it's just
muscle memory to hold control and press L, so that's what I do. I don't use reset
all that often unless there's something wrong with my shell session, maybe
something is enacting right. If that's the case I might type reset, but most of the
time I'll hold control and press L, that's what I'll do. Now earlier in the
video I showed you CD- to go back to the previous directory, but what I'm going
to show you right now is a different way to do the same thing, but it's a little
bit more flexible. What I'll do right now is change directory into D slash var
directory, but I'm going to go about it a different way. Instead of typing CD I'm
going to type push D, and then the directory I want to go into, and you
can see that I am now in the slash var directory, and that's pretty cool. So what
I'll do just to illustrate the point is just change directory a few more times.
Now I'm in my home directory, and now I'll just go into my .config directory.
So I've changed directories a few times here, it doesn't really matter which
directories you change into, but what I'm going to do right now is type popd,
and now back to Etsy. When you type push D and then give it a directory, you'll
change into that directory, but it's not quite that simple. When you change
directory into the new directory, the previous directory is added to the stack,
and here you can actually see the stack. I'm going into slash var from slash Etsy.
The push D and popd commands are actually more involved than this, there's more you
can do with it, but for right now what I recommend that you remember is how to
type push D and then popd, and push D remembers the directory that you are in,
and then popd will take you back to that directory, even if it's not the most recent
directory that you are in. If you recall, cd- takes you back to the previous directory,
but push D gives you the ability to remember a specific directory,
then popd puts you back into that directory any time you want to go back there.
So if you plan on doing some file system navigation, and then at the end of that you
want to return to a specific directory, that's when push D and popd helps the most.
So now I'm back into my home directory, let's go ahead and continue and check out some more tricks.
The next trick I'm not going to spend too much time on because it's one of those things that I
could actually explain in greater detail, but I've already done that, I have a whole video
about background tasks, so I'm going to summarize it here, but I'll leave a card right about here
if you want to check out my background process video and learn even more about how this works.
Now let's say for example I have a file open, I'm going to use Vim for some reason this doesn't
always work with nano, I don't know why, but it really shouldn't matter if it's a text editor or
htop or whatever program, basically any program that is in the front, you know something that
takes you away from the command line, and what if you want to return to the command line,
but you don't want to close the program you were in. So what I'm going to do is just open up a random
file, I'm going to choose the etsy ssh sshd config file, and let's just say I'm in this file right
here and I'm changing some configuration options, but I need to work on something else real quick
because something came up and I need to go do something else, and let's say I've made a bunch
of changes to this file, I'm not ready to save the file yet because I'm not finished with it,
but I also don't want to lose it either, so how do I get back to the terminal without actually
saving the file and also without opening up another terminal window, but what we can do is
we'll control and press Z, and that effectively minimizes that particular program to the background.
Now it's not quite the same thing as minimizing a program in a desktop environment or a graphical
user interface, but we're going to pretend it's essentially the same thing because that's the
value that I see here, you have a program running, you don't want to lose it, you don't want to lose
your work, and you do want to return to it, but you also don't want to open up a terminal just to
get back to the command line, this is a great way to do it. So now you know how to send things to
the background, but how do you get it back? Well, that's easy, you type FG for foreground,
and then it comes back, it's that simple, you hold control Z to send something to the background,
something that's in the front, and then FG, and that'll bring it back to the foreground.
So I'll go ahead and exit this, and like I mentioned, it doesn't really matter if it's a text editor,
another example of this is H-top, and this is a really cool utility for monitoring system resources,
but the same thing applies here, I can hold control and press Z, and send to the background, FG,
it's now on the foreground. If you want to find out more about how this works, then check out the
video that I mentioned, but at the very least, being able to send something to the background,
and then bring it back to the foreground, will probably save you a lot of time.
Just keep in mind that if you close the shell or log out, you will lose whatever's running in the
background. So just make sure you remember that when you send something to the background,
you should bring it back to the foreground, finish what you're doing before you close your terminal
window. All right, so it's time to move on to the next trick, and what I'm going to do first is
just update my package repository index, so I'll type apt update just like that, and I'll press enter.
Oh wait, I forgot to use sudo. You know, as long as I've been using Linux, you would think that I'd
remember that by now, but even after two decades, I'm constantly forgetting to run sudo. Of course,
I could just run sudo apt update. I mean, it doesn't take that long to type that command,
but that's not what I'm going to do. What I'm going to do instead is type sudo,
and then two exclamation marks just like this, and then I'll press enter.
And it worked. Now check this out. When you run sudo exclamation mark exclamation mark,
the two exclamation marks actually refer to the previous command that you just ran.
So by running sudo exclamation mark exclamation mark, I'm telling the command shell to repeat
the most recent command, but put sudo in front of it. So that way, I don't have to worry about
retyping the entire command just to run it as sudo. This is a great way to repeat the last
command, but make sure that you have the proper privileges and run it with sudo. And again,
I find myself forgetting to use sudo quite often. So this trick right here is something I use at least
once a week. Now another trick is going back through the command history by holding control
and pressing R. Now this is kind of confusing to explain. So I think showing you will make more
sense. So I'm going to hold control, I'll press R. And now the command prompt has changed to a
search field here. So what do I do here? Well, what I do is I start typing part of a command
that I remember, part of any command that I would have ran in the past. Maybe I want to bring back
a long command that I ran in the past, but I don't remember the syntax and I just don't want to go
through the history file to find it. I'll just type what I know of the command. So we just ran
apt update, for example. Now notice I just typed apt and it's already showing sudo apt update.
If I hold control and press R again, it'll go to the next thing in the search history that meets
that criteria. And control R will just keep going back through the command history. And then once I
find the command that I was looking for, I rerun it by simply pressing enter. And the sudo apt
install htop command, that's what I ran off camera to install htop on this computer.
So there's pop D. We ran that one. We also ran push D. Any command that I've ran in the past,
I could easily run it again with this trick. Hold control and press C to break out of this.
And what I'm going to do is show you yet another way to run previously run commands that I think
is even better. What I'm going to do right now is run history just like this. And we see all of my
command history, which is very useful in and of itself, especially if you're a new Linux administrator
for a company. If you're working with a server that has a particular problem, maybe it's a problem
that's happened in the past. And as a new Linux administrator, it's always a good idea to check
the command history because you could find out what people before you have done in similar
situations. And like I said, this is a cool trick in and of itself. But that's not actually the trick
that I want to show you. What I'm going to do is show you how to rerun any command from your
history. Notice that there's a number on the left side of each of these commands.
So for example, I typed this command right here off camera to see whether or not htop was installed
on this computer. It wasn't. So then after that, I installed it. But what if I want to run this
command right here yet again? I could just right click and copy it. And then I could right click
and paste. But that's not what I'm going to do. What I'm going to do instead is refer to the command
by its number. But first I'll type an exclamation mark. And then directly after that, I'll type the
number no space or anything like that. And as Linux people, we often refer to the exclamation
mark as bang. So essentially I'm typing bang 102. And what happens is that it actually shows me the
command that's associated with that number. And then it runs it. So right there I was editing the
SSH config file. So I could do that again by typing bang and then the number just like before.
And now I'm back into that config file. I think this is a very useful way to use the history,
but I'm going to make it even better. One thing that I think is missing here is the date and time.
I feel like it's really helpful to have the date and time that every command was run in.
So that way if I'm looking for a specific command during a specific time period, I could find it
and have a better idea about the actual command history and when the commands are executed.
But the problem is we don't have that information here. So how do we get it?
For that we have a very special variable in its hist time format. And what I'm going to do is set
this equal to a very specific string. So I'm going to type percent capital Y dash percent lowercase m
dash percent lowercase d space percent uppercase t and then another space.
And adding another space here is really important. I'll explain why in a moment,
but anyway I'll press enter. And now that we've done that, let's run the history command again.
Now we have a date next to each of the commands right here. Depending on how your shell is
configured, it might actually show the same date for everything because maybe a date wasn't recorded
when it was first created. Different distributions set this up differently. So this may or may not
be a problem for you. But at least going forward, it's going to have the correct date and time
for every command. So if you're looking for a specific command from a specific time period,
you could just scroll through your history. And as you can see, it shows that information here.
Now one problem with this though is that when you close your shell, then the his time format
variable is going to go away. We set the variable here in this session. So even if I opened up a
new terminal window, it's not going to apply to that particular terminal window. It's only for
this session. So what I want to do is actually make this permanent. And the way to do that
is we just open up a special file with an editor. We can use nano then it doesn't matter.
And what we're going to do is open up the dot bash RC file in our home directory.
And right here we have his control. And that's actually another trick that wasn't on my list,
but it may as well have been his control being set to ignore both means it's going to ignore lines
that include a space at the beginning. So if you want to type a command and you don't want it to
show up in the history, if this is set, you could type a space in front of the command,
and it won't show in the history. So if you are running a command that contains something sensitive,
it might be a great way to hide that from the history. But that's not what we're here for.
What I'm going to do instead is add the his time format variable right here in the bash RC
file. So that way every single shell I open will automatically have the setting.
Just like that. So hold control and press O to save the file, enter to confirm it,
control X to exit out. So from this point forward, every terminal window that I open
should have the his time format variable set, giving me the date and time for each command.
Now earlier I mentioned to not forget to type the space at the end when you're setting the variable.
And the reason for that is because if you don't, then there's not going to be a space in between
the date and time and the command. So this space right here would not be present. Because you added
a space at the end of that string, it's putting that space right here in between the date and the
time and the command. So if you don't include that, things get, you know, confusing. Now another
command that I want to show you guys is completely useless. I mean, it's cool, but it gives you no
practical capabilities whatsoever, doesn't enhance your workflow. So technically, it doesn't even
belong in this video. But I figured it might be fun to show you. And that command is C matrix.
You have to have this package installed most of the time this will not be installed.
So you could use your distributions package manager to install this package.
So I'll press enter and you'll see immediately what it does.
Does that look familiar? If you recall, in the background, I often have a laptop that has this
as the screensaver. But it's not actually a screensaver, it's just a full screen terminal window
that's running C matrix. I just think it looks really cool in the background. Again, it has no
practical use whatsoever. It's not going to enhance your productivity, but it's cool. Now as an aside,
what I often do is press F 11 to make the terminal full screen. And that makes it look even cooler.
But F 11 is not actually specific to C matrix. That's a trick in and of itself. So I'll press F 11
again. And that undoes the full screen. And then to get out a C matrix, I hold control and press C.
And now I've broken out a C matrix. So again, I'm going to press F 11. And notice that the terminal
is a terminal shortcut. And it's recognized by quite a few desktop terminal emulators.
There's some that don't understand F 11, but most do. And that makes it full screen. And I mean
full screen to the point that you won't see any window controls at all. You won't see your panel.
It's literally taking up your entire screen. So I'll often do this if I want my terminal to
basically cover up everything else if I don't want any distractions. And I just want to work on
something without seeing anything in my desktop environment. I don't want to see email alerts.
I don't want to see anything. But what I'm working on, I'll just press F 11 and make the terminal
the only thing that's visible. And when you press F 11 again, it returns it back to normal.
In addition, most desktop terminal emulators will allow you to increase and decrease the font.
And this is something that I often do in my videos. So what I'm going to do is hold control
and shift at the same time. And while I'm holding those down, I'll press plus. Notice that every
time I press plus, the font will get larger. If I hold control, not control and shift, but just
control and press minus, as you can see, the font is shrinking. Now, often when I do this,
it kind of plays around with the sizing of the terminal. So I'll often press reset to make sure
that it's going back to the proper size. Otherwise, I might have some blank space up here. But anyway,
that's how I actually adjust the size of the font in my videos. I often crank up the font size to
make sure that you guys are able to see what I'm doing. And sometimes I have to shrink the font
size if something I'm doing is taking up too much space. I've had some people in my comments ask me
how I do that. And if that's you, well, now you know. Now, what I'm going to do is just press
the up arrow a few times. I'm going to just bring up a previous command. I think this one right here
is good enough. And what I'm going to do is hold control and press U. And it just deletes everything
on that line. Literally everything. And depending on your computer, it could take some time to
actually backspace everything out. I mean, that didn't take too long. But if you had a complete
wall of text, control U will simply just delete everything. That's pretty cool. Now, similar to
that, I'll bring up another command here, maybe something a little bit longer. I guess that's
fine. Since we're on the subject of control U to delete everything on the prompt, there's a few
other shortcuts that also involve holding down control. So what I'll do is hold control and
press A. And that puts a cursor all the way to the front of the line. And then control E takes you
to the end of the line. Now, suppose that I want to run this command right here. But before I press
enter, I realize that I probably should have included sudo at the beginning. Now I could hold down the
left arrow go all the way to the beginning, which might take more time if the command is even longer.
And then I could type sudo and I'm fine. But what I think is more practical is that you can hold
control and press A. And that immediately brings you to the front of the line. And then control E
takes you to the end of the line. So that way I'm able to jump to the beginning, add sudo, jump back
to the end. That'll save some time. Maybe not the most useful thing in the world, but you never know.
Maybe this is something you'll find helpful at one point or another in the future.
So I'll clear the screen. This time I'll just hold control and press U to delete that command.
And now I'm back to an empty prompt. Now what if I wanted to run two commands one after another?
Maybe I want to run sudo apt update and then sudo apt dist upgrade. The first command will update my
package repository index, whereas the second command that I mentioned will make sure that
all available updates are installed. What I could do is run sudo apt update,
and then once it's done, I can run sudo apt dist upgrade to run the second command. But that's not
what I'm going to do. Instead, I'm going to set up the command just like this.
And watch what happens.
It immediately changed the command into the dist upgrade command. So if I was to press enter,
it's going to install all of the updates. Now of course, apt is actually specific to Debian and
Dubuntu, but the command itself doesn't really matter. I'll just say no for now because I don't
need to update anything. I'm just using a temporary installation on my studio laptop.
I don't really care to update it right now anyway. So what I'll do right now is just chain two random
commands together. So ls dash l. And then I'll run echo. Hello world. So the first command produced
this output right here because I ran ls dash l. And the second command echoed hello world to the
screen, which we see right here. So now what I'm going to do is show you another variation of this
same idea. So I'll recall this command and I'm going to take away the semicolon here.
And instead, I'll type two and percents. What do you think's going to happen? Let's find out.
The same thing. But wait a minute. If it does the same thing, if this method changed two commands
together as well, then why would I want to use the semicolon versus the two and percents?
To demonstrate the difference, I'm going to bring back this command right here. But what I'm going to
do is make the first command completely invalid. So I'm going to list the storage of a directory
that doesn't exist. This will produce an error. And then I'm going to chain the command into echo
hello world just like before. But the command stopped me though. It's telling me that this
directory does not exist, which I knew. But it didn't run the second command. Hmm, that's interesting.
Let's bring that back, take away the end percents, and I'll replace them with a semicolon.
So we get the same message as before. It's telling me that the directory does not exist.
But it still ran the second command. So now you can see the difference. If you chain commands
together with semicolons in between, it will actually run the next command if the previous
command failed. But on the other hand, if you chain commands together with end percents instead of the
semicolon, if it encounters an error, it will not run subsequent commands. And that's the difference.
Depending on what you want, maybe you want the second command to go through if the first one
fails, or maybe you don't. And that'll determine which one of these you actually use. Now another
command that I want to show you guys is tail dash F. And I feel like this is a command that a lot
of people know already. But for whatever reason, I didn't find this out until much later in my career.
So I want to make sure that I let you guys know about this as early as I can.
So if you didn't already know about this, well, you're about to know about it.
So what we're going to do is just tail a log file. I just chose the var log syslog file randomly.
You could give it any file that actually exists. Now when I press enter, it's going to show me
the contents of var log syslog, or at least the last portion of it. And you can't really see it now.
But if anything was to happen on this system, then this is going to update in real time. So I could
literally watch the log as content is being added to it. So that way, if I'm troubleshooting something,
I could keep my eye on what's happening on the server. Maybe the other person that's telling
me about a problem can try to reproduce the problem. And while they're doing that, I'll just
watch the log. And as they're trying, I'll see new entries being added to the log file. It's a very
cool thing to do. And to break out of this, you hold Ctrl and press C. And now you're back on the
command line. Now for the next trick. If I list the storage of my current working directory,
I actually have this file right here called hello.txt that I actually created off camera.
But check the contents of that file. You can see that all it contains is hello world. Now we're
going to pretend that this is a very long file. Maybe it's a log file, for example, and we want
to empty it out. Now most of the time you can actually delete a log file and then the service
will recreate it. But that's not always the case. It's actually easier to truncate a file
especially if it's a log file, it's a safer thing to do than outright deleting a file.
Maybe there's still an open file handle to that file. And if you go ahead and delete a log file,
maybe a new log file will not be created. And that wouldn't be good. So what you could do
is run truncate. Because set the size, that's what the dash s stands for, we'll set the size
to zero. Be very careful with this, by the way. And then we'll give it a file name. And that's
going to make the file size of that file exactly zero, thereby deleting everything it contains.
And that's why I mentioned you should be careful with it.
If I kept the contents of hello.txt one more time, it's an empty file. And that makes sense. We set
the size to exactly zero. It's now an empty file. So now I'm going to show you guys one more command
that I like, and that's the column command, but it's actually more useful when you chain commands
into it. For example, if I run mount, it's going to show me a list of all the file systems that I
have mounted on my computer or server or whatever happens to be. But it's all kind of jumbled together.
And yes, part of that is because of my font size. But even if I shrink the font size and then run it
again, it's not all that much better. So let's try this a different way. I'm going to run mount.
And then I'm going to pipe that into column dash t.
And I might need to make the font size really small so you can see the difference.
It's going to make sure that all the output is shown in columns, which makes it a lot easier to
read. And it's not specific to the mount command. Any command that produces output that's a little
jumbled might actually benefit from being piped into the column command, like I'm doing here.
If nothing else, piping mount into column dash t is useful of it by itself. So if that's all you
take away from this, then I guess that's fine too. So hopefully you've learned something new with
today's video. Go ahead and let me know in the comments down below what your favorite command
line trick or time saving shortcut happens to be. I look forward to reading what you guys have to
say and maybe I'll learn something new myself. Anyway, as always, thank you so much for watching
and I'll see you again very soon.
