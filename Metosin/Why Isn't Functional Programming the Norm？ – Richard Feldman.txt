Welcome, everybody.
This is, why isn't functional programming the norm?
I'm Richard Feldman.
So I'm going to start with a question.
Why isn't functional programming the norm?
Has anyone else wondered this?
Like, everyone ever looked around and been like, hey, yeah,
exactly.
Like, I spent a lot of time doing object-oriented programming
in my career.
And then, eventually, I came across functional programming.
I started doing it and doing it more and more.
And now I've been doing it for several years.
And at some point, I was just like, yeah, why isn't this
the norm?
It seems so great.
Like, why isn't everybody else doing this?
So I set out to sort of answer this question.
And just sort of pretty directly say, like, why are things
the way they are?
Like, why are they this way instead of that way?
And I found out the answer.
And it turns out, the answer is, it's complicated.
There is no one very simple, nice, neat, tidy answer.
But in this sort of quest for understanding,
I ended up learning a lot of things
that sort of explain why things got to be the way that they are.
And I want to share them with you.
So because it's complicated, we're
going to break this down into three parts.
So first, we're going to talk about language, and then
paradigm, and then finally, style.
So let's start with language.
So what languages are the norm today?
If it's not functional programming ones, what is it?
So I found this study by this company called Slashdata.
And they draw up various different sources
to compile this information.
And they ended up producing this Global Developer
Population Report for 2019, which you can read on their website.
And it basically blaze out the top 10 languages,
like in terms of usage, thusly.
And this is probably no serious surprises here.
JavaScript, Python, Java, and so on and so forth.
These are probably languages we've all heard of.
And it's also not a huge surprise that, unfortunately,
the total number of functional programming languages
in this list is zero out of 10.
But that's the way things are, not necessarily the way
that I would like things to be.
And so looking at this list, I then
sort of ask the question, how did they get so popular?
How do they become some of the 10 most popular languages
in the world?
So I ended up concluding that this breaks down
into three major categories, and then two kind of exceptions.
So one is they had a killer app.
Another is they had some form of platform exclusivity.
Another is they had a really quick upgrade story.
So let's start with the killer apps.
So this is the Apple II, and it's running Vizicalc.
So Vizicalc is one of the earliest examples of a killer app.
And what I mean by that is that, basically, people
wanted to use Vizicalc so badly that they would sometimes
pay upwards of $10,000 for this $100 piece of software
to get the hardware to run it on.
Like, people wanted Vizicalc in their lives so badly
they would just go out and buy an Apple II just so that they
could run Vizicalc.
And this is sort of like an example
that sort of crops up in programming languages as well.
Byte Magazine, back in 1980, said
Vizicalc was the first program available that has been
responsible for sales of entire systems.
And that metaphor also extends to cases
where someone wants to get at a particular application
of a programming language, and then they buy into the programming
language itself along the way as sort of a cost of getting
at the application they want.
So here's an example of this.
What would you say is the killer app for the Ruby programming
language?
Rails, exactly, right.
And I think this really drove this point home
when I looked up the Google search trends for both Ruby
and for Rails.
And it turns out they have the same shape.
In 2005, when Rails comes out, Rails' Google search term
goes from 0, has a big spike, and then Ruby has exactly
the same spike, and then Rails' popularity tapers off,
and then Ruby's popularity tapers off.
So I think from this, I can kind of conclude pretty definitively
that Ruby's popularity in the top 10 is explained by Rails.
And I don't think that if Rails had not
happened that Ruby would actually be one of the top 10
most popular languages.
Killer app for PHP, I think, has changed over time.
So I think at first, it was basically the things that kind
of everybody was using it for, which is basically
making HTML dynamic.
Like, if you've got a static HTML page
and you wanted to make it a little bit dynamic,
it was really hard to do that faster or more easily than PHP.
You just tweak some stuff, insert some code
in the middle of your HTML, and then upload it, like,
filezilla it up to a server, and then, OK, it's, there you go.
You're done.
But these days, it actually seems to have narrowed down
to having two particular killer apps for PHP.
So this is a graph of PHP's popularity over time.
A little bit more dire than Ruby's.
It's been in pretty steady decline since 2004.
And in fact, if you look at the end,
and these two particular applications of PHP, WordPress
and Drupal, it looks like the total number of hits for PHP
is the sum of WordPress and Drupal.
That's about it these days, which kind of matches anecdotally
what I hear from people.
I still hear people using Drupal a good amount.
I still hear people using WordPress
for building sites for people.
But in terms of using PHP for their own site,
or for going out and starting a startup around it,
that's pretty much done, like Facebook and Slack
are kind of cautionary tales in that regard.
Killer App for C was actually systems programming.
So back in the day when this came out,
this is way before my time, but I actually
watched a talk by Brian Kernahan, one of the co-creators
of C, and he explains that actually at the time,
if you wanted to do systems level programming,
like you wanted to write a kernel,
or you wanted to write like LS or some system utility,
your options are basically like assembly language or Pascal,
which I'm not a Pascal programmer,
but the way that he talked about it sounded like that
was a ludicrous idea.
So apparently not really done.
And so when C came out, it really filled this need
that a lot of people had.
So like, awesome, I want to do systems programming,
I'm going to reach for C. And that really kind of kicked off
C's popularity.
I think there's some potential for like some FP killer apps,
like anything can do it.
If something comes out that's sufficiently popular,
if it takes off, I believe that it would take that language
with it.
So examples that come to mind for Elm, there's Elm UI,
basic pitch there is you don't have to write CSS anymore.
You can make front end applications,
and it's got this whole layout system that's really nice
that you don't have to think about CSS.
You just write your Elm code, and then you have a UI.
Closure, Datomic, like it's a nice database.
Like that's independent of programming language,
because if you want a really nice database,
and you say, hey, I think I would like to use Datomic,
Datomic takes off.
If a bunch of people say that, I think
it would bring closure with it.
It would bring a lot more closure programmers
into the world in the same way that Rails did for Ruby.
And finally, ReasonML has this thing called Revery,
where the basic pitch is you can have a cross-platform app built
with web technologies, but it doesn't actually
run everyone's favorite electron.
So all these things have the potential
to cause these languages to take off in the same way
that they have for non-functional languages.
It's just a matter of, will they?
I don't know, we'll see.
So second way that a lot of these languages became popular
is platform exclusivity.
So I'm going to talk about a few examples.
Objective-C, Swift, JavaScript, and C-Sharp.
So we'll start with Objective-C and Swift.
Does anyone think that Objective-C and Swift
are just like great general-purpose programming
languages used in all sorts of different domains,
kind of the way that Python is?
OK.
There's one.
I appreciate your bravery.
So I think probably the rest of the people
who are thinking is like, no, those
are things that you use to build for Apple.
But it turns out, even if that's kind of their deal,
like Apple has this platform exclusivity thing,
where these are the blessed ways to develop for Apple.
And everything else is maybe technically supported,
but really, really difficult in comparison.
Turns out, Apple makes a ton of devices.
So even if both of these languages, Objective-C
and Swift, are pretty much just being used
to build for Apple devices, that's
such a huge amount of development that gets done
that it's just like, yeah, that's
enough to get you in the top 10.
And which is kind of interesting if you think about it,
because it almost means pretty much no matter
what the design of these languages was within reason.
Could have been functional.
Could have been imperative.
Could have been object-oriented.
Could have been just about anything.
And they would be in the top 10, because Apple
is such an enormous source of programming.
So interesting to think about these things.
JavaScript kind of in the same boat,
not with a proprietary thing, but just with the web.
I don't know if you know this, but studies
have shown that the web is huge and has gotten really big.
And I mean, technically, when it came out,
like at the inception of the web, there were like two,
and then very shortly, three viable options, namely JavaScript,
Java applets, remember those, and Flash, remember that.
And pretty quickly, people discovered
that the problem with Java applets
is that they're miserably slow, and no one ever
wants to use them.
And Flash kind of had a heyday.
It had a good run, and by good, I mean,
was full of security problems and crashing.
But eventually, it kind of died off.
No one really knows why.
And then eventually, it was pretty much just JavaScript.
So JavaScript had platform exclusivity
over the most popular application delivery platform
in the history of anything.
So somehow, that made it to get all the way to number one,
really surprising, exclusivity over the web,
as far as like UIs go.
So this is another example of platform exclusivity,
not because of a closed proprietary thing,
but because of an open standard, where they just all
converged on one language.
It'd be interesting to see if WebAssembly changes this.
It's really got an uphill battle, but at least has the potential.
And finally, we come to C-Sharp.
And this is an interesting case, because it's about platform
exclusivity from two different angles.
So first, we have Microsoft Windows.
So this is mid-90s, Windows 95 is in the works,
and out comes Java from some microsystems.
And Java has this tagline of write once, run anywhere.
And Microsoft is not like this, because if you
can run it on any operating system trivially,
that means you don't have to run it on Windows.
And you could run it on somebody else's OS, like Mac,
or Linux, or something like that.
And Microsoft, at the time, made pretty much all their money
from Windows and Windows-related things.
So they really didn't want people to be writing a ton of Java.
They wanted people to be writing something
that they controlled.
So they came up with this language called C-Sharp.
And that was the language that they controlled
that had an almost identical feature set to Java
by some very strange coincidence.
So what Microsoft actually wanted out of this
was they wanted lock-in.
Like they wanted people to be like, OK, let's just use our thing
instead of that thing.
But the way that they achieved this
was by using Platform Exclusivity on their vast and very
genuinely good network of tools and ecosystems
around MSDN, documentation, and stuff like that.
So if you wanted to get in on the Microsoft IDEs,
like Visual Studio, like before Visual Studio Code,
and you wanted to get a Java-like experience,
the only way to do that was C-Sharp.
Because Microsoft was not going to build those tools for Java.
They were just going to build it for C-Sharp.
It was successful.
So C-Sharp became a very popular language.
And to its credit, it had a number of design features
that were considered by many people, improvements over Java.
And this got it up into the top 10.
And then finally, we have the quick upgrade path.
So this is basically sort of working at people's,
like the considerations that they do when they're deciding
to adopt a programming language.
So of course, everybody's thinking about the benefits,
you know, the things that I think
will be good if I use this language.
Familiarity is always a big thing.
We're humans.
We get a first impression of something.
We're like, oh, that looks nice.
I know what that is.
Or you say, oh, no, that's a lot of parentheses,
hypothetically.
This is the thing that people do.
We make snap reactions to things,
and it impacts whether or not things get popular.
Learning curve is another one, right?
You look at this thing, you say, well,
I don't know what the word monad is.
I don't think I'm going to have time
to learn all these textbooks about category theory, whatever.
Ecosystem access, am I going to be
able to leverage this huge ecosystem of code that's
already written for whatever language is?
And how much effort is it going to be to migrate?
Like, how different is this from the current code that I have
or the way that I'm used to writing code?
All of these things are considerations.
And so the quick upgrade path is basically saying,
don't worry about it.
Don't worry about it.
This is all benefits.
And the drawbacks, it's super familiar.
Learning curve's almost zero.
Full access to the ecosystem.
Code migrations to the snap.
CoffeeScript is one of the early languages
that succeeded on this.
Their tagline was, it's just JavaScript.
And they basically were like, yeah,
you can learn this in about half an hour
if you're a JavaScript programmer.
We'll migrate all your code for you.
You can just run a script that will convert your JavaScript
to CoffeeScript.
And then it'll have all these benefits.
And this was enough to rocket CoffeeScript up to,
at one point, at its peak, it was the 11th most popular
language on GitHub.
And this tagline was maybe not 100% accurate.
I mean, it's literally not just JavaScript.
It is a different programming language.
But it's so close to JavaScript that it's like, OK,
it's approximately equal to JavaScript.
The language that I think has a more reasonable claim
to that is TypeScript.
I mean, TypeScript is actually a strict superset of JS.
So it's like, OK, yeah, I guess fair enough.
That actually is just JavaScript.
So they actually have the thing where
you can rename your file name from .js to .ts.
And it's supposed to just work right out the box.
Then you can just start adding features from there.
Pretty impressive.
And certainly, if you're looking at that and saying,
oh, so you have these benefits and the costs
are I have to rename the file, OK, that sounds good.
Where do I sign up?
And a lot of people have signed up.
TypeScript is doing really well in terms of popularity.
C++ is arguably the first example of doing this
and being really successful at it.
C++ is a near superset of C. It wasn't literally TypeScript
style, a strict superset.
But often enough, you could just take your .c file,
rename it to .cpp, and just go and just get
the additional benefits of C++.
Worked out really well.
Kotlin is maybe the most modern example of this.
It's going more with the coffee script flavor.
Kotlin is a substantially different programming language
from Java.
It's not just claiming to be a drop-in upgrade,
but it is like they really emphasize this on the website.
100% interoperable, existing code bases.
I've no trouble migrating.
We've got a script that will convert your Java to Kotlin.
And again, also language that's been doing really well.
OK, so that's most of the languages in the top 10,
but there are two that we haven't talked about.
So one of them, Java, has a strategy
for getting popular that, as far as I know,
has never before or since been attempted
to get popular, which is epic marketing.
I mean, seriously.
So in the 90s, there was a lot of coverage.
And in fact, the early 2000s, basically all the money and power
that Microsystems was putting behind Java.
In 2003, they introduced a new $500 million marketing campaign
just for Java, nothing else other than this programming
language.
And keep in mind, this is in 2003,
when Sun was having financial difficulty.
So this was after untold amounts of marketing dollars
that they had done back when they were flushed with cash.
And at this point, they already had millions of Java users
and they were like, it's not enough.
We need to announce a new re-upped effort
and tell everyone how much money we're spending.
This did, however, result in some pretty hilarious stuff.
So this is from the late 90s.
This is a Sun Microsystems commercial called the SPI.
And it's basically just like a James Bond spoof.
It's like James Bond and Q, where
they just go through this briefcase full of gadgets
and Q was like, this was built with Java technology over
and over, including this credit card that, for some reason,
is Java code running on it.
I don't know exactly why that's critical to James Bond's
success here.
Also, there was this funny moment in the middle
of the commercial where they just
have this woman in a lab code holding a C++ textbook.
I think that was just to be like, hey, C++ programmers,
come use Java.
It'll be great.
And that was the goal of Java, was
it was supposed to be familiar for C++ programmers.
They really wanted to attract them.
James Gosling, in one of his talks, used the term.
He's like, we wanted to hoodwink them into thinking
that Java was something that they already understood.
So they were really pushing this, even
in the middle of this commercial.
So this was so successful that it actually
impacted what has today become the number one programming
language.
So the story of JavaScript's early development
was, Brendan Eich was working for Mozilla.
He was tasked with making a scripting language for the browser,
so you could do real-time scripts in the UI.
And his original design was actually based on scheme,
like a functional programming Lisp.
That could have been number one.
But people at Mozilla were like, have you
seen this Java hype train that's coming?
We've got to get on that.
Put it in the name.
Just stick it in front, we're going to have JVA in our name,
and also make the syntax look like that,
and make the language be object-oriented.
And Brendan Eich's like, OK.
And that's the story of why the number one programming language
in the world is object-oriented instead
of a functional Lisp.
I think it's pretty, you would have a tough time making
the case that it's like, yeah, if JavaScript had been
a Lisp, and it was the only way it had
exclusivity on the browser, no, I wouldn't have gotten popular.
No, who cares about the web?
That's not a big deal.
People get scared away from parentheses, so no.
No, no chance.
I mean, it would still be number one.
It would still be the biggest thing in the world,
because the web was still the biggest thing in the world.
But this is why it ended up the way that it did.
It was because of, ultimately, Sun Microsystem
spending millions of dollars on marketing.
Go figure.
Which brings us finally to Python,
which has unfortunately the least exciting story of all these.
It's basically just like slow and steady.
It just slowly and steadily grew over the years.
So you can exemplify this by looking at Python in comparison
to two very similar languages, the Python, Pearl and Ruby.
So this is back in 2005, when Rails is just taking off.
So you can see, at this point, among those three languages,
Python was the least popular.
So Python had just been kind of cruising along,
and Pearl is kind of in decline, almost PHP style.
And Ruby, at this point, has just skyrocketed up
because Rails just came out.
So at this point, Python's kind of in third place.
But hey, so slow and steady wins the race, as they say.
And as we see, as time continues,
Pearl continues to decline.
Rails helps Ruby out, but then eventually,
it kind of tapers off.
Python's still just kind of cruising along,
cruising along, cruising along.
And then eventually, I don't know,
Python just kind of gets an uptake.
The slope changes a little bit,
and it just sort of slides on up.
And then by the time we get to the president,
it's like, holy cow, what happened?
Python is now the number two language in the world,
like out of nowhere, but it wasn't out of nowhere.
It was just out of slow wear.
It never had like a Rails moment
where it just jumped up to the moon.
It was just kind of slow and steady,
and then eventually, slow and steady,
slightly more increased, and then that was it.
Just multiply that by enough years,
and eventually, it just becomes a really popular language.
So good on them.
I almost feel like this is how we would like
programming languages to work out.
They just have a good design,
they're people like them,
and then over time, people use them more, and that's it.
But of course, as we're seeing,
in real life, it's more complicated than that
most of the time.
Of course, there are other factors that go into popularity.
It's not like these particular stories
are the only things that influence them,
but I think that they're kind of secondary to these things.
Syntax is one, we talked about,
of course, anyone who's used Lisp
is familiar with people's initial reactions.
Job market, people are always just kind of catch 22,
where they're like, oh, I don't want to learn that,
because if I invest in it,
no one will be able to hire me,
and then employers are like, I don't want to use that,
because if I do, I won't be able to hire anyone.
It's like, well, no, just, whatever.
This happens, right?
It very much favors languages that are already popular,
and sort of reinforces their popularity.
And then finally, community.
This can be either an asset,
or it can be something that makes people go away.
Ruby, I would say, this is a big asset to them,
was the Ruby community has a reputation
for being really welcoming and friendly.
I think among functional programming communities,
it's kind of a mixed bag.
Some of them are notable for being really welcoming.
Others are notable for being kind of arrogant and stuffy,
so it really kind of depends on where you go.
But again, like I said, I think these are pretty secondary
to the main ones that we just talked about.
So this led me to another question, like, okay,
so I can see that there's a variety of explanations
for how these languages got popular,
but how come they're all OO?
Like, that doesn't really seem to relate
to killer apps and things like that.
Like, how come all of these except for C in the top 10
are all object-oriented languages?
Is there more to this story?
Is there something about object orientation
that causes or is partially responsible for this popularity?
Because it seems like if that's just a coincidence,
that's a pretty big coincidence.
So I looked into this some more,
and this leads me to part two, paradigm.
So Wikipedia defines paradigm as a way
to classify programming languages based on their features.
So because features can overlap,
like you can have multiple sets of features,
you can have overlapping paradigms as well.
So some languages are, for example,
imperative and object-oriented and procedural at the same time,
or they can be hybrid, object-oriented and functional.
You know, this is the thing, they overlap.
So I was trying to sort of narrow it down
to the stuff that's uniquely OO,
like the non-cross-paradigm stuff,
and say like, okay, is it the case
that almost all these languages are OO
because of some uniquely OO features
that are really not found in other paradigms?
So this, of course, led to the question of like,
what are the uniquely OO features?
I mean, I can think of a few that get talked about
as sort of canonical OO features,
like encapsulation maybe, inheritance, objects, methods,
so I kind of started to investigate these.
So inheritance, this breaks down into two categories.
One is what people call interface inheritance.
This is basically just another term for subtyping.
Of course, subtyping is found in all sorts of languages,
so that's definitely not uniquely OO.
The other one is implementation inheritance,
which most people just call inheritance,
but I have encountered people who want it
to be more specific, so for the rest of this talk,
whenever I say inheritance, I mean implementation inheritance.
Interesting thing about implementation inheritance though,
it's not actually considered to be a best practice, really.
So there's this phrase composition over inheritance,
like favor composition over inheritance.
And I think the earliest time this was used
was in the Gang of Four Design Patterns book,
it's this really influential
object-oriented programming design book.
But now this has just become something that gets repeated
by every object-oriented thought leader
I've pretty much ever heard of.
This is just kind of the way you're supposed to do stuff.
It's like, yeah, inheritance is a thing,
it's found pretty much every object-oriented language,
but you know what, it's kind of disfavored
in favor of composition.
I think that's pretty interesting.
So that leads me to the conclusion that if inheritance
is one of the uniquely OO language features,
which I think it is, it's pretty hard to say
that this thing that is recommended not to use
as a best practice is somehow explains the popularity
of all these OO languages.
So I don't think it's inheritance.
And I especially don't think this,
when you think about what are some modern languages
that sort of self-identify as being able
to support OO paradigms, what do they think of inheritance?
So Go is a good example of this,
because this is a language where they don't really need
to have backwards compatibility
with any of the other object-oriented languages.
Like Kotlin, of course, needs to have inheritance
because they want to have really good Java interop.
Go doesn't care, I mean, Go is basically trying
to be another better seed based on, you know,
using the learnings of the intervening time period.
Really some of them.
And basically Go is like, you know what?
We support an object-oriented style.
This is from their FAQ, but they don't have inheritance.
They just decided like it wasn't worth it,
didn't want to do it.
And it's especially interesting when I look at this
in terms of what does that imply
for what methods and objects,
which are kind of two of the other things
that I said might be some of the uniquely OO features.
Then it turns out that once you take inheritance
out of the picture, methods and objects
are kind of just the same thing
as like procedures and structs with some syntax sugar.
So I think this is kind of true in Go,
like quote-unquote objects and methods
are really just syntax sugar.
So like if you look at these two function calls,
like one is, or procedure calls,
circle.grow parentheses three
and grow parentheses circle comma three.
In both cases, the logic that you're running
is this grow logic.
And in both cases, grow has access
to the circle and the number.
So whether or not you write it in method style
or whether you write it in sort of procedure call style
is really just a matter of syntax.
Semantically, the only reason these could possibly be different
is if you have inheritance in the mix.
So to me, this kind of reduces down to,
okay, I've ruled out objects and methods
as being uniquely OO.
Really, it's either, it's just implementation inheritance
and or maybe encapsulation.
So what about encapsulation?
If Go supports an object-oriented style,
how do they do that?
If they don't have a first-class concept of objects,
how do they do encapsulation?
So this gets into a sort of broader concept
called modular programming.
This is one of the things you'll find listed on Wikipedia
as one of the programming paradigms, modular programming.
It's like imperative programming, modular programming,
et cetera.
So modularity is essentially where you get to define
a public interface and hide private implementation details.
This is about information hiding.
And this comes from a language called modular,
which sort of pioneered this in 1975.
Now, languages with modules are all of them, basically,
like every modern language, except for C and C++,
which are like too old school to have had it back in the day.
Although modules actually are apparently coming
in C++ 20, so this is a temporary state of affairs,
but it seems to be that pretty much every language
has agreed, you know what's good?
Modules, we should have a module system,
except for the languages that are too old for it.
And Go is no exception, Go has a module system.
Now, what's interesting here is how modularity
and encapsulation relate.
So again, this is the definition of modularity,
public interface, private implementation details,
and here's the definition of encapsulation.
Public interface, private implementation details,
but specifically about an object.
So encapsulation is kind of like a weaker form of modularity.
It's like a subset of it.
It's like modularity, but only applied to objects.
And this was a feature that you could find
in another early language with a similar kind of name
called Simula.
This is a language for performing simulations.
And Simula did not have a module system,
but they did have encapsulation.
So you didn't get the full-blown module system
that every modern language seems to agree is what you want,
but they did have a more limited form,
namely encapsulation.
So you got some of the benefits,
but they were kind of limited to just objects.
So Simula inherits from the interesting choice of words.
Simula is a descendant of the Algal programming languages,
like really influential language in the 60s.
And it had some of these language features,
objects, classes, inheritance.
Those were brand new as of Simula.
Simula introduced to the world objects,
classes, and inheritance.
Garbage collection, it did not introduce
because John McCarthy did that with Lisp back in the day.
This was the original garbage collected language,
but Simula just continued to use that.
And Simula was very influential
in another famous object-oriented language, Smalltalk.
So this was maybe the most famous
of the original object-oriented languages,
considered by some to be the only true object-oriented language.
So Smalltalk was designed by Alan Kaye,
who drew on Simula, among other sources of inspiration.
And he coined the term object-oriented.
So objects existed before Smalltalk,
but object-oriented was an Alan Kaye original.
He came up with this term and he applied it to Smalltalk.
And you can kind of see why,
because in Smalltalk everything is an object.
Like you have objects, right, those are objects,
and then the way that objects call methods
is by passing messages to other objects.
The messages are also objects,
and then also all of those have classes,
and classes are also objects.
So really, like seriously,
every primitive in Smalltalk is an object.
So, I mean, yeah, I would use the term object-oriented
to describe that, maybe even object-obsessed.
And really, like, you know,
so this is a pretty natural term,
and it got picked up by a lot of people,
and they were like, oh cool,
object-oriented systems have like objects
and classes and inheritance.
And then like three decades later in 2003,
Alan Kaye was like, just kidding,
actually like object-oriented,
I never really should have called it that,
because really it's about these other things.
I really think OOP is actually about messaging,
local retention and protection and hiding of state process,
extreme late-binding of all things,
and only Smalltalk and Lisp are object-oriented.
And the rest of the world is like, excuse me?
We've got C++ and Java and like all these other like,
these seem object-oriented to us,
and you're saying like, no, and he's like,
this is, I coined the term, this is what it means.
Here's the thing though, like language,
like spoken language evolves over time.
I mean, Alan Kaye, maybe this is what he actually,
in his heart, truly meant back in the 80s,
but it's like that ship has sailed,
like we just, the word means a different thing now
than what he wanted it to mean originally.
I think it's just too late, like object-oriented programming
is just like what we consider to mean these days,
which is not this.
So if you wanna learn more about objects
and Alan Kaye and the history of the term
objects and object-oriented,
Hillel Wayne wrote this blog post
that really goes into the history in a lot more depth,
and if you wanna check out that link a little bit later,
you can.
Now I bring up Smalltalk because this is the language
that influence Objective C, which is one of our top 10.
So Objective C was created by Brad Cox.
He did an interview, which is at that link right above there
if you wanna see the full interview,
where he kind of explained the story
of how he ended up creating Objective C.
And the story goes like this.
He was working at a company called ITT.
They were working on the Unix systems,
and they were programming them in C.
This is where the C influence in Objective C comes from.
And Brad's job was he was on a productivity team.
He was supposed to help everybody else
in the organization get more productive.
And what he says in this interview is he's like,
I wasn't happy with C as a productivity foundation.
I was kinda looking around for anything that could help.
And it was about the time
that the Byte Magazine issue came out.
Now if you look at that Smalltalk logo,
I've omitted something here,
which is that this was actually the cover of Byte Magazine.
Remember we were talking about Byte Magazine for Vizicalc?
So Byte Magazine was essentially like
getting on the cover of Byte Magazine
was like being on the front page of Hacker News
in the 80s, right?
This was like before the web,
there was no Hacker News, there was no any web.
But this was a big deal.
So Brad's like leafing through this,
and he's like, huh, this is interesting.
This seems like it's related to the problem I have.
A whole bunch of things in there
that Smalltalk was offering
that I thought might help encapsulation for sure.
Encapsulation being our subset of modularity.
See is so bad at it.
Everything is public, it just turns to soup.
The pain of that is what I was trying to escape.
It's just really interesting.
Like Brad Cox was basically saying,
I want modularity, I want a module system.
And with the benefit of hindsight,
we can say Brad, go look at modular.
You'll get the real thing that everybody's gonna conclude
is what you actually want later.
But he didn't have access to that.
He had Bite Magazine, and Smalltalk was the one
that happened to be on the cover of Bite Magazine.
So he was like, cool, here's the thing
that solves my problem, this is what I'm gonna use.
And so he ends up making Objective-C from that.
And it's pretty interesting to think of like,
this is what happened in the 80s
based on his being only aware of Smalltalk.
There was no web.
But like Bite Magazine has done other covers, right?
Like here's one for Lisp.
I mean, who knows what could have been, right?
What if it had just been like modular
on the cover of Smalltalk Magazine?
Instead of Objective-C, it's just Modular-C, right?
And then now one of the top 10 languages
is maybe a dialect of standard ML instead of
being a dialect of Smalltalk
and a hybrid of Smalltalk and C.
Because really, that was the one thing that he wanted.
And this was the way that he knew to get it.
And much later after the fact, we look back
and we don't think like, oh, Objective-C,
that was based on a need for modularity,
which everybody now knows is best solved by modules.
We look back and say, nope, that's an object-oriented language.
Object orientation must be great.
Not really the story, when you dig into
what he was actually saying about what his goals were.
There's another language that's descended from Simula.
This time, not by way of Smalltalk.
I put up a little curtain so I can have a big reveal
as to what the language is.
So this is Bjarne Strauschrup.
Anyone know who this gentleman is?
Okay, yes, so I have a spoiler right here on the slide.
He's the creator of C++.
But he's also the creator of another programming language,
which he created before C++.
Anyone know what that was called?
C with classes.
This language had a very specific goal.
It was to have C, but with classes.
And actually, it's not quite true.
It was C with classes, but also a stronger type system.
He wanted to make the type checker a little bit stronger.
So he gave this interview where he kind of explains
his thought process and what he was doing.
And he was like, why did I want to add classes to C?
Well, Strauschrup had actually used Simula personally
in a previous job when he was working at this company
where he's like, I want to use C,
and I want to use something nicer than C
for modeling my domain.
I just want to be able to get more organized.
And he was like, yeah, you know what?
I thought classes were pretty good
when I was using them in the Simula days.
I really liked that.
And so I'm just going to try and bring that in.
So he does, he makes C with classes,
and then he runs into a problem, which is that C with classes
is what he calls a medium success.
And the problem with being a medium success,
as he explains, is that it's like, okay, so this works.
I got a few people using it.
Couple of users, it's pretty nice, they're happy with it.
The problem is that I'm the only maintainer.
And there's too few of us to spread
the maintenance burden around.
And so I'm kind of in a pickle.
Like on the one hand, I could just say,
well, I don't want to maintain this for the rest of my life.
I'm just going to walk away and abandon it.
But then all the people who are using it are my friends,
so I don't want to do that.
And he's like, so what do I do?
He's like, well, the only other option seems to be,
maybe I'll just add more features
so it'll be more useful to more people,
and then maybe it'll get popular enough
that I can find some other maintainers.
So he does that, he adds the additional
non-object-oriented features
and renames the language to C++.
And it became slightly more popular.
And it still maintained this whole
like drop-in C replacement thing, right?
That upgrade path that's really smooth.
But this is really interesting because again,
we have actually a pretty direct experiment of like,
does object orientation cause success?
And he was like, well, I added object orientation
and a stronger type checker as a bonus.
That was not enough to cause success.
Then I added a bunch more features and success.
So we have a very direct experiment
as to whether or not object orientation
caused the success of C++.
It's like, no, because when it just had object orientation,
it was called C with classes,
which nobody in this room had heard of.
So clearly not a causal relationship there
between the OO stuff and the success of C++.
You want to see this whole interview?
Again, here's the link to this.
Really interesting stuff.
This is from the 80s when Straussrup
was interviewed about C++.
Okay, so to kind of sum up this family of languages,
a lot of people were going to write C code for Unix,
like it's great systems programming language.
They find, you know what, the ergonomics are not great
or maybe like, I just need some modularity.
In the case of C++, adding OO features to it
did make his life better.
He was happier with it, but it wasn't enough
to make it be like the rocket ship
that jumped into the top 10 like it ultimately did
until he added additional non-OO features.
And then we look at Java and we know,
okay, Java really wanted to appeal to C++ programmers.
So why is Java so object oriented?
In such a way that seems very familiar
to C++ programmers, it's like, well,
can we really say that Java's object orientation
was in there as a first class really great thing
or was it just that this was familiar
to a large group of users
and that was why it was object oriented
and that was what caused its success.
Because we've seen that familiarity
and this smooth upgrade path is a really big deal.
And then of course the same thing can be said of C-Sharp.
C-Sharp was intentionally designed
to be exactly the same feature set
or very close to it of Java
so that it could be presented
as a really viable direct alternative to Java.
So if you trace this lineage back,
all of it comes down to like potentially the reason
that all of these languages are object oriented
in this whole lineage right here
is just that Bjarne Strauss-Straub created C with classes
and then it wasn't popular enough
so we added other features.
But then the other features don't get the credit.
It's the OO that one sort of medium success failed experiment
is what gets all the credit in retrospect.
Similar thing with Objective C.
Like Brad Cox just wanted modularity.
He says this multiple times in the interview.
But ultimately what he ended up settling on for modularity
happened to be small talk
because that was what he knew about at the time.
And then of course Swift needs to have
backwards compatibility with Objective C
and so it's also an object oriented language.
So really like digging through this,
like at least with this group of languages,
I'm not seeing it.
I'm not seeing that object orientation
caused their success.
I'm actually seeing the opposite
that it actually was legit a coincidence
in all of these cases.
So what about Python?
Python is not any of these groups.
It's not like a direct descendant of C
except in a very kind of weird argument type of way.
Did object orientation cause Python success?
So I don't have as direct an interview like to point to here
but I do have a quote from the creator of Ruby,
which is Matt's.
And he said, you know when I made Ruby,
I wanted a scripting language that was more powerful
than Perl and more object oriented than Python.
So Matt's view was that Python was like
not particularly object oriented.
And he's like, I really wanted something
that was a lot more object oriented.
He was pretty into like these small talk ideas.
And I think that's really reflected
in the language of Ruby.
So you would think that if object orientation
is like really essential for success
that the fact that Matt's successfully made Ruby
more object oriented than Python.
And in fact, Ruby did enjoy a period of time
where it was more popular than Python
that that would have led to some sort of long term success.
But of course, we already know from previous charts
that that's not what happened.
Ruby did briefly surpass Python's popularity
but it was basically because of the Rails bump.
And then once that died off,
Ruby's a killer app language.
Python is the language that's like people like it
because its fundamental design is pretty good.
So are OO languages the norm
because of uniquely OO features?
I think the answer is just no.
They're OO because modularity is a good idea
and they happen to originally get it from OO by chance.
All right, which brings us to the final part, style.
So functional programming style,
I'm going to just claim without any evidence
is avoid mutation and side effects.
I'm claiming this because I've talked
to a bunch of people about it
and this seems to kind of be the consensus
but at the end of the day, nobody's really entirely sure.
There's no authoritative source that we can go to
to say what the FP style is.
So I'm going to claim it's this
and hopefully it'll go along with me.
Now obviously no language features are required
to program this style.
Like you can almost do this in assembly.
Not saying it would be pleasant
but theoretically you can just choose not to mutate
and choose not to have side effects
and most languages, certainly any procedural ones.
Having said that, obviously languages differ
in their support for this style.
Some languages are very conducive to programming this style.
Others make it pretty difficult.
Like assembly.
So why is an FP style the norm?
Well, one argument is just that it's just a matter of time.
Like it just hasn't had enough time in the spotlight
and just like over time it's going to become
more and more normal
until eventually it becomes kind of the norm.
Actually this is a pretty compelling argument.
So if you look at the Kotlin FAQ,
it says is Kotlin an object oriented language
or a functional one?
And the answer is hey, hey, we got both.
We got OO and we got functional.
Like you can use both.
This is not what you would see
in a 1990s Java dialect FAQ.
That was just not a thing back then.
But like these days, the functional style,
that's considered a selling point.
That's like oh no, like people agree
that the functional style is good now.
Like don't worry, we support that.
We have good support for that.
In a language, remember where its main thing is like
hey, this is our super smooth Java upgrade process.
They're bragging about their ability
to support the functional style.
Look at Swift.
They say some additional features of Swift
include functional programming patterns
like map and filter.
And again, this is a language
which doesn't need any help to attract functional programmers.
They're just gonna be like everybody's gonna use it
because if you wanna build for Apple, you kind of have to.
But Swift is also saying like hey, we're a modern language
and in a modern language,
you gotta have good support for the functional style.
Again, not saying this means
FP is about to take over the world,
but it does, it is important to note
that this is not something you would see in the 1990s.
Something has changed.
And if you don't believe me about those two languages,
take a look at these collection of books.
Functional JavaScript, functional JavaScript,
functional programming JavaScript,
beginning functional JavaScript, functional light JavaScript.
I mean, just lots and lots of stuff
about how to do functional programming
in languages that are not functional languages,
but which do have some support for it.
Java even, like Java, functional programming in Java.
Like this is a real thing.
Python, sure, like that's the top three languages
right there, all this huge selection of books.
C++, there are multiple C++, functional programming
and C++ books.
I mean, this is a change.
This is, none of these things would have flown in the 90s.
No publisher's gonna be like oh yeah,
like functional programming and C++.
Let me sign you up, I'll give you a nice advance on that one.
No, this is a sign that people are coming around
to the idea that you know what,
actually like the functional programming style,
like I don't think people are languages yet, certainly,
but the style is gaining traction.
And I think this is interesting because if we are somewhere
in the middle of like a transition from OOP style
to FP style, like maybe this hybrid thing
is an intermediate stage on the road to FP becoming the norm.
That's a plausible thing.
Now, how much time are we talking about?
I don't really know, I mean, this whole talk,
we've been talking in timescales of like decades,
so it might be that maybe we're in the middle,
but actually the middle is like,
maybe we have another decade or two.
I don't really know, I mean, I can't say with any certainty.
What I can say though, is that something has changed.
Like this style is not something that people were considering
a positive thing in the 90s, and the idea that it is
a positive that I think has become sort of mainstream now.
And I think this can translate to
popularity of functional programming languages.
Like imagine somebody who's already concluded,
hey, you know, FP style is good.
I'm just like choosing to write functional programming
JavaScript, functional programming Java.
That's just how I write my code.
At some point, you look around, you're like,
hey, wouldn't it be nice if like the language I was using
actually had strong support for this style,
instead of just kind of being an afterthought at best?
Wouldn't that be nice?
And then at that point, maybe people start saying,
on my next project, I'm gonna try and embrace a language
that is really good at this, and not just like,
okay at it, kind of as a side effect, no pun intended.
And at that point, like who knows?
Maybe that changes these rankings.
Maybe that influences people's decision
of what programming languages they're using.
Okay, so to sum up, why isn't functional programming
the norm?
Well, it's complicated, but I think we've learned a lot
about some of the factors that go into this.
We talked about language, paradigm, and style.
Why aren't FP languages the norm?
Well, no one, there aren't any sufficiently large
killer apps for FP languages.
But I gave three examples of things
that could plausibly take off.
Killer app can come out of nowhere,
can come from anywhere.
No exclusivity on large platforms,
but hey, maybe if there's some platform
that has FP languages as the exclusive way
to write for them, and that platform gets big,
who knows, that could happen too.
Can't really be a quick upgrade
if you're substantially different.
I mean, if the whole point is the language
is like really significantly different,
you also can't say, don't worry,
it's a drop in replacement, it's just JavaScript.
If it's like, well no, the point is it's not JavaScript.
I don't think we can ever have that.
No epic marketing budgets, and to be honest,
I don't know if we're ever gonna see
an epic marketing budget on the scale of Java,
but we can dream.
And then finally, maybe FP languages
are in a slow and steady Python-esque growth state,
but those just take decades to resolve,
so it might just be a long time before we actually see them
reach that level of popularity.
Are they the norm because of uniquely OO features?
I don't think so.
I mean, information hiding, aka encapsulation
in OO languages, it's not a uniquely OO feature.
Modules can do it too, and modules
seem to be the consensus best way to do it.
Inheritance does seem to be uniquely OO,
but again, best practice in OO languages
is to encourage composition over inheritance.
And without inheritance, like objects and methods
are basically not any different from structs and procedures,
so I think the answer to this is no.
It's not that OO causes languages to become popular.
It's just a coincidence, it's just a long for the ride.
And finally, why is an FP style the norm?
Well, I think it's just a matter of time,
it's becoming the norm.
I think that's something we can all appreciate
and look forward to in the future.
Thanks very much.
Yeah, questions?
Yeah, sure.
Yeah, so how do you see a list fitting into this picture?
Is it a functional or an unfunctional programming
language in your mind?
Oh, man, you're opening a real can of worms here.
So the question was, how do you see list fitting in here?
Is it a functional or not a functional programming language?
So I actually, this talk is trimmed down to 40 minutes
from two and a half hours, because I had so much material
in this.
One of the questions that I started going around asking people
is like, and just think about this,
because it can fry your brain after a while.
It's like, how do you look at a programming language
and decide this is a functional programming language or not?
How do you do it?
And I would just go to people and ask this question,
and they would say, oh, well, it's this.
And then I would give them a counter example.
They'd be like, OK, well, no, it's not that.
It's this.
So I'll just rattle off a couple.
So one is like, OK, so it's a functional programming
language if it has support for first class functions.
Like, OK, so Java is a functional programming language.
No, no, no, not Java.
But they have to be pure.
OK, so OCaml is not a functional programming language.
Clojure is not a functional programming language.
No, no, those count.
But OK, you need immutability.
Like, that's important.
OK, but like, so Rust is a functional programming language.
It's immutable by default even.
No, no, no, not like that.
But you just go around in circles.
One person suggested a score.
Like, if you have a certain number of things checked off,
then like, you cross a threshold, you're functional.
But ultimately, I ended up concluding that, to be perfectly
honest, like, classifying languages as functional or not
is kind of arbitrary, definitely very fuzzy,
and ultimately not as important as talking about like,
the style and their support for the style of like,
being able to avoid mutation and side effects
and like, still have a really good experience.
So to directly answer your question,
like, would I say Lisp is like a good functional programming
language, I would say it really depends on the Lisp.
Like, if there's a Lisp where like,
every part of the standard library
requires you to mutate things and do side effects, maybe not.
Clojure definitely is.
So I think it really just depends on the language.
Yeah.
Hi, awesome talk.
Thanks very much.
Thank you.
Performance.
Performance.
Yeah, it's one of these things where Python is a bit slower,
C++ is meant to be fast.
So people often talk about this with FP
because reasons you can probably go into.
I was just wondering what you thought about performance
as a kind of like aspect of this discussion.
That's a great question.
Yeah, so the question was, how does performance factor in this?
So I think performance is one of those secondary concerns
that doesn't necessarily cause a language to be popular or not.
I think it more impacts the areas in which it can be used.
So for example, like some applications,
you just need the level of control over memory
that C and C++ give you.
And if you look at Rust, like Rust is one of the very first
new competitors in that space that's viable to challenge
the crown of C and C++ in a long time because of that.
So I think if you need that level of control over performance,
you're probably not going to go for a functional language.
You're probably not going to go for any garbage
collected language.
You just need to be able to directly manage memory.
But as we've seen, there's a ton of domains where that's not true.
In fact, pretty much all the other ones,
which is why all the other languages in that top 10,
except for C and C++ are garbage collected.
So I think as far as performance goes,
it really depends on what your performance needs are.
If you're writing like a back-end server language,
in a lot of cases, you don't like it.
Python's a perfectly acceptable one.
Like it's not as fast as Go, but a lot of people are just like,
yeah, but it's fine.
Like it's good enough.
Like it's going to be dominated by the network
and the database anyway, so who cares?
I think that, so it's really domain specific.
And so overall, to answer the question,
I would say performance, I think, is a consideration,
but it's pretty secondary to the other factors
that I talked about earlier.
Also, I don't think it's true that functional is less performant,
but that's like a myth.
It's just not.
Like if you have mutation and you can do it all over the place,
then certain algorithms are available to you
that are not otherwise available.
But if you're not using those algorithms anyway, it doesn't matter.
So anyway, and also there's certain performance optimizations
you can only get if you have certain functional guarantees.
So yeah, I can go on for a while.
Thank you, Richard.
Thank you.
Thank you.
Thank you.
Thank you.
