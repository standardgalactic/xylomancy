Hello. Welcome everyone to the sixth annual Turing lecture. This lecture series is a part
of a broader effort at Kings called the Alan Turing at Kings Initiative. And this is an
initiative to raise funds for studentships, fellowships, and other academic endeavors.
These lectures are essentially all of them are focused on topics that somehow relate
to the legacy of Alan Turing. And today's talk is going to be about what computer scientists
like to call formal methods. And this means applying logic and mathematics to the reasoning
about the correctness of programs, basically, or building tools to help people do that kind of
thing. And our speaker, Byron Cook, is a professor at UCL and a vice president and distinguished
scientist at Amazon. And Byron has been sort of at the cutting edge of actually applying formal
methods in the real world. So the work he did, for example, at Intel very early on when Intel
was having problems with chip design, I don't know if you remember the Pentium bug, but that
certainly stimulated a lot of effort to use formal methods in proving the design of circuits
correct. Byron then went on to Microsoft where he developed a lot of verification tools that were
essentially solving the problems that Turing proved were unsolvable. And it turns out many
of them are solvable in practice. And that work got rid of the blue screen. Remember the blue
screen of death from Microsoft? Well, that work pretty much got rid of that blue screen of death.
And then from there, Byron went on to Amazon where he really spearheaded the formation of
formal methods groups at Amazon. And today, Byron tells me there are over 600 people at Amazon
working on formal methods and over 20 groups doing that kind of thing. So apparently this kind of
work touches every aspect of Amazon's development and roll out of their services. And I just want
to say that when I did my PhD in kind of in this area back in the 80s, this was considered like
kind of crazy stuff that no one would ever use, that was too impractical, it was focused on toy
problems. No one is ever going to use this stuff. And I think for me, it's very satisfying to see
what someone like Byron is doing now, like actually bringing these ideas and technologies
into the real world, making real impact with them. So I'd like to introduce Byron.
So we finally figured it out. And it's a huge honor for me to be invited and to be associated with
Alan Turing and Kings. I hope you all read the abstract and know what you've signed yourself up
for. So I'm going to tell you, I'm going to attempt to tell you something rather technical,
but I've promised to aim it at a general audience and I think I'm going to fail horribly,
but let's have a good time together. So we'll see if that works. As I was preparing this talk,
I'm like, oh, what have I done to myself? But I think this talk brings something for everyone.
So I think that the technical people in the space will enjoy pieces of it. And then those of you
who don't come from the space, I hope you'll take away something from it. That's interesting to you.
So this talk takes a needle and thread through a bunch of characters that are Cambridge based.
I was really excited to be invited to give this talk because it's a very Cambridge story.
There's a King's story. So there's some characters that were Kings people. Frank Ramsey is a really
interesting character. I mean, he's a lot less well known than Turing, but also very, very important.
King's person, sort of the boy of wonder, actually born in Cambridge, born just on the other side of
Jesus' dream at the lock bridge, the house when you cross the lock bridge. He was born there.
And then because father was at Muddlin, and then he was here. And I think he worked with this chap
quite a bit. And then, unfortunately, he died. I read his new biography about him. And from what
I can work out from the biography, he died from a disease he caught by swimming in the camp.
So you need to be comfortable. And then Alan Turing, I don't think I need to introduce.
There's another character, which is the spinning beach ball on the top left just above Frank
Ramsey. And so some of you may be familiar with this concept. So I'm going to give you a bit of
IT advice. So if you take nothing else away from this talk, you can take this. When you see that,
what you need to do is you need to go into the force quit applications of your Mac,
find the program and kill it. And hopefully that will take care of it, though it might be
there's an infant. So what's happening here is there's an infinite loop in one of your programs,
and it's causing it to hang. Hopefully it's not in the operating system, because now you're really
in trouble. But if it's in like a Chrome or Outlook or something like that, you'll kill it,
you'll lose your data. But that's how it goes. And if you use Windows, this is kind of what it
looks like in a similar situation. If you use a phone, this is what it would like to look like.
But I believe the phones are designed that after a certain quite short amount of time,
they just reboot the phone. So the Mac, luckily, doesn't reboot itself every time that it gets
stuck in an infinite loop. But the phones, I think, designed to just reboot. And you may not
even notice the way that the phones are designed. But we also have this problem. So it turns out
that our bodies get, there's little infinite loops sometimes that we find very unpleasant.
So this is skin cancer. And it turns out that skin cancer is, in a sense, the regulatory mechanisms
in your body to maintain cell growth and death. And so skin cancer is your body kind of going
into one of these states. Okay. So the quest is to build tools that can talk now about what's
going to happen in the future. So we want to build a tool that takes a program and says
things that usually have the word eventually in them. So, hey, when I press this button,
does it do the rockets eventually launch? Or if I ask this question, will I eventually get the
answer? Or if I model disease as a system, and then I want to make a change to characterize the
change I think that we should make for medicine, now does the system eventually do the thing I
wanted to do? Does the cell growth stop and we reach homeostasis? So that's the kind of
things we want to do. And we want to do this without actually running the system. We want to
take the system and reason about it. Because we may not have the whole of the entire system,
and also we don't want to interact with the world, but we don't actually want to launch the
rockets to learn the rockets will be launched. We want to ask, in some theoretical world,
would we launch the rockets? Okay. So just a bit of bookkeeping. I know myself, and I'm going to
use all these words to mean the same thing. So just to take a moment, the halting problem,
the question of program termination, finding infinite loops, and talking about systems that
like trying to show that systems don't hang, it's all the same thing. So when you hear me talk,
say, in one breath, I'm saying, program termination, and, you know, three breaths later,
I'm talking about the halting problem, it's all the same thing. This is again for the
non-technical people on the crowd. Okay. So what is program termination? So for those of you who
know what program termination is and know what programs are, bear with me for a moment, we're
going to take a one-minute tutorial on programs and program termination, but also this program will
show up from time to time. So it's sort of worth it to everybody. So here's a program. I'm sort of
assuming a few of you are in the, I know at least one or two people in the room don't know how to
program because they're my family. And so what this, this is a program written in Python, a language
called Python. And what happens in this program is the first thing it does is it says, this is a
while loop. So it says, hey, is in greater than one? If so, go here, do what it says, come back,
and then ask again. Is in greater than one? Okay, go here, do what it says, come back, ask again.
And the idea is that this code here is modifying in and one would hope that eventually
the code that's modifying in would make in be not greater than one, in which case now the loop
would terminate. Okay, so that's the idea. So this is a computer program. That's a while loop.
Sometimes while loops, you want them to run forever. For example, you want your actual computer to
run forever. But inside the computer, inside that loop, there's often some code that you really
want to terminate. And that way you can get back to the start of the loop. So often systems are
written with one big while loop that you want to run forever. And then code and inside the while loop
you want to terminate. And that code may look something like this. Okay, that was your one
minute tutorial. This is a really interesting program. So this is a wicked little program,
actually. So this is called the Colatz conjecture. And no one knows if this program terminates. And
what I mean by that is, so a program is, we would say guarantees termination if for all possible
values of in, so in here actually could range over all mathematical integers. And so for all possible
values of in, does this program guarantee to exit? No one knows the answer to that question. So a
program guarantees termination if you know that it's true for all possible and no one knows.
And there's some really great quotes here. So this is a pointer. Yeah. So this is called the
Colatz conjecture, but it's also called the 3n plus 1 problem. It has some great names, whereas
the Hellstone numerals. The Thwaites conjecture. And then look at this great, great quote here
from Paul Urto. Mathematics may not be ready for such problems.
It's extraordinarily difficult, completely out of reach for present day mathematics.
Look at that innocent little program. Okay, now as an aside, my colleague in Amazon,
Marine Hula, is so close to solving this puzzle. It's agonizing. I was really hoping I could say
today. Oh, and by the way, at Amazon, we solved it mic drop. But alas, I wasn't able to. So he
has this really, really fascinating paper that's very, very insightful, that combines some really
beautiful, it's such a beautiful paper. So they're really making some serious headway on this problem
that I'm very excited about. Anyways, back to Cambridge. So there's another really interesting
character that's, that's, that's, that's, so, so Frank Ramsey was a Kings, Alan Turing was a Kings,
and Byron Cook, you know, cycled by Kings. For six years, I cycled by Kings, and I cycled
by Kings on my way to Microsoft Research, which at the time was at West Cambridge. Now it's by
the station. And when I cycled to, to, to, to Microsoft Research, a lot of my work was with
these two jobs. So this is Andre Rybolchenko, who is my intern. And then a long, long time
collaborate, he's actually later joined Microsoft Research. And then Andreas Podolski, who is his
PhD student. And, and what happened was that I decided to move, I'll tell you part of the story,
I moved to Cambridge. And when I moved to Cambridge, a bunch of people who were in Europe,
you know, I moved, you can probably hear, I'm American. So when I moved to Cambridge, a bunch
of people who are in Europe, were like, Oh, wow, cool, we should work together. And these, and
these were one of the, one of the sets of people who do that. And so I did this work with them that
was really explosive. And so I ended up, the all the, all these other people were like, Wow,
that's super cool. We should like, there were like, possible ways that we can solve other
problems that were related. So I ended up working with a whole network of people. And it was really
a very, very exciting time. And many of these people spent much of their time in Cambridge.
And there were of course, many scientific papers. And they all used theories from Ramsey and Turing.
So that's, that's, that is what we're going to talk about today.
Okay, let's start at the beginning. So, and here I'm going to, I'm going to do a little bit of
guesswork. So I, so I don't know if you know that there's this, the Greeks, the ancient Greeks
had this like, calculating device, right, that would, that would, that would predict
eclipses, for example. Meanwhile, they're also doing proofs, right? They, they have, they, they,
they, the Pythagorean theorem, you know, there's all this work kind of in the, the Greek empire.
So it must be, and here I'm just guessing, it must be that someone in town, sorry, some,
someone in town thought, Hey, could we get the device to prove theorems for us, right? It's just,
it's inescapable that that's true. So I would believe that that must be when, you know, our, our
people, our ancestors first said, machines, mathematics, let's put them together, right?
But what, what I do know is that, from the, from the, is that Leibniz explicitly asked this, right?
So, and we calculate the truth of any mathematical statement. That's the sort of fundamental thing
we want to do. And so here's what this would look like kind of in our modern role. So imagine on
your phone, you have some magic AI app, and you could ask it simple questions like, Hey, is there
a number between, this is an easy one, is there a number between 10 and 20? Yes, there is 11, try that.
Okay. Is the Colatz conjecture valid, right? And, and the, and the idea is that the answer
produced must be correct. That's the game we're playing. That's, that's what Leibniz suggested.
And that's what, you know, we're going to talk about much of today. And, and, and maybe it's not
an acceptable answer. You can't say maybe in this sort of, in this, in this purest Leibniz world,
and you can't run forever trying to as well, give me, give me some time. And I'm going to go off
and compute forever and just never come back, come back with an answer. No, that's not allowed
either. That you have to answer the question, and you have to answer it in a finite amount of time.
That's the rules of the game. Today, we would call this automated reasoning. So if you look at
like my title or like the groups that we have the groups in Amazon, all these like 20 teams are
called, you know, identity automated reasoning team or crypto automated reasoning team, storage
automated reasoning team. So automated reasoning is what we do. And practically, there's a few
people from the crowd, you're all laughing because you, you, you know, that we've kind of given up
on requiring you can't say maybe or our time out from time to time, right? So we're, we're
practical people and we're like, eh, sometimes we don't know the answer, right? But, but, but the
purists didn't think that. So in this, this paper, paper book by Hilbert Anakerman named it the,
the, the decision problem. And I'm not going to try and pronounce the German, right? But it's,
that it's called the decision problem. And this, this was came out in 1928. And this got everyone
in the mathematics logic world very, very excited. So back here in Cambridge, both Ramsey and Turing
were like, oh, the decision problem, that's super cool. Can you automate reasoning about
mathematical logic and mathematics such that you always get an answer, you know, super cool,
super cool problem for them. And they, and they, and they both did some interesting works. And
now we're going to talk about that. So Ramsey had this, had this very nice paper right before he
died, unfortunately. And he didn't prove or disprove the possibility of there being a general
solution to the decision problem. But he, but he did something else instead. And so what I'm going
to, I'm going to, I'm going to, we're just going to take a moment to introduce a little bit of
visual notation. So there's an idea of a graph. Graphs have nodes. Graphs have edges. Edges are
the arrows. And the idea is you can go from A to B, if there's an arrow. Okay, that's a graph.
That's a sort of fundamental concept that you see in computer science and mathematics.
And what we could do is we could color the edges. So I could color some of them red,
some of them blue, some of them green. And then what Ramsey did is he has this really,
really amazing result that's about monochromatic subgraphs. So here's, here's, here's a monochromatic
subgraph. It's, it's like the original graph, but with only the red arrows. And there's sort of
different flavors to the Ramsey theorem. So there's a Ramsey theorem is kind of a family
of statements. But what's really amazing about it is he says, if, if your graph is infinite, I can't,
I can't show you an infinite graph on this finite screen, but imagine it's infinite. If you have
an infinite graph, and a couple of other conditions are met that I don't really want to tell you about
because then it'll turn into a math lecture, then, then there exists an infinite monochromatic
subgraph. And that's going to turn out to be a very, very powerful tool for us. So take this
graph, if it's infinite, it's also complete for those of you who know what that means,
but it doesn't matter. And, and the number of colors is finite, then there's going to be
an infinite monochromatic subgraph. Okay, remember that. Meanwhile,
Alan Turing read this paper by Kurt Gertl, that was the start of the argument as to why
there could be no solution to the decision problem. And what he did was he wrote this
paper that he's, you know, famous for, I mean, it was, if you saw the exhibit today, you saw his
copy of the paper. And I mean, I think this is, this is probably the most studied theoretical science,
theoretical computer science. I mean, it basically started theoretical computer science. So this is
like absolutely fundamental paper. And so he's, I'm going to, I'm going to frame this in terms of
graphs, but he basically, you know, you know, I don't overstate this too much, but he basically
invented the idea of like the, the, the idea of what computation is. Like, I mean, people were
doing computation before and we had machines, but, but, but essentially he's like, he talked about
that in terms of, he combined that to mathematics, let's say. And again, we can think of like a
Turing machine you can think of as a graph where it's like, what are the possible transitions
between, between, between a Turing machine. So I'm going to, I'm going to explain this with my phone.
So by the way, the iPhone is like so much more powerful than anything he probably could have
a possible image. Right. So it's a really, really, it's a super computer in your, in your, in your,
in your pocket. And so, so here's me and my phone. I opened up my email. I write reply.
And then, and then I hit send. Okay. And then, and then in the sort of Turing view,
each state of each configuration of my iPhone is a state. And then you have transitions between
the states. So I can go from me opening it, seeing Tim's mail saying my reply hitting send,
that's, that's a progression. And that, and that state states and configurations. Okay,
that's a little bit of background. Let's look at this program. Remember this one? I've added,
by the way, the, the line numbers. So you could have a state of the system where the value of
n is 20. And the location is location one. So we're at this line of the program and n is equal to 20.
And then we can transition to the value of n being 20 and the location being two. Okay, get it?
Good. So what he said was, is that we know that there will be always be programs for which we
can't answer the basic question of termination. So it's, it's what we say is it's, it's undecidable.
Right. So ie, the answer is no, we cannot calculate the truth of any mathematical statement.
Because if you could, the question of program termination is one of those mathematical things.
And he sort of linked up the idea of computer programs to what's computable to mathematics.
And then said, well, this thing can't be solved and that can be bridged the gap over to the
mathematical side. Super cool result. Leaves us in a bit of a lurch though in terms of like he
sort of identified a sort of Achilles heel of computers. And so I'll, I'll, I'll illustrate
that by what was stressing me out in, in 2003. So here's a list from Microsoft.com. Right.
And I'm going to poke on Microsoft a little bit now that work at Amazon of, of, of device drivers
that you could download. And you could put these in these, you could put these into your machine.
And each of these device drivers is backed by source code.
And the problem is that there may be device drivers out there for which we can't answer
the termination question. And boy, when a device driver goes into an infinite loop or
in a world of hurt, like that is a really bad situation. Because now like you, you're,
all your programs are going to start hanging. Like this can be, this can be a very,
very bad situation. We don't want that to happen. So non-terminating device drivers hang your
computer and hang them often in quite bad ways. But what's not so known, who knows,
raise your hand if you know the paper checking a large routine by all in turn.
One hand, that's staggering. Really, you don't know this paper. People, people in automated
reasoning in, in, in Amazon, pull up your hand if you don't, if you, if you work for Amazon and
you don't know this paper. That's interesting. Okay. Great. Well, you're going to know about the
paper. I think this is one of the most interesting papers there is. This comes from 1949. He totally
tells us how to do our job. It's amazing. So, so he gives a very clear instruction for how to prove
a program terminating. 1949. Would I say 49, 47? 49, I think. And so I'm, now I'm going to put a
few words in Alan Turing's mouth. So he doesn't quite say this, but he says, but, but basically
between, read between the lines, what Alan Turing is really saying is, in practical cases, we can
answer the termination question. And then furthermore, in cases where we can't, we just return maybe,
what's the big deal? Right? Like, he's like, yeah, yeah, yeah, I proved the halting problem
undecidable. Get over it. Like, life moves on. Now we need to do practical stuff. We have computers.
Remember the war? Like, computers are cool. Let's, let's, let's, you know, let's do good things here.
And so to think about this, think about like British Airways, right? On time arrival is not
guaranteed. But, and I know you're probably all winging about British Airways right now, but
they're pretty good. Like you do often arrive most of the time, right? You arrive, you arrive,
you get on time arrival often enough that you think, I'll fly again. So, so, so they're, they're
not horrible. So the real, the real thing that they need to do is just to make on time arrival
frequent enough to make the airline useful to their customers. And it's the same with, with
termination prover. So if you're building a tool to analyze termination of program, so long as the
tool answers often enough with the right answer, then, then you're going to use it even if you're,
even if you know from time to time, it's not, it's not going to, it's not, it's not going to give you,
it's, it's, it's not going to be able to answer it. And, but, you know, the answers need to be
correct. Yes or the, yes, no answers need to be correct. Okay. So in 2004, what, what Andreas
and Andre and I, oh, sorry, I want to say something else. This paper on the left, the Turing's famous
paper has kind of been a buzzkill in, in the, in the IT industry. It's, people do not, what's the,
the thing you do in improv, you don't say no, you say yes and right. So there's a whole lot of
people who didn't study improv apparently in the IT industry. And so if ever you have some idea,
like, oh, I know we could do X, Y and Z, someone's going to be like, that's the whole thing problem,
you can't do that. And oh, I feel shame. I'm sorry, I suggested it. Let's not solve the problem at all.
Sorry. And that's, that happens a lot. I mean, I've seen that personally a bunch of times that you
hear that a lot. So this is like the most abused theoretical result in computer science that you,
because it's the halting problem, don't even try, you know, like life is too hard.
But very, very, very few people in 2004 thought it was, it was practical, even in my own field.
Like, you would talk, you would talk to people on my own field. The vast majority of people would
be like, but it's undecidable. But it's like, yeah, but so is the state space reachability problem
for infinite state systems. But they did, oh, yeah, I forgot about that. So, but, but with,
with the exception of some brave souls. So there were a few brave souls that were, that were trying
to solve this problem. But the problem for them is that their tools all solved this only for
little tiny programs, like little eight line programs, seven line programs. So they, and they
didn't have sort of any of the actual features you'd see in real programs like pointers and
concurrency or any of that. So they were fun. They're super fun, but they weren't actually going
to solve anything. And so that's, that's where Terminator steps in. So this is a tool that Andre
and Andreas and I wrote. And by the way, if you're Cambridge people, do you know this ride?
Have you seen this? I don't know if they have this anymore. So this is at least when I lived here
in the mid summer, common every summer, they would truck in these rides, right? And so then this was
one of the rides. So I was looking through my photos for this talk, and there's so many photos of
me in front of the Terminator ride because I did Terminator. Okay, so, so what we did is we,
as we looked at this, the Turing paper, and had a good read, right? So what we realized was is that,
hey, there's actually two parts. And I'm going to tell you about that. So there's two parts to
solve. And you can still solve them with independent bits. And then, and then, and then you're done.
So now I've put up a paper, I put up three paragraphs from a paper that's 74 years old
that's referring to a figure that's not included in the screenshot. So we're not going to make it
very far through this paragraph clearly. And it's written in language no one would know. But I just
draw your attention to the first line and move over here so I can see it. In order to assist the
checker, the checker is the person doing the proof or the tool. The programmer should make assertions
about the various states that the machine, that's the program, can reach. And the reach is a really
interesting bit. So, so imagine that these states are unreachable. Imagine these states are reachable,
but it turns out there's no path over here. And here's a little infinite loop. Here's a what is
that six states that could be repeated forever over and over and over again. So imagine this is
my iPhone, right? So I have six configurations of my iPhone and they're just going around and around
between those configurations. But it doesn't matter because it's unreachable. So there's tons of
termination bugs in your phone, tons of termination bugs in your computer that are never going to
be triggered. You're never actually going to experience them because they're unreachable.
And that first three paragraphs is all about that. It's just about reachability.
So, yeah, kind of, I think I'm saying that. So, so we were like, okay,
turns out I worked on reachability. So we know how to do this, right? So let's, let's,
so what, what, what, why was I working on reachability? So now we're going to take a little,
a little psych, we're going to move over to Seattle for a few moments. So it turned out in 2003
that 85% of crashes in Windows XP were due to device drivers.
And that was a big business problem for, for Microsoft at the time. So what we built over in
Seattle area was a real world automated reasoning tool called static driver verifier in the research
community. It was called SLAM, but for device driver writers, they knew it as static driver
verifier. And what it was designed to do was to show error states reachable or unreachable.
And so if this is the blue screen of death, you actually, you actually referred to that.
This is the new blue screen of death, by the way, which you don't see very often these days.
But this is what you get when your machine is like, sorry,
lost all your data too bad, it sucks to be you. And this is what you would see on a Mac. And this
is what you would see on a really old Mac. And so the question is, and I've sort of put this on
purpose, is this line there or not? And remember, these states, these state spaces are typically
infinite. So you can't just walk them explicitly, you have to like, you have to abstract infinite
sets, finite sets and do all this all kinds of trickery. But yes, we're trying to figure out,
are things unreachable or are they reachable? And so there was a whole bunch of work that we did
over in Seattle area, and I was involved in that. And Andrew Herbert, who's in the room here,
I was visiting Cambridge, and he was like, why don't you leave Seattle and come to Cambridge?
The environment is great here, and you'll have a good time. I'm like, great, let's do it. So
with eight weeks difference between that conversation, five weeks difference, my wife says,
between that conversation and moving, I came, joined Microsoft Research, started chatting with
these guys and said, let's work on the termination proving. So the point I'm making is that this
problem was actually already pretty much solved. So it's just a question of reachability. So the
red part is actually about, okay, now we've found a reachable state, how do we know that that reachable
state doesn't lead to a non-termination execution? And all the green bit is just about how do you
how do you show that states are unreachable? Okay, so let's look at this one. This one's
fascinating. We're going to spend a little more time with this one. Finally, the checker
has to verify that the process comes to an end. That just, I'm translating, that just means we're
okay, now we're going to prove termination. Again, he, you know, he or she should be assisted by the
programmer giving a further definite assertion to be verified. So the point that he went,
this he really in our, in our lingo today would be the prover, the tool. And so this may take the
form of a quantity which is asserted to decrease continuously and vanish. I'm going to translate
all this, by the way, don't panic and vanish when the machine stops to the, to the pure mathematician
is natural to give an ordinal number. Don't, doesn't matter what that is. If you don't know,
doesn't matter. I love this line. A less-hybrid form of the same thing would be 2 to the 80
times n minus r plus 2 to the 40 times r minus, what is that, s plus k. Pretty cool, huh? Let me
translate that. Can we find a function? I'll call it a, based on the, on the state, based on the
variables of the, of the state, that will choose only positive, but also decreasing numbers. Okay.
So imagine, let's look at my phone. I took a screenshot when I was writing this talk. I had
seven Slack messages at the time, unread. So maybe the function is the number of Slack messages.
One possible, it's not going to work very well, but another one, maybe be the amount of free space
left on my phone. That's a little more reasonable. And then imagine we took a,
a transition from this state to this state. I don't know, like, who knows what. Internally,
you can't see it, but it made some transition. Maybe the amount of space,
a free space has decreased, probably quite likely, right? Because of it, because the phone's
actually doing little logs and all kinds of, like, it's always sort of using a little bit of
more and more and more disk space, not disk, but you see what I mean. Whereas the number
of Slack messages, well, we can see it stayed the same. So I had seven before, seven before, seven
now. So that's not a good one. So this number didn't go down. So remember that the point,
the point we're trying to make is we want to find a function, a function, some function f,
that on every, that I'll always say this in a moment, that it finds decreasing but positive
numbers. And so what do we, what would we do with that? Oh, I think maybe, okay. And yeah. So
here, for example, let's write a little function for this guy.
Maybe what we do is we say, oh, let's do in minus the location. So we were at, in this value of 20,
location is one. So maybe it's in minus x is 19. So it's just this number minus that number.
And then the next one is 18 because I've now subtracted two. Okay. So that's a positive
number and it's gone down. So that's possible. I mean, it's not going to work because no one
knows that the program terminates, but that would be a plausible starting point as you begin your
journey into this world. So the thing that we need to hold is whenever we take a transition
from one state to another state or configuration to another configuration, and we have that function
f and we map, the greater than needs to hold. So if you, if you, if you say the pre-state is s,
and then we apply f to s, and then we say the post-state is t, and we apply f to t, you need
greater than to hold. And that's a condition that's required. So the idea of how to prove
termination, and this is Turing's idea is find a function, think about it for a bit. Then if this
condition holds for all possible transitions of your system, this holds, you're done. You've
now proved termination. Okay. Right. So if you turn your head, you can see it. 19 is greater than 18.
So now, why does this hold? So imagine a non-terminating execution. Again, this is infinite,
so I can't, I can't show it to you on the screen, but here's the first few states.
Now just begin applying this function. Oh, and by the way, we have the function. I already said that.
And this condition holds. Now let's just begin applying it. And I'm making these numbers up,
but imagine the first one's 30. We've got to choose 29 after that because it has to go down.
27, 25, et cetera, et cetera, et cetera. We're going to run out of room. It has to be positive also.
So now we're out of space. So I said, imagine we have an infinite execution, but we have
a function f that's positive and decreasing. It turns out you can't have both. Right?
Right. I'm too far. You can't have both. You can't, you can't have a non-terminating execution
and this function. You can only have one of the other, i.e., if you want to prove termination,
find one of these, and you'll know that you don't have a non-terminating execution.
Or if you have a non-terminating execution, you can't have one of these. It's a, it's a, it's a,
there doesn't exist. If the program doesn't terminate, there cannot exist a function that
meets those conditions. And so the trick is to find the f, right? And so Turing found the posh
one and then he found the less posh one. Okay. I've kind of said already that. So now, so now
the thing that we wanted to do was to automate this. And so, so consider any reachable state
and, you know, maybe those states in my phone and imagine we found an f, then it turns out it's
super hard to find a single f. Like, like, and this is kind of why these tools from before weren't
working, because they were trying to find single s. And why is it hard? Because you're going to find
an f that's going to pick out all these values. I'm naming these values. So a needs to be less,
greater than b, a needs to be greater than c, c needs to be greater than d, d needs to be greater
than f and e, and f and e need, both need to be greater than g. You're, you're like solving all
these things all at once. And if you have a 10 million line program, it's just, it's going to
be impossible. You're not going to be able to do it. And so, so what we figured out was that you
could use these tools for finding proofs of toy programs, and you could find multiple ranking
functions. It's going to turn out there's one thing we're going to need to do and Ramsey's
going to solve it for us. That's going to be the punchline Ramsey's going to solve a course.
So imagine we could find one termination argument of g for this transition, and another termination
argument for here. We can, we can color them. So here's, I'm just going to make my life a
little bit easier. So notice, I notice I've colored this transition green because I have the green
function. And here I've, I've colored it red because I have the red function. Okay. I'm preparing
for Ramsey. The problem right now is that this isn't a valid termination argument. And the reason
is is because I have two functions, you could imagine them alternating, and there's just no
reason for the numbers to go down. So if I have two termination arguments, it's not valid because I
just alternate them. There's no reason I know I can't know I can't alternate them. So, so I haven't,
I haven't proved termination. But what we can do is we can borrow some techniques from these papers,
and now I'm going to do a construction and just believe me. Okay. Because we don't want this to
turn into a 30 minute graph theory course. Okay. There's this idea of transitive closure. And it's
really neat. And the graphs are really amazingly, they have so many edges, it's unbelievable, but
it's a construction, you can do it. And, and, and now what we can do is we can, and this is, and,
and imagine this is infinite because we're saying, oh, maybe this program doesn't terminate.
So now what we can do is we can take the monochromatic Ramsey subgraph.
For those of you who signed up for this talk, this is kind of the worst slide, right? Sorry,
that who don't know, who don't know math and logic and that kind of thing. So we can take
the monochromatic Ramsey, say that when you go home, right? You, you, how was the, hey, honey,
how was the talk is like monochromatic subgraphs. And, and, and now we can pull this trick again.
So we'll, we'll, we'll do like trying, we'll say, okay, imagine non non terminating it,
non terminating execution, but from the monochromatic subgraph. So it's only the green edges. So those
were only the edges where we had one function. And we did this, we did this construction,
and you're just going to have to believe me that sort of added a bunch of more
transitions. And this is, this is a valuable thing to do. And then, you know, ask me later,
and drinks, and I'll explain it to you more, the more you get drinks into me, the more I'll explain
it to you. And, and again, we, now we get to say, oh, look, you know, now it's only one function.
So we know what's going down. So voila, right? We've, we've now, we, we, we have this thing
that Turing was saying, we need, we need to find a quantity, which is asserted to decrease
continuously and will vanish when the machine machine stops. And we did it. And it was Ramsey's
theorem that helped us do it. So the payload is the summary is Ramsey's theorem lets us use
many simple functions, rather than a, rather than a single Turing style complex one.
Okay, how am I doing for time, by the way? Does anyone keep track? Okay, 15 more minutes,
but I might run long, I don't know, there was a Q&A afterwards, so I might eat into that.
Okay, so this, that's the basis of Terminator. So there was this, this paper that said,
hey, everyone, we have a termination prover that works for actual programs, like programs that
people care about, device drivers. And it worked really nicely. So it, so it, so here, you know,
here, remember, I showed you this code a little bit earlier, this is a device driver code, it's
actually from the mouse, it's a piece of the mouse device driver. And, you know, it has bugs. So
one of the developers agreed, yeah, that's a bug. And then we, and then we had a bunch of
papers, what were these papers doing? A lot of these papers were chipping away at this maybe
problem, or the, the Terminator itself is running forever problem. So we were able to prove some
device drivers terminating. We also found some real bugs, but then there was a whole bunch of
maybes and spinning forever. And then these papers kind of chipped away at them. Other papers
generalized Terminator. So for example, these folks together with me generalized it. So you
really could say anything that had the word eventually, like, you know, when we could ask
when, whenever this program opens a file, does it eventually close it? And that's eventually,
right? So things like that. Another thing we did, so it turns out that a lot of programs
are what we call concurrent. So you might have two copies of the program, both operating over
that variable in at the same time. And proving those programs terminating is harder. So it turns
out device drivers kind of a very special flavor, and we were able to do something. But then the
question is, can we generalize to more programs? And the answer was yes. So then Jasmine, who's in
the audience, made the following reference. Hey, Byron, she worked with me, well, she worked in
Microsoft Research. And then after this statement, she worked with me. So Terminator looks like
something we need in the analysis of biological models. So that was this skin cancer comment
I mentioned. So then a collective of us, including a designer from the Royal College of Arts,
essentially an anthropologist, a couple computer scientists, and Jasmine, and others who are
biologists. The idea here is that you have your skin cells, and you have genes, and there's like
the genes are talking to the other neighbor genes. And they're all as a family trying to say, hey,
we should only have, you know, what is it, five layers of skin, six layers, six, six layers,
I don't remember. But like, let's keep it that number. Let's not have a whole bunch more because
that's bad for our bodies. And let's not have a whole bunch less. That's also a bad news for us.
And so this paper allowed us to analyze that. So we were able to build models of various kinds
of disease, and then answer questions like, hey, if we modified the model, would you get
homeostasis? And the one really neat thing about it is this tool was designed such that
biologists can use it, and it had a notation very similar to what they use in their day-to-day
life. And so there's, you can use the tool still today, it's called Biomodel Analyzer.
And there's been some amazing results. And Jasmine in her lab down at UCL now has gone on to do
amazing results. And many of them found and perked with the use of this tool. Another thing I did
is I got really tired of using the kind of formulas that we were writing that came up quite a bit.
And I found that notation kind of limiting. So Talba Auerbach, who's a friend and an artist,
began working with me on new symbols. So here's Talba and my Cambridge
Microsoft Research Office trying to invent new mathematical symbols. And if you know LaTeXA,
we ended, David Reidenfurch, who is the guy in the photo, implemented these new symbols in
MetaFont. And we came up with something I like quite a bit. So it's this operation. So this is
the lifting of a relation, happens to be greater than, with respect to math, allowed us to talk
about this in a much nicer way. So this is the thing you've seen before. And now I can say this
really nicely. I can say the transition relation, this is that the graph, is a subrelation of the
lifting of greater than with respect to f. And so this showed up a lot in talks and so on at the
time. And so if you don't know math and logic, just close your eyes for a second. But if you do,
then I'm going to explain what the meaning of this is. So the lifting of the relation
with respect to f is the set of pairs of states, s and t, such that
if you apply f to s and apply f to t, greater than holds, so the relation holds.
So she's a really famous artist and there's always articles about her. But amazingly,
Terminator was in Vogue magazine. My greatest moment. Okay. And then sort of one final point
I wanted to make. So it turns out that the layout of data structures is just unbelievably crucial
when trying to prove termination of realistic programs. And so here is a data structure of
a kind of typical data structure you would see in a device driver. And I'm just going to kind of
walk you through this a little bit to get the idea. So device driver might come here and then
it come here. And now it's sort of walking this data structure. It's called the list, right? So
it's going, there's these arrows which saying it's a link to the next and the next and the next.
Here it's going back to where it was before. And if the device driver somehow gets confused
and doesn't realize it's already seen this, we're in a world of trouble. Because now what it's going
to do is it's going to just spin on this thing forever. And so what's the termination argument?
So here I've put a little picture of a post-it note in an effort to say, oh yeah, remember this.
Okay. So imagine we've been here and we've left a post-it note saying remember this,
don't forget this. And we've gone here and we've gone here and we've gone here.
What's the termination argument? Well, there's actually two list segments.
There's the part we haven't viewed before. And there's the part that we have viewed before.
And what's the size of this? Well, it's two nodes. And the size we haven't seen yet is two nodes.
And so when we go another link, now it's three to one. And so this is where we're going to get
the termination argument, right? We can take a transition from some state to some other state
and look, it went from two to one. And that's going to be the function we're typically going to use
is the number of links back to the node that's the head of the list. So there you go. So we're
mapping. And so the termination arguments are kind of like that. So this paper sort of recognizes
this is with Peter Ahern and his postdoc and his PhD student, for example, Josh Burdine and myself.
And then after that, we're like, hey, let's keep working together. This is pretty cool.
So then I joined this thing with gang, I guess, called the East London Massive,
that that was a collective of people interested in reasoning about data structures. And so Josh,
who was his PhD student and postdoc and Samin, who was his ex PhD, had graduated as a PhD student
and I here ended up building this tool called Slayer, which reasoned about shapes on behalf
of the termination prefer. So we'd run this ahead of time. And that's that that that was very, very
powerful. And it was also very powerful because it turns out that many of these 85% of crashes were
actually shape oriented. The device driver would come in, it would modify that list,
not leave it in a good state. And then the device driver would come back in,
start walking that list, it wouldn't be in a good state. And then horrible things would happen.
And so it turned out this is a whole other research area basically driven by
the termination proving a whole bunch of different papers, some of them related to termination,
some of them not. But that's, you know, invite me back. I'll tell you all about that. But here's
an amazing thing that happened. So, so, so, so be who's in the audience. And I'm also married to
for past 27 years, or I can't remember now, sorry. And Peter, that's this chap, they started a company
that made a Slayer like tool. And, and they sold it to Facebook. And you can still use it today.
So it's called FB infer now, that you can go to this FB infer website and find out how to use it.
And, and, and that really got me to thinking, like, maybe it's time to leave the research lab
and go take things into product really, really into production at a level that that we had,
that we hadn't seen before. So, so now that we sort of realize that almost any mathematical
statement, you know, maybe as we get closer and closer and closer to that, this becomes more and
more commercially relevant. And so that that's kind of where I wanted to take things. So this
was the old Terminator website. Terminator is now dead. This website's gone. You have to go to the
way back machine to find it. But what it did was pretty interesting. It inspired a new class of
tools. There's a whole bunch of termination provers now that you could use. There's whole sessions
at conferences on termination. There's a pretty healthy international termination prover competition.
Everyone can, like a lot of people know that termination is impossible, but now it's a,
it's a, it's a much, it's a much more nuanced situation, right? Now, most people in my field
at least know that termination is possible, but you can prove termination programs and sort of
a practical thing that can be done. But, but also that I think that we made pretty mean,
I mean, this, this vogue thing is obviously a joke. I mean, I mean, it was real, but obviously that
made no material impact on the IT community. But, but, but I think that the articles and wired
and economists and financial times and science did and the, and the, and the, this great sin in the
Terminator article of the scientific American. So I think that these helped the IT community
understand that termination isn't like a death sentence. Okay. So that's, that's the end of my
Cambridge story. As I said, yeah, so I mean, I said goodbye to MSR. I've gone on to Amazon.
That's three talks. I can tell you all about that. And I'll tell you about that at drinks,
if you want to know more about it, but I've tried not, I've tried not to talk about the
Amazon work because that's all I do all these days. So I just, I thought it'd be fun to come here
and tell you this Ramsey Turing story and, and, and I hope you had fun. So with that, I'll
gavel this to a close and I'm happy to take questions.
Well, thank you for that wonderful talk. Let's have some questions. And we have a microphone
to go around. So first question. Byron, great talk, fantastic talk. Maybe it's a relief you
didn't mention artificial intelligence. So much in the, the whole in both these days.
But I suppose I would have asked about that. I mean, obviously Turing was famous for that.
But I mean, how do you see maybe today's developments in artificial intelligence
having an impact on the kind of, you know, automated reasoning that you're talking about?
Yeah, I'm, I'm very excited about so the in, in the auto, in the automated reasoning,
sometimes it's a really terrible name for it because it's rather not a automated trade.
Like there's, there's a lot of tools, there's tools like Lean, Paul Light, Isabelle,
you know, I can name a whole bunch of tools and they require a human to sit there and poke
it to make it do the right thing. You ultimately get a proof that it's the checks, the checking
is automating, but the finding is not. And those tools are rather more powerful in theory than
the fully automated tools because the automated tools, because the problem is undecidable, cut a
bunch of corners about what they can prove. So they can prove a much more limited set of things,
whereas a super genius sitting together with one of these tools that are not automated,
as automated can do incredible things. So all of your proofs of like the four color theorem,
the kelp work injector, you know, that have been done with, with, with these tools have,
have required a human. And so what we're seeing right now is that the generative AI
chat GPT style tools are able to do these. So that's a really amazing time. So what they can,
because they're training on all the past proofs and all the tools and these tools are super hard
to use, but guess what? All the people who were making them able to use wrote papers about it
and provided scripts and the scripts are on GitHub and the tools have trained on that. So now
they're able to say, you know, like, hey, you know, find me a proof and hallway of XYZ and they're
not terrible. So I, so I think that's a really amazing thing. So making the tools easier. The
other, the observation that I'll just sort of put on the table there is that when
LLM's lie to you, that's incorrectness. And guess what we know how to do, right? There's,
there's, there's statements that are incorrect and, and, and, and, you know, it's not escaped the
notice of the community that that's something we could potentially solve. So, but that's, that's,
you know, that's a whole new area.
There's a question there.
Any, any thoughts on why you explained how you took the Frank, Frank Ramsey staff and
the Turing staff and you put it together and you move forward for a subset of the problems?
Any thoughts why Turing didn't do that himself, given that, presumably they, they knew each other
pretty well and charged each other intellectually? Yeah, so, so as, so the part where I said,
believe me, this graph, you know, we can do this thing. And then the graph got really colorful.
That would be very hard to do manually. So the paper would have been pages and pages and pages
of calculations, which computers are really good at and humans are horrible at. So I think what,
what, so the single ranking function, you just need a really smart and insightful person to be
like, Oh, I got it. I was in the shower and I realized this is it where, but, but in terms of
automation, it's really hard to know even where to start. Whereas this, this other approach is much
more automatable. So I think that's probably, probably the reason we have another question there.
Thank you for the talk. So for all those tools for automated reasoning, I'm guessing those
tools are not formally verified. My question is, do you think there's any value in actually
formally verifying their correctness? Or do you think there's, it's just too much work to do so?
There are some tools that are formally verified. And what a lot of the tools do today is produce
a proof that can be audited independently. So for example, a lot, a lot of these tools boil down
to a class of tools called SAT or SMT solvers, propositional satisfiability, or satisfiability
of propositional logic together with other theories like arithmetic, you name it, strings,
arrays, unintroverted functions. And the solvers today can produce proofs that can be audited
independently by a tool like Halllight, Lean, et cetera. And let's, let's say that we believe
Halllight. It's very small, kind of eyes have looked at it and they're like, okay,
we're going to believe that. Then these tools that are, that are doing really pretty harrowing
high performance computing to try and find the proofs, ultimately produce a proof that can
be checked with a simple thing. That's pretty believable. So yeah, so that's something that
we've pushed on really, and I don't want to talk about Amazon too much today because it's like,
that's all I ever do nowadays. But at Amazon, that's something we've pushed on very, very hard.
It's actually producing auditable proofs as opposed to just some magic tool that some
smart person wrote and you just have to believe it. We have a question over here.
So it's a two-part question. You mentioned British Airways and you said that could they arrive
on time enough or frequently enough to be useful? You didn't say anything about them arriving with
a luggage. I don't suppose there's any kind of mathematics. I'm not going to take that one.
But the second thing was to think about classes of mathematical problems that may not be
where you can anticipate or hypothesize that a solution or an algorithm could exist.
So the example I was thinking of while you were talking was the traveling salesman
where, and I imagine that Amazon must have thought about this for a while, getting the
in the course you're trying to deliver, where the presumption is that an algorithm could be
found, but that actually proving it within a finite time is, or at least up to now,
hasn't been possible, unless somebody's solved it and I'm unaware of it.
Is there an extension from the kind of approach that you were taking there to prove
termination to actually tackling those class problems, maybe try to come up with a definitive
yes, there is definitely, we can now state that there will be a finite algorithm,
even if we can't actually find it within a finite time, or even to help us to find it.
Oh yeah, I probably not quite going to answer your question, but a couple of thoughts. One of
the interesting things about Ramsey's theorem is it doesn't, it says you have this
arrow and graph and there exists a monochromatic subgraph, but it doesn't show it to you, so
it's not constructive. And so if you use some of these techniques, you can't actually see
the termination argument, you just know it exists. But I think your question was rooted more in a
little bit about can we synthesize or convince ourselves that algorithms exist when we don't
know what this specific algorithm is there. We surmise they do, but we can't definitively,
or at least we couldn't definitively prove it. Yes, so I think so, I mean that like,
if goal box conjecture is proved likely, it's via these methods where you don't,
like the proof is kind of non-constructive in some sense. I imagine so often non-constructive
proofs are easier than constructive proofs. So yeah, so I think that the harder part will
actually be to find the witness. We have another question in the back there. So,
Byron, I'm sure you're aware there were two schools of computer science in Cambridge in the
post-war years, cheering because there's a mathematical sophistication, mostly programmed
in binary on the Manchester Malt one and the pilot ace, because he could use his mathematical
sophistication to kind of reason about the algorithms and convince himself they were correct
so the fact the notation was a very unproductive way of writing software didn't bother him.
The engineering philosophy that kind of came from people like Wilkes and
another college in Cambridge just down the road was give the users a symbolic notation to seduce
them into the idea that programming actually is really very easy and you could just write stuff
and it would be fine. Kind of the symbolic world of one because we have programming languages and
the effort in programming languages has been to design languages in which you can't make mistakes
yet you can still write useful stuff. So my kind of question is now we have the kind of tools you're
talking about do we need to continue investing in improving programming languages or can we just use
scruffy languages and rely on the tools like yours to prove our software is correct.
And I've got all kind of programming languages scruffy but I've never quite managed to find the
perfect one. A couple of observations there so one observation is I think Rust is this incredible
language and so I spent a lot of time trying to get people working on very low level systems
code to adopt tools that we had that could prove memory safety of those programs and it was really
tough letting and then one day Rust comes along and they're all like without me even prompting them
like oh I started learning Rust and Rust has a very sophisticated proof prover in it
but they came for the speed so because Rust could be faster they're like I'll learn these tools but
also it was super well done that the developers of Rust talk about ergonomics like the ergonomics
of developing and Rust is really important to them and I think that's been very powerful so one
could prove you know just like there's turning completeness of you can express all programs
in Rust or C or Askel or Prolog there's there's sort of you know you can prove the same things in
a lot of these systems but I think that Rust's ergonomics are much nicer than some of the tools
like in C where you then try and prove memory safety. That's my first observation. Second
observation is there's this fascinating blog post by Ranjit Jala where he shows that you can take
a program in an imperative language and prove it using horror triple style reasoning and you have
quite sorry everyone but just bear with me for a second. You have horror triples of quantifiers
and and and then you just slam the you you apply these SMT solvers with
quantifier support and it's it's so hard and it's so compute expensive or you could write
the same program in liquid Haskell and there's no quantifiers you can prove the same property
and it's because Hindley Milner is somehow resolving the quantifiers for you and it's
very very low power very easy very predictable you don't make a change to your code over here
and suddenly the proof stops going through so so I think that there's a lot to be said
for the ergonomics of the language and the IDE and the experience particularly developing in cloud
you know I'm talking about Amazon but if you're developing programs in cloud the ergonomics of
how do you develop that and understand the program such that you don't have to like
SSH over to some other machine to find out what the machine that state it's in I think are very
important so so I think that automated reasoning programming languages and the sort of software
development experience go really hand in hand and there's some very powerful experiences we can
have now that we couldn't have before. Great, other questions? Okay I think it's time to thank
Byron for a wonderful talk and I believe though there are going to be refreshments out in the
chatroom room again okay thank you all
