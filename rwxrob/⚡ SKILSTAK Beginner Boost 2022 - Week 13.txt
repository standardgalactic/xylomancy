Start recording. All right, we're recording for the beginner boost today. As you can tell,
I am very casual today. I am supposed to clean my room and I've been playing all weekend and
went out and had sushi and watched jazz last night and before that went to the art show and
stuff. So that's all in the vods. What are we doing today though? What are you here? You're here
because you want to know how to configure your .files and that is what we're going to do. Week
13, what an appropriate number to do your Linux .files. And so we're going to talk about, well,
what is a .file? Where does the name come from? Which ones do I care about? How many of them are
there? What's the standard? And this is an essential part of understanding Linux or Unix. The
Unix standard does sometimes apply, but not always. And so we're going to go over all that. So the
first thing I'm going to do, and we already did this like four or five weeks ago, right? We went
through kind of like a speed pace. We went through all the configuration files just to kind of talk
about the file system. We were talking about the organization of the overall file system of Linux
and we really don't have, other than that, Davo, we kind of went through that. We really don't want
to spend a lot of time explaining to you what every directory in all of Linux is for. That wouldn't
be a boost. That would be a full, whatever, comprehensive coverage of the whole thing.
So we're not going to do that, but we are going to talk about everything in your home directory,
and that's super important. We did finish bash coding scripting yesterday, or last, not yesterday,
but last time. So, and that was a prerequisite. You really can't do any configuration until you
know how to write the code. So one of the best ways to get practice with with bash is to actually
write the bash configuration file, which is also written in bash. And so we're going to jump right
in and talk about all that. We're going to go for four hours today, so we'll be taking breaks as we
go. But beyond bash, so let's talk about the specific files we're going to cover. Okay, so
we're going to say we're going to do shell bash shell configuration. And we will talk about how
to configure other shells a little bit. Just so you can know if you like around a Mac, you can
see stuff that's different, you know why, which defaults to Z shell. We've already, you know,
talked about that. We've already bashed Z shell enough. And we already know how to use Vim. We
did that. We covered that. You all should know that. So we're going to talk about Vim configuration.
And we're going to talk about, actually, we're going to do x slash vi slash Vim configuration. We
are not going to do anything besides that. We are going to do Tmux configuration. So we covered
Tmux utilization. But we didn't cover Tmux configuration very much. And so these are the
things that kind of go together. Bash vi Tmux. And we will configure a few other things. So like
your scripts directory, right? And so you can start writing scripts and, you know, use them and
thing. And what else we need to do? We probably will do links and or W3M. So you can use those.
And we already talked about that, but we're going to talk about after that. And I mean,
once you have those things, you're pretty much going to have everything on the terminal that you
need. And the real important ones are these three, the bash vi and Tmux, because those are going to
give you files that you can transfer as a single file, each one a single file into any system that
you're ever using. So if you get on a container, and I'll show you how to do that using SSH,
we did do some SSH configurations. So we should probably put that in there.
I mean, I think you already have that, but we should refer to that. So it's really important
that we talk about that one for security purposes. We're not going to be doing GPG today. Okay.
I mean, I don't, I don't know, maybe we should do GPG today. Because we have to do GitHub
eventually. You know what, we'll save GPG from when we do GitHub, which will probably be next week.
But I would, I really want to get through all this today if we can, because I just want all the
configuration settings in here kind of kind of talked about in one day. And then you all can
go use it and configure your own VM. Let me just remind you that the VM that I'm using that has
all of my own configurations in it that we're going to be going over today is in GitHub.com
slash rvx-rob slash boost VM. And you can install VMware Player or VMware Workstation
Pro if you want to buy it. And you can put that VM that I'm using, you can use this exact same one.
We've covered that already in earlier days of the boost. So, but that's, I'm saying that because
you're going to want to know where to get all that stuff. And that's where it's at. So again,
these are the things like when I, when I install a system, they're the first things I put on so
that everything just works, right? And I'm, we should probably talk about, I mean, there's,
we're not going to talk about it. I want to talk about Git, I want to talk about GitHub,
I want to talk about a bunch of us, but we're going to save those conversations for when we
talk about those tools. I have a question for the, for the group here. Should we cover,
and this is my style, I would do this if I were teaching in person, should we cover
Git and GitHub before we do go programming or after?
Because if we do it before, then we can use it to do our commits to our go code as we are
working through it. If we do it after, then we can kind of retroactively do it, but we,
there's a, there's a chance we're going to lose our, our code along the way.
I think we should probably do it before, but it's so, it's not fun. People don't like it. They,
you know, they just want to get coding, right? Before would be helpful for go commits, you think
before? All right. Well, we'll go ahead and, and, and do it before. I think you're right. I think
we do need to do it before. All right. So that's at least, you know, another week of stuff that
we have to do before. It's definitely not fun though. And that's why I don't, I mean, you know,
I, I'm, I'm going to tell you right now, being a boost in all, we are not going to do, yeah,
I'll absolutely save your butt. Oh my God, it saved me so many times. All right. So we will do that
next week. All right. So, so next week, we'll put that down here. Next week,
we're going to do, I want to put these all here. We're going to do, that means we're going to have
to do GPG. Let's actually save SSH for that same day. And that'll get us through this nice and fun.
We'll have a fun day today. And then we'll do SSH and GPG config, right. And then we'll do Git.
We'll do the GH tool. And we'll do GitHub. And we'll talk about, we'll talk about all that stuff.
That, that's going to take a full, you know, four hour day all by itself.
So that, I think that's good. Let's do that. And then, and then the week after that,
I think we're pretty set to start coding after that and go. And again, the whole, this is very
loosey-goosey because I like to work with the group and see where they, where they want to be
and what they want to do. I've changed entire classes from, from Java to Go on the whims of the
people in the class at six weeks to set up Emacs. No, we're not, we're not touching Emacs. If you
want to touch Emacs or VS Code or any of that, you're going to have to learn that on your own.
Because I mean, you know, that's not hard to pick up. None of this is really hard to pick
up if you spend time with it. But, but, but yeah. All right. So that's a, that's kind of our goal
for today. I'm going to put this as the read me. And we're talking about configuration today,
not necessarily usage, but as we go, we're going to cover that as well. All right. So the first
file that we need to talk about is the bash or C file. So let's talk about the home directory.
So let's CD enter, which takes you into your home directory. And what does the tilde mean?
It's just a little bit of a review. What does the tilde mean? The tilde means you're in your home
directory, right? In the review of the prompt, this is the active username. This is the machine I'm on.
This stuff is all represented in an environment variable called PS, is it PS or PS1? There's
my PS1. This tells me everything. We're going to go through these really quickly. As usual, if you
want a full explanation of bash, the best place to go is the man bash. And I strongly, strongly
encourage everybody listening to this, including the veterans to go through all of the bash man page
beginning to end at least once, right? Because there's stuff in there that you may not even
know exists. Like, for example, completion, you can do completion with one command instead of
writing a separate shell script. And people don't know this because they haven't read it.
So it's not covered in any books or anything. So there you go. You can go look at that and
know where to go to look for stuff. All right. So I'm in my home directory. So if I type tree,
you're going to get a lot of stuff. I don't want you to see all of that stuff. That's like all my
get commits and stuff. And as I mean, let's just do find dot depth one. Oh, whoops.
Pass must be presided. Oh,
by what? Did I do that right? Is it depth? I thought it was depth.
I have to look at my thing. Do you guys know about this? So if you don't want to list everything,
hey, thank you for the fall. I don't remember my depth command. I gotta go look at it.
Max depth. Yeah, max depth, I think it is. Max depth one. Yeah. All right. So this tells you
everything that's in the current directory. Okay, so let's just do directories though.
So let's do find dash type T D. Find is your friend, my friends.
Warning, you have a global max to find the arguments type. Vocable options are not
positional. Max depth effects test specific specified before it as well. Okay. All right.
Well, maybe I should do it like this instead. That make the warning go away. Okay. So here's
everything in there. If we do a max depth of two, you can see like two layers.
So, I mean, there's lots of stuff in here. And we're going to talk about what's in here. But
the reason it's called dot files is so we'll say covered covered.
Why are they called dot files?
Pipes. Yeah, we did that. We did pipes.
Yeah. We did pipes and filters and stuff. I'm pretty sure we did that, didn't we?
We did that last week. How to read, use reading. We did read IFS and all that stuff.
We didn't do different the pipe file type. We didn't do five files or anything.
So why are they called dot files? They're called off files because they're being with
dot. And what does a dot do? What is a dot use, use initial dot to hide a file or directory.
So that's why we use the dot to hide things. Okay. So, so normally when you're listening
in here, you don't see all that stuff, right? If you do want to see them, what do you use
ls-la to see all hidden, right? You could also use find. And I just did that, right? So you could
do ls-la. You see all your files there. And you see some of them are redirects. And we're going to
talk about that. And that's a way to manage your dot files. We're not going to, don't worry,
we'll get there. But just so you know, dot files means hidden, right? So that it's not shown,
it's not in your face all the time. ls-l will give you the long version, ls-a will give you just,
there's all the files. So there's lots of them there. And the colors represent different,
you know, whether they're a symbolic link or they're a directory or just a file.
I have to be careful here because, I mean, I haven't put anything in there that I need to be
careful of except for the SSH directory, which we'll talk about next week. But the thing to note
here is be careful who, you know, who you show your dot files to. It really depends on the dot
file. Most of the time it doesn't matter. And I, all of my dot files, by the way, if you want to see
any of mine, are in my dot directory, which is on GitHub. So you can go in there and you can study
it offline if you want to. And that includes my scripts and stuff like that. So, I mean, so
let's talk about how should I manage, manage my dot files. So there's lots of ways to do this.
I've seen streamers talk about tools that they install to help manage your dot files better
and everything. And I don't like any of those techniques. So my favorite technique is to
put your dot file into a Git repo, which we will do next week. Okay, we're going to create the
dot file directory today. And we're going to put our stuff in there. But, and we're going to symbolic
link it and all that. But we're not going to, you know, we're not, we're not going to make a
GitHub repo for yet, not this week. Okay. So see, see here, I have like all my dot files and you
can choose how you want to organize them. And we're going to go through all that right now.
All right. So, and I'm going to show you how I do it. But of course, you can do it however you
want. I've had, you know, there's streamers who take strong exception to the idea of writing your
own setup scripts to do your dot files. I'm like, why would you need a tool for that?
That's what shell scripting is for. So I want control of it. And so I do it that way.
I mean, any, there's a couple of things about the dot file organization that we need to cover
before we leave this. So let's talk about that. A standard, expected, right,
content, I guess, files and directories. And this is kind of going to be
I don't know how to do this. Let's make it its own section. Okay. So there.
So let's, let's just start, start right off the bat. I'm going to give you an overview and then
we'll go in and we'll start looking at them. Okay. So profile profile. What is profile?
Right. Profile is used. This is the boost. Yep. This is a boost episode, even though I'm being
chill. So, so boost, I'm actually live in case you're wondering. So profile is like
original login script. So what is the dot profile file? Let's see how they say it.
What is the stream title saying right now? Oh, yeah, let me change the stream title. I'm sorry.
Yeah, let me change it. You know what? I've gotten used to not doing that because
these days, I don't need to change the stream title because I'm just recording it. So thank
you for the reminder. We are week 13. Thank you for the reminder. Let me change it really quick.
We're still in just chatting too. We should go in software. We're in science and tech.
We're in science and tech. This isn't software. Linux. Yeah, done. How's that?
Sorry about that, everybody. As I said, I'm very important.
Well, instead of a dash A, for what? For listing? What are you talking about?
No, no, it's fine.
Does it? I mean, I've never used it. Is that a positive thing as well?
I mean, let's test it. This is why we have a team of people here watching me so we can check it.
Let's go to Busybox and see if it supports. Actually, that was the Alpine. Run
RM. We'll do whatever Alpine has. Alpine is a container that has a minimal
unit distribution in it. Okay, cool. Never use it. Not a thing that I ever use, really.
Let's see. Go back home. Nothing there. Interesting. Yeah, I don't know. I've never used it,
but yeah, it's cool. Sounds like a good option to use.
Okay, what is profile? So, profile in Linux is, I mean, when I list, I want to see everything.
So, it's probably why. The profile extension is used for files in the terminal programs.
Show profile goes by Linux and macOS terminal program. It contains definition for shell
environments such as environment variables. This is a horrible answer. And how do I open it?
No. So, I know what I want to say, but I want to see what other people are saying about it.
So, I'm going to go ahead and say it. So, the profile is what controls you logging in.
Right? It's for logging in. And there's something we probably need to talk about here really quick.
So, there is a difference between login and the login, let's see, login shell.
All right. So, what is the login shell? We're going to have to talk about this. So,
there are login slash interactive, right? Now, does anybody want to take a stab at talking
about the difference here? In order, we have the knowledge to cover this, because we've already
talked about sub-shells and sub-process. Anybody remember what those are? So, this is going to
be important because it's the first thing in the BashRC file when we get into it. So, when I run
a shell, so when I start a new Bash program, it runs a new interactive shell, because it knows
it's got a terminal and everything, right? But when I run something in the background,
and we haven't talked about backgrounding processes or anything like that yet in Bash,
and we probably should have talked about that, I don't know if that's a boost topic or not.
All right. Suffice it to say that when you, like, run ps3, you might have to install it,
right? If you have to sudo app, install ps3, right? So, this shows you everything that's
running on the machine. As you can see, we've got systemd that's running at the top,
and then we have all the programs that run under that. These programs are all executed
using a syscall called exec, and ultimately, they create this parent-child hierarchy relationship,
right? That kind of thing exists all over in, you know, in this. And you can see there's my
Tmux server, and I have Bash, and Bash is running links and stuff, right? And there's my Bash process
running ps3, okay? Well, what happens when you have a Bash that's running another Bash, right?
Then you have a situation where, and we talked about exporting variables and all that, I don't
want to cover that again, but the difference between interactive shell and a login shell,
I mean, a non-login shell, login or interactive, I guess, is kind of the same.
Technically not. I mean, there's yet another situation where you remotely connect into the
shell, into the machine, and that is yet another thing that will run if you make a remote connection
into the machine. So you have these sort of three states of Bash or, frankly, anything running on
the system. You have a shell where someone has interactively connected, and that's going to
show you, like, look at all those Tmux processes that are still running. So like you remember,
I'm SSH'd into this, so technically I'm remote. It would be who? Yeah, so here's all my Tmux
sessions, and it shows that I came from that machine and I SSH'd in or whatever. And then you have
just an interactive shell that maybe was started by another login shell. I think, yeah, you have
remote shell, non-login and login. That's a good way to put it. Thank you. And interactive just
means that you can type. You can, like, interact with the shell, right? It's not running behind
something. It's not running because some other program started it or something. And this becomes
important when you're doing things like in my Bonsai command, which we're going to write. We're
going to write some Bonsai and go. And you can see how the colors are all here and everything, right?
That's because the program that can detect that it's in an interactive shell, that the output,
standard output, is to a terminal. That's how you detect this, by the way. The way to detect that you
are using an interactive slash login shell is that the standard output is going to a terminal.
If it's not going to a terminal, it's going to a program or something. And that's so you can do
things like this. I can see that the colors are not there now, right? Because why? I sent the same
exact output to a program, to a pager more, which is alias to less. And now the colors are taken
away. And the reason for that is so that if I wanted to output that, the output of that command
to a file, I wouldn't have all those ugly color escapes for that in there. And that's an important
technique that's used all the time. But I'm showing it right now to illustrate that an interactive
shell or an interactive terminal or a login terminal, which are kind of the same, is one
that the output is going to a terminal. And that's the best way programmatically to determine that.
I believe that .profile is the one that runs all the time, no matter what it always runs, right?
So you kind of have to have a .profile even if, in fact, let me try it without it. Let me try it.
Let's do some experimentation. Let's go back into here and let's actually move my .profile out of
the way, right? Let's move it to .old profile. And so now I have no profile, right? Now let's actually
log in from Anton again. I'm going to have to go out here and make a new screen. So this is
Robby TV. This is my Git Bash terminal running on Windows, not WSL Windows. This is Git Bash
running on Windows. So I can SSH. If you want a Bash-like environment, Git Bash is by far the best.
And you SSH into Anton, which is the name of my system. And it gives me normal stuff.
And it says, well, it's kind of filled the screen there. What's up with that? All right. So as you
can see, that still worked. And the reason it worked is because my shell is Bash, right? So
it knows to run another file in here, which is called .bash, right? .bash, I think profile or
Bash RC. So Bash profile is, let's actually take a, let's go, let's take a look at
another account here. I want to take a look at a brand new account. Actually, let's do that. Let's
use a brand, let's don't use mine. Let's use a brand new one. All right. So, so now, well,
I think we already configured this one, didn't we? No, I did sdash. That's why, so it should be fine.
So if I look at .profile, what's in there? All right. So this is what comes in your .profile file.
And it's usually really bad. The profile executed by the command interpreter for login shills.
So the file is not read by Bash if Bash profile or Bash login exists. Okay. So Bash is unique.
If you're on older unique systems that you won't get into, profile becomes important because
particularly if you're like running on Mac, I'm pretty sure if you're running Mac,
if unless you're running your, even if you're running Bash, you're making sure they're still
needed. And is it good to have this file around? Yeah, it's probably good to keep it in your
collection. I've never had it, had to need it when I go work on a remote system. I just copy
over my Bash RC file. And so one of the goals that we're going to talk about is how to make
all your stuff in a single file instead of having it in Bash profile and Bash login and all over
the place. And so Bash RC. So Bash RC is meant to run any time you have any Bash program
execute whatsoever, login remote or anything, right? Bash profile and Bash login
are supposed to be only for login shills, right? And the default mask is an Etsy profile.
By the way, if you want to change where this comes from, you can go look at that, right?
Etsy profile is where all this stuff comes from for the whole system, right? This is where it copies
this over for everybody. And so I don't want to go too far down that horrible hole. It's a
pretty big rabbit hole. It suffices to say it's annoying as hell to have to manage multiple files.
So what I would suggest is that you just put everything in Bash RC. And I'm going to show
you how to do that, okay? So like right now, if we log in, actually, let's do this, let's
actually log in. So you can actually log in from the command line to another account as if you
had remotely logged in using the login command. su su dash does the same thing essentially.
But so we're going to do login. Let's log in as the boost account
and cannot work without effective route. All right, fine. su login,
called by Bash RC and can keep Bash's clean. I don't agree with that at all.
I hate that approach. I've read that so many times and I hate it. Bash ALS is supposed to be for
Bash ALS. People who put a full blown Bash RC and Bash ALS are not doing what I would do.
I don't agree with that. But if you want to do that, that's fine.
People think it's fine and they'll leave there. The only time that would make sense to put anything
in your Bash ALS file would be if you wanted to keep the dot Bash RC file unmodified and you
or for some reason, your multi user system has locked down that file.
I don't encounter that situation very often. So that's not something I recommend.
But a lot of people recommend it all the time. So I just want to say I find that really annoying,
mostly because it's a misnomer. It's not about Bash ALS's file. It's like everything.
So my preference, by the way, when you're doing this, you got to be careful to do it with an
extra account because or to keep the other file around because you can keep yourself from logging
in if you're not careful. But you have a VM. By the way, how do you go take a snapshot of our VM?
You can go take a snapshot of your VM if you're scared, right? That's why we're doing VMs. Let's
do it. Let's go into maybe our Workstation Pro or whatever yours is and where are you, my friend?
Okay, here we go. And so we're not on the SSH endpoint. We're going to go find our other one.
We're going to go to Anton. And I am going to take a snapshot file. Where is it? It's VM snap.
Snapshot take snapshot. All right. And we're going to take snapshot snapshot one.
Boom. Okay. Now you can always go back to that later if you need to.
We are running right now. So this might make us a little bit slower for a second.
It's really lagging. Oh my God.
It's a pretty big image. So I don't know. We might crash. I hope I don't.
Yeah. You know what? I forgot to pause it. I forgot to pause Anton to take a snapshot.
You should generally pause it before you do that.
I'm kind of curious to see if it's even going to be able to do it.
My, uh, my fan is sure moving fast.
Yeah. I did a lot of around there. I hope I didn't break it.
Oh, it's not a grub arg. It goes to the finish. Oh.
When is command, jake command? No, I'm not doing that.
And it bin bash. Interesting. Yeah. Yeah. We don't play with grub because we're using VMs
right now, but you could do that if you wanted to. Um, yeah, that would be more for like, if you
want to, which I want to do, by the way, if we have time, not in this booth, but later on,
I make it so that we can talk about how to make your own Linux machine. If that's what you want to
do. Uh, I'm not, I saw something that I do anymore. I am going to be installing Linux on a bunch of
other stuff. We're getting kind of laggy here. Yeah. Get back into VM. Yeah. I feel like I might
have broke this. I might have broke this by taking a snapshot. It usually doesn't do that.
Well, I should have, I should have stopped the image engine before it's taken a snapshot.
It's trying really hard to do it with all this processing power going on. And it's kind of lagging
my computer up. Yeah. We are definitely breaking. I know we're breaking because I, this is a huge VM.
Yeah. It, it's a huge, the machine doesn't have enough memory is the problem.
Um, uh, I don't have to stop it.
Shut down.
Client loop. We got a client loop. Yeah. Power off.
We're still there.
Taking a snapshot is supposed to take a snapshot of the VM,
but you need to have the VM paused or stopped to do it. I can't believe it. Let me do it.
I made a mistake.
Yeah.
Yeah. I broke it. And then my host, my host OS is like having all kinds of problems because it's
running out of RAM. Yeah.
Yeah.
So, because I turned up the RAM on my VM
and it's trying to swap it all out, which is really bad.
Yeah.
Nice thing about bash OS is
that it didn't have enough RAM. I had to free up some apps to give it the RAM. That's, that's why I
was failing. Now it's fine. It's fine now. I had to free up some RAM. Yep. All right. So we're back.
We should be back now. Sorry about that. The reason for that,
in case you're wondering, I know exactly why that happened. I just forgot. First of all,
number one, I forgot to pause the VM, which makes this saving faster. And number two,
I've allocated eight gigabytes of RAM to Anton because I want a nice smooth experience.
So taking a snapshot of an eight gigabyte memory image on a 16 gigabyte system,
that's running other things at all, causes lots of like pain and suffering on the part of windows.
Or any computer, frankly, because it didn't have it and it can, it didn't swap it very well.
So as soon as I cleaned up some of that memory and got rid of those other applications,
both of them electron applications, by the way, Discord and Spotify would take enormous amounts
of RAM. And as soon as I cleared, cleared up that RAM, I had enough RAM for, for VMware to finish
the snapshot, which you probably would have done even without me turning it off. But I'm going to
go ahead and turn it back on. I actually have a command for that. We already have a snapshot now
taken so we can do that. So if I want to turn it back on, I have a command here called VM run
Anton. And that's a, that's a script I have. And that will start up Anton and then we can
as a stage back into Anton as soon as it comes back up. And that does it headlessly. And we've
covered about how to do this stuff in other boosts. So I don't want to go back to it, but
that's kind of a fun, you have to write your own VM run command. It's waiting for it to come on.
You guys want to see which one it is?
So this is what's in there. Oh, whoops.
VM run.
Oh, it's just a, okay, there we go. So VM run is just, is just a function that I added
to my bash RC file in on my windows machine. And so it runs VM run and runs the headless
no GUI for this. This is actually a really good thing to have. I did, I think we cut and paste
that into other, other stuff, but I kind of want to put it in the notes as well. Again,
once we get there. So SSH Anton, Anton should be up now. And that's because we set up our
SSH config, which we did a while ago. And so now we are in here again, we're in the home directory,
and we'll just run the Tmux from here. And we should be good. All right. So
let's see here though, I do want to go to the boost again really quick
and go to the 13 read me. I want to put that a little bit of code in there.
VM, actually, let's, let's put it a separate file because I want to cut and paste that into the,
to the docs. Touch VM run, smocks, VM, actually no, because it's a, it's a function.
So, so yeah, that's a windows thing. Now, I do kind of want this here. In fact,
in fact, I'm probably going to add this to my bash RC file because, and this is leading into
another thing I want to talk about, which is conditional evaluation of stuff in your bash RC.
So
even if you can always use init equals bin bash to get back into Linux without a snapshot.
Yeah, but I wanted to save the changes up to that point. So, okay, so we've got,
I'll call this and read me again.
And we'll go back here. And we're in the home directory. All right, so dot profile,
by default, if you want to look, and the master makes a good point, if you, if you want to use
all the defaults, you can do that if you want, right? And you can just put everything in the
bash aliases file. I don't particularly like to do that myself. But if you want to do that,
you could with bash. Okay. If you want it now, the way that I've configured mine is that
it works at one point, I think I actually have broken it since then. At one point,
my bash RC would work with politics shell and bash and a bunch of other stuff. But
I've since changed it. So it's, it's pretty bash, bashified. It's also no longer generic.
And so let's talk about, let's talk about organization of dot files again for a second.
So, so you have, you have this profile, we talked about the interactive thing,
right? And you have the login or slash interactive, and then you have remote,
which means you came from outside from someplace else. And those are the, the main ways. And then
you have non interactive, which means stuff is running, but there's no interactive terminal.
And that includes scripts that are being called from, from other things. Okay.
And we're going to, we're going to jump right into the bash RC file right away on that.
And you can decide whether you want to do the, but let's talk about the organization a bit.
So you have the dot profile, which is just kind of there. You have the bash profile,
which executed if you have bash, the bash history file, which is created.
That's the thing that, you know, when you do your set dash OVI, which we're going to talk about,
you can navigate through here and check the lines out. You can even go to a line.
If you, well, no, I guess you can't. That was, I guess you can't. I thought you could.
Anyway, so bash profile, bash RC. And then we have some standard directories. And I want to
put these in the readme. Okay. So we have, I'm just going to put these out here first. So we have
dot config, standard, say, user slash local, local means usually just for the user configurations
for different applications. And go, by the way, this is called the US
OS. I think it's user. It's not user. It's a user config. I think it is. I guess user config.
Let people know this. So I'm going to show you how to get to it.
There we go. User caster, user, configure and user home. Those are the, those are the main ones.
So user configure. So this is a standard across, it's set by the, the open desktop.
And we have cash. Okay. Is your local cash. Now what is cash? Cash is,
cash is where you write things temporarily that are meant to be, to go away. So like your browser
cash or, you know, things that are, that a program wants to use and have it be there for next time,
but might throw it away. And it might contain sensitive data like tokens and things like that.
So you don't want to make that public. There's another one couple here that are, that don't have,
they're not part of a, an official standard. And this localize is just
localized tree similar to slash. So this is something that has kind of taken off recently,
which recently being like five, six years or so, which is, which I find very, very nice. So
if you want to, instead of putting something in like user bin, which is, you know, guys, no user
bin is right. User bin is where we have all the programs and stuff, right? So let's say you compile
some code, you know, you could, at one point we used to put this in, you know, bin, right?
And at one point we used to have, you know, TMP and, and that kind of thing. And we would put them,
you know, I would say old, old school
place to put localized biners. But this has since changed to be like,
like this is your local bin, modern place to put localized binary executables.
So, you know, I used to put them in bin. It's like, you know, this is like the old school place to put,
to put TMP files. And these things, you know, are related to the stuff that's on the system.
What else we got? So,
so we have cache, which we talked about. And if you look at the cache,
ls.cache, you'll see we have, you know, different programs in here. I put my Z program cache in
here, go Java, go build. I mean, the stuff does this. Now, the problem we're going to have is that
there's kind of modernized applications and there's the old stuff. And the old stuff still does
.files at the root. And as you can see, it's rather messy. And this has been a problem now
that Linux has kind of become more prominent. Because there's so many people that want to do
configuration that the .files, I mean, this is a relatively clean new system. I've only been working
on the anson here for kind of a couple months. And but as you get going, and depending on how
old the applications are, the more messy everything gets. And one of the things that Neovim claims to
fame is that they put their stuff in the right location, right? Because they, Neovim will put
everything under .config, .cache, .local, as opposed to Vim, which uses .vim.info, .vim,
and .vim.rc at the top level, right? And GuruPG, for example, GPG, that's another thing that doesn't
observe, you know, these little conventions.ssh is one of the older applications. So when you
are looking around in here, just know that there are kind of modern approaches to this,
and then there's the old approach to it, right? Tmux by default looks here as well.
And this is my own stuff, but the Tmux. So that's just something to keep in mind
as we go through it. So those are the main directories. So yeah, we want to put here
something about old school, Holmder organization
versus modern standards. And it's, and if you want to know where the standard is,
you can go look it up. I think it's X386, a desktop standard. This has become the
place to go get the documentation if you want to look it up. They're the ones who kind of
championed it, even though X is a, you know, is a terminal, not a nonterm, I mean,
what do I want to say, a window technology. So you can actually do a desktop standard
directory organization. All right, let's go look at that.
X386, directory FSF, free software directory. X386 implementation, no.
I don't know what it is. Linux directory. I'm trying to, I thought it was free desktop foundation.
Actually, there we go. It's specifications, free desktop.org,
base, or xdg, cache, home, xdg, whatever. So these environment variables, which we'll talk about,
are also where you should go if you're writing scripts instead of, you know, but go has
encapsulated that. And it's looking for that base directory. If you're making new code, if you're
making new scripts that are meant to be run by users, or if you're making new applications,
I strongly encourage you to get up to speed on the specification for that. And again, on Windows,
it's local app data, which is libcache, and it varies, right? So it's home.cache on Linux and
Unix. And this is, again, one of the advantages of go is that, you know, you write it and go,
you do it right, it will cross compile and work anywhere, and it will use the appropriate locations
for things. That's why I like it so much. And so, so there we go. Well, old school,
home to organization versus modern standards. So just make sure you got that down.
And I think that's enough conversation about how this thing is organized. And now we're going to
dive into the individual programs to and how to organize them. So the, the first one is going to be
all of this stuff to log in. And we talked about this. So the bash profile, the bash RC is the
most important, in my opinion, unless they don't have a bash aliases file, if you look at the
standard bash aliases, or bash profile, which I should be able to look at here. I don't know,
Etsy skill. Etsy skill contains a Etsy skill is an exact duplicate of a new user's home directory.
So if you put anything in Etsy skill, adding to Etsy skill for all new users, if you add anything
in Etsy skill, it'll automatically be added to everybody else. So it's also a good way to go
back and see the defaults. So let's say you screw something up and you want to revert.
Yeah, you can go back to the skill and, and you can go check it out. So this is one of the reasons
I don't mind just using my bash RC, because if I needed to revert, I can go back in here and see it.
Bash RC. So this is a default bash RC for the system.
And again, so this is the first program that runs when you log in. And we talked about this
before, but I want to show it to you again. So Etsy password is the file that contains
all the users on the system. The x stands for where the password used to be in flat text,
by the way. And, and it's now in secret. And then we have the user ID and the user group ID,
which are almost always the same. There's usually always a group made for a given user.
And then we have just a generic like comment field, people put all kinds of things in here.
There's a standard like common notation for like, that it's a really old script from for dealing with
like multi user student systems, when you do add password that does that. And then we have over
here, we have the actual home directory. This is the directory that they'll be put into when they
start their login, or if they start a new process. And over here, then we have their shell. And the
shell, the shell can be used. I mean, this is their login shell or your login application.
And you can do all kinds of fancy things with this. I mean, you see route has been bash,
you could actually make your login show Python if you wanted to. You can, when I worked at
teleport, we made the login show of a particular account and application that showed transit times.
And it was actually a way to start it. If you wanted to create a mud multi user dungeon,
or some sort of interactive text adventure, as long as you're careful, so they can't break out,
right? You can, you can set that to be the shell. And then people get there's actually
the Star Wars. You can, you can SSH to a particular account, some place that you can watch and ask
the animation of Star Wars. And that's because they set as the shell, the program to run when they
log in. So we covered this already, but it's important that we go over it again, because
it does kind of, I mean, bin false means, hey, you know, nobody should be logging into that account,
period, right? And bin bashing and Barry is another one. So I've been bashing on Barry too.
And that, that's going to cover it. Yeah.
I'm sure I'm thinking about something here.
Yeah, that's it. No, that's right. That's right. I got it. Okay.
What's the difference between user bin no login and false bin false is a program that just returns
one, I mean, zero, one or negative one or something. That's it. It's an actual program that predates
everything. No login is a fancier version of that. I don't, I don't know. Man, no login.
No login. Politely refuse the login. Oh, apparently it's more polite than it's a BSD thing.
I'm, I'm not, I don't use the login. I use false. I've been using false forever. So
yeah, are you here as well? I didn't log into the login.
Yeah, interesting.
It gives less, less exiting. Yeah, it doesn't give any info at all. So they don't know what's
a user or anything. They just connect and it just drops it. That's why I like false.
I couldn't remember why, but I think that's probably the reason. So, so again, here is
the standard bash RC file. So this, this is the, I mean, technically speaking,
if you're running from a remote login shell bash profile, I think runs first, but it's empty,
right? Let's look, let's see what's in XC scale, by the way. So,
so dot profile is like any remote thing. So let's look at that one.
So this on a standard system executes command interpreter for login shells. This file is
not read by bash. If bash profile bash login exists. And then I'm asking myself, why do I even have
one? The only reason I do have one is there are occasions, I think Mac is one of them,
we're having it night. It works nicely. So this just says, Hey, if I'm going to,
for some reason I ran dot profile instead of everything else, go ahead and execute it. In
fact, I wonder, I'm going to experiment with something. I'm going to get rid of mine.
Did we already do that? Didn't we already do that?
No, it's not there. So apparently profiles like really not used. I might even be able to
delete it from my system. Let me try something else. Bash dash. No, they got it. So kind of
useless. I mean, I hate to say it, but it is the profile is kind of useless. You may find that you
need it on another system. If you want to run bashing for some reason, you can't change your
login show. I mean, I don't know. I can't remember why I have it. I'm this one. I'm kind of
considering getting rid of it. I mean, I do have one, but, but mine is all it does is just run my
bash RC. It's basically a short version. It was anyway until I moved it. It's just a, do I have
a bash profession in this? Oh, and you notice how this is written in old school shell as well.
It's like the headaches. Yeah. So, so if we have bash, then include bash RC and just run it.
Yeah. This is interesting because this is using this is using politics notation
for the shell stuff as if, because dot profile, this is the one thing I know about profile dot
profile is spans all shell types. So like if you're on a unique system reacts, which I haven't been on
in a long time, or BSD even on a Mac, you might have issues with dot profile. So dot profile might
be the first thing that runs. Just know that. And, but more importantly is that bash RC, right?
This is the most important file and your, the main bash configuration file. And I
prefer to do everything in bash RC so that I can SCP that bash RC file to anything,
and I get the exactly the same environment. So, so let me give you, let's actually do
an example of that. Okay. So if I, let's say I want to work on a container for some reason,
and I want to Docker, we haven't done Docker yet, but in fact, when are we going to put
Docker on there? And we need to put that on there somewhere, probably after the ghost stuff,
because we can do from scratch containers. All right. So Docker dot it dash dash RM,
let's run a bunch of which will run a bunch of search a lightweight image. And let's just go run that.
Oh, I didn't do run. And so now I'm on a one two. Okay. And that's actually see, do we have a user
over here? Let's add a user add user. Rx Rob. And you pass her by the way, these
see how it's copying files. That's what you want to try again. Oopsie. Yes, please.
My super secret password. And I'm going to leave memory told you the commas. So this stuff all
goes in the comment. There is a user ad as well. Ad user is a pearl script that comes on all a bunch
to makes it kind of nice to do it. It's just a convenience. You can do all the same things
with user ad, which you should probably memorize as well. I haven't I mean, I look forget all the
time because I always do this. So and now I can actually change over to that user.
And now I'm running as me. Now, I don't have my profile, right? So this is me with an absolute
bare bones Ubuntu Linux profile. And I have all the stuff we just looked at. We have a profile
that there's no behind here. Oh, that's right. I have to use Vim. It's probably Vim tiny too.
What the hell? What do you serve it as a Vim install that default anymore?
Since when?
Studio app update. I shouldn't push. Oh, I guess I don't need that. There's no, there's no
studio either. What? There's no Vim. After install Vim, you know what? You want Vim instead of Vim
tiny. Vim tiny is usually the one on my default. I mean, I don't know why you would do this, but
you know, all right, let's do that. Okay. Hey, we can see stuff now. So let's do
our XROM Vim.profile. So here is the file as we just saw. And the default Vim's gotten better,
by the way. The syntax, I think it's gotten a lot better. So now we have a Vim info because
I actually did something with Vim. So we have a bash history because that shows
all this stuff that I did. There's all my commands. My skill bot actually would query
interactively the history file, which you can make update in real time. And it would tell you
if you did it right by looking at your commands. And that's why be careful. I mean, if you type
a password wrong or something like that, and you go splash your history file on this live stream,
you know, I've seen passwords in history files before, because people don't know where they are
and they type in the wrong place or something, or worse, they're in a program that takes the
password on the command line, which is totally stupid. Bash logout executed by bash when login
script exists. So this is kind of a way with bash logout file, I don't ever use it. I don't even
think I have one actually. Do I have one? I do have one, but I don't use it. Oh, it just clears
your console. So it increases your privacy. That's cool. Now I don't use that though. You have an
alias to delete the last history line for that. Just to delete the last one. Yeah, that's probably
a good idea. Yeah, and everybody knows like if you, here, let me show you something. I mean,
I think people know this already. We already covered it, but let me show you again. Wait,
I just killed my thing. I'm a bad streamer. Bad streamer. I did, I killed my thing.
Where's my Docker line? All right, let's get back in a bunch again. I gotta do it over again now.
So it's good exercise. I'm not going to have them on here again, though, because I threw it away
because ephemeral containers don't stay around. They don't remember their state. So I gotta put
container. How about that? It's due to no update. And dash wide is taken by app update,
by the way, people said it's not. It is. So we do app install them dash wide them.
I'm reading it so I don't need to sue you there.
Alrighty. So what I wanted to show you, so we were, we were talking about add,
add user to VXRub and password and password.
All right. Now that's the same as saying login if I had, right?
So you see my stuff sell the same. I hate fuzzy finders and I absolutely detest control R.
I do not ever use control R. I use set dash OVI and we're going to talk about that. Don't let me
forget. If you're not using set dash OVI, you're doing it wrong in my opinion, because you're using
VI for everything else. And I have strong opinion on that. So we'll talk about that.
People tell me all the time use control. Oh, they're clear to the screen. I'm like, get bent.
You have no idea what you're talking about. Okay. So
LS, LS dash A. So there's all our files, right? And let's go edit a profile and we'll get our
VIM stuff all automatically initialized. And we do that. LS dash A. So there's our VIM info.
Yeah. Look, if you want to do it, that's fine. You know, I don't really hate you when I say that,
right? I'm just, I'll just laugh at you. And then I'll buy you a beer.
Okay. So if you want to do that, that's fine. HL search,
file marks, it tells you this remembers. So this file like remembers all the information about
your stuff while you're doing your VIM editing. And you really shouldn't depend on it. It is nice.
It does remember where your lines are. And we're going to go through that later. But in the bash
logout, you don't need mess with. But what I wanted to show you is that the only file that
matters here is bash RC. But I do want to show you what Mossy was talking about, which is,
if you'd rather not mess with the file, it even says it in the recommendations in the comments
down here. But I just don't trust them. Alias definitions. You may want to put all your additions
into a separate file like bash like bash aliases instead of adding them here directly. And my
question is why? Why have yet another file that you have to manage that's just sitting around there?
I don't, I don't ever do this because I want to clean directory and I want to control what goes
into the directory. I want total control. I don't want to trust some really bad shell code,
by the way. This this new one to default bash RC is really bad. It's just so bad. And I don't want
to go, for example, the history file size, massively broken. And we can get into this
when we get into it. It does some other history settings. So the main reason that I don't want
to use a bash aliases thing is because I want to throw this crap out as soon as possible.
It's absolute crap. It's a good start if you want to like go from there, but
it does things that I would never do. Plus it's using single. I mean, I don't, I just don't want
to talk about it because I'll get angry. Okay. It's horrible. It's just really bad. And I mean,
God, look at this. I cannot. Okay. Plus it says you're really horrible color prompt,
which is completely bad. And it's inefficient. It's totally inefficient because now you're
starting this really horrible thing to start another thing, which also has to run another
script. It's inefficient. It slows down your, it slows down your logins and everything. Okay.
And, and I don't want to do that. It tries to give you some aliases. It's just, it's just bad. I mean,
why would they put the aliases in dirt colors if dirt colors doesn't exist? Right? Why would they,
you know, they only activate color if there's only dirt colors. No, you can use grep with color
without dirt colors being enabled. There's just like so many stupid assumptions based in here
that I just, I can't talk about it and not get upset. I do want to say though, that this is where
a number of misconceptions come from. For example, people log into Ubuntu or Kali Linux or something
and they tell me, oh, you should use LL for everything. And I'm talking about, you mean Ls-L,
A, right? And, or they're, or they make a command called L that does this, right? And the answer is
that's an alias and they don't know it because they don't know what an alias is. Now you do.
And, you know, they, they set up alerting, which I don't really like alert. I mean,
look at how horrible this line is. This is, this is objective proof. These people have no idea
how to code or script. This script is so stinking bad, I don't have words. And, and you do,
you understand why all these sub-shells are unnecessary. The reason they had to do that
is because they made it into an alert instead of making it another script or a function. They
could have done this whole thing as a function and saved all of that crap, but they didn't.
And they decided to make an alias. And by the way, why are alias is bad because it can't be used
as UNIX filters. I could go on and on and on. This was written by whoever manages, somebody
at Canonical, whoever manages the, the main login for Ubuntu. And I'm glad I opened it up because
it was a really good reminder why I'm never using it. Okay. And you don't have to use it either.
And here's how you change it. Okay. So, so I'm going to go back over to my other script over
here and I'm going to show you why I think you should put everything in a single Bash RC,
because when it's in a single Bash RC, all I have to do is copy it over, right? And I don't
remember how to SSH into containers. Does anybody else know how to do that? What's the
Docker command for that? What's the command for it? I don't remember it. Does anybody remember?
What is the Docker? I know there's an SCP command for Docker that will SCP into a running
instance and I can't remember it. And I didn't mount the directory because I don't normally
do this. Normally I would, you know, but if I wanted to, I'm trying to figure out how, how I could
do that. I mean, let me think. Let me think. Let me think. Let me think. Let me think.
We could actually SSH. Sometimes I go to the machine and SCP it from the target machine
and sometimes I do the reverse. Is it just Docker copy? Really? God, I might that.
But they don't have to do it to the running container.
God, I'm out of shape. I am so out of shape when it comes to this stuff.
So we are running one. Okay. So there, what is this name?
A container ID. Okay. Okay. So, so Docker copy dot bash RC to, I mean, this is one example. I mean,
pretend like this Docker copy is like an SCP to another VM or something, right?
I'm having a feeling that container is going to come first.
I did up bash RC.
And I mean, I didn't put the user. I should probably do that.
I must specify at least one container source. I think it did.
I don't, I don't know how to do this. I don't have to look it up.
I'm sorry. I don't know everything. Sumi, um, Docker copy. Oh, really? Is it that's all?
All right. Well, colon.
No, no, no, no, no, no. We went dot bash RC into, and yes, I use my mouse again. Sumi.
Slash temp. Yay. All right. So we should be able to go back to the Docker container and do ls slash
temp and see nothing because it's hidden. All right. So now we have a bash. Oh, you know what?
It's a sim link. Yeah. Watch. I copied the sim link and not the file it points to, which,
you know, you wouldn't do. Okay. Let me, let me resolve the sim link there.
Uh, I can, I can fix this. I can fix it. All right. So we're going to say,
um, what's the, what's the thing that does, that it resolves symbolic links automatically?
I should probably learn that again. There's a switch. There's a flag you can put on
copy and the other one that will actually copy the, the destination file instead of the actual
symbolic link because I, what I want to do is this, I want to do, I think is it dash f?
I don't use it very much. This is for me too. So we want to follow some links.
Hard links. I can dereference. There we go. Dash l. So you might want to do a dash l.
I wonder if the Docker has a dash l. Wouldn't that be cool?
It might. It might have it.
Oh, damn.
It does. It does have it. That makes me very happy. Okay. So the Docker CP command has a dash
capital L as well as the cap. All right. Now I'm going to put that on my list because I'm,
I need to remember that one. I don't use that ever. I need to, um,
copy dash l, uh, follow symbolic links. We haven't, do we do symbolic links?
I don't think we've done symbolic links yet. Do we need to talk about that?
I think we, no, we're going to, you know what, we're going to talk about it because we're going
to put all that stuff in a git repo and then we're going to link it in. And people, people
complain about that all the time and they say it's messy. There's streamers who complain about
that because then they want to use some fancy tool for it. I think learning how to do the
symbolic links properly is better personally because it works everywhere and you don't have
to install some extra tool that you don't have access to. It just works. Uh, spelled out flag
when I don't remember. Can you do dash dash flag? I wasn't sure of that. Okay. So, so anyway,
we've got this new bash rc here, right? And I want to take it over. So all I have to do,
I mean, I could have copied it right to the directory if I wanted to,
but I kind of want the option of having, you know, remember, I can go get the,
this one from Etsy scale if I need to, right? So let's just do that. Let's just copy
temp.bashrc and we'll copy it to here if we can. And now I do ls-l a, we should see that the file
has changed. Uh, it's still readable and everything. It's bigger though and we're going to go look at it.
And now we have, this is my, uh, shell check enabled bash rc file, which we are now going
to go through. All right. But now the other piece of this is, uh, when you copy a bash
rc file over, um, you're like, but it doesn't look like it's using it. And people log out
of the terminal all the time and log all the way back in, you know, reboot their computer to get
the fresh colors on their terminal. You know, you don't need to do any of that. You need to remember
this command exec bash dash l for login shell. And what this does, OD references on, okay, what
this does is it replaces the running program, uh, with a new program, uh, keeping all of its
associated connections and pipes and resources and everything. And it's a way to reinitialize
your shell with a new one. So after I execute that, it executes bash really quickly and you
see now I get my fancy ps prompt, uh, from, you know, the one that I've been maintaining.
Uh, and you can't even tell other than the host name that I'm not on my own system.
Right. All I had to do was copy one file and I copied it to temp, but I didn't have to. I could
have copied it right over the top of the other one. It would have worked and that is all I would
have had to do to get, to get my bash to work properly. So you, you'll hear me when I argue
against the shell and fish and other things like that. One of my main arguments against them
is all of the individual files that have to be copied over to a target environment to get it to
work. So hypothetically, you're working for a new company. You come on and they have like really
old login jump machines that you have to use. You don't get the choice. You have to use them,
but you do get the ability to manage your own home directory, hopefully,
including your RC file. There are some places that will not to even change your own RC file,
which is just stupid. But if they do, then you just copy that file over, you log in,
your exec bash dash L, and you're good to go. And now you've got all your favorite things.
You got your, you got your, you know, you got your, your aliases, but actually I don't, right?
And this is actually one of the problems I've had in the past. At one point I'm going to,
I'm going to just confess here. At one point I put all of the stuff that I have in my script
directory. I put all of it as functions inside of my bash or C file, and it was huge. And it was
kind of stupid because every time anything ran, it had to initialize all that stuff over again.
And that's actually one of the advantages of Z shell. If you're on the same environment,
is it has lazy loading of functions when they're used. And so you, the functions are not stored
in the file. They're stored in a separate directory. And that you have to copy the whole
directory over if you want to use any of the functions. But since my, and by the way, if you
use functions like that, those functions are still not usable as, as UNIX filters. So you can't use
them as, you know, from, you know, magic wand commands inside of them or anything like that.
So you still have to have a collection of scripts. And we're going to get to that.
But you only need to bring over the scripts that you've come to love. But as we go through the
bash or C file, one of the topics we're going to talk about is when to use, when to use an
alias, an alias function or a script. Okay. And, and that, that is, that is a big question.
Every time a script runs, bash or C runs, yes. It's absolutely right. And that is why I'm glad
to answer that question because, because, because we're going to watch the reason it's okay. So
let's get into the bash or C file itself. Let's start going through it. Okay. And just like anything
else, you can actually put shell check in here. We can guarantee the correct, the correct task
with the script of copy process, the correct task of the script. I don't know about that.
Yeah, I don't know. But let's go through this. Okay. So I'm going to go through this really.
I know we haven't taken any breaks. Do we need a break before we keep going? What time is it?
Does everybody, does anybody need a break? Otherwise I just, I feel the need to keep going.
Shaw, you can, but you don't need to. You can just read it. Right. You could do that. But in
this case, you're just reading it. It's just copying locally, you know? So
all right, I'm just going to keep going. If you need to pause the video or whatever, let me know.
Okay. So, so here we go. You could do it, Shaw. So Ping, Ping and Masi are talking about
validating the file that you just copied over, right? If you're using SCP, you don't need to do
that. You just don't. If you want to be extremely paranoid for no reason, you could, but you really
don't need to do that. But if you did want to do that, you could, right? And what that's, checking
an SHJ is a way to validate that the file has not been modified in any way. And it usually works.
It didn't. One of the biggest hacks in history in the 90s, they hacked the WFTP server and they
successfully hacked the source and created a file that had Trojan in it malware that passed
the checksum validation because they made sure to avoid the sections of the file that were used
in calculating the mathematical checksum of the file. So the checksums have gotten way better since
then. And, you know, you're usually safe to do that checksum validation, but it can still be defeated
if you're using the bad ones. So I don't know if that's the reason I don't. I think you should do it,
but if you're doing encrypted tunneling, so which is SCP or HTTPS, TLS, then it's not as big a deal.
You should probably still do it for fun, but particularly if it's a script that you're going
to be reading, right? If you're going to be reading through the script. But if it makes you feel
better, you should do checksum validation on the thing. If there's any possible reason to do that.
We are doing the boost, my friend. So welcome to the stream. We are recording this for YouTube. So
just know this. Every Sunday we record videos for YouTube. Okay, so I'm going to go through this
file line by line and we got a lot of cover. So and I'm going to give very brief summaries of
what it's doing. If anybody has questions, please ask the questions now because I'm not going through
it again. All right. And this is based on the assumption that as any beginner would, you're
going to find a veteran out there or somebody that you trust, and you're going to say, I don't
really understand Bash yet, or I don't understand them or Tmux. I kind of use your files. And so
it's a part of the culture of Linux and Unix to pass down or to share dot files. In fact, if you
go to GitHub, and you just search on GitHub for dot files, you will find literally thousands of
repos that have different people's dot files, right? Because everybody is proud of their dot
files. It's like, it's like the customization on their car and they want to show you their version.
There's Jess Razzles dot files. So, you know, she's container girl. She was, she's over at
Oxide with Brian Ketchel now. Everybody puts in dot files. And my dot files are there. Everybody
puts in. In fact, having a significant dot files repo that is well organized is a really great way
to improve trust with a potential employer because they can go in there and they can see that you
know you're talking about right away. I know this person is not someone I would ever talk to
because they're using crappy Z shell shit on a Mac. I'm just kidding. It's a joke.
All right. So, and look at what they're doing too. He's making his entire get reap. This is,
this just shows he doesn't know what he's doing. This person doesn't want to ruin because, because
he's cloning, he's, he's, he's making a dot dot files and then he's going into there and he's
doing script bootstrap for the whole thing. Okay. So we're going to, I'm kind of jumping ahead, but
the reason we're not having public dot files because, because a lot of the things that are
going to go in your dot files are going to be login tokens, you know, organization of, of,
of like mostly login tokens, your secure shell configuration files. And by the way, people
commit all the time they commit their private keys. People constantly commit their private keys
to GitHub because they don't have any, they just, I'm going to put my whole home directory in there
and they just commit their home. Please don't do that. There's nothing that says, don't ever hire me
more than some shit like that. And by the way, we have that, there's a company that I know of
that shall not be named that is doing that in production. And they're saying, well, the repos
are private. I'm like, Oh my God. You know, and then what is it? Last month, all of GitHub's private
repos were compromised. Okay, well, it's more fun for the hackers out there. I'll put it that way.
So anyway, you can go through the dot files. It's, it's don't feel bad or don't feel guilty or dirty.
Just set as a goal that you're going to go make your own dot files. You're going to seek to
understand your own dot files. But, but for right now, there's no reason not to steal somebody
else's. And as I mentioned, if you want to go steal mine, which could always use improvement,
because, you know, you can go out to slash dot and you can see my stuff. Now, one of the things
I'm going to show you right away, I'll show you from here, actually, is the organization of it. So
my bash for C. And this, by the way, I noticed the other day when I was going through this that a
couple of specific things to me referring to my name are in here. My goal in creating a dot files
is creating something that you can copy and paste as is for you. Right. So see this whole who am I
think this is so that I can create a user. We're going to come back to that. But, you know, I get
busy and sometimes I'll make a mistake and I'll commit something that refers to me. In fact,
I think I have something in here. I don't know where it is. But and, but if you, but if you do
that kind of thing. Now see the better option instead of doing a dot files that is this, right.
So this is something I use. I source I wrote a function called source if and then I have added
dot bash personal dot bash private and dot bash work. And this allows me to use the same bash
or C file everywhere I am. And I have a bunch of stuff in dot bash work, for example, that deals
with our VPN and logging around it and, you know, sets a socks proxy and all this stuff that you'll
get into if you get into the IT profession. And, you know, so you can you can do that that way
if you want to my dot bash private is actually mounted as a USB stick, which is another reason
to use a VM instead of Docker. I'm sorry, instead of instead of WSL to WSL to does not allow you to
to mount USB sticks, period, which is really horrible. So I happen to keep I mean, I'm not
doxing anything here. I keep my private data, my private stuff on a USB stick, and then I
mount that USB stick. And then this gets symbolically linked to what's called a raw get repo that
never touches the internet, ever. And that's got, you know, my private keys and my GPG stuff and
stuff like that. And that's one of the reasons I'm using a VM container here because I don't
want to show you any of that stuff. But I do want to show you how you could do that if you
wanted to. And then you can you can break these out. Okay, so in terms of references, you know,
if you want to follow along in this thing, and you can just go click on the dot file here, and
I'll send you the link here so you can go look at it. And I'm always, you know,
pilfering other people's good ideas as well. I'm constantly going through it. All right,
so let's let's jam through this thing really fast. I'd like to read about dot files. Oh,
yeah, it's so much fun. Yeah, I've made so many friends just through my dot files.
Seriously, because I've like reached out to other people's dot files. I'm like, man,
I really love what you did here. Blah, blah, blah, and say, thank you, or you open an issue on
the dot files thing, just to be nice or, you know, comment or something. And I've had people,
Q macro found me through my dot files on Twitter, and then saw some stuff in there and started
talking about it to his to his peer group. And it's a part of the culture, right? So, you know,
drink a beer or whatever, non beer, coffee, whatever you want, whatever beverage you want,
and then talk about making a better dot files. People at night, like when I'm like putting
the music on, I'm all I'm doing is cleaning my dot files up and it's fun. Cleaning your dot files,
your your dot files up is is really, really fun. You just put music on and, you know, shoot the
breeze of your friends on Twitch and and just clean up your dot files. In fact, it's addicting.
It's really addicting. You want to, like, creating new ways to doing things. In fact,
because of this, I ended up making bonsai, which is a monolith that has all of my commands in it,
that I can compile for another system. Let me show you that. So this, I'm going to give you a little
little little snapshot of bonsai. So where's my CP command? I was, all right, wait, wait, wait.
So it's over here. Okay, so I can do capi dash l. I can do which is Z, right?
You remember my Z command that's got the POMO timer and everything?
Yeah, I can copy my Z command. And I can copy that. Oh, let's make a new directory. So while we're at it.
Where am I? All right, so I want to be careful because if I close this window, we're dead. My whole
thing will get reset. So we're going to make a directory called .local.bin. Notice the spelling
directory. Oh, what's the fix for that? What's the fix for that? It's a non-posix fix, but what's
the fix for that? What just happened is a little bit of a quiz here. We covered this. I just want
to see who knows. I tried to create a directory that doesn't have a parent directory. How do I fix
that? Dash P. Well, that's a good job. Okay, so dash P, it says make all parent directories as well,
right? That's all. Yep, dash P. That does not work on BSD Unix, by the way. That is a bash.
I'm sorry, that's a bashism. It's a linuxism. All right, so anyway, so now I have a bin directory,
right? And I'm going to go over here and I'm going to copy my Z program, which you guys are
going to make one, too, if you want to. It's a bunch of only. A lot of people do that. Yeah,
yeah, a lot of people do that, but I don't. Sometimes I like doing explicitly, but...
So let's actually copy this into the home directory. But to do this, we might have to do it
as a specific user. I think it's just going to copy it over as root. Does it dash U?
Actually, no, let's just put it in slash temp and I'll copy it over. It doesn't matter.
Either way, it's fine. All right, so now I can do this. I can say copy slash temp Z
into .local. And because it's linux already, right? Which is Z, exec bash dash L and which is Z.
And the reason that it didn't see it in the path is some cool magic that I'm doing with the path,
building up my path on login. And I want to show you that in a second. So now I have a Z program,
right? Well, it's not Schmox, which is Z. All right, so now we can do Z. That's my Z program.
Pretty cool, huh? I could have done that on PowerShell. I could have done that on Plan 9.
I could have done it on BSD Unix. I could have done it on AIX. I could have done it on anything.
So this is the moment where I'm going to tell you that I am in the middle of porting all of my scripts.
Why use a bonsai monolith instead of scripts? So I'm moving on to the next phase of evolution
and I am getting rid of my scripts and I'm putting the ones that I use all the time and do a single
bonsai monolith because why? Because I was able to copy every single script and every single thing
I ever want to use by using one copy command for all of that stuff. And it fulfills everything I need
as a, look at that, ZPOMO start. My Tmux over here isn't set up yet, so that's why it's not doing it.
What if I do ZPOMO? You'll see it's there. Oh, I haven't set it yet. ZPOMO in it.
All right, now let's try ZPOMO. There we go. So my POMO is running in my new container
and I didn't have to do anything. I just copied it to binary over, one binary.
So, and look at all the commands I get for free. You see that? I get all of those commands for free.
I want to do EPIC. If I want to do ISLNN, I can do that. I can do, I can run, I mean,
anything. I've got my ENV thing. I don't remember as long as, oh yes, data. I like giving all of my
environment variables. I could get whatever. And that would work on Windows. It doesn't even have
Linux if I did it. That's one of the reasons I like it so much. So I'm, as I said, it's got,
it's got my YAML parser built into it. So I don't have to install that. It's got my,
you know, it's got a way to set localized variables. It's got a way to talk to Twitch if I wanted to
do that. And I can, I can adjust it to have anything else off of that that I might not want.
What does AFK do? Oh, there's no chat, chat command. Oh, my chat, my chat command talks to WeChat.
That's, that's got the problem. Hello. Watch is going to try to chat, talk to WeChat and
there's no WeChat. Yeah, so it can't do it. And now it's, now it's not happy. Why isn't it happy?
What did I do to it? I broke it. I broke it. It's waiting on my, it's waiting on terminal input
and it's trying to talk to WeChat and WeChat's not there. I found a bug.
I definitely found a bug. All right. Let me, let me go log in or something so I can fix that one.
All right. So Docker, what does it connect? No, it's attach, right?
Docker attach. I know. That's embarrassing. It's what I do. My program is trying to talk to WeChat
and it's all hung and it's not doing control D because control D is getting intercepted by stuff
before it. Monolithic functions only file. I would love that. Wouldn't that be great, Masi?
Yeah. I mean, we'd have to be scripts though. So, I mean, you could just do a tar ball and
untar it. That's what everybody else does, right? Yeah. Another way to do this is just make a tar
ball of your scripts and then just untar your scripts and then you're good to go, right? So
people do that with their entire home directory. They just tar, they have a setup script that just
tars their home home directory and they just go over there and they just run it and untars it and
does it. It's kind of a fun script to write if you want to do that. So, oops. I don't know.
What is the name of our Docker thing? I know this is taking a long time. I'm sorry. Docker attach.
Did I do that right? Or do I do, or did I do exec? I can't remember my Docker commands.
I'm sorry. There we go. su-rvx-rub. Phew. ps-ef grab rvx-rub.
Oh, there's no pcr grab. Because I alias grab. I forgot about that.
We'll do slash grab. There we go. You guys know about that, right? Anytime. Okay. I'm going to show
you this. Use to disable aliases and functions. So, do you see what I did?
It's like, I forgot. I don't have pcr e-grep installed, so I want to use the actual grab from
the system, so I put a slash in front of grab, and then that finds the actual grab and it works.
So, now I need to kill zchat. So, the other thing that I like about using the zchat compile thing
is I can see it. It's not like bash something, right? So, I need to do this. I need to do
pkill756756. We'll try to kill it nicely and see if it dies. And we'll see. Is it still there?
No, I'm not having it. Okay, fine. All right. Fine. That's nine. No, we need to kill. Kill so physics.
One more time. Okay, it's gone. You could also, I could also have done pkillz and that would have
got it, but that's a little bit scarier. And now we should have our, we should have two containers.
Yeah, we should have two container processes. There we go. So, by the way, has anybody had
to do that on assistive before? You like login on the outside and then go kill the process? I went
crazy. So, it's a thing that people do to survive. I've done that with X before. I've had my,
something with, what's it called?
Popoos. Popoos was blacking out my screen and I had to SSH in, kill all the processes surgically,
and then reboot it because it was so screwed up. That's why I got rid of Popoos, by the way.
It's crap. Absolutely crap. We're writing an install script for every dependency,
like use for curl, et cetera. I do, I do have an install script and we're going to talk about
that. We're going to talk about how to write installers. I don't know if we're going to get to
that today. Maybe we should do that next week. Let's talk about that. Do we have time? I don't
know if we're going to have time. We still have to get through the other configuration files and
it's, oops, wrong system date. It's four o'clock. We're supposed to, we're going until six though,
right? We're going until six. I get that right. We just changed the time recently. That's why I'm
wondering. So, yeah, we're going until six. Okay. So, we have time. We have a lot of things that
configure. So, let me, let me, let me put that on the list. We need to put linking.
We're going to put git. We're going to put gh. We're going to put github. We're going to put
linking, ln, and we need to do installers. Got some installers if you want them. And we will
justify why. I don't want to get into that right now. Let's finish going through the bash receive
file. But yes, I have custom installers for everything because there's no less than six
ways to install most Kubernetes things. And you have to pick the way you want to, you know,
do that. Sometimes it's just adding it to an app, you know, a list of stuff to app get.
And other times it's not. So, I, this has been a problem. I'm, I'm repeating, I'm going to repeat
myself tomorrow next week. But this is, this is one of my, my, my main concerns is, is I want to
be in charge of how something is installed on my system. And I like the package matters and stuff,
but let's take Go for example, right? And depending on where you install it, you're going to get version
16 or 17. You're not going to get version 1.18. So, in order to get a 1.18, you got to do some
extra things to make sure you get the right one. You can try to customize an extra, you know,
get repo, an extra, you know, app repository in order to get the latest one to do app install,
or you can just write a minimal script that curls down the right tar ball and, and un-tars it to
the right location. And so the ability, this is why we did batch scripting, my friends,
before I wanted to do anything with configuration. Because, you know, if you don't know how to do
basic batch scripting, you're really going to be lost when it comes to automating yourself, you
know, and configuring your life in Linux. And, and, and that includes writing those installers. So,
we covered that over three weeks. So, hopefully you've got at least enough batch behind you to
understand what we're going to be reading. All right. So, let's go back to the container and
read the default batch rc, which I just copied over here. And let's break this down line by
line as we were going. All right. So, the first thing you see is a shebang line that has just
the word bash in it. And this is for one purpose only. This is to tell my VIM, or any VIM, whether
or not VIM has been configured yet, which is kind of the point, that it's a bash file, right?
Dobb bash rc is not by default recognized as a bash thing. And of course, you could always do set,
you know, ft equals bash here, and that'll do the same thing. But that's just a nice convenience.
It works everywhere. It does not actually evaluate it at all. It's just a thing. You'll see pro people
doing that too. Some of the people will do that. This next line is the default line that's read by
shellcheck to disable certain checks that I think are dumb or stupid or overzealous. And I turn that
off. And I haven't run shellcheck on my... I'm kind of embarrassed to run it. I don't want to do it.
I haven't run shellcheck on my bash rc in a long time. I am regularly changing my bash rc and
not running shellcheck on it. I probably should. So anyway, and then we're on to the most important
piece of the beginning of this, okay? And this is what allows you to have a single file instead
of all those other files. Remember all that talk we said about login and interactive shills and all
that stuff. Well, here you go. This is one of the most cryptic things any beginner will ever see.
And I, to this day, still have trouble understanding what it is. So we're going to unpack it. But I
want you to know that all it's really doing is it's detecting whether this bash rc is running
from a login shell or is it running under an interactive shell, okay? And if it's running
interactively, then it continues to work. If it's not running interactively, and this is, we were
talking about this before, we're kind of bouncing around the topic. Sometimes you don't want all
of this to run, right? So if it's running interactively, I want this bash rc to run. If it's not
running interactively, I want it to end immediately. I want it to stop working. And I want it to
return, right? And if you don't do that, then every shell script under that is going to run the
bash rc file. And I forgot about the nuances of this, but that's what this is doing. This is
ensuring that, and if I think, if I remember right, I think, I think no matter what, well,
that's not right. Never mind. For a version that might not be a part of a package measure repo.
Yes, that is part of a problem. Yes, that is very true too. And you stick a list of packages
and you have an app. No, you can't, actually. Yes. Animation first approach, yes.
Pretty soon, not manual action. Yeah. And another thing too about writing install scripts,
and I'm going to talk about that at length next week, is I regularly take those install scripts
and copy an install script over to a system I want to put that on. Or I copy that install script and
I put that code into a Docker file to create a new Docker image. So there's lots of reasons to
isolate your stuff. I've tried to make my own package management systems before and stuff,
and at the bottom line, I just broke down and make individual scripts and make
somewhat logical break up here. So all you need to know about this is that this says
return right away unless this is an interactive login shell. And you can actually look at,
I don't know if this is going to be covered here.
We're going to have to go look for that. Whoops.
Let's go see what actually dollar that actually does. Say what does dollar do in Linux?
Golden images or VMs? Yeah, I don't, but the things change too much. It changes too much for
you to modify your VM that often. It's way too tedious in my opinion. So anyway, Linux terminal,
so we got all these special things, right? These are all the arguments, like what the argument
numbers are. Actually, I'm trying to look, I'm trying to look for the actual explanation of that
thing. I know you can just echo it by the way. It'll tell you all the things in it, but I've never,
these are all of the commands that have been set for the current shell.
Yeah. So yeah. So you could do, I'm trying to find,
I think it's options. I should know this, but I don't know this.
Dollar, it's preceded by dollars per instance. I don't know what dollar dash.
I think we have to escape it. There it is. PS1 is set and dollar dash includes I. Oh, there we go.
Here we go. Oh, look, look. A login shell. The good reason I read the bash man page. A login shell
is one of the first characters of argument zero is dash or want to start it with dash,
login option. An interactive shell is one started without non-option arguments,
unless dash s is specified and without dash c option, blah, blah, blah. So PS1 is set and,
so you don't even get a PS1 unless dollar I includes, unless dollar dash includes I
if bash is interactive. So this is how you can tell if it's interactive. And let's go see if we
can find the next one. The current set of options, there we go. Here we go, here we go, here we go,
here we go. So, signal the end of options, okay, cause all rx to be assigned.
So here's all of the options, right? So we have hset, location of commands that are set.
So I guess it's all the commands that all the options that were passed the bash. I've never
really looked. The options are off by default unless otherwise noted. Using plus rather than dash
causes the options to be turned off. The options can be can can also be specified as arguments
to the indication of the shell. The current set of options may be found in dollar dash. The return
status is always true. Interesting. So dollar dash tells you all your options. Yeah. So that's
interesting because some of them are just indicated by a dash, you know? So yeah, very cool. Anyway,
so this is how you check if it's interactive. And this is pretty much code. Hi Matt. So this
is code you're pretty much going to need to write no matter what, right? This always has to be there.
All right, let's go on. So, distro detection. So this is something I actually had a very exhaustive
distro detection section at one point. I was checking the unames for Mac and all these different
versions and I deleted it all. If you go back in my .files and look at the history of that,
you can find that. This is actually dead. I don't do WSL2 at all anymore, so I would take that out.
But if you want to set a variable or, you know, back to this is why you know bash, right? If you
want to set an environment variable that contains your distro, you can do a little bit of detection
and then you can have a single bash RC that has conditional logic in it for the different distros.
Um, I am so regularly on the one two server and potentially in the future if Fedora or,
you know, Rocky or something that I really don't care. But I also have a bash RC that's
that I run on my Mac. But I stopped caring about that as well because I started running VMs and
just using Linux everywhere. So in order to simplify my shell, I added this uname. Let's look at uname.
So, uh, let's see. I use a uname to see info about the system.
Um, so you name and there's LS, uh,
LF or whatever, not LF, there's no unames pretty common though. So you name,
yeah, you name dash a, this gives you basic information about your system and we'll just,
I'll let you read about that on your own. So you name dash R gives you, I think the,
what is it, the distro? Oh, it gives you the actual version. Interesting. And I noticed
a WSL. If you do that, you get Microsoft. It's so weird. I would put that, that doesn't make
any sense. Uh, at one point I had all the rest in there. I deleted them all. And yeah, because
Darwin, if you're on a Mac, it gives you Darwin if you're on, you know, whatever, uh, local utility
functions. So these are some functions that I wrote. By the way, if you're going to do an
inline function in bash, you're supposed to have a bash already. We just spent three weeks on it.
Okay. So, um, if you, I put underscores in front of things that I want to be private,
I just do that no matter what. Just to remind me visually. Um, so this, by the way, we didn't
talk about this before. This, this is a, this redirects both, uh, standard error and output
at the same time. It's a bash four plus ism. And you can do one liners, uh, functions if you
put a semicolon in there. You got to make sure to put a semicolon in there because that serves
as a line return, right? So this is probably not the best as probably use command dash v here,
but that would be only if I wanted to command. So type says this is, I just have this to check
whether I either have a function, alias, or a script, right? If I have any of those three
script in the path, if I have any of those three, that will come back as positive, uh,
source if, so source if says if the first argument exists, if it's readable, uh,
if it's a readable file, then source it. And what does sourcing do? So we haven't talked about this
in bash before, but I'm going to go through it. So sourcing, which is either the word source or
a dot by itself, uh, literally this does the same thing as if you typed every line of the file at
that location. So it's not like import in Python or something like that. It's the same thing as if
you had actually typed those lines at that location as is. And, um, it's very essential in your
bash or C file. It's also a really big source of security flaws because somebody who makes some
stupid app out there is going to say, just source this and you'll be good. And they don't even have
you look at the code. Cobra does this. It's one of these dumb things that does this. And we'll get
into that a little bit later. So, um, environment variables also see NVX. NVX is a command of mine,
um, that helps me manage environment variables without having them be hard coded. Uh, hey, how are
you? Uh, what's that? I remember to test for interactive to use the test command itself.
Uh, that's another way. Yeah. That's another way to do that. You could also do that for sure.
Yeah. And that's, that's actually how I, I test for interactivity in, in other applications.
Um, I think that the way of using dash T, uh, of using, uh, I don't use single brackets,
but if it's just, you know, um, I think you can use that as well. Uh, if, if you are, um,
I think you could do that on any shell, not just bash. So I've seen both of these.
Uh, I actually do that very thing in my bash code too. So they're both work. This is the reason
this one is here is I'm pretty sure this one works, uh, in shells that are not bash.
Can I get that right? I think it works in POSIX as well, but I don't remember. I've had this this
day for God since the nineties. So the, the, this, what this session, what this does, by the way,
everybody, Klondike is repeating something we talked about earlier. This checks to see if the
terminal to which the, the running shell program is connected. Uh, if the standard output, which is
zero is going to a, is going to standard output. I mean, if it's, if the program's output is being
sent to zero, which is standard output, if it's not, then you know that it's, you know, embedded
inside of something else. Uh, seashell as well. Does it? Yeah. So that's interesting to know. Yeah.
So, uh, I, I think this might be a better answer. So you can say that. Thank you for
bringing that up. Yeah. I'm going to put that in the notes. Uh, when to use, uh, dash t zero, uh,
versus, uh, case. So yeah, that's, that's a good thing to know. I don't think I really, I mean,
I honestly didn't know that until today. I mean, I, I knew that it worked on bash, but I,
and I suspected it worked on AT&T and other stuff, but that it's hard because I've been around for
a while. So I don't always remember whether it works on AIX or whatever. And this, my original
bash RC was created to run or it wasn't even a bash RC originally. Um, and it was just,
you know, whatever. And it was originally designed to run, to run on anything. It's very much of
just bash now though. All right. So here we have a number of environment variables. Let's go through
these. What time we got? So I'm just going to power through, uh, my friends. So this is using the
default sort of thing. Uh, it's a little bit redundant because, you know, I could have just done
this, but this says set the user to the user. Uh, we're going until six map. So, and then it's
just me at home eating food. I'm not going to do anything fancy today. I got, I'm, I'm chill.
I got my jammies on. I'm making YouTube videos with my jammies on. That's how shelly I'm doing.
Um, so user equals user, whatever. And then who am I? So this actually runs the command
who am I? And gives you the current, um, effective user ID. And you can read all about it here.
Uh, what's the difference between effective user ID and user ID?
Right. I think I could have used an environment variable for that, but that's a reliable way
to do it. The reason I want this is so that I can set these things up. And, and if I'm running
as a different user, uh, my, my brash are still work, right? These are all exported. Why, why am I
exporting these? Somebody, somebody give us a quick and dirty answer. Why am I exporting these
variables instead of just setting them for this file? I mean, we cover this as a bit of review.
I want to just do whatever, right? We're exporting them because we want any program that uses this
shell, which is every single program after the shell starts to use them as well. So that means
when I run any program at all, uh, that starts from the shell as the parent, it gets it. So that's
we're putting double quotes around everything for safety because she'll check told us to, right?
We don't want people doing crazy things there. Uh, I'm setting a repo directory. I, I personally
think it's good to have your get it. We'll talk about the get up stuff next week, but I personally
use a repo directory and put everything in there. And we'll talk about that a lot. I have a dot files
repo, which links to my GitHub repos. And then, um, I can use that as a variable as well.
I've added some other ones, some snippets and scripts, my help browser, you know, these things
keep growing. Um, I have documents downloads and templates and things because not everybody wants
to name them the same. And I have those pointing to other things, public and private, my pictures,
music videos, PDFs, virtual machines, all stuff that I've just come to use for my other scripts
and stuff. Uh, is that directory? This is a big thing. This is, you know, for my notes and stuff,
my Zettlecast back when I was doing videos to go with my Zettlecast entries. I don't do that
anymore. Um, my clips directory, which makes me very sad because I can't run my clips now that
I'm doing terminal only. I need to figure that out. I'm going to do that. And command clip. This
stuff is all old. I need to get rid of it. So here's a very controversial one. I'm setting, I'm
explicitly setting the term to X term, two to six color. And this, this is highly controversial
because it's not necessarily a two to six color terminal. And I don't want to go down the rabbit
hole of terminal color right now. Uh, when we do some of our coding and go, we're going to be talking
about escape sequences and terminal colors and, and, and dealing with all of the ANSI terminal,
you know, standards and everything. And so we're going to talk about that. But if you want your
two to six colors to work, you have to do this. So if you're going to run things like sunrise,
which, uh, I know it's like, you see how it's kind of the colors are not completely on.
It's kind of because there's, there's a millions of colors set, right? So we'll get to that.
HR rule is my own rule with, uh, 73 total, uh, editor VI visual VI. This is your editor, uh,
editor prefix VI, uh, my, my private binary key. We'll talk about the go environment variables
later. Uh, these are really important, but they're not, we're talking about it all right now.
Uh, Python don't write by who I used to have a really derogatory comment right by the century.
If you go through my history, you can go find it because I hate it. Who made this? Who picked
this name? I'm a stupid Python programmer. Um, so anyway, LC Coal 8, this makes all of your sorting,
uh, use the C method for, for, for sorting and you're going to want to set that for everything.
Um, the C flags, this is just for C compilation by standard flags. It just uses them. We're not
going to do any of that until maybe Christmas. We'll go through the C book pop possibly again.
Um, and then here's some fun stuff. Okay. A lot of people don't know this. This,
this is something I didn't find until my forties and this is, this is based on,
this is how I get terminal color, right? So when I'm doing, when I do man LS,
I get colors in my LS, right? And people will tell you to use some other form of man or,
you know, they'll install this or that program. All you really need to do is use the historical
support for term cap, which is a way of communicating what type of terminal you have
to everything. Now that's terminals have been really, really standardized at this point. Um,
so these settings are not as significant, but you can go in here and we're actually putting in
the codes for the colors, which again, we'll get into when we do go programming and you can set
them. You can set them. And once you set them, anytime you do anything that uses less or more
or anything that, that uses, you know, trough and rough, all the stuff that does that rendering,
you'll get color. So if you want color, that's how to do it. Ansible inventory.
This is something left over from Ansible that I don't even know about. There's my good old
Docker UNIX host, which I hate. We're not going to talk about that right now. Vimspell.
We'll talk about that when we talk about Vim configuration after this.
This is pointing to your spelling, your spelling dictionary.
GPG, GPG, TTY. I don't know about that one. We'll have to go look back at that when we do GPG.
So pager, this is important. This checks to see if you have less pipe enabled.
If you do, it makes it so your pager acts better. That's all I can say about that. Let's keep going.
Dure colors. Okay, this is super important, right? If you want color in your terminal
on the LS command, you have to set up your Dure colors. All right. So let's do that. Let's look
at that. So Dure color. And if you think that I typed this by myself, you would be vastly mistaken.
So I have taken somebody, I love that. This is such an old file. It actually has something
that shows you the colors when you set them. Isn't that cool? So this is an ancient, ancient file,
a .dure colors file that you need to go in and set. I don't even know where I got mine.
I ripped it off from somebody years ago and I have been tweaking on it ever since.
But this allows you to set the colors for the different type of files depending on your terminal
color. And if you want my terminal colors, I've already told you you can go get those in my .dup
files. But this is how come that when I LS, I get files that look a particular way. I go in slash
proc LS, that you see some of those files, they look a little bit different. I don't see any
FIFOs though. Where would they be? Maybe in slash dev. Yeah, look at all those weird different
colors. See, I might actually want to change the the TTY color scheme now that I'm looking at it.
I haven't ever invested a lot of time into it. But, but yeah, that's that's where you would go
do all that stuff is in your .dure colors. This says dash R says if I have a readable
.dure colors file in my home directory, then evaluate .dure colors dash B home home colors.
And that means evaluate you had to be very, very careful with. Evaluate says,
take run this command. See how it's in quotes. It actually runs that command at that location.
All right, it's not the same as an import. It actually runs the command and you build up the
command as a string and then you run evaluate the string. Eval is generally considered to be
really, really, really bad. And you don't really need it in bash. There's another way to do this
using a here variable. I mean, not a here variable, a file descriptor replacement,
and I probably should update that. But this works on any shell.
And like text backgrounds. Yeah, you can use any kinds that you want.
I've left this as an eval because this this particular code right here works on any Unix
or Linux system. And if I were to do some of the other fancy batches, and there would not work,
so I left it that way. And it's just that that makes it I love color. Yeah. So this is some
pretty amazing magic that I discovered on the internet two years ago, actually. And I will
never ever go back. And I cannot tell you how cool this is. I'm running out of steam. I've been
talking straight for 43 hours. How much time we got? Are we are we this one's going to take a while
to talk through date 427? Man, I haven't been taking any breaks. I'm just going to keep going.
I want to get through these configs today. Alright, so I mean, you got you y'all can
stop the video, right? So if you need to stop it. So a couple things here. First thing I want you
to see how the functions have the pattern of a function definition body, and then at an export.
I know I need a coffee break, but I'm not going to take it right now. I'm actually really hungry.
But I'm I'm going to go through the six. So maybe after this bash RC, and then we'll do
them RC after this. Okay, I want to get through this file. It's going to take a long time. This
is like 800 lines long. So so here we have where this I don't the convention I want you to see
here is we will soon. Yeah. See here, it says and export path append. If you don't do that,
then this says, conditionally, if if there's nothing wrong with the syntax of this function,
then export it so that sub bash shells can use it. Okay, that's what this is about. That's what
that convention is about. And this is the way you should do it. And this is a bash only thing.
You cannot export functions from Z shell. And exporting functions in bash was the the cause
of shell shock or bash door. If you want to go do the research on it as the biggest is the biggest
Linux bug in history, some say they refer to it a Mr. Robot actually shell shock was called.
And what it did is it allowed people to define functions just by setting setting variables
because they they had a problem. And that's been fixed for more than a decade. And so
that's not a problem. But the ability to export functions in bash is one of its most powerful
and most controversial things. But that's what that's that's a function that's doing that.
So this says for all the arguments that we've talked about that, go ahead and check them.
And I'm going to go through this logic. And then we're we'll take a break of this.
So path equals so again, the path is a variable, an environment variable path, right?
Echo path. Here's the here's the short. Here's the actual version.
The path is a variable that contains in order every directory to look in to run a program.
So when I do which LS, it tells me Oh, it's user bin LS. Well, we see here,
user bin LS, oops, user bin LS is one of the directories, right? If I were to put a program
called LS up higher in the directory path, that one would resolve first, which is one of the reasons
I don't like using user bin ENV Python or bash or things like that, because user bin ENV
can be defeated by messing with the path locations of things. If you if you want to own somebody,
put something that they use all the time. And if you get access, put something in a path above that
and watch them get very confused, because, you know, it'll run that instead of what they think.
So and you'll do that to yourself a lot too.
So what this script does, what this function does is it adds something to the end of the path
if and only if that thing exists, right? That thing that thing is not already in the path.
That's what this is. That thing doesn't already exist in the path. And it also actually exists
as a file. So the test that she says, if it doesn't exist, we're going to skip it, right?
And this is why when I added that new Z bin, and I tried to look for it, I couldn't find it and
I had to rerun the shell, because you don't want to unnecessarily clutter your path with
a bunch of paths to things. So I'm a huge fan of this approach, because it only updates your path
with stuff that exists. And because if you have something in your path and somebody sees you
have something in your path in those little directory there and they can access, they can
just go put whatever they want in that directory. I mean, they have to get, you know, they have
to escalate privileges to do that. But still, it's just not wise to do that, right? You shouldn't
be putting anything in your path that and you can actually append to the path. The other thing
that's really great about this is let's say you have a script and you want to add a new path just
for the sake of testing, you can run this from the command line, right? So I can go over here and
I can say so path, right? And he gives me my path and I can say, well, what's my current directory?
Okay, well, that's not in the path. Let's temporarily add it. So I can say path prepend path
prepend dot, right? And now when I run my path, I can say, okay, so let's say that I'm running a
bunch of stuff in this directory, right? So, you know, like echo, echo, hello, hello, world,
do, hello, schmox, hello. And now I can run hello and it will see it.
At least it should see it.
What did I not do right? Oh, whoops.
I had an infinite loop. So there we go. See how it ran it without me doing the dot slash?
But, but, except bash, I think it actually is going to remember it.
Yeah, it still did. See that? But it put the other stuff in front of it. That's interesting.
Hmm. That's really interesting. So yeah, but you can go ahead and remove it out of there if you want.
So anyway, if you temporarily want to add something to your path, you can just type that
and add it. It also prevents you from adding, a lot of people who are in their scripts, what they
will do is they will add to the end of the path and they'll just keep adding to the end. And so
you'll end up with a path. Every time you rerun your shell, you end up with a path that's got the
same path in it like 40 times. Right? So, so this fixes that. And I encourage you to study it and
look at it. Another cool thing about this is that, I don't care if you can see this here, but this
adds any command that I have. So I can actually make a GitHub repo and it will look inside of
the repos. And if it sees anything in there, it will add that directory to the path automatically.
So this allows me to, some of my bigger commands, I can put them in their own git repo and then
they get added to the path automatically as long as I put them in the right place.
And then we have all the, all the regular things here, open gdkbin and my scripts directories last.
And again, we have the path append here. So this is my append path. I put all my stuff. This is
relatively new additions. I put some of the virtual box stuff up there because again, I can run this
on git bash or WSL too or whatever. Right? So I can, I can do some of that stuff ahead.
CD path. Okay. So this is the last thing we're going to cover for a bit before I go get some
coffee or something. So the CD path is by far the most misunderstood, not known thing in bash.
Anybody who comes at you with, I want, I want to be able to do, I want to do fuzzy finding
and tab completion on my paths. And, and I just love how my Z shell just reads my mind when I
want to change directories. They don't know about CD path. It's very poorly documented, even in the
bash man page. And it's considered unsafe by some people. And I want to talk about it fully
before we get into it. Because of that. So CD path is a special environment variable,
which for some reason doesn't even show when you try to echo it. It doesn't even
display. I think it's a bug. And I mean, you can't do this. You can't echo CD path.
It doesn't work. I don't know why it, wait, that worked that time. I must have lied. Oh, well,
I lied. I didn't work before I was wrong. I must have been doing something wrong. So the search for
path for CD, this is a column separate list of directories that the shell looks for destination
directory specified by the CD command. A sample value is dot. And okay, this is the part where
it gets controversial, right? There's like that never, never, never put dot in your path, right?
Why? Because you don't want people running stuff in your current path. You want to make sure you
put it in a safe place or make them type dot slash, right? But when you're talking about cd-ing around
to different things, you always want to include dot colon is the first. And if you don't, it's really
funny. If you don't, if you, if you add a CD path and you don't put that, you'll type cd to go into
something that's in the current directory, and it will take you someplace completely different
based on the rest of the path, because it won't let you change directories into anything in the
current directories. Very, very, the first time you do it, and I did it, it was, it's pretty freaky,
triggers it out, you know, freaks you out. So, so yeah, this says, this says, I want to look in my
current directory, I want to look into my home directory, or I want to look into the user directory.
And if you look at my CD path, it's pretty complicated. I actually build up a CD path.
CD path. I build up a CD path that contains my dot files, my common directories. And this is how I
can get away with this. So, I can do CD scripts, right? Look what it took me to. I was in my home
directory, and it took me right into the scripts directory. And, yes. And it does add to the length
of letters to type different, differential out of directories. I don't know, it depends on the
directories. I don't have that many places I go. No. I mean, yeah, I mean, what would you do?
You could just do CD scripts tab, tab. And I can just do that. It does tab completion.
So, I don't know. I like it because I don't have to install anything. And people that like to install
extra fuzzy finders and tools and stuff like that just exhaust me. I only want to install one RC file
and one monolith script, I mean, command from now on. I don't want to have to install scripts
or untar a whole bunch of stuff. I want to minimize the amount of time it takes me to set up on a
remote system or any system. And that's my priority. So, people have different priorities,
and that's fine. So, yeah, I would encourage you to look at CD path before, you know,
reaching for Z shell, which is a horribly flawed shell on several counts. And we'll just burn
into your muscle memory things that I think are bad for you. Seriously, a lot of my best friends
strongly disagree with that statement, but I'm telling you what I think. Having any friction
using CD path. Yeah, particularly because it's for an interactive process. Setting up a CD path
in an actual script would be interesting. You'd only be able to CD into that thing. You know,
you could actually export CD path into a runnable script and force it so that directory could
never go in any of those, but those paths, which is a nice security mechanism that's consistent
with what we used to do with path by explicitly defining paths at the beginning of any script,
particularly in system scripts that are shell scripts that run at login or the running is
rude or something like that. And we talked about that a lot during the show programming days.
I don't want to get rehashed, but people that write shell scripts these days are just like
totally lazy when it comes to security. They use use of an ENV. They don't care where they are.
Sometimes they'll put dot slash in their path. I mean, they just they're just lame. And it drives
me nuts because there was a time when we actually cared about security for these things. And you
just don't see that that much these days. So yeah, a good old days, right?
You can have complete a lot of directories. So CD path can give you unexpected completions.
I don't think it has ever given you an unexpected completion.
No, it gives me because I know where my directories are. Yeah, it there has been a time or two where
something resolves ahead in priority from another thing. And in those cases, I just CD into one of
the top level things that I'm fine. So for example, one of my favorite commands is this,
cdgithub.com. It's like, okay, well, now, now what do I do? Tab tab, right?
CD tab tab and I can get I can do my own all my other stuff. So I don't I think the reason I like
it is because I'm no less fast than people who use any other type of tool. And I'm 100% compliant
with bash on any system. So, you know, I if you I don't believe in adding a dependency to your
muscle memory or that has to be installed without there being a good reason. And if there's something
that's good enough, I'm going to give it more weight than some extra shit written in Rust by
somebody who wants to replace, you know, whatever. And that's why I use VI, you know, instead of,
I use Vim, but you know, that's why I don't use any of them. So anyway, so here's a check. Here's
the options. The options are going to take a while for us to talk about. And so is history. So how
much how much more we got? We got a line 150. Okay, so we're halfway through. I am going to take
a break, though, because I am stop. I'm going to stop talking here. Simplicity is undervalued.
I do think simplicity is undervalued. And I, you know, I'll end with this. But I the thing that
annoys me is that so many people, I don't know if it's an age thing. But I think when you've been
around longer, you start to value the simplicity more than you do your ability to show off
something. I don't know if it's an age thing. I don't know what it is, but but I find it unfortunate
that that sometimes people who choose simplicity who are very capable of using a very highly
complex method, they've just chosen the simple one are judged as being simple themselves. And
you know, I don't have any specific cases to talk about here, but I do feel I feel like that's a thing.
Yeah, we're going to take a break. We're we're not going anywhere, though. We're going to be here
until six tonight. And I don't know, maybe I might catch the sunset. We'll see. So I'm going to put
the timer on. I'm going to take eight minutes. I'm going to go make a smoothie. And we'll be back.
I can't turn music on for you, though, unfortunately, because the music will be
recorded. And I can't I can't do that. Can I do stop kind of pause recording? I can do pause
recording. Oh, my gosh, I'm going to do that. All right. So unpause pause recording. Okay.
So it looks like recording again. All right. So it's auto tnara. And now it's auto tnara. We're
just talking about music, my friends. We were just going we were just we were listening to the
killers and and, you know, different people. There's a playlist called she's still preoccupied
with 2005. It's kind of a play on the 1985 thing, right? And, you know, it's just crazy to me how
an entire decade has gone by a decade and a half since this music.
I know it's making me feel old.
But it's time to finish up our configuration and have some fun tonight. Later on,
I'm not going anywhere. Just in case you're wondering, not even the sunset tonight.
Okay, maybe the sunset looks pretty. We'll see. American hip hop. Yeah.
We can talk about music forever. Come back if you're on the YouTube watching this right now.
Come back some other time and have fun with us. We we have a lot of fun over on Twitch.
But you don't want to hear about that now. You want to skip over. Okay. What are all these
shield check options? And where do I read about them? I'm going to confess something right now.
I only know what two or three of these actually mean. And I have to go look them up every time.
And in no glob, I remember finding this problem. We want to cover no clover though.
I think no clover is an important one to cover. So first of all, how can you even look these up?
I don't recall. So let's go look shopped. Help shopped. So shopped is set on unset shell options,
changing the setting of each shell option, which takes the name dash O.
Well, how is this different than set? What is set about? Because I use set all the time.
How is set different than shopped? I know my club service. Yeah, we'll talk about those ones.
Is it on site for a project at work? Really? Oh, that's so kind. Thank you for saying so.
That makes me very happy. I'm going to make it better. I'm going to make it better.
We're going to make it so you can do pipes within it if you want. Anyway,
stay tuned for bonsai programming. I may do some of that tonight, but I'm not promising anything.
All right. So what is the difference between set and shopped? I have wanted to know this since I've
been doing this for years and I still don't know the difference. So what is it? So set that show
VI, which we'll get to, is a thing, right? And set our unset values of shell options and
positional parameters. Change the value of shell attributes or positional parameters or display
the names of them. I mean, seriously, I still don't get the difference. I want help here.
What is the difference between set and shopped? I have never known. They're both in there.
Change the setting of each shell option op name.
Set an unset shell option. Should we try it? Should we try it? Let's try it. Let's do,
let's do a, well, let's see. It has to be a bash. Let's run a new shell. I'm going to try
something here. Let's see if we can actually set the VI as a default shell command editor
with this. I mean, X, right? Experiment. Let's experiment. So run it. What are we going to run?
We're going to run it and remove it. We're going to run it one, two server
and see what we get. So, so there. So shopped dash O. Yeah.
It shows you what the value is. What? Set that show. Yeah.
All right. Oh, look at that. So set changed it and shopped just told me what the value was.
At least dash O shows you what the value was. That's interesting. I did not know that.
I did not know that. All right. So, so, so I'll put that in here in the notes.
Uh, use shopped dash O to see the value of a shell option and, uh, use set dash O
to change the value of a shell option. Kind of cool. Are you found a stack exchange thing?
Uh, what were your search terms? Cause I refuse to use a graphic browser. It's against my religion.
So set and shopped Y2. You know, I hate it when I have to admit that stack exchange is useful
sometimes. I really hate it. Good old Google. I used duck duck O so there. I at least I didn't
use Google. Uh, okay. So what are we reading here? Um, is set and shopped are both shell
built-ins that control various options. I often forget which ones as well. That's the question.
Okay. Uh, I tried looking at the second line of help set and help shop if I had to verify that.
We just did that. Don't tell me what I already know. Don't tell me to RTFM.
Uh, in bash release it says set or unset values of shell options, personal values,
and set and unset shell options. This is not helping me. Uh, as usual, the first answer is wrong.
As far as I know, the set dash O options are the ones that are inherited from BornStyle
shell. Ooh, now that would make sense. That would make sense.
You're right. Never the comments is strictly speaking. Yes. And the shopped options are the
ones that are specific to bash. That makes a lot of sense to me. It seems intuitive,
even though I don't see enough proof that that's true. There's no logic that I know of.
Uh, any documentation are shopped. Well, there are set to show options like blah, blah, blah.
Uh, it's probably the idea. I don't want to hear probably, I want to hear what it is.
The difference is it changed environment variables. The difference is in the changed
environment variable used by bash setting with a set command results in shell ops while
shopped results in bash ops. And there it is. And that is worth quoting.
That is indeed worth quoting. Yeah. I don't know. We'll figure it. Okay.
Um, okay, uh, grok the difference between shopped and set, which boils down to set being, uh,
legacy and shop being bash. I learned something today. Did not know that. Did not know that.
Um, so yeah. Yeah. Okay. So anyway, all right, we're done. We're done with that part anyway.
Next. Uh, okay. So what is check wind size? I don't even know how to look these things up.
I think we can do it in the man page though. Let's do that.
Can we do that in the man page? I think we can. I think we can. I think we can. Um,
um, help shopped access for any op name. All right. So scoop it up.
I'm the scat man. Who played that the other day? It was so funny because I'm always doing that too.
Cool story too for the scat man. Did you know the scat man actually had problems
speaking and then he'd made the scat man stuff nice famous because he's a scat man.
That's what happened. That's the story.
A little, a little, that's the coffee. That's why I'm getting like this. Okay. So
shop, I have no idea how to look it up. Man bash. When in doubt, man it out. Man up.
Check wind size.
Columns. Columns used by the select compound. So columns is a variable.
Automatically said, if the check wind size option is enabled,
are you telling me that we don't get columns and rows without the check wind size option?
Oh, I'm going to actually put this in here. Wait, no, I'm not. That's a container.
That would be, that would be non productive. I'm going to put this in my own bash receive because
reasons. I like, I like making my bash rc into like an instructive assistant sort of thing.
So even though it's an extra line that parts shopped is for bash ops set is for shell ops.
I think shell was actually a dollar dash as well.
So check, check wind size.
Enables columns and rows. I'm going to check this. I'm going to check this. I know that
we're going over time, but I don't care. I mean, we're not really, but I want to check this.
I'm going to check it right now. So there,
Docker run dash it anything really that has to be, it has to be bashy. So let's do one, one, two,
dash, dash or one, two. This is why I do like having Docker around because I can try different
distros out really quickly. I could have done with Cali if I wanted. So echo columns.
Oh, look, we have columns. Yeah, I wonder if we have, let's see, echo bash ops.
We have check wind size set by default. Interesting. So I didn't really need to put to
set it. It's kind of a built in, right? How do I turn off shopped?
I mean, shopped, what dash s, what's the opposite of dash s?
I don't know shopped. I'm learning it. So there,
enable, set each shop name, disable. Okay, set that show. We know that one.
I know unsets for variables, right? So, so let's try.
I mean, shopped dash. I've never done this before. U for unset.
Check wind size. I want to know. I want to know.
Now, shopped dash. Oh, check wind size. Gosh, dang it.
What the heck?
Check. All right, shopped dash you. Check wind size.
Uh-huh. Do echo bash ops. It's off now. Echo columns. I bet it's already there though
because it was already set when it logged in. I see it told you. I told you. So how do I not have that?
Exec bash to show. No, because it's going to log in and it's going to set it again because it's
going to run through the bash or see. Uh-huh. I mean, what if I did this? What if I said
bash or see? No, Vim. Oh my God. Oh my God.
I don't know why I'm doing this. Set emacs. That would be a no.
I can't believe they don't ship with Vim anymore.
They want that thing tiny, I guess. Okay, Vim. That's Vim, I promise.
Uh, bash or see.
Where's all the stuff?
You know? All right, all right, all right, all right. Hissapen, there it is.
This is a bunch of server container. Check wind size. Now what? Exec bash dash U, L.
Now what? Uh, shopped. Oh, check wind size.
I, that's it. Echo bash ops. Dammit.
What's happening, people? Okay, so let's say
shopped, no. I'm staring at you. And why are you saying that it don't exist? Because I am staring right at you.
Oh, I know. Wait, I know an option name. Which is, I only do that with like a VI?
Oh my goodness. What do we have here? What do we have here?
Shopped is, uh, fine. Man, shopped.
Help shopped. Oh my god.
Uh, oh, restrict op name. Oh, look at that.
I thought I was just going to print. Print HTML option with an indication of a status.
Ooh, that's what I should have done. I should have done that one. Let's see that. All right.
You ready? Ready? Shopped dash P. Wow. My goodness. I did not know that was the thing until today.
I like it.
Look at all those things. Look at all those thingamabobs.
Yeah. All those great options that are set on the shell.
Last pipe. I mean, some of these you actually want to, you want to set, but I think most of
them you do with, with, with, with the set dash. Oh, I think. Um, I think, I think shopped is like
set on steroids. That's what I think it is. I think shopped is set on steroids, but I can't
say that for sure. That's enough for my curiosity to be satisfied. All right. So let's move on.
Shopped is a thing that sets options. There's probably a shopped variation for no clover.
I probably could put no clover here without using set dash O. I know that set dash O works on any
system though. You know what I mean? Uh, unsaid. Yes, they're unsaid, but did it say, did it wait?
Shopped dash P. Was there like a no clover there?
No, there's not. No.
What?
What? No, that's freaking me out. So, okay. So apparently,
all right. All right. All right. Set dash P. Man's set. Help set.
Um, turned on whatever the real effective user needs to do the match. Look at all that stuff.
Oh, this is the one where it's like all smashed into each other.
Sim is dash C. This is weird.
Simifined. I think these are the things that are in, that are in the opt variable. That's what I think.
Instead of the value of the variable,
all assignments, job controls, enabled, read commands, set dash O. This is what I use all the
time. This is how you turn VI mode on and we'll talk about that in a bit. In fact, I don't, why
has the VI mode on on here? Oh, I think I put it under VI. Yeah. That's a history thing. That's why.
All right. We got keywords. What else? I want to see all the options. How do I do that?
How do I, how do I run it to see all of the options?
I want to see all the stuff that's on. Oh, there we go. The current set of flags may be found in
dollar dash. Oh, look at this. Oh my God. That's so freaking cryptic. Does that mean,
watch, echo. I now, well, I finally understand dollar dash because it has like a one line
equal, look, watch, set that show no clubber and watch. Big C is going to go on. Yep. See.
I made a joke. I'm writing some code in the goal. They allow me to create and manage my virtual
machines. Nice. Using the vert. Super cool. All right. So, so, so this is interesting. So,
apparently there are two sets. I'm going to summarize their phrase. You don't have to
pay attention. Okay. Apparently there are two sets of settings for bash. There are the bash only
settings, which are set with shopped SHOPT. And there are the kind of legacy settings,
which have always been set as, as with just the set command that go back to politics,
both of which are, are, are, are contained in different environment variables. We have bash
opt, which will give you all these. And then we have shell ops, which is the long form of, oh,
wow. Are you seeing this? Okay. So shell opt is the long form of bash opt that gives you the names.
And that's very interesting. Because we had a no club, but, but, but there's also this other
old school environment variable, which just has the letters that go with the names.
So I want to see if this works here. So up here we have an H and H is what is an H is one and so
I've always wanted to know this. So I'm taking some time to figure it out. So the H hash all.
All right. So there's hash all, right? Did I pause the recording? Yeah.
Yeah, I think I did. I mean, I think it says it's some pause.
Should I check the file and see if it's, see if it's getting bigger?
I know you're now you got me scared.
Um,
I mean, yeah. Properties.
1.18 gigabytes. What the hell?
That's huge. That's gonna take forever to load that. Oh, well. Um, yeah, I'm pretty sure I did.
If I didn't, I'll just publish the volume. We'll call it a day.
Now I'll go cut out the music and stuff. All right. So never you fear.
Anyway, so I, what does the I do? So I,
I don't know. Um, you next I'll screw that. No, here we go. Help, help set.
Was I, you think I as interactive set that shy? Oh, we know that one because we already went through
the, yeah. Okay. So that is, but is it interactive dash comments?
What the hell is interactive dash comments? I do not know.
Um, you know what I'm saying? Mark variables, blah, blah, blah, blah. Option name set as
dash a all export. I mean, interactive comment. Allow comments to appear in interactive commands.
Could I indeed be checking for,
I don't, it doesn't look like I have interactive mode set to me, which is like freaking me out.
Look at this too. We have like an interactive comments here and then we have an interactive
comments here. It's totally different. Login shell. That's set over there.
Wait, wait, wait. I have a feeling that this is actually this one and not this one. That's what
I think. I think that this is, I think this is goes with bash. So I think, yeah, because watch,
if we do no clover, we already have no cover is set. We already set that one, right?
So, yeah, so no clover was correct, right? That one matches. It was capital C. That was the one
I checked. So there's capital C, right? Um, di mode should be here. Uh-huh. V.I. mode is the one I
said all the time. So let's go check that one. Exit error set dash E, which is something we should
set in our shell scripts. We talked about last week. Um, emacs style. I don't have emacs style.
So what does that go? There's like no equivalent for that one. What the hell?
Five fell positive privilege. V.I. Oh, use a V.I. line editing interface.
But it doesn't look like I can grab it from here. So there's only like special things that get written
here. This is kind of frustrating. I mean, what's the criteria, right? Like what's I? I is interactive
commands. I'm guessing there's no proof of that. M is what? What is M? M is monitor, which is on. Okay.
Some of that have short flags. Uh, capital B, is that one covered?
No. What is capital B? Oh, there it is. Brace expand. Okay. Brace expand. Okay,
then we got that one. C, we know that one's no clover. H.
Do you know how to get it? Is that a thing? Manic, that's it. That looks very interesting.
We'll try that next. Let me give you a second though. So we got B for brace expanded. C for
no clover. H is his expand, which we have. And S, S has got to be V.I. mode.
S has got to be V.I. mode, but I don't see how. You know what I mean? It's not listed here.
It's like V. Let's set brace expand and see if it'll be. I actually think it will do that. Yeah.
All right. That's that. All right. So we set, uh,
it's not unset. Unset is for variables. What is it? Set dash? What is it? Set dash something?
How's it going? Job? Job is value.
Pprivilege V.I.
Revose mode. Is it dash U? Same as the other one? Okay. So set dash U, brace expand.
What is brace expand? Can I use like the, yeah, you can.
I mean, I remember reading that. So look at that. It's gone. It's gone. It did it.
So V.I. is just not covered. I mean, it's not covered. I don't know why. It's just not.
V.I. print shell input lines as they're read. No. Turn on whatever the real thing is. Same as X.
Emacs mode. It's almost like the person who wrote this didn't want to do the other one.
Either we are truncating our help file or something.
Emacs. There's no Emacs. There's only V.I. because I set dash of V.I.
I think it's probably like a flip on or off kind of thing. That's why it doesn't have its own value.
But I don't know. I don't know. I just know that that's, there's no way to know. I mean, what's S?
What is S? All right. I'm going to change it. I'm going to change it to Emacs mode.
Uh-huh. Set that show Emacs. And then we're going to echo. I can't even use my counter cursor anymore.
And it's still S. It's still S, people. Why?
No unset. What the hell is that mean? And why isn't there Emacs mode there anymore?
Is Emacs not a thing? Maybe Emacs is a default.
Oh, there it is. Never mind. There it is. There's right there. All right. So, so,
I think the dash, the S is, whatever.
No, it's not. No, Emacs, no. It's that show of V.I.
Set that show of V.I. That's, I've been doing that for literally three decades.
So, there you go. So, it's interesting because it does not have a letter equivalent.
You cannot look it up in the show. I mean, not in the, in the small ones anyway, the short ones.
It's not there. It's not there. We noticed that because we saw that it didn't change at all when
we were changing. So, it's one of those options. It's interesting because I have a feeling that,
that it's, it's kind of in between historically the single letter sort of operate, operate,
you know, settings, and then the full shop stuff that came later.
Editor is different. No. This is not editor, right? This is your command line read line.
Yeah. It's, it's your history. It's your history. It's your history mode. So, I mean,
we're getting ahead of ourselves, but, but the history uses something called read the read line
C package and the read line, anything that uses read line, including, I mean, anything,
you know, whether it be pine or nano or we chat or any application uses the read line library
allows you to just will recognize VI motor Emax mode.
And that means you just navigate the history using VI or Emax. And the default, by the way,
is Emax because the people that wrote bash and all this stuff are big Emax users,
even though the standard should have been VI because VI is the standard Unix editor because
VI is the visual mode of X and X is the modern version of Ed and Ed is the standard Unix editor.
Emax is a bloated piece of crap that a lot of amazing people use to make great software.
It has. So, so, yeah, anyway, I mean, that was a, that was a fun rabbit hole. I mean,
that was a big X on the RWX, right? Explorer, exploitation. But I feel like I know more about,
about set and shopped. I've been wanting to know about them for a long time. So that was kind of
fun to look at. So as you can see, you can go read about these anywhere you want to.
Check when sizes by default. A lot of these are on by default, but I go ahead and set them anyway.
I need columns and rows if I want to do anything fancy with like resizing my window or anything.
Like Tim, I use those in Timx all the time. And expand aliases. This is, so like if you have,
if you have an alias, do I have an alias? What do I have an alias? What kind of alias do I have?
Do I have an alias is alias dash? Is that a thing? I don't know. I've never done it. There we go.
Alias. Oh, coin flip. Yeah, we don't have that. So, so you can do diff tab tab.
I think, I don't know. It's not working right now, but that will expand aliases in the command
line. Glob star is the thing that gets you extended glob star. Glob star gets you your star
expansion from the command line, which we talked about at length in the bash the other day.
Dot glob includes the dot files in your glob. If you don't have that, when you do commands and
stuff, they won't get included. So, so yeah, an extended glob allows you to use star star.
If you don't have that, you actually need to put that if you want to use the like 10 line
shell script to write your own static site generator with pandoc and bash.
You need to have that enabled because otherwise it won't descend. It won't use the two star thing.
That's not on by default. You know, the VIMO though. Yeah, I don't, I don't, I don't know if VIMO does.
We'll get to the VI stuff in a bit here and shop nul glob. So,
I don't remember why nul glob killed something.
I think nul glob will actually
glob even if you don't have anything typed at all. Let's go look.
So we could do man, no. I mean, we could do man bash.
Nul glob. Go back to this source. The nul glob option is set.
Let's see if, if no matching file names are found and the shell option nul glob is not enabled,
the word is left unchanged. If the nul glob option is set and no matches are found,
the word is removed. If the fail glob is set, no matches. I don't want to do that.
At the start of the name or immediately following a slash must be matched explicitly
unless the shell option dot glob is set. The file names dot and dot dot must always be
matched explicitly even if dot glob is unset. So all of this stuff has to do with globbing
from the command line. And we talked about that a couple of weeks ago. So you're like,
L is splat, right? If I do splat, splat, it does everything all the way down, right?
I do like that. It's going to do everything. In fact, there's too much stuff,
like way too much stuff. So let's go over here. So let's do this. Let's say
L is, wait, am I not in town? We need to get off phantom. All right. So let's do L s dash
dash L star. And it will give you all the directories. I use star star. It will give me
all the directories and the sub directories. And it includes dot. I think if I turn the other
stuff off, it wouldn't even give me the dot files. They would be kept out of that.
I should note, by the way, that you can set these options for the course of a script if you want
to have your script not go through the hidden files or something. You can explicitly set it at
the top of your script. And people did it a lot. Or if you need to turn on double star expanded
globs like if you're making a static site generator with Pandoc, that's something you could do for
that as well. So yeah, did I just close my container? Damn, I'm going to have another one open.
I've been trying not to do that. Oh, shit. I think I closed this one too. I think my
container is no more. Oh, well. Hey, Doug, whatever. You know, I'm getting sloppy because I'm tired.
Here we go. So back to where we were.
STTY annoyances. So STTY. So this is a really, really big one. And let's talk about this. So
just Disables, Control, S, Accidental, Thermal Stop. Somebody told me about this
two years ago, a year ago, a year and a half ago on Twitch. I love Twitch. God bless you,
Twitch. Thank you for existing. If we have any Twitch admins watching right now.
Thank you for existing because I have learned so much through Twitch just from people telling me
why are you doing that? You're dumb. And I've fixed some things. And this is something I've
never known about. So let's take a moment to show you about this. This is really,
really important. In fact, it's so important. I'm going to give it its own bullet point in the
in the in the video, right? So yeah, this is so use
STTY. We talked about STTYs and what they were. We're going to talk about them a lot more when
we talk about colors, but we've already gone through that it stands for teletype and it's
left over from the days of, you know, terminals, stuff. So disable, dental, terminal, suspend.
All right. So in order for me to explain this one to you, and I've talked about this before,
so back in the day, teletype machines, you don't know what a teletype machine is. I know for
visual interest, I will show you what a teletype machine looks like. If you haven't seen it,
you can like think about the teletype machine while I'm talking. And so all terminals are
have as origins these teletype things, right? And that's what GTY means, right? So and, you know,
their line return line feed, carriage return line feed, that whole thing was all, you know,
advanced backspace, bell. And so all of these special, you know, escape sequences that don't
print anything were designed to control the, the teletype machine. And to this day, they still
exist, right? Well, one of the commands was for when the teletype machine got too slow. If the
teletype machine was too slow and it was getting too much data, there was a special escape sequence
that it could use to say, I want to suspend, right? And what it would do is the data would still come
in, but it would suspend the data for a while and it would stop printing, even though it was still
receiving data from whatever being typed in or whatever. And there would be some sort of buffer
that would capture all that stuff. And then when it unsuspended, it would go back and get the new
stuff and read it out. Well, let me show you that exact thing happening on the command line to an
unsuspecting person who just started using the terminal. It's the most annoying thing beginners
have to deal with all the time. And I didn't know until two years ago how to escape this besides,
without exiting my terminal, right? So I'm going to try to recreate it for you. In fact, I'm going
to start a brand, I don't know if I think I've got too many fixes in place for it. So I'm actually
going to start a new terminal to Anton as boost. Let's do it. No, let's see. I'm wondering who I
could attach you. So we to boost, boosted Anton. Okay, fine. Let me go back on Anton.
And then we'll, we'll, I think we can probably, I don't know. You know, I think I'm going to be
fine over here. I think so. I think if I just, here, su-boost. Oh, no, I got too much configuration
going on. So we can't have that. Let's do, um, I mean, I, okay. So the reason I'm concerned is
because we have Tmux and a bunch of other things that might fix it for us. Okay. But I'm going to
try it anyway. Okay. So normally, if you, if you type this and be careful if you do this,
okay? Cause you're, when you do it, you might have trouble recovering. So make an extra terminal
or whatever you want to do, but you'll be typing along and then you hit control S. Right. Now,
mine goes into searching mode, right? Which is a totally different thing. And the reason for that
is because I have this safeguard put in place now and I didn't have this, uh, this before,
right? And I'm trying to create a situation where, uh, that's true. And let me see if I can, I'm going
to break. Um, all right. So, so root doesn't have it. Okay. So root doesn't have it. I'm not taking
it in my head. I'm not right now anyway. So root doesn't have it. And let's see if root has troubles.
So I'm typing LS. I'm taking my PWD. Maybe I'm working on a file temp foo. I'm like,
and I'm really going fast or something. And I hit control S. Well, that one doesn't do it either.
Damn it. All right. Control S. No, this has been fixed too. Damn. I can't, this isn't
working. I knew this was going to happen. I can't break it now.
It's only, you know what? Wait, wait, wait, wait. I might have an idea.
I've, I've totally fixed myself. So I fixed myself so good that now I'm, now I'm broke because I
can't show you the, how to break it. All right. So, so yeah. So I'll control S. Nope. Damn.
I mean, maybe a container, maybe a container, SSH.
No, because the whole thing's getting, you know what? It's all because of the host, the host terminal.
Yeah. And my git bash has it in as well. So it's really hard for me to break it again.
You know what? You know what? I think I figured it out. I'll go use Anton from the command line.
Yeah. Because I mean, watch, I mean, even, even here, see, it's even fixed here
because of my bash command lines by fiction.
I can't break it, my friends. All right. So I know, well,
what does that do? Resets everything? Is that the one that turns them all off?
Is that the one that lists them all?
I can't remember.
So anyway, the STTY command controls your TTY. It's a great way to look up how many rows and stuff
you have like that. If you don't have the environment variable, it can do all kinds of fancy stuff
from here. Oh, it is the one that is the printer. Yeah. All right. So, so let me check it. Your,
your BOD speed. I mean, all this stuff from the old school terminal that mattered, right? We don't,
we don't do any of that now. Suspend is control Z. See, this is my five-year-old.
This is control Z. See, this is what I find interesting is that it's, it's not doing it anymore.
That's like, I, oh, stop. See, look, stop, spin, undeft. And actually, it wasn't suspend. It was,
was it, uh, did I do it wrong? Control Z. I know my control Z is off too. It's, it's, it must have
been stop. I think I got it wrong. I think I've been saying it wrong all this time. It was doing
stop instead of suspend. It was, I mean, it felt like a suspend, but it was stopping the stuff.
So we have to get it so that that's not undeft. We need to define it to be, I know,
I know, I think we can do this. I mean, how can we tell it here? STTY, I've never done this.
STTY, stop. I don't know. I don't know what I'm doing. I want to know though.
I promise it'll be worth it because every one of you who doesn't have this set right now has
encountered this. As soon as you see it, you're like, oh my gosh, that's what's going on. It's so
annoying. Um, echo. So turning off echo, by the way, if you want to make a script that doesn't
echo to the screen when you're typing in passwords and stuff, that's how you do it.
Is it, is it just, is it just, uh, S? Yeah, yours does S, right? I don't know how to, how to, how
to type it though. Yeah, I'm trying to figure it out. Input settings. It's definitely stop.
This is way more than I normally would look up. I don't care.
There is stop char, but I have to type the character.
Yeah. And it's, it's, it's going to try to do something when I type it.
Yeah, but I won't, I won't, I don't think I can type. Yeah, I, I think I have to do,
I think I have to do the dollar sign for that. Yeah, let's try this.
STTY, I've never, I can just take it on my bash or see it reload. You know, uh, stop.
STSTOP. I can't just do that. That's not gonna, I don't think it's gonna work.
I, I don't think it's gonna work. Let's go check. Hey, oh wow, maybe it did work.
Maybe it did work. All right, here we go. So we're doing our thing,
and I accidentally hit control S. Oh, it worked. Yay. So it is, it is a carrot. Okay.
So now I'm like typing like, Oh, what happened? Anybody ever had this happen, by the way?
Has anybody, I call this a suspend, but actually that's wrong. The name is stop.
Has anybody ever stopped their terminal? Anybody ever done it?
I know it's control, but normally when you see a carrot, it means that the actual control
character has to be typed. So in, at least in bash. So anyway, I just typed a whole bunch
of stuff. What happens when I do start, which is control Q, boom, it types them all out because
it just bring the buffer was all filling on and all that stuff. Control Z is suspend and suspend
will work. Like if you're doing sunrise, right? You can do sunrise and you can do control Z,
and it will stop it, but it's still running. And that sends it, it sends it a suspend, right?
And you can foreground that and it will bring it back.
Control Z is suspend. By the way, this is a reason I hate nano for beginners.
Because nano encourages beginners to try to use control commands to do things they shouldn't.
Like they want to get out of something so they do control S for stop or something,
and then they get getting screwed up. And if they don't have that configuration,
which is what's set us off on this conversation, they don't have this thing.
So while we're at it since time, and we haven't really talked to it before,
let's under this, but here, grok backgrounding, suspending processes. So a process is a running
program. And any program that you have at all, it can be backgrounded, right? So I can do,
like right now, I could probably try it, let's try, I'm gonna save my stuff so I don't lose it.
So control Z there. So that stopped my Vim program, but it's still there, right? By the way,
how do I show all the running programs in the background? Jobs. Jobs shows all the stuff that
I have running, right? And if I go on it back, I just do foreground. And if you have to pick one,
you can do foreground and then percent and then the number. And that'll get it. I don't want to
overly dwell on jobs. But it is the way you can like suspend a thing or put it in the background.
So if you don't, like if you're doing something, yeah, you wouldn't want to do kill that one,
that would kill that process, right? But you can refer to any job with a percent in front of it.
And that will, that will do. So, but you know, sometimes, for example, if you're like running
a Minecraft server, right? You know, if you accidentally run Minecraft, you don't have
Tmux running and you just have backgrounding and that's all you have and you got to get to the
shell and then come back to it, you can like leave the Minecraft server running and you can do control
Z and suspend it and do whatever. And then you can just foreground or whatever and you go back to
your process. Okay. So it's kind of like a poor person, the poor man's screen or poor man's Tmux,
right? Tmux and screen are way better for that kind of stuff. But it is, it is possible. Now,
the problem though, is that if you do control S, which is not currently enabled on this one,
we got to, we got to put that in a terminal where it's enabled, it's enabled it in.
STTY-J, let's go look. So it's undepped again. So STTY, we used to have to do this with,
anybody remember having backspace problems? We used to have to do, we used to have to set a race
and EOL, we used to have to set a race all the time. Otherwise, if you push the delete key,
it would just keep pushing control characters. Anybody remember this? I mean, it was a long
time ago, but in the 90s, in order to get delete, the delete key to work, you'd have to do that,
right? So you can also do, you can also suspend a process using the PID, right? Absolutely.
Yeah, you can. You can do kill, whatever, and then the PID. And then that'll stop,
that'll suspend the process as well. So, so yeah, let's try the other STTY. So STTY,
stop, we're going to make it the same as normal S. And, and now when we, we type control S,
we get frozen and like, oh no, I need to close my terminal. No, you don't really,
you just need to do control Q and that'll restart it. Now, granted, a lot of people do this,
and then they try all kinds of crap. They're like exit and all sorts of things. Remember that
everything, when you, when you actually find the right keystrokes, all that random stuff that you
type to try to get the right thing will execute because it's just been, you know, so sometimes
it is better to just kill the screen. I mean, if that would ever happen to you too, you can only
just do, you know, Tmux, which is control a ampersand, you know, and sign. And, and that,
that puts you, it just kills your whole terminal window. And I, that's my go-to for everything.
It just shuts my entire window instantly. And it's just as easy to type, but I don't always
have Tmux available. So it's good to know how to do that. And, and so it's so back to our, our exercise
Yeah, there's all the other stuff.
Looks like we got a lot of random crap running right now. So, all right, so here is our
bash rc file.
Yeah, I'm not using control alt. I need a TTY. No, no, I'm not, not a fan of that. I guess you
could do that, but I'm not a fan. So STDTY noise is disables, control us accidental, thermal stops.
So if you don't do that, then it will actually send control s to this, to the, the, the program.
And in the case of bash, that makes an interactive backwards search, which is something I don't
normally do, but, but, and frankly, I didn't do probably because this was never a set in my
past rc before. So that's quite a bit on that one, but that'll help you out. We're halfway
through. We're going to go through this fast history control. So it's super important, my friends,
that you increase your history file size. And for lots of reasons, we'll get into history and
his depend the shot of history pen. What this does is it causes your history to constantly get added
to instead of resetting it every time you log in, set that show causes your history to be editable,
as if it's a big VI file. So my, I escape, and then I'm pushing up and down, J and K,
I'm going up and down. I can look through anything in my entire shell history with a slash. So I don't
need to have completion for this. And if I wanted to, I could do it. I, I prefer this because my,
it turns my history into, in a huge VI file to which I have one line of visibility. And since my
go to is using slash for things anyway, and then I can just n, n, n, n, and find all the
Docker things or capital N, n, n, n, n, or dot and then go to the right thing. I use it constantly.
I use, I use that constantly. I don't use anything else. I think it's kind of silly to,
to use some of the other options that are out there. I'm able to pull up stuff from months ago
by just typing slash, whatever, and it'll pull it up. And I like it more because it's explicit.
It does take a few more keystrokes. I really, really don't like command line history things
like, like all my Z-shows that try to guess what you want to do. And they're constantly trying to
help you out by hitting tab drives me insane. I, I don't like that. I'm a more of a precise guy.
I want to put slash and I want to know exactly what I'm looking for. So that I can find it. So
if I did something as rude, I can go look it up. By the way, this is another reason that I use command
line links, uh, searching because my command line history becomes my search history. Let me say that
again. If you learn how to do command line text searches, your command line search history becomes
your web search history, at least when it comes to research that you don't really care about,
you know, even if I need pictures or something, I will do the initial like location of those pictures
from here. And then I'll, I'll go to the URL with the dot or whatever. And I'll open
a graphic web browser and look at the image much more efficient. We'll talk about that more when
we did links. We don't already did links a little bit. We'll come back to it. So, but that's another
reason I did that. Uh, I also do, you know, my Zettle Castings when I create them, I use the
term. So I use my history for everything. Uh, and I don't use, you know, dollar, dollar, I mean,
or bang, bang, or whatever people use. I don't need it because I guess you go up in history. It's
like faster. So, uh, so that's my take on that. You can go look at that. There is another option
here that you can set that, um, is a little more complicated, but you can put a command, uh, inside
of your dynamically evaluated, uh, prompt that will cause your history to update, uh, as each time
your prompt displays, it will update the last history and that's more efficient. Uh, it confuses
you though if you have multiple terminals on, right? Because you'll maybe have another terminal
and then now your history and you go up in the other terminal and logically you're thinking you're
going to go get to that last command you were at and you ended up going to the last command that
was entered in another terminal. So I don't like that. Um, but that's a trick a lot of people do.
Um, you can set, this is me building my prompt. Uh, I am not going to explain this. This is,
this is me proving, uh, to myself and to the world that you don't need fancy prompts.
This gives you a, a, a prompt that will automatically wrap, uh, to two lines. Um,
history dash a, yeah, if you want to put history dash a in there, you can do that.
Uh, I don't particularly like that, but if you want to do that, it just makes, uh, your,
your history update no matter what terminal you're on. And, and I, again, I like having,
so my history doesn't update until, uh, for everything until the terminal dies. If that
terminal dies, it writes everything that that terminal ever did to my master history file.
Otherwise it's just available to that terminal only that I'm talking about Tmux window. And then,
and then it, but, but if I, if I want all that stuff to be available, I just have to close that
pane and then boom, it gets all written to the history file and go get it. And I prefer that
myself. I don't, I don't like being surprised by having edited something like, usually when I'm
opening a new window, it's because I want to do something really temporary. I want to go look
at something. I don't want it to screw up, uh, the history of my other pain. And so I don't
like history dash a and the prompt command personally. Um, a lot of people do it though.
All right. So, um, down here, I have my prompt command. Uh, again, as I said,
the prompt command is does one, you don't need to export this by the way, because it's not used
by anything else. The prompt command environment variable is very special and it will execute
or eval whatever is the, whatever the string is every time you enter a command. Uh, and it can
slow things down, but by doing that, I've written this kind of fun little script that rebuilds my
prompt, uh, depending on the size and where I am. So if I have a short name like this, it puts it
all on the same. If I get, you know, kind of down low into the middle user, local bin, uh,
it's just usually still using bin. Uh, I think only if, if I get, I probably need to get in
a GitHub directory. If, if the, there we go. So if I, I want to show my GitHub or I want to show
what branch I'm in, uh, was it going to detect on CD? Uh, did I, did I remove that? I hope I didn't.
Yeah. I'm still in Maine right now. So it's not showing it. Uh, at one point I had it showing
like what my current directory was, and I, that's not there anymore for some reason. Um,
I'll have to go fix that, but it was, you know, it'll show you what, what branch you're on and
that kind of thing. And it wraps automatically if this number count is past a certain point
and it does the, the double line. So you can have fun with your own prompt. I'm not going to go there.
Yeah. But my B is not working for some reason. Oh, it was because I'm a master.
Yeah. If I'm a master, it doesn't look like it. Well, maybe not me. It doesn't look
like it's working right now at all. Should I take it out? I'm going to take it out.
Double short. Where's BB is there?
Beagles master. If equals master or B equals main, that, that is incorrect, I think.
I have a bug. I do have a bug. I'll have to go figure it out. Anyway,
uh-huh. I don't know where my B is not showing up. Nope. It's not. I'll have to fix another day.
I don't know where it went. I actually didn't notice that that was broken. It used to show main
and blah, blah, blah, blah, blah, blah, but somehow I broke it and I'll go figure it out. It's kind
of fun though. This is the kind of thing, you know, you blow like a, an evening on just having fun
with. These are all the colors, by the way, and stuff. I'm going to skip this though. I'm
spending too much time on it. All right. So keyboard. This is where I, I map my keyboard. This only
works on a system where I can actually map it. It says 6K, XKB map. This doesn't work on a virtual
machine. So, I mean, I don't think it does anyway. Let me try. Yeah, it's not working right now.
It only works if you have a hardware. Oh boy. Yeah, I see what I did. So that was me remapping
Caps Lock. It only works if you don't, if you have access to the hardware and I don't. And my,
it works on machine. It would be interesting to find out a way to get this to work.
Oh, it's looking for the display variable. That's why. This only works if it's an X thing. So it
probably wouldn't work with Wayland either. I don't know. But if you had, it's because it's a,
you know, it's a hardware OS mapping. You know, I, I don't know. And I don't think I even have a
display variable set actually. Let me go check. Display is the thing that X uses
to display stuff. Yeah, my display is empty. If I turn on, so I'm not even using X. So this
doesn't work unless you have like a window manager and I don't. I'm just a terminal.
So you can't remap it. You can't remap Caps Lock. There's probably some other way, but that's,
I added that when I was doing Papa with some men on the desktop when I stopped. So
I mean, I'd be interested to see if this actually works all by itself. Let's try.
I can run this command from here. No, we need to export that though. Let's go grab it. Oopsie.
I'm kind of curious to see if it'll even work.
X and RWX break things.
I don't think it's going to work. Load keys could do it. Yeah, there's,
yeah, I could get something from Windows that would take it over. You know what I mean?
Yeah, I'm pretty sure I could, I could do something.
Now it doesn't work because it's a hardware thing, right? It's a hardware interface.
It just messes me up. I have mixed feelings about that anyway. I've gone back,
just so you know, I've gone back to using control the bracket for everything because
every fucking, every keyboard works that has it. So I don't mess with this at all. In fact,
I should probably disable this or something like only works if you have X and R using
graphics, graphic Linux terminal.
And I don't, I use the terminal. So I'm not a fan. Control left bracket is exactly the same as
escape. It's easier to hit than escape and doesn't require any modifications or messing around.
When we get to the VI stuff, there's a lot of people who remap VI keys. I hate doing that.
I tried it for a while. I tried to use FG as a thing. I think I still have it mapped here.
No, I turned it off. I turned it off. If you type two letters really fast,
it'll operate the same as escape, but it really messes your muscle memory up.
Control left bracket does not. So we'll talk about that when we get to VI later.
So here's all my aliases. We're about, we're almost done here, I promise.
We're not going to talk about any of this, the command line search aliases
until we start talking about links. And we will cover that sounds probably next week, it looks like.
But this is how I do all my command line searching. I call program well duck.
And that, that, that opens up a text based web browser that opens up a search
over the web, et cetera. An alias dash a that clears out any aliases that may have been previously
said. And then I reset all my new ones. As I said before, aliases are generally a bad idea.
If you want the output of the thing that comes from the alias because you can't use them. So
see here free dash H, right? Let me give you an example. So free dash H, I'm going to put this
in my thing here. No, no one to use aliases and when to not. All right. So, so, okay, so free dash H,
right? That's a thing that, yeah, I want to use that free make gives me human readable, right?
If I, the real free with the slash in front, right? Gives me this thing I can't read.
And so that's nice, right? I want that. Now, if I go edit a file and I want the same thing.
So I'm going to use my handy dandy, you know, bang, bang, which you now know, right? And I type
free. What am I going to get? I get the non alias version. And that, my friends, is why aliases
are not the best option for certain things. Now, I, if I, so, you know, let's go back here.
I want to use aliases, functions or scripts. Oh, I already have that up here.
I want to use an alias function or a script. I already have it up there. Okay. So, but I,
it must be, I must like this. So let me show you another option here. So if I comment this guy out
or if I unset that or whatever, let's, let's, let's just for grins, let's make this into a function.
Okay. So we're going to say free. And we're going to take over, you know, whatever it is,
and export dash F free, right? And then we're going to say free dash H.
And we'll pass it any potential arguments that are there. Okay. So I now want to use that.
I can do that in spat up here. So I can say that I want to use this. I'm going to say
exact bash dash L to reload. Let's see what my free is. So my free is a function now. And this is,
is the recap of what's the difference, right? So if I go into temp foo now. So what do you think is
going to happen? Actually, I'm already in temp foo. I thought I was so myself. What happens?
What do you think is going to happen when I do bang bang free? Is it going to print it or not?
Anybody? Well, thank you. See if you can guess right now what you think is going to happen.
I don't use tilde for anything because I just use CD. Yeah.
Yeah. So, well, that was bad.
That was really bad. Why is it not working? I must have my free waiting on input somehow.
Oh, you know why?
Yeah. Free is the function here. I think it's because I think it's calling itself actually.
Yeah. Let me. Oh, right, right, right, right, right, right. Never mind. Dash free.
Dash. Oh, I did it wrong. Okay. Here we go. There we go. I did it wrong. I'm sorry.
Isn't slash nice? Uh-huh. So type free. Free is make sure it works. It's not working. God damn it.
I think, you know what? It's doing an infinite thing and my computer is going to crash here.
I'm so bad. I'm so stupid. Okay. There's a couple of ways you can do this. I thought slash worked.
I've used that before. I swear I have. Anyway, so let's do this instead. Let's do command dash
be free, which I know will work better. What damn well work. You better down while work.
All right. So let's try this one now. So let's try that one free.
I might, you know what? I might have to do which free actually. Yeah. I think I do have to which
free. Or I don't, maybe the problem is I'm trying to name it the same thing, which is dumb.
Bash aliases foobar. Yeah, I could do that, but I want to break things.
No, it's not, it's not doing it. It has to be which I'm, it has to be which because that's the one
that's in the path. Yeah. So
do, do, do, do, do, do. I'll get it. I promise.
Time free. That's because it's the same name. There we go. Okay. That's what I wanted to show you.
Well, you learned something. You learned three ways not to do it. Okay. So
is that inside a script? Possibly. Yeah. But I don't want, I wouldn't, I wouldn't want to
do it that way. That's like way too much hassle. No, I mean, the whole point of this,
of using bash command line stuff is I, I don't want to think about it. Right. I want to type
bang bang free and I want it to be what I want. And now it is.
Why did the function work? And why did the alias not work? I want you to take a moment to think
about that. Why did the alias not work?
And I think mostly I think you were the one who actually tracked this down for us. And we figured
out a way to export aliases. So they actually work in sub processes, sub shells specifically,
not sub processes, sub shells. And there is another reason for this too. Okay. So,
so there, there, there is yet another situation that we're not going to hit until we use go.
But this method that I use will not work. If the program that wants to run it
is going to use an exec syscall because this only works with bash shells.
And I actually ran into that while I was like importing some code over to go.
So the, the moral of the story is if you ever are going to use it in VI,
you're more likely to be able to use a function. But in general, it might be better for you to make
it as a bonsai subtree command or as a script. And the reason for that is because you're going to
want to use these things from other executables and sometimes they're not always going to be
bash scripts. Sometimes they're going to be other things. You can just want to use that little
thing and you're going to want to leverage the whole unix and nests of the whole thing.
And you can't do that with a bash function because a bash function can only be executed from bash.
And, and you know, if you're, if you're running from another executable, it has no idea about
bash functions. So this kind of thing is the kind of thing that's a small thing, but it would,
it would actually end up in my bonsai command. And I'll show you how I would do that. I would go
to my main here and I would add myself another command in here, some sort of simple command
to do this kind of thing. And I mean, I could just do a standard executable.
I don't know if you want to see that right now or not. But I mean, I mean, here's the env one
that I wrote. So, so this was, this is just a basic command. And it runs the same thing, right?
And then we could have it call free and look up the free executable and run it that way.
And then when I compile that in, then I can just do z env path or whatever. And it'll,
it'll go do this stuff just like it was in a shell script already expand aliases aliases
alias free. That doesn't work. I wish it did. It wish it did. I've tried that before.
I have, I have expanded aliases on right now. Yeah. It doesn't work because I'm calling it from
within a script and it doesn't expand it unfortunately, at least, at least not consistently.
And it certainly doesn't do it from an executable. So it's, it's not unixi to do this. In fact, I
have stopped using functions altogether at the only time to use a function. I've covered this
before, but I'm going to cover it again. It's so important. The only time I ever use a function,
the only time is when I want to do something complex that modifies the existing environment.
And usually that means changing the current directory, which you cannot do from a sub shell.
You can't do it because you need to modify the properties of the existing shell.
Everything else that is just saving me typing that I really don't care to use in bash or
anything like that. Turning colors on, you know, changing view at these kind of things,
this faster versions of clear the screen. These are all things that I prefer to do
from, from, from aliases. And that's not a very big list. PCRE, grab, bash top, whatever.
And I never, ever depend on an alias to be out of them because my fingers remember it.
So here are some functions, turn less color off. I haven't used ENVX in a long time.
ENVX is kind of nice. What it does is it takes a file, parses it up, and then
sets it in the current environment. So if you have a script, it's very
dockery, but if you have a script or something that wants to do significant changes to the
current environment and then throw them all away, you can use this. But, but yeah. And I used to
put a number of, I would have a private .EMV file that had all my local environment variable sets.
How's it going? And so, so new from another shell script, another function. Again, why do I have
it here? Because it ends by changing the current directory. So I have one like this. I have a,
I have a clone, you know, I don't know, clone structs, right? And that what it does is it,
is it clones, it clones my GitHub repo and, and changes into it. So it takes care of
a number of things at once. That's the kind of thing new from, this actually will make
a new GitHub repo and change into it. This will make me a new bonsai command and change into it.
CDZ, this, this just changes my directory into my zelocast and that matches whatever I'm searching
for. And then I export all those functions kind of on their own. Clone is the one I just showed you.
So clone will clone any GitHub repo by default, it assumes you as the user. Otherwise, it will,
if it doesn't have a slash in it, it will just, it will take the user so I can clone. I do this
all the time to like look at stuff, right? So who has a garypo? You want me to look at?
Someone give me a garypo to look at and I'll give you a sense of how that works. I really love
this function. This function saves me so much time. Of all the functions I have, I'd say this is
probably my favorite besides the path append. And this is original. I wrote this one. It also
grabs all the recursive submodules, which is super cool. So let's say, and you'll see me use this
all the time while I'm doing streaming. So I say, let's go evaluate that code, right? So who wants
their code evaluated? No one, no one brave enough to get their code evaluated right now. Okay, so
we'll go to, we'll go to github.com. Let's go find somebody's random code. How about Neo? I think
we need to find Neo. I do. I don't even have Neo here right now. A while ago, we're wrapping up
a YouTube video here, but you're welcome to hang tight. So the Neo project, Neo smart economy,
come on Neo, Neo Vim, no. Neo for J, no. Oh my God. Neo matrix.
I think this is the one. Yeah, so
is that the one? No, this is it, stw3. Can the function take in a path to cdn2?
No, because I have the standard path for all that. You could set that if you wanted to,
but I don't have that. So let's say st3w, I want this, right? So copy, I'm going to go grab this.
So I'm going to go clone, paste, and that downloaded it. I already had it. So let's delete it.
I already had it, I realized. So now let's do it. So clone st3w, it goes and grabs it,
grabs all the recursive sub modules, puts me right in there, and I can get to work looking
right at the code right away. And I don't have to deal with the command line at all. I don't have
to go to the web. I don't have to do anything. Work in Vim. Well, because it's a sub shell,
yeah. A sub shell is the only run executable things. You can get functions to work. I showed
that just now, but if you wanted to make it so that it took a path into where the thing,
yeah, you can modify that one. I don't know. So if repo equals whatever,
yeah, user repo equals the HTTPS. Oh, look, it looks like, yeah, takes a repo.
I don't know. I don't think so. I think you can actually cause it. I think there is a way to make
aliases propagate to sub shells. I know that. I just, I don't think it's a good idea.
Because it's, first of all, it's a bash shell. As I said, the executables are always going to
be the way to go. That's why I'm more, you know, akin to using a bonsai thing. Anyway,
so there's that function. Okay, so let's talk about completion. We're going to go kind of
long here tonight, but that's okay. So this is one of the most important topics to cover today.
And tab completion, you know, people laugh at me because, because I'm not really a fan of
completion inside code. I could be convinced to use it. But, you know, when it comes to,
how was it, does not exist. Did I, did I, mine, mine worked?
You might need to set some of your other environment variables to get it to work.
Yeah, because it has some other dependencies. You know, you know, mine's there. Yeah, you might
have to go look at some of the other stuff that it has in there. So let's talk about completion. So
what is completion? Completion is what allows you to work really fast. So,
so when I CD into questions, I hit tab and I don't have to type all that. Can you imagine if
I type that every time? And in fact, completion is to blame for so many like really long names,
because they're just so easy to type, you know, and you just hit tab, do whatever completion is
a popular thing in VS code and other code editors and it's been around for a long time.
But it's also good on the command line. And if you have CD path set, it will also work for that.
And so there's, there's a bunch of the way completion works is that the bashell and any
show really, they have something called completion context. And when you hit tab, it says, okay,
let's look at this line and let's evaluate what, what the person thinks they want. I happen to
think completion is one of the most effective ways of doing anything. I mean, I'm more likely
to go ZZ tab, tab to see what I can use here or go to CTO tab, tab, right?
Tab, tab to see what, oh, look at all those commands. I don't have to read them at all.
If I don't remember them, I can just tab, tab, complete them. And, and people who like tab
completion for code, coding, coding argue the same point. And which is why I think I could be
convinced eventually to use, you know, COC or some sort of tab completion within my VIM
or my IDE or something like that. In fact, you can type an entire webpage with like HTML tab in
VS code and pick from the one you want. And this is where people are going with the whole,
what is this code, you know, that, that AI that's doing all the completion,
which is a different issue, which we talked about in questions and conversations the other night
regarding legality, because it's including code that's proprietary and could be tainting your code.
But the concept of completion is a really strong one. I think it's really solid,
co-pilot. Yeah. And then people should, to learn to use it. And unfortunately, a lot of people don't
understand that you don't have to write a separate script to do completion. You can actually just
enable a program to do completion by typing complete dash C, you know, build, build or something.
And you can have the program do its own completion. And if you want to get into that stuff, and you
really want to see any of that, I've prepared some examples for you can go read that I don't
really want to get into right now. But if you go to artifacts, Rob, slash CMD is the CMD,
I think it might be bash example, there it is, bash command example. So this, this has my example in
here. And it uses bash completion. And then Bonsai uses the same technique for, for completion using,
so this also includes documentation generation, and completion that automatically is detected
based on any function that begins with x dot. If the function begins with x dot, it gets completed
automatically. And a simple version of that is I did with the ops API recently. Oops, ops API,
in our dev script here. And I took out all the other doc stuff, and I just put this,
I just put this here. So this, this is, if you, if you, we talked about this in the
bash scripting the other day, if you kind of decompile this and understand what it's doing,
you'll understand a lot about bash, but what it's doing is it's just making it so that,
that this program, anything that begins with x dot is automatically tab tabbable.
And you can, you know, type check tab and get all the stuff that has check with the end, etc. So
that's completion. And, and, but in order to enable completion, you have to put that in your
bash receive file. And up here, I have own comp, this is an array. And it's like, these are all of
the things that provide their own completion. So they would be evaluated, they would be set up
using complete dash capital C, which is very minimally documented in the bash thing. So you
have to look for programmable completion. That's the secret word that will get you to the line
where you need to be. And this will talk to you all about completion ad nauseam. Most people check
out when they talk about completion, because there's, there's these, these, lots of these
like functions that have been created to help you, but they actually hinder you in a lot of ways.
But you see them used extensively. And, and in all of these other programs, this is my single
biggest complaint about Cobra, which is a go library that creates extensive completion
code scripts that need to be sourced and used. And the reason to do this is because,
you know, Z shell doesn't support commands with their own completion, which is really unfortunate.
That is a reason all by itself for me to never use K shell or RZ shell or K shell or any variation
on it. They don't under, they don't support basic internal completion. What would you rather do
completion with some shell script that has to be created to reflect the same logic that's already
written and go, or something that already can use the go code that you already wrote. So the entire
reason, raison d'tre for Balzai, I'm going to make a plug for it right now, is because of
completion and internal documentation and, and all the things that come from that.
And so you can go look at that. But let me give you a sense of this. That's what this is doing. So
this is saying, for all the ones that I already have, I'm just too complete to actually, because
those are the easy ones. Those are the cool ones. Those are the good ones. But the rest of them,
we got to go use its own, you know, clunky completion type mechanism. And most of them
have something completion bash. That's how you know, you're using a Cobra piece of crap,
because it always has the same thing, at least it's consistent. But, but let me tell you why I
think this is crap. Because if you look at like, let's, let's do cube CTL, right? Cube CTL,
completion. Okay. Whoops. We have to tell it what shell we want bash. All right. So that might not
look like much of a big deal, right? Until you count it. All right. So that's 302 lines gotten
smaller. Actually, it has gotten smaller. Thank God. It was much bigger than that before. It's
302 lines that have to be evaluated every time you run an interactive shell. Every time you run
an interactive shell. And if you want your completion to just be there, let's do kind. Kind, WC,
uh, dash L. Oh, whoops. Bash 1174 lines. Yeah, I mean, they've taken it down a notch.
Cube CTL used to be thousands of lines long. It used to be 32,000 lines long. 32,000, I mean,
32,000, 32,000. They've, they've, they've fixed it. They've dabbed. They've taken it down a notch.
That's good. Probably because everybody was complaining about it. Seriously. Last time I
did this, I actually wrote a big thing on bonsai about it. I did. I wrote a big thing. You're
like reaming him for it. And I think they might have fixed it. That's actually really good news.
Um, so here's bonsai. There we go. Uh, so, so Cube CTL was 12,637 lines last time I checked. And
now we just checked it. It's only 302 now. That's really good. Pandoc's actually pretty good. Yeah,
Pandoc does a pretty good job. Um, Pandoc has its own thing though. Let's check the other ones. Let's
check Minikube. Minikube has, oops, Minitube. I wonder how Minikube installed. That's why I have
the check it out if you haven't. Spotify, kind, compose, helm. Let's do helm. Helm is trash. So
the source code is absolute trash. Um, I don't have that installed either. Damn it.
Uh, yeah, the rest of them, I don't have any of these installed.
What's Docker like? Oh, say Docker. Okay. So Docker and these other ones are kind of weird.
You have to actually use their independent completion file and then source it. Uh, if you
want to, if you want to create shortcuts, and that's what this is doing. This is creating a shortcut.
Um, uh, let's do Pandoc. So Pandoc is, what did they say?
Okay. Pandoc. I dash dash bash completion. 83. That's not bad. I'm, I'm really happy to hear
that the, that the QCTL has come down. It was 1200, 12,000 lines. Imagine, imagine forcing
every single person who ever used your command to get to source 12,000 lines of code. I mean,
my entire RC, my entire bash RC file is only 500 lines. So in order for it to run completion for
just cube CTL up until recently, I had to, my, it was, I, my, as I told you, it's sourcing it.
So it's essentially the same typing right there. And my, that effectively increased the size of
my bash RC file to something on the order of like 15,000 lines every time I run an interactive thing.
And if, if you want to hear people complain, you should, there was somebody who wandered
into my Twitch year and a half back and they were like, Oh my God, I wish they would just stop
because all the cloud native people have been complaining about this because they're all using
the same thing. So you combine, you put all those things in there and they're all just blowing up
everybody's bash RC files. And so they're the startup on their interactive shells is as slow as
VS code. There was no error at all. I don't know. So yeah, I don't know that that seems interesting
that it's like working out. This is some stuff for swagger completion. So this is kind of stupid
because it actually had to the number one complaint I have. And this is why I for forever hate Anaconda.
Anaconda is a, is kind of a, kind of a, I don't know what it is. What is Anaconda? Anaconda is
like a really bad CPAN for Python, specifically for machine learning kind of things. And it's
absolutely horrible. I mean, it's just so bad on so many levels. And I don't have time to go
through every one of those things. I don't like just saying things are bad without telling you why,
but it is, it's just terrible. And the first way and the first reason I knew it's horrible
is because it screwed with my bash RC file. When I went to go install it, now it warned me,
it warned me it was doing it, but then it proceeded to go in and screw up my bash RC file and write
whatever it wanted to to the end of it. And if you write a program that willingly, I don't care if
you put markers around it or something, if you're willingly screwing with somebody's bash RC file,
you're a bad person and you should be fired. I'm only kind of kidding.
Seriously, there is nothing that makes me more angry than some
dome developer full of hubris who thinks they have the right to screw with my dot files.
Who gave you permission to screw with my RC files? In this case, it would be me.
Because they asked me, they said, do you want to say all this required stuff to your bash RC
for you? We're helping you out here. I'm like, okay, fine. Somebody reminded me after that,
after a rant, I was ranting like, you know, you don't have to do that. You could have said,
no. And I'm like, oh, okay. I can't tell you how many times I have had stuff royally screw up.
And by the way, every time you do a new install or something like that, it never remembers.
And if you're storing your dot files and get repos, which we will do at the end of all of this,
you're even more screwed up because now you're making changes that you didn't have any control
over. And this is what swagger is. So swagger is one of the hands down worst projects I have
ever seen. It is so totally bad. The open API YAML specification is the only good thing about it.
Everything else, all the software, the crappy Java, the horrendous, you know, necessity to like
change my bash rc file and all of the other novice crap is just terrible. In fact, I'm deleting this
right now. I'm deleting this right now. I added that because swagger told me to add that and
swagger is not even a thing now. The core people on the project left the project and created open
API, which is only minimally better now. And we're going to rewrite all of that. Don't get mad, get
busy. In the open source world, you can rewrite it and make your own. And that's probably a good
note to end on. So this stuff down here is for all of that customization that you want. So
you may be saying, Mr. Rob, I want to be able to show off my dot files with the rest of the world
and how awesome my dot files are. And I want to help all those beginners out there. And I want to
show that I'm not a noob. And I'm going to put snarky comments and fun jokes in there and all the
other things that people do in the dot files world, right? But I want to be able to have like
subtokens. And I want to add a Twitch token so I can do a lot of the WeChat. And I want to be able
to add, you know, I want to be able to add tokens that talk to Twitch with my scripts. And I don't
want to necessarily like, you know, even knowing where the files are, I don't want to give up that
information. Plus, I want them to be able to use my file, my thing without forcing them to use my
exact, you know, directory structure, blah, blah, blah, blah, blah. Well, one of the things you
can do is you can add a source if at the end for the different files that you might want to maintain.
So I actually maintain a bash work. As I said before, I maintain a bash work at work. It's in
enterprise GitHub. Nobody sees it except for here. And it overrides everything above here, right? So
it takes over my GitHub information and, you know, what, whether to go out to, you know,
GitHub this.com or to go out to the internal one. And then I, you know, the private one is only loaded
for my local machine when I have it connected. And that's got GPG keys and stuff like that that I
would never want to commit. So that's what those are about. We talked about them already, but I'll
talk about them here. Terraform stuff is just left over from completion. For some reason,
the Terraform completion stuff does not work up here. I couldn't figure that out for the life of
me. I don't remember why that was actually. So I'll just leave that one there. And that's the
end of today. I know it's been a long day and some of you probably had to take several breaks
along the way. No worries. We made it through the BashRC file. You know, you're going to be spending
the rest of your life, Linux life, playing around with your BashRC file, and for fun and profit.
And, you know, grab a beer and come mess with your .files and listen to good music with us.
It's a never-ending thing. I'm constantly redoing my Todd files and my shell scripts.
By the way, just as kind of a summary here, and I'll zoom in for this story. So when I was
first starting, I didn't know shell very well, but I knew Perl really, really well.
And so I wrote all of my scripts directories and everything in Perl. And then, you know,
in a 2000 someplace along there, I was like, man, I should get up with speed with Python.
So I rewrote everything all in Python. And then a lot of them are the same things,
the same things that I rewritten over and over again. And I've always had Bash as my shell.
So I did, for an entire weekend, I tried to do ZShell with people on Twitch helping me and just
to do a fair comparison of the two. And that's when I, you know, determined that, you know,
in a friendly way, I don't want anything to do with it ever. And then the latest incarnation of this
is, you know, I'm tired of maintaining all of these scripts in all of these different places.
I just want one executable. And so that's where bonsai is coming from. And we kind of have permission
to do that because everybody's doing that now. I get GH, Twitch, Twirl. I mean, there are all
these like monolith, Unixy monoliths, which means that it's a monolith that's got broken up into
multiple subcommands. And so that's been my, my current take on that. I've been really enjoying
it too much actually. There's actually a really interesting blog out there somewhere. I wish I
knew the name. And it was written by a guy who was like, he's basically like, just stop configuring.
And he was, he was basically capturing the dilemma of, of spending your entire, I mean,
the whole idea of optimizing your configuration for your workflow is to make you more efficient.
But if you count the amount of time that I have total number of hours that I've spent optimizing
my workstation and my top files and everything, there's, there's probably not enough time ever
for me to ever recoup that time in terms of efficiency, right? But every once in a while,
you hit, you do add something that adds tremendous value to your entire workflow,
such as my clone command or the bonsai command or, you know, and that kind of thing. And
and so I think it's worth it to do it. Plus it's fun, you know, and it keeps your skills fresh,
keeps your shell scripting or go coding fresh. So don't take it too much of that to heart. It's,
it's fun. And I personally, I, I think it's very addicting. And I think there's probably more than
one person in this room right now who is very addicted to configuring their, their stuff. So
it's time for me to end the stream and pick my socks up and stuff and, you know, be a good
citizen. It is Sunday though. Give me a break. And we are going to call it at that point. So if
you want to hang around at renting, renting time is greater than improving work full of time.
I don't know if it is. I don't know about that. I mean, it is fun to round. It's probably not
good for my blood pressure, but it's really fun. I thank you everybody as well. I'm just going to
say it again. I appreciate everybody being here. Don't get angry. Get busy. Yes. Reconfigure.
Or write your own editor if you have to. People have. I mean, that's good. I want to encourage
people to do that. Even if they get it wrong, at least, you know, they have the courage to do it.
So, so we're done here. And the next thing you're going to see on this channel is probably me
playing games or eating or something. So I'm going to go ahead and just stop the recording.
Again, thank you for being here. We'll see you next Sunday at two. We'll do be two to six. And
it looks like we'll be covering the rest of the configuration. So we only got to the bash
configuration today. Thank God we got through that. I have a feeling it's going to take us
the whole day to get through Vim config. But I'm going to hope not. So we're going to put that down
here. Wait, why does it keep doing that? Wait, you can't see my screen here. Here you go.
So I'm moving I'm moving these topics to the next time. So we just did
configure as a bash configuration day.
Let's say that bash configuration day.
Um, I mean, but for no other reason, then, uh, oh, uh, oh, uh, oh, I screwed up somewhere.
What else is new?
I want to use what?
Oh my God, it, it got rid of it. That's weird.
Yeah, it did. It got rid of it.
Okay, okay. All right. All right, peoples.
Uh, bye-bye. Thank you for the follows.
