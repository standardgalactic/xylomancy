Hmm. This desert is awesome.
That's how I feel like about doing this topic.
I feel like the better approach to people who criticize pearl is to just like chill and drink my coffee.
Yeah. Yeah. Yeah. Are you done yet?
Yep. Are you done?
Hmm. Oh. Right. Right. Right.
Yeah. When was the last time you used pearl?
Oh. Oh. Yeah.
Oh. What was that? What was that? Regular expression? Did you have trouble with that?
What's a regular expression?
Oh. How do I put this?
Yeah. What was the language you were using instead that you said you preferred to use?
Oh. Do you think that that language is the only language that has regular expressions?
Okay. Hmm. All right. How much coding in Chinese do you do for Chinese strings that use the Unicode?
Oh. None. Right. Okay.
Oh.
Yeah. Well, I'm sure you're going to have a great day. I really am. I'm sure you're going to have a great day.
I got stuff to do though. So if it's okay with you, I'm going to go pop on my camel here and we'll get shit done while you're doing whatever you do.
I'm sure it's fun.
I couldn't resist. I couldn't resist. I know I'm an old pedantic grumpy asshole.
My Rust video proves it. I know it. I'm just going to own it.
And one of the things that makes me the most annoyed of all is people criticizing parole for being a read-only language or writing it and not being able to understand it or not knowing what it's for.
Or, oh, that's only a boomer language. You know what else is a boomer language? C. You know what else is boomer technology? Linux.
These are old things. You still use them every day and you love it.
Just because something has been around a while doesn't mean you throw it out and start using something new.
I'm not just saying it because I'm an old guy. I'm saying it because I recently had a massive sort of come-to-tech Jesus moment where I just was like, why did I ever throw parole out?
Some 12 years ago, 13 years ago, I threw parole out on the floor and I said, no, I'm going to do everything in Python from now on because that's what the world is doing.
I didn't bother to ask myself why. I just listened to everybody else and said, well, this is probably the way to do it. If I want to get a job, I better do it in Python.
So I was back when four people were doing Python. I was doing Ruby and I had done Ruby before that. Ruby was awesome.
But here's the thing. We were also writing large applications.
We were writing applications that needed the pseudo object-orientedness of Python or the scale of Ruby.
Really what we needed was go at the time or a language like it that could support the weight of enterprise development without the complexity and just absolute bloat of Java.
And so that's what we needed. So I went ahead and I'm definitely going to accept comments at some point and I'm going to go into the IRC.
There's going to be all kinds of people in here with all kinds of opinions and I love that.
But I was particularly grumpy recently. Not particularly because of any single person.
A lot of people took the back end of my wrath on this because it was actually me.
I've done a lot of reflection over the last day. It was actually me coming to terms with the fact that I threw out something which I tend to do that had an application for a specific area.
And that area is a very niche area but is a very important area.
And so when I came back to it, I actually just discovered all over again that the only prototyping language I should be using for Unicode Regular Expressions matches right now is Perl.
It's the only language on the planet that supports it as far as I know right now.
If I'm wrong, put it in the comments and I'll go look it up.
I just put these items together here. I don't know.
I'll put these up. Good reasons to use Perl in 2021.
It's 2021. Everybody thinks, oh my God, we've got to get Perl out of there.
The BSD team went to the exhaustive effort to remove Perl permanently from the distro, which I think was a stupid choice.
The NeoVim team ripped out Perl from inside of it.
It had some internal Perl support from there.
They went, get that fucking Perl out of there. We get that out of there. We can't have that.
And everybody's just got this Perl hate.
F Security, which by the way, F Security, really, really, you're going to permanently date your company to an Amazon thing about a guy
who struggles with psychotic problems.
You're going to make a Mr. Elliott reference for your company name,
and then you're going to have the gall to put inside of your job description as a bullet point,
has a healthy disdain for Perl. I'll show you those lines of that.
All you're really doing is proving how stupid you are.
If you don't understand why Perl is still a very, very viable cybersecurity language,
then you don't have any business being in the industry,
because Python's not going to do what Perl's going to do,
and I'm going to tell you all the ways that that's true.
All right, so the first one is regular expressions.
Perl is the industry standard for regular expressions.
In fact, your regular expressions use in JavaScript and in Go and in Python.
They're all using PCRE.
In fact, if you look at the Python source code, it literally links in LivePCRE,
which is the exact library created for Perl-compatible regular expressions,
because Perl set the standard, because Larry Wall and the gang, they saw a problem.
They said, you know what, AUK ain't doing it, said, oh my God, ain't doing it.
By the way, which version of AUK or said you have on your system?
Is it AUK or is it NAUK?
So Larry Wall fixed a problem.
He said, you know what, we need something that's relatively standardized
that has the best of all of these things together that fits that space
in between shell and C, and that's what Perl was.
That's what it became.
And that's all it was ever intended to be.
The fact that Perl went on to become the industry standard for back-end web development
is just a testament to the robustness of this command line utility scripting language.
That's all it was ever intended to be.
The fact that it even put up with what it was put under,
all the weight of the entire worldwide web development was put on Perl's shoulders,
which it was never designed to do.
The fact that I was able to write enterprise software that fell on its face with PHP, by the way,
and with Python, those things just did not do it.
They didn't do it.
And so Perl was there to do that thing.
It stopped judging Perl as an enterprise language.
It was never meant to be a language.
You know what it was meant to do?
It was meant to replace sed, awk, tr, cut, and all the other unnecessary sub-shells
in a way that could take one sub-shell, and it could be extremely powerful,
and it could be loaded, and it could do things that the other languages don't even dream of doing.
Like, oh, something as simple as mapping.
You know, map, filter, reduce.
Those are all built into Perl.
Those concepts were built into Perl before JavaScript was even conceived,
and they've been there all along as somebody the other day was saying,
you know, I've been looking for a language that's better than Node,
because it's more powerful on the command line.
I don't want to have to install Node on everything.
I was like, have you even looked at Perl?
What's Perl?
So leave it to the old guy to bring this up.
And I was just as much, I even made jokes about it.
There's a video, somebody put a comment recently on my Go videos,
and they say I was making a joke about it.
This looks like it's harder to read than Perl.
And I'll be the first to admit that there has been really bad Perl written.
There really has been.
There's been Perl that's been written that is, you know, just abysmally bad.
In fact, there's entire competitions that I'll let you go look up on your own
about Perl obfuscation contests, where like really super intelligent people,
you know, show off their ability to make their code absolutely completely incomprehensible.
By the way, that same sort of culture and thinking reminds me a lot of the Rust community today.
A lot of the Rust developers, they're very elite, they're very intelligent,
and they take pride in writing code that no one can understand.
Oh, it sucks to be you.
Can we just agree that that attitude in a developer should be like rooted out of any dev shop?
If you think you're better because you can write code that no one can understand,
you need to be fired on the spot.
I mean, if that sentiment bubbles up at any level in your team,
you have to shut that stuff down because it will destroy your team because, you know,
they'll think they're elite and they wanted this thing.
But let's talk about that for a second.
The reason that Perl is considered a read-only language is because it's got completely different design decisions.
The design decisions are we want to write a very contextual, very implicit, very magical language
that is able to write very, very quickly and powerfully in the fewest amount of keystrokes.
Because it's a shell script.
It's a shell scripting language, guys.
It has the best command line one-liners for shell that you will ever come across.
You might not understand them, but it doesn't matter because they're a single...
I'm not reading the comments yet.
If you guys are slamming me, I'm going to say my piece and then I'll read what you guys had to say.
So this is an example.
So here is a one-liner for Perl right here.
It's integrated into my VMRC.
It will actually go out and it will change any markdown link that doesn't have anything between the parentheses
into something that contains the link to DuckDuckO every time I exit my program.
Now, that is a very, very dense, unreadable line.
It would take you several minutes to look at it.
Because everything that it's doing, if you were to write it out in Python one step at a time,
you would have, like, 30 lines of code.
So, you know, 20 lines, maybe.
You know, the point I'm trying to make is that Perl is deliberately dense and contextual.
It's deliberately that way.
It's that way so that you can get more done on the command line.
And if you look at a language like AUK, you know, people are like...
This is the craziest thing.
In 2021, 2020, I continue to read and hear people talk about the praises of said and AUK and how awesome they are.
And then those same people will turn around without having any knowledge of what Perl even does.
And they will slam on Perl.
They will slam on Perl and they will say, well, Perl is that, blah, blah, blah.
Meanwhile, AUK is awesome.
And they have no idea what they're talking about.
They don't...
And it's like...
And they'll talk about how great AUK and these big, fancy lines, you know,
like if you're going to make a bunch of sub-shells, do it on a single command line.
And a powerful single command line is an essential skill to have if you're in cybersecurity,
if you're doing a lot of system administration.
But most knowledge workers should be able to learn how to use the Unix command line.
That is the true power of the Unix command line is learning how to use pipes and stuff.
And so if you don't know how to do that, you know, that's on you.
It's not on the language.
The language was designed for those people who can level up to the place where they can get a lot done in one line.
And that's why it exists that way.
And AUK, by the way, is very contextual as well.
It's very, very contextual.
And people will love on AUK while they'll hate on Perl, even though Perl is also contextual and they'll hate on it for the same reason.
The difference is you don't see AUK scripts in files that are running back-end common gateway interface processing
to connect to a database.
Perl can do that shit.
AUK can't.
And it's the same exact language.
In fact, it starts up almost faster than AUK.
Not the same speed.
Perl is obviously bigger than AUK.
But AUK has, you know, instead, people complain all the time about it.
Well, it says, you know, but you should see how fast the runtimes are in Perl these days.
I mean, you just started from the command line.
So let's talk about that for a second.
The chances of you getting a consistent version of Perl on a unique system are equal or better than getting a consistent version of AUK on a system.
In the day, in the 90s, there was NOK, there was NAUK, AUK, and all of the different AUKs had different forms of regular expressions.
One of the most annoying things that Larry Wall fixed with Perl is he was sick and tired of everybody disagreeing about regular expressions.
Regular expressions are hard enough to learn as it is.
I mean, there's wicked difficult to master as a beginner.
And so he's like, you know, I can't remember which one has which.
If you've written any VIM script, you'll know it's already different than said, you know, do I escape it?
Do I not escape it?
Does it support this class?
Does it support, you know, politics classes?
Does it have a backslash done?
So he said, you know what, I'm done with that.
I'm going to take all of that.
I'm going to put it in here and I'm going to take all of this.
I'm going to put that in there.
He took every single regular expression was there and made sure that the priority of Perl is on really powerful text manipulation, the practical extraction and reporting language, P-E-R-L.
I think that acronym came after Perl existed.
And, you know, there's all kinds of stuff you can read out there from people on this whole topic.
So that's what Perl has always been good at doing.
Perl has a wicked, great templating.
People don't even know.
You can use FMT in Perl and get really great textual templates for output.
You can, you know, anytime you're dealing with text manipulation and that includes parsing logs, you know, power gripping through stuff.
It also includes converting things to binary.
People don't understand this very well.
It's usually the last thing they learn in Perl.
There's a Perl pack, it's called.
And Perl pack allows you to specify very precise binary notation.
So you can parse binary files with Perl using the pack statement.
Let's you do that with Ock.
You can do it with Python, but which version of Python is Python even going to be on your system?
Is it going to require a pip install?
That's the problem with Python.
Python's not on those systems.
It's not on all unique systems.
And if it is, it's not going to be consistent.
It's not.
You can't count on it.
So think of all the reasons that you want something that's already there.
The reason that you use, you know, the bash is because it's default on Linux.
The arguments people make for using a POSIX shell is because that's supported on all forms of Unix.
They don't have to, you know, have a Docker container just to run their application.
They can write a script and share it, or they can, more importantly, they can put a script on the system.
And if you've done any pen testing at all, you should obviously immediately understand the benefit of this,
which is why it's so stupid that F security would make fun of the language that's the most effective
for writing, harvesting, you know, penetrations code on.
The reason that Go is going to destroy Python in a cybersecurity world as soon as everything gets ported over
is because Go can write packages and payloads that run on the target system from any other system.
I can write it on iMac.
I can write a target for a Windows machine, send it over there,
and execute it on the system without any dependencies whatsoever.
If the system is a Unix system, I can write it in Perl.
I can write a Perl script and run that Perl script over there,
and I could, you know, how it depends on how powerful your shell is, right,
but that you've, you know, your backdoor you've got.
But if you go on that system, you have Perl ready, but it's a Unix system, right?
So you don't have Python.
Go dig apart the rootkits.
They use Python.
They have to ship the whole fucking Python interpreter with it
to make sure that they have the right version.
Whereas if they were attacking a system, and that's fine if you're attacking Windows or something,
this is why Go is going to be better.
Go doesn't have a whole bunch of bundles.
It's just got one very difficult to decompile executable that then can go on the target system.
That's got a ton of stuff, including high-level encryption built into the standard library.
Again, I think Go and Perl are still very viable for all kinds of hacking techniques,
particularly when you just have a shell thing.
So, I mean, anytime you're dealing with text, and so the reason I came to this is because I'm doing with,
oh, here's another thing.
Let's say you want to work with a system that's in Chinese,
and you want to use regular expressions to parse through logs in Chinese.
Oh, no, you don't have regular expression support for Unicode.
How am I going to parse these congy characters?
Can't do it.
It's no surprise that Perl is the first language to implement backslash p,
which is a Unicode-reg-x class match.
So you put in parentheses behind that, you can put whatever plane of the Unicode set that you want.
As far as I know, as of this date, Perl is the only thing that supports that.
And so as I was implementing my KN utility for knowledge management stuff,
I wanted to make very strict regular expression matches for the URIs that I'm using for knowledge nodes,
and I wanted to say any uppercase letter, not just any ASCII uppercase letter.
You should all go, if you want some homework right now, go find your preferred language right now
for your standard language, your workhorse language,
and go see if with a regular expression you can match a set of Unicode characters
that matches all capital L lowercase u, that class,
which is the Unicode character set for uppercase letters.
And we're not talking about just ASCII.
Ask yourself and then do the research to see if your language can do it,
and I'll bet you that it can't.
I know Bash can't.
I was trying to do some of this stuff in Bash because 2020 was an experiment to see how much of my life
I could just do completely entirely in Bash and go,
and I found out that as of this week that there's a pretty significant portion of what I like to do that I can't do.
I can't match Unicode character classes, period.
Not possible.
And maybe that's coming out, and I imagine all of that,
I imagine the pressure that Perl's going to put on everything else is going to do that,
and since Perl is the thing that defines the standard for regular expressions,
LibPCRE is a good bet that anything that supports LibPCRE is going to get an upgrade
because the people who support LibPCRE who are no longer associated with the Perl project
are going to add that Unicode backslash P support,
and it's going to land in every other language thanks to Perl.
All right, so I don't know how many times I have to say it.
I have a little soft spot on this in me, and if I sound aggravated,
it's mostly because I'm aggravated at myself for not remembering what Perl is good for.
Now, let's do spend some time talking about what Perl is horrible for.
Perl is not for object-oriented programming in any sense.
It's not for programming anything at scale.
It was never designed to do that.
Don't do that in Perl.
Do it in Python.
Do it in Go.
Do it in Java.
Do it in C-sharp.
Don't do 10,000 lines, 100,000 lines of Perl code.
That's ridiculous.
Perl is a fucking shell script.
It's not designed for that.
Don't use it that way.
Use it the way it's intended.
And then you'll make a benefit of it, right?
So even JavaScript is more suited for that because it's strictly typed.
It can be transpiled.
I mean, Perl is not the language for that.
It was never designed to do that.
Don't do that.
I did it.
We all did.
Because it was the only thing.
Python couldn't even do some of the stuff we did.
And then eventually Python caught up.
And it started being able to do that.
It was a little bit more verbose.
It had Python had that really, really, really sweet C-stubbing so that you could make NumPy
and all the stuff that Pythons become famous for.
Perl was always...
Perl didn't like people writing C-stubs for the language.
No, it's a shell scripting language.
We're not going to add support for C-stubbing to the language.
It has it.
But it was like, we're not going to really focus on that.
That's not our goal here.
Our goal is to maintain a decent shell scripting language.
As soon as you start...
As soon as you have to add a dependency to something from C-pan in your Perl code, you've
failed.
It's my opinion.
In my opinion, you're no longer using Perl for what it was intended to be.
Just a present shell script that gets a lot of stuff done that's better than Bash and
ZShell and Fish and all the other shells for writing really great, fast code.
The speed and performance of Perl is way better because your average Bash code that would be
100 lines, 200 lines long, it's probably got at least half dozen, two dozen, three dozen
sub-shells in there to get stuff done, even more if you don't know what you're doing
and you're using a lot of set and awk.
In that case, you might as well just write one Perl script, which is one sub-shell.
And all that performance goes away and it's actually faster, even though it might take
a little bit more memory for it to run.
So that's the case where you wouldn't want to use Perl.
You definitely don't want to use Perl for large-scale enterprise applications.
It was never intended for that.
Don't do that.
It's a bad idea.
For that, I personally think Go is the best thing for that because you can tell that Go
is highly influenced by Perl on many levels.
But grab a more verbose, strictly-type language.
The whole world has realized that interpreter languages are not the thing to go to for large-scale
development.
Microservices, the whole cloud-native world is all Go right now.
All of it.
This is just stating facts here, people.
I'm not trying to state this.
This is an opinion.
This is the fact.
Go was developed for cloud-native development, whatever you want to call that, at Google,
specifically for those reasons with strong concurrency before anyone was thinking about
it because Google needed it, and now we've all benefited from that, and Go has become
the overwhelming industry standard for cloud-native development, period.
And that's not even up for debate.
I mean, you can confirm that all over the place.
I don't need to tell you that.
So don't use Perl for the wrong thing, but use Perl for the right thing.
What is Perl's right thing?
Perl is the right thing whenever there's a lot of text involved.
Whenever you're pushing the limit of that little shell script that you wrote, whether
it's Z shell or Bash or TC shell or whatever, if you're starting to push the boundary a
little bit, and particularly if you're a little bit afraid of that POSIX glob in your shell,
you don't want it to work.
This is not a thing about Perl that people don't really give it credit for.
Perl is a very, very safe language to write in.
It's probably one of the safest, and that was largely because of all the stuff that
was happening with the web.
Anybody know about dash T, capital T?
Hmm.
Okay.
So you were slamming on Perl, but you've never used the dash capital T switch ever?
You don't know what it is?
Okay.
Let me help you understand that.
Dash capital T turns on taint checking.
And there is no language on planet Earth that does this, and they should.
Taint checking is one of the best things you will ever add to a language.
Taint checking automatically says any input, whether it be an environment variable, standard
input, or any other file handle, is automatically tainted.
And the only way it gets untainted is if you explicitly write code that checks the data
coming in in some way.
Speaking match it against the regular expression, or you explicitly set the path.
When you turn taint checking on, one of the reasons people turn it off immediately is
because it forces you to set the path in the script, which means that you can't trust
the path of the system.
You have to explicitly set the path because the people who made Perl and they added
taint checking were fundamentally interested in security.
You don't see that in Python.
You don't see that in many other languages, even Rust.
Rust is supposed to be a secure language.
I don't see anything about tainting in there.
There's a lot about managing memory and borrowing and stuff like that from what I know.
I'm not going to say I'm a Rust expert, of course, but I don't see anything that's doing
that, and I really wish more languages would do it.
And Perl is really good at that.
And by the way, if you're writing a shell, one of the dangers of shell scripting is if
your shell script gets adopted as something that gets installed everywhere, you might want
to add those kind of things.
But at that point, you probably should move it to another language like Go or C Sharp
or Java or whatever, or even Rust.
But again, Rust is a systems engineering language.
It's a difference.
It's a C++ replacement.
I don't want to get into the language where I know.
Let's just recap here.
Good reason to use Perl in 2021.
It's old, but it's still very useful, like Linux.
Old, very useful.
Still getting improved upon, still increased.
Just forget Perl 6 ever existed.
All the rest of us have.
It's got the industry standard for regular expression.
It includes Unicode support, which supports matching Chinese characters as well as emojis
and everything else.
And others don't.
Other languages don't.
It's on every system, every Unix or Linux system created in the last 30 years.
You can go back to Perl 4, and if you don't push the boundaries, if you don't need Unicode
and stuff like that, you can find Perl 4 on systems that go all the way back to the late,
I'd say the very early 80s, probably 86, right?
So it's going to be on everything.
You have just as good a chance of finding Perl on things as you will finding Auk.
Except BSD.
BSD went to great lengths to rip it out.
And I think that was a really stupid decision, but that's their decision.
It has, it creates a single powerful sub-process instead of lots and lots and lots of sub-processes
like you would use in any other shell scripting.
I think it's got one of the most brilliant developer teams ever to have lived.
I have never been burned by Perl.
And I wrote a list of all the things that have burned me over the years.
And Perl was always there to have my back.
PHP, bad memory leaks burned me.
Java, serious JVM bug.
They had to fly a guy in from Sun Microsystems so I could prove that our Nike software wasn't going to make the deadline
because of the stupid JVM bug to which the guy said, huh.
And I just felt very validated and pissed off at the same time.
Perl had my back.
It worked out every time.
Every single time something else has failed, and especially because I know Perl,
is because it has rock solid development.
It has never had a stop you in your tracks bug that I've encountered.
It may have had them, but I just didn't ever encounter the PHP had them.
JVM, Java's had them.
Go hasn't had them in any so far, too.
So far, Go hasn't had any.
The only thing that stopped me with Go that I would consider a bug, a big one,
is that Go routines, if you're not careful with them, they'll leak.
That's not a bug though.
So Perl provides the ability to write the most powerful one-liners in the world.
In fact, there's, you know, I have an alias called Pi, Perl, you know, that's p-i-s-e,
which will recursively find and replace a keyword and everything.
Said some years, almost like five or six years after Perl had ever had this,
added said-i in the Linux version, which does essentially the same thing.
The difference is, is it said has a completely different set of regular expressions.
It doesn't use the same PCRE standard, which is really confusing.
So might not go with that.
There is a replacement for that these days called, just read about SD.
It's not in any of the app package kind of things, but which actually replaces with the Perl expression,
so you can use it for said that way.
There's a lot of the new utilities are getting replaced.
Perl is dense, hard to read, contextual and implicit, but it does it on purpose,
so it'll be more powerful.
Perl is not going anywhere.
Sorry, people are not taking it off of stuff.
In fact, if anything, I think Perl is going to increase in usage as we go forward,
because the world is turning to conversational things.
The terminal is becoming important again.
You know, people are learning that manipulating text and parsing,
and parsing conversational text and grammars and things like that are important,
and Perl is going to be right there to do that.
You know, Python will do it, but first of all, you have to install Python.
Secondly, you have to make sure you have the right version of Python,
and the answer to that that everyone tells me is,
well, you should run a Python virtual environment.
I'm not running a Python virtual environment to run what is a glorified shell script.
Python is good for those applications.
It's horrible as a shell scripting language.
It's horrible.
Have you ever tried to do...
One-liners in Python are so horrible.
I hate them.
So, it's still the best language where text is concerned.
It has a pack and map and grep.
It's the safest shell scripting possible, way safer than Python,
and it has syntax similar to shell.
And that's actually something people don't like.
At first, they complain about it being kind of weird and cryptic and looking weird,
but that's because it's designed to feel like you're coding
in sort of POSIX or Bash or ZShell with, you know, some extra power.
So $0 is a special variable name for, you know, the current running script.
Well, that's the same thing you would use if you're writing shell code.
So that kind of weirdness in the variable naming and stuff like that,
that's not Pearl's fault.
That's because it feels like you're writing shell code.
So Pearl is the natural progression from writing Bash or ZShell or Shell.
And actually, if you're a ZShell advocate, you guys know I don't like ZShell.
I play and complain about it all the time.
But if you are a ZShell or a POSIX person, then Pearl is a really great companion for you,
because Pearl does all of the things that those languages can't do.
Bash can step into that Pearl space way more than ZShell can,
particularly with exported functions and things,
and full regular expression support.
Actually, ZShell has regular expression support, we saw that.
The regular expression support in Bash and in ZShell appears to be
the same exact regular expression support that you see in Pearl.
So I'm able to reuse those kind of things.
And by the way, that and the use of associative arrays,
which are otherwise known as hashes or dictionaries and Python,
those things are, you have to have Bash 4.2 or higher to get that.
ZShell doesn't have it, of course, and neither do the POSIX shell scripts.
But Pearl has gobs of that in droves.
You can use, it's very advanced support for references and all of that stuff.
So you can do some of those advanced techniques where you're dereferencing
and you can actually directly manipulate the symbol table,
which I did to create Pearl Classes Pragma,
which at the time, it made sense to,
it was sort of an effort to bring some of the better parts of object programming
for Ruby into Pearl.
You can look at that, it's called Pearl Classes Pragma in my GitHub if you want to see it.
But it shows what you can do, you can actually directly manipulate the symbol table in Pearl.
That's the kind of stuff that in Python,
oh, wait, Python you can get down into the underlying stuff,
which by the way, almost all objects in Python are dictionaries,
and it turns out it's benchmarked, it's actually faster to deal with the internal dictionaries
than it is to use objects as, what they call them,
like small objects as if they were like, it's rather than hash map space.
Anyway, so it can take you to where you need to be, but not further.
And if you try to take it further than that, you're doing it wrong.
At that point, it's probably time to grab another language.
And one of those other languages would be Python.
Python is definitely suited for a larger application sort of approach.
So this TypeScript, I imagine Dino is going to be more of that kind of thing,
but definitely Go in that space, those are meant for larger applications.
C Sharp and the Java, all the traditional OOP things.
And C++, but if you're going to do, that's a different thing altogether.
As soon as you're headed to C++ and Rust, you're looking for performance,
and C and optimizations like that.
And all different languages for different purposes.
But to date, Perl remains the best language where regular expressions are concerned
and where any text manipulation or command line is concerned.
Basically, when your shell starts to get a little complicated,
time to pick up some Perl and just use it.
Use the Perl on your system. You don't have to get crazy.
All right, that's all about it here.
Actually, technically, I'll be closing the video at this point.
I'm going to take some questions from the chat and try to keep my cool here.
I'm just going to tell you right up.
I have had in the past very little patience for people,
as I kind of started out with, people who attack Perl who don't know it
and have never used it.
And I try my hardest to not be that person.
You should at least have tried it at a minimal level
in order to get at least your basic bearings on it before you don't like it.
And that's my opinion.
So, I mean, obviously, this is all opinionated stuff.
I'm going to bring up the whole chat here.
Toot, toot, toot.
And I'll put you guys down here.
I'll go back up and go back to the earlier pages.
Windows is boomer.
I fecal.
It's background.
Community in Perl.
Could there be a better combo?
Hi, all.
Let's see.
Hello.
Perl is my Swiss Army chainsaw.
I went back in and wore.
I like that term.
I heard that term yesterday again.
Key macro, the Swiss Army chainsaw.
How are you doing today?
I'm pretty good.
Hey, Naman.
It's good to see you the other day, too.
He doesn't read Twitch chat.
I can see Twitch chat now.
Thank you for having my back there.
If you want to chat live, you'll need to go to blah, blah, blah.
Yesterday he was reading, so I thought, yep.
Naman, we have a bridge now.
I'll message from Twitch or Mirage IRC now.
Thanks, by the way.
Let me credit to Vera to be Vera for that.
My IRC admin, he's been doing great.
I really appreciate that.
User Perl, wow, that's new.
It was new within the last three days.
We move kind of faster, particularly with the people I have helping me out.
Hello, sir.
Just discovered your channel.
Great.
They're also great, bite-sized articles.
I learned a lot from back in in the day.
Yeah, articles and magazines from Merlin.
Yeah, actually, Merlin used to live in the same town as me when I was in Portland.
Yeah, Randall.
I was there when Randall was convicted of hacking.
We had the Save Randall campaign and all of that stuff.
In fact, Randall, if you happen to watch this all the best,
I know you probably don't remember me.
I remember one time in the middle of the day, Randall Schwartz and I and Lynn Soprell,
the web mistress from Telephone Internet Services, we went and grabbed a drink.
I remember just shooting the breeze.
I don't even remember what we were talking about.
He was a really nice guy.
I remember all the hassle he had to go through.
He's the one who wrote Learning Pearl.
He's something of a God in the Pearl community.
He invented the Schwartzian transformation and a bunch of other optimizations for Pearl
that, quite frankly, should have been unnecessary.
As I said, Pearl was pushed to do things it was never intended to do,
and the fact that it did them and kept on going is just a testament to how great this shell scripting language is.
Let's just remember that that's what it is.
It's a shell scripting language.
It's not anything more, so don't use it for that.
And you'll be fine.
In fact, you'll be happy, particularly if you're in cybersecurity.
If I was in security, I'd be all over this thing.
Thanks for a great talk this morning.
Yeah, no problem.
Hi, everybody.
Hi, Rob.
This is...
Oh, hi, Kitty.
Hi, everybody.
Rob is in the yesterday's mood, as I see.
I'm not even sure what Pearl is, and I've just started learning how to navigate the terminal.
That's nice, Mark.
Pearl is basically a more powerful version of Bash.
When you get shot, Bash, Awk, and Set all combine.
Those are all tools that you use on the command line.
Bash is the language that the interpreter that you use every time you execute a command in a Linux system by default.
And so Pearl is...
You can write scripts in that language, in the same language that you run, your interactive terminal.
You can write things that just happen when you run them, and that's what makes the terminal so powerful.
But at some point, you're going to want to reach for a little bit more power,
particularly when you're dealing with stuff with text.
And then when that time comes, that's what Pearl is there to help you with.
And normally in the past, you would reach for Set and Awk and TR and stuff.
So these days, that's what Pearl is there to help you with.
Pearl's a women wisdom.
Did I say women? I did.
I know, I'm proud to remember the Sally DeFunk London Pearl Mangers Group.
I know. I was all over the Pearl Mangers Groups too.
I loved them. I gave lots of conversations and presentations and all that stuff.
This has inspired me to learn to Pearl.
I still use Pearl all the time for interacting with network kits and APIs.
There you go. See what I'm saying?
And this is something too, is people like Cypheric do not speak up.
The people who are using Pearl aren't just old cronies like me, you know,
curmudgeons and me, pearl curmudgeons, like we used to call them.
They're not. There are people who have discovered the use of Pearl as a network integration layer,
as the duct tape of the internet, that was once called, because that's what it's good at doing.
Pearl is fantastic duct tape.
It's like really great in making a whole bunch of stuff work interactive together,
so you can have executables and you can call those executables.
I do that in the KN tool.
You can parse network input.
It has a really great TCP IP stack, so we can go talk to it.
Try that with AUK. You can't do it.
Python has it, but it gets like which version, right?
And it's not going to be on the system by default.
So, yeah, will Pearl integrate with Vim as well as Bash?
Absolutely. You know why?
Because Pearl can be any...
Look, Sophie Colt, let me... I want to make something clear here.
Anything that can be executed can be integrated into shell.
Okay, so if you use the...
And if you watch me do the KN development, which I'm going to do later,
any script that can run can be integrated into Vim, right?
Now, this is actually...
If Pearl and Vim has integrated support so you can actually code Vim script in Pearl,
the NeoVim people ripped it out.
Another reason NeoVim is totally stupid.
I mean, they've made so many...
I mean, why would you rip out the world's best text manipulation language
from the world's best editor?
I mean, what kind of stupidity do you have to have in your head
to disassociate Pearl from NeoVim?
That decision by itself, when I saw that, I was like,
okay, you've just proved you have absolutely no idea what you're doing to me.
That's a project.
Anything that braves appropriately with a step in, step out, which works with Pearl.
That's right.
And that's really the shell.
When I say shell integration, what I really mean is anything that can be run from the shell.
And that includes Pearl.
So let's try something here.
I want to show you what I mean by that.
So if I'm just doing a foo, I can write a markdown file, right?
I can just say, I put my title up here, something in the title.
And then over here, I'm going to say, you know, I can actually write some Pearl code.
I can say, well, let's see.
Something simple.
I mean, I'm used to writing Bash so much because Bash is so easy to integrate.
You could do four.
I mean, it doesn't...
There's not very many reasons that I would write Pearl in line to do this kind of thing.
But I guess I could.
I mean, I could...
I know, I just can't think of any reason that you would do...
Oh, maybe a pack.
Let me see if I can think of a pack.
I'll do one for you, Fiko.
I'll make a video on that.
So one example would be if you had to bring in some binary data.
You know what I mean?
But Pearl isn't very good for writing one-liners.
For that kind of thing, I'm big into Shell.
For I in, you know, zero, like 34, do, echo, I, done.
And most of the time when I'm writing one-liners, I'm writing in Bash and I will continue to do so.
Pearl steps in when I need to make a script.
You know what I mean?
Like when I need to make a script.
But if I'm writing one-liners, yeah, that is your friend.
But, you know, so much of that is already done in Bash.
So I would be, you know, I'd be sort of hesitant to do that.
So, okay, so let me show you how to do this.
This is some Bash code in the middle of my thing.
And let's say I want to write, you know, number...
I want a number of bunch of stuff.
So, some...
And then I can just run this code.
Old Codgers.
Git team, yeah.
Yeah, yeah, they're...
The Git team, I think the Git team has some Pearls still left in it.
People were complaining about it, actually.
So I can run this through Bash.
And then that'll just replace it.
It'll put the zero in there even if I want.
So for that kind of thing, I would stick with Bash.
Just because it's so easy to do.
But when you want to use Pearls,
when you want to start to write a script like I've done with the KN tool.
So this is the KN tool that has to look through the environment.
And another thing, too, is it has data dumpers and things like that are standard.
So you can dump your structures and get it...
That kind of stuff in Bash is really, really painful.
I mean, it's really painful.
You've got to know...
It's just crazy.
I got into it there at the little bit at the end.
And then I came back to Pearl and I was like, oh my God, this is so much easier.
But the thing that's important to consider is that the subroutines are like shell subroutines.
In other words, you don't define an argument signature.
You just shift stuff off.
You're coding in shell.
That's what it is.
Once again, if you take nothing more away from this,
Pearl is a shell scripting language.
That's what it is.
It's not meant to be...
You can't run a Pearl interactive shell,
but it's meant to be a shell scripting language like the next level up.
So here's how you do a dictionary.
This is actually taking a reference to the function so that I can run the function later.
This is a good example of a map.
So this takes every file inside of this directory through GlobExpansion.
Maps every one of those files replacing everything up to the slash with nothing.
So it's basically trimming off the stuff except for the name.
And then it returns the name by just...
That's the current value through the loop.
And then that thing gets returned.
So all of that returns as an array.
And then it loops through the array and it joins them all
and makes a little pass for the whole thing.
So that looks pretty dense.
And it is dense, but it's also very, very, very powerful.
I mean, if I were to write that in Python, I don't know how many lines that would be.
That would, you know...
Actually, for Pearl, I recommend you do install Pearl docs and just use the man pages.
Something else I didn't even mention is how great the man pages are.
You gotta remember, Pearl existed before the internet existed.
So it's documentation.
You can go Pearl Intro, Man Pearl Intro.
This is the best source of information on Pearl you'll ever find.
I'm telling you.
And they even have UserBinionV.
I hate this.
I do not like UserBinionV.
I do not recommend you do that.
It's an unnecessary...
So it's also insecure, even though they suggest it.
But my point is, is that you can go read anything you might want to ever read about here
just by reading through the documents that come with it.
So the man pages on Pearl are what I would recommend for free.
There's, you know, the good old learning Pearl from Randall Schwartz.
It's probably, I don't know if it's been updated recently.
The thing about Pearl, as it's been around, it hasn't really changed in 15 years.
I mean, they've added support for a command called say, which I really love.
I mean, that actually...
I found out, by the way, if you are a Pearl person, this might be of interest to you.
If you are a Pearl person, you need at least 5.10 to use say instead of print.
But that'll save you that annoying backslash and at the end of everything.
And if you've done any Pearl coding at all, you know what I'm talking about.
Super annoying, right?
You have to put backslash and on the end of everything.
And if you're a shell scrapper, it's super annoying.
So if you use at least version 5.10 or above...
I also did the research and found out that 5.14...
5.14 is the first version that supports Unicode backslash P.
And they're at now at Pearl 5.30.
And there's no intention of ceasing support for Pearl 5 ever in the future.
So they're continuing to maintain it.
The Pearl cookbook is...
Yeah, I love the Pearl cookbook.
It's funny.
I actually...
When I give it Pearl some years ago for Python and some other things, I got rid of all my books.
I have like Pearl testing.
I used to be on pretty good terms with most of the book authors.
It's been forever.
It's been forever.
I mean, I was really in the Pearl community.
But I, you know, and then I kind of moved on.
And it was funny because a lot of the people in the Pearl community, many of them have never left.
That's still all they do every day all day is Pearl.
I'm like, guys, there's a lot of other stuff out there now.
You know, just giving them a hard time.
But environment variables are the same.
I don't know if you can notice this, but you see how things look a lot similar to Shell, right?
This is a...
FileSpec is a standard library for joining.
So you can do it in a, you know, in a standard way.
If it looks a little bit like...
You know what I also find interesting?
Doesn't this look a little bit like Rust?
It does, doesn't it?
In fact, there's remarkable similarities between Pearl syntax and Rust syntax.
I think I find always find interesting.
You can sometimes run into a Rust person that will slam Pearl for being right only or read only
because the syntax is so bad.
Meanwhile...
Pearl and syntax?
That's not...
I mean, I'm going to say it again, since I had...
I just moderated, like, 80 comments on my 48,000 hit Rust is slow
and I changed the title and everything to try to get people to leave me alone
over that thing.
But no one watches it again.
Only 14% of the people watch...
They only watch the first, like, 20 minutes of that Rust video.
They don't see any of my conclusions at the end.
They just see the first stuff and then they go off.
Most of them don't even watch the video.
So I had to be careful by making this video and try to be more specific about it.
I'm going to go ahead and drop the stream here pretty soon
and restart the stream,
try having a little coffee with my wife
and I'll come back.
I'll be coding in Pearl all day today and tomorrow.
In fact, I'm going to be coding in Pearl a lot over the next few days.
Most of my shell script library in my .files
is going to be converted to Pearl subcommands of the KN tool
and the rest of them are probably going to...
I'm going to rewrite them in either POSIX and DASH
or a few will remain as bash.
But I'm personally going to start writing everything...
All my shell scripts will either be in POSIX, shell, or Pearl.
And to the ZShell people out there,
that's probably going to be music to your ears
because everything I write, you'll be able to use.
You could use the bash stuff anyway, right?
Because it's got a shebang line that points to bash
and your system probably has bash on it, even if it has ZShell.
Not if you have a Mac though,
but it's a good bet that you have Pearl on it.
So say, for example, you're a Mac user
and you want to use any of the stuff that I write,
you'll be able to use it because it'll either be in POSIX shell,
which is ZShell compatible,
or it'll be in Pearl,
and you already got Pearl in your system usually.
In fact, anybody got a Mac handy right now,
they can go on there terminal and do which Pearl,
or do pearl-version.
Anybody have a Mac out there and want to admit it?
I would love to see what version Mac comes with.
It might not come with it though,
but Pearl artistic licenses is completely different than GPL3,
so I think it has a good shot of still staying on the system.
Maybe not though.
5.32, seriously, on your Mac?
Wow, I'm impressed.
There's another reason to use it.
Another reason to write your shell scripts
is if you write your shell scripts in Bash,
default Mac users won't be able to run your shell script
because Bash has to be installed.
They can run your Pearl script.
We just proved it.
They can run your POSIX shell scripts.
If you're searching for usability across the board
for your team and for your friends,
or if you're a live streamer that wants to be able to share cool things with people,
it kind of behooves you to write it either in Pearl or POSIX shell.
Interestingly, that's the position I had in 2007,
or Python, but Python has to be installed.
There are slight differences with active Pearl, strawberry, Pearl,
especially using different modules.
None of those need to be installed.
Good old active Pearl and strawberry Pearl.
Anybody ever play with Indigo Pearl?
That's how I got Indigo Pearl.
I'm not a Pearl 7 or a Pearl 6 fan.
I will only use the Pearl that comes on the system.
The very purpose of Pearl is to have a shell script
that's on everything that just works.
That's Pearl 5, and that's never going to be Pearl 6 or 7.
If you're reaching for Pearl 6 or 7,
then you're making a different decision.
You know what I'm saying?
You're now making a decision about kind of a different scope of application.
At that point, you've got lots of things to evaluate.
You've got to see, is this better than TypeScript?
Is this better than Go or Rust if it's low level?
I am never going to code any Pearl other than Pearl 5,
because I just want the shell script.
That's what Pearl was intended to be.
That's the best thing it ever was,
and the fact that it keeps getting pushed to be more,
I think is a mistake.
I apologize, Pearl people, out there.
I know some of you are very hard working,
and they tried really hard with Pearl 6,
but Pearl 6 is a perfect example of what Brian Cantrell,
formerly a joint now from Oxide Computing,
calls second system syndrome.
It's when you open up the gates
because you're going to make a new thing,
and all of a sudden it never gets done all of a sudden.
Because so many new ideas come in,
and they overweigh the thing,
so it never gets done.
Because you just keep trying to do it.
I think all of the Pearl versions beyond Pearl 5
suffer from second system syndrome,
and they, frankly, they open the door for Python.
I would have easily picked Python over Pearl 6 or 7 any day,
just based on the TensorFlow support
and all its wide adoption and Jupyter notebooks.
I know those things can be done in Pearl 2,
but there are so many reasons to stick with Python
for that stuff, and automation, all of that stuff.
Pearl 5 after 4, yeah, completely fair.
That's a fair critique.
Yeah, yeah, finding talk, I'm off.
Take care, Q-Macro. I completely agree.
A lot of people don't know this,
but Pearl 4 didn't have this notation at all,
this reference notation right here,
to this file spec stuff like this.
That was all of Pearl 5 edition.
Yeah, the split between Pearl 4 and 5.
Pearl 4 was really, really just a better awk,
and you didn't have this idea of objects at all, and bless.
I don't even want to talk to you about that stuff.
In fact, I would suggest you not even use it.
Really, I think as best as possible.
I do hear because I'm doing a join,
but for the most part, I would rather you try to stick with Pearl 4 syntax
as much as you can and keep it functional.
If you get too much into the Pearl object-oriented world,
which you can totally do with the thing called bless,
Python does the same thing as bless, by the way.
They just don't call it that.
Then you're kind of going off the deep end at that point.
If you're reaching for bless or for some way to make an object,
you're probably doing it in the wrong language,
and you probably want to rethink your selection of Pearl for that
and move to something else.
Keep Pearl as a glorified shell language, and then you'll be fine,
because that's what it's really, really great at doing.
Any other questions?
Let me talk to the YouTube people for a second.
By the way, here is the regular expression I want to see
if people can test in their own languages
and see their preferred languages if they can match it.
We have a match.
This matches any uppercase letter character
according to the Unicode classification,
which includes several letters that are not in the code plan.
If you're interested in this, by the way,
this stuff is all in the pagan notation.
If you go to github.com slash pagan, and you click on spec,
and then classes in there, you'll see all of these planes
subdivided out by their exact character names,
and so you can decide if the match is actually working.
We did that because we built it into the specification,
into the parsing expression grammar notation,
which is the specification for that.
No more talking about that, though.
If you want to know about that, we do that on Fridays.
We work on the pagan grammar notation,
meta-language, and writing all of that stuff up,
which is really fun.
That's how I happened to know about this,
because I was going through it, and because of pagan,
I was like, well, gosh, I really don't want to just
match upper ASCII here.
I want to match any uppercase letter,
even though I think environment variables,
as a default, must be ASCII characters.
I think that's the requirement for all systems,
but I don't know that.
So this is just a match to isolate any action
that might actually be an environment variable,
which allows me to do this.
So now I can just do a KN path,
and it will show me the whole path.
I can do whatever, and I can do some other things with KN.
But if you want to know more about the KN tool,
and you have questions about what it does,
and how it works, and why I'm doing it,
stick around, and when I come back,
I'm going to be coding on that all day today.
And I'll be coding in Perl, mostly.
In fact, I'm going to be moving all of my library,
my .falls library, either to Perl or to POSIX shell.
So if those topics interest you, please stay tuned.
I won't always be talking a lot,
because you can listen to the desert in the background
if you want.
I thought I'd bring up the old Perl Camel for fun,
because Perl's not lost in the desert.
It's still getting used all over the place, right,
say Farak?
Anyway, it's been fun.
I'm going to go check our YouTubers
who don't have a way to communicate with us right now.
It's unfortunate.
Uh-oh.
Message retacted.
We had a couple of messages get retacted.
Looks like they didn't want to follow through with it anyway.
Maybe they came in to our other thing.
So, Alexki, did you get your question answered?
And Catalan, that's planning on using a Perl set of bash scripts.
What do you think?
I think it's a great idea.
I do.
And you're hearing this from a guy who was big on bash
until two days ago.
Two days ago, I got really burned by bash.
And the first burn was that,
oh, okay, thank you, thank you.
The first burn about bash was that I could not
match Unicode characters.
That was the first burn.
And the second one was that I could not do documentation.
And we haven't even talked about that,
but Perl has wicked, awesome documentation support.
You write the documentation in the script file at the end
so your interpreter doesn't have to go through the hassle
of parsing it like it does with Python.
And it makes it wicked fast.
And so that way, your little script that was,
at one point, it was just a little shell script.
And now it's a Perl script.
You can actually document it in a way that is totally marked.
You can mark it up and everything using Pod.
It's an old format, but it still allows you to create
man pages and stuff for your little shell script.
So you've got little shell script that you made.
It can grow up.
And because it's all coming at the end of the file,
the interpreter completely ignores it.
Completely ignores it.
So it's extremely efficient documentation.
So for the KN tool, I wanted to document each of these commands
that I'm making, these actions I'm calling them.
And I was putting these big long bash comments and stuff.
I'm like, man, this is horrible.
And then I remembered how well and easy it was to document
your functions in Perl.
I mean, to document everything in Perl using Perl Pod
after the underscore, underscore, end, and putting it all there.
And so that documentation travels with your script.
So once again, that and the Unicode support caused me
to change writing my KN actions from bash to Perl.
And frankly, based on that, I won't be returning to bash
other than as an interactive shell.
I won't be writing any more shell scripts in bash because of it.
And I love bash.
Don't get me wrong, I love it.
I think it's really cool.
I learned a lot going through it.
I still think reading through the bash user guidelines is fine.
But I've got to tell you, I was getting a little bit annoyed
at all the stuff for variables that I had to do to use the Perl
in bash.
In bash, I had to make sure that I had curly brackets
and double quotes around all my variables
and I had to write a little macro to do that.
And I was starting to wear on me.
And then last night, I started writing all the same stuff in Perl.
And it was like, I wasn't pushing a rock uphill anymore.
It was like easy.
I can just use $ whatever for a variable name
and just be done with it.
And it was just so liberating.
And it just started flowing again, not just because I knew it before,
but because it's a much better language to write shell scripts in.
And that's what it's always been intended for.
So anyway, also I feel Perl is easier to read than bash.
Yes, absolutely.
In fact, can I show you the bash equivalent?
So the other thing that, and you've got to understand,
I was really loving on bash.
But let me show you this here.
So here's a good example of where bash falls on its face.
The fact that you can do it is still pretty cool.
I'm sorry for the background.
It's a little bit off.
So here is the code to do completion for build scripts.
Oh, yeah.
Perl has got awesome support on Windows.
You usually have to install something,
but usually people are running it on Linux.
It's through WSL or something like that.
So let me see if I can find it.
So this code right here,
this is code that converts,
every bit is dense as Perl.
The difference is that it's not as powerful as Perl.
So if you're going to buy off on that,
this replaces everything up to the dot.
Actually, this replaces all the dots with a slash.
So that's what it does.
But this is where it really gets crazy.
So let's see if I can find it.
Compliant.
Where's my compliant?
I guess I took it out already.
Yep.
See dot files.
Scripts.
I might remove those icons.
They're kind of annoying.
I was just trying another thing for icons.
Let's try Perl.
Yeah, for Windows.
And where is it?
Right here?
No.
I think I removed it already.
Oh, well.
Actually, I have another one that does this.
So this command, this here, see this?
This code right here fulfills tab completion
by checking to see if an environment variable
has a compliant set.
And if it does, it iterates over all of the commands.
This is how you write, and this is,
I'm just going to say it, this is ugly.
This is how you write a dictionary in Bash.
Yeah.
Ugly sin, right?
You know how you write that in Perl?
Hashtag, I mean percent commands.
But you have to type all of that just to get to that in Bash.
This here points to malware.
The address tied to malware.
What's that?
Perlcom domain.
IP address tied to malware.
Oh, boy.
Does that count points to malware?
It doesn't surprise me.
Yeah.
There's a lot of hackers still using Perl,
not just old people.
This here says replace, this says,
does the substring from zero to however long
the first argument is, which is like maybe,
you know, five, ten, six characters,
does it equal that same value to C?
It's basically a substring match.
That match is like, no problem.
It's like half that length in Perl.
So, you know, the one I was really going to show you
is the dereferencing.
Like when you're dereferencing a function
and you want to change, you know,
do alias and stuff like that, Bash just really falls apart.
Because it's not designed for that.
Bash is not meant to do that kind of thing.
You know what I mean?
They forgot to renew the domain.
That doesn't surprise me.
A lot of the Perlmongers are tired.
They're just like, I just want to make my stuff work.
It's another reason I decided to do an entire video on Perl
because a lot of them aren't doing anything.
They're, I'm going to call you out guys.
They're stuck on UCP and they don't come up for air
and they barely got on Twitter like three years ago.
It's just, I hate to say it, but it's true.
They're kind of like, there are many people
from the Perl community who are stuck in the past
and they're good.
They're smart and they're intelligent.
But they just, God, would they consider live streaming?
Probably not.
So I figured I had to make a video on it
at least to show people what's available at any,
people didn't even want to use the terminal
and now everybody's starting to see the terminal
and it's largely because people who have been making
powerful use of the terminal for years
are finally making videos and showing it,
hey, this thing is actually a thing.
In fact, I've seen several security people do things.
You know, Hammond comes to mind and it's dope.
I think his name is, a couple of people have done videos
on the terminal.
The terminal is really awesome for cybersecurity.
Oh, news flash.
It's like, but because they're doing it,
other people are becoming interested because the,
you know, the generation, that's where they get their data.
I mean, everyone else is like, well, yeah,
but the people who, there's not a lot of people
making content that's digestible, you know,
I'm just going to say it, the older generation
is not communicating their knowledge
to the younger generation.
They're not, they're just, they're doing their thing
and they're too busy to be bothered to do it.
You know, they're making their craft beer,
they're doing whatever they're doing
and they're not sharing and so I figured
I at least needed to start sharing.
It doesn't mean what I have to say is anything,
is any better than what anybody else has to say.
It just means that I just have an opinion to voice as well
and so we can put that out there with everybody else.
What's that?
I switched to Winner 10 and FreeBSD and JWM
for the exact reason, never going back.
Yeah.
And I'd be curious, does your FreeBSD come with parole?
I'm not going to rip on you, I promise, don't be afraid.
Does your BSD have parole on it by default?
I'm pretty sure it doesn't, right?
Yeah, I read a bunch of stuff that said
that the modern BSD variants
have successfully ripped parole dependencies out of everything.
I still think Git has a dependency on it
but I think it's built into the problem, to the program, yeah.
And I understand why they did that.
I think it was a stupid decision
but I understand why they did it, right?
But anyway, trying to go back to processes going on right now
for parole.com, oh wow.
Yeah, Git is heavily dependent on parole, right?
When I joined development, parole was already considered legacy.
Yeah.
So it's interesting to hear that alternative point of view.
Well, I'm going to say something here,
parole is legacy.
You know what else is legacy?
Linux.
Linux is legacy.
Linux is older than parole.
Is that true?
No, I don't even think that's true.
I think parole is older than Linux.
I would love to know that.
And is using parole for machine learning is idiotic
and definitely legacy.
But using parole as a better awk, as a better said, is, yeah,
it's 87, yep, clean start.
Using parole for what it was intended to be used for,
which it is still the best in breed at doing, is not legacy.
It's not legacy.
I mean the code bases we're trying to migrate, god yes.
The term parole code base is a fucking oxymoron.
Sorry.
Sorry for the swear word.
It's a tool for the job.
Yeah.
It's a tool for the job.
And I recently had to blog a lot about this.
I find myself, you know, getting uptight for having to defend tools
that are the best tools for the job.
And sometimes, you know, people, I get overly defensive about it
and I call people assholes and stuff, which I shouldn't do.
I did that yesterday.
It's a mosh if you're out there, I apologize.
You know, it's not about that.
What it's about is it's like what Cypheric says,
it's the best tool for the job.
If the job is parsing text that potentially has Unicode in it,
there is no better tool on planet Earth than parole right now.
Your language doesn't do backslash p capital L U to parse uppercase letters in Unicode.
It doesn't do it.
And so, you know, just best tool for the job.
And if the job is a better bash that's going to write a shell script
and prototype rapid applications development in,
and then port it perhaps if you're going to, you know,
write a module or thing that does grow a little bit,
then at that point, yeah, do it in Python, do it in Go, do it in something else.
But having a pearl code base that's not a bunch of scripts,
that's definitely legacy in my opinion.
In my opinion, that's legacy.
You know what else is legacy?
Using anything with pearl moose or manga, you know.
There's all kinds of object-oriented things that got added on to pearl.
I hated all of them.
I tried really hard to make pearl into object-oriented language
back when I drank the object-oriented Kool-Aid.
But then, you know, with the pearl classes pragma that I made.
But the fact of the matter is, is pearl has no business in that space.
I have a pearl code base running on 52,000 machines that I've been to this day.
And I wrote it in pearl moose and it got shipped.
It was my endpoint for collecting data.
That was definitely a sweet spot application for Go.
And if I had it to do today, I would have done the whole thing in Go.
But we didn't have those options back then.
So I definitely agree that most pearl in the enterprise that you're going to encounter,
or anywhere, frankly, is going to be legacy.
The application is legacy.
The application of pearl in that instance is legacy.
But pearl itself is not legacy at all.
Pearl is cutting edge when it comes to regular expression parsing.
It is the front of the pack in creating the best regular expressions known to mankind,
humankind, whatever.
And in that sense, pearl is not legacy.
Pearl is the industry standard.
So as long as you can separate those things, though.
PCRE is a separate lib, but it does not have slash pat p in it yet, as far as I know.
If it did, Python would have it.
So that might be that it's a new thing.
If anybody has any information on that, and I'm wrong, I would really love to be wrong on that.
So please let me know if your language supports the backslash p Unicode class match.
PCRE is not the same as Pearl Regex.
It's very close.
Yes, it's very close.
But it was heavily inspired by Pearl.
Yeah.
In regular expressions, most people don't ever need a regular expression.
I'm the first to admit that regular expressions are usually bad.
Regular expressions are a bad idea if a simple substring match or a split would work.
Pearl regular expressions are an unnecessary complexity that can actually really tank your performance.
So a lot of times, just a good old substring match or a prefix match or just a range match are way better.
I'm guilty of really, really loving a good regular expression and wanting to do that first because it's just easier to write.
It's easier to write than a substring this and if this substring matches that, but that code is usually more performant.
So that's the thing.
Yeah, they are.
Pearl regular expressions continue to be more powerful than PCRE and they will be.
I think they're going to continue.
Pearl once again proves that on the front of regular expressions, it is not legacy.
It is the cutting edge and it's going to continue to influence PCRE and the rest of the regular expression inches because it's dominated the industry forever doing that.
So yes, most code bases are legacy Pearl, but Pearl itself is anything but legacy.
And as long as you use it as the most powerful shell scripting language on planet Earth, which it is, then you're going to be fine.
How's that?
And you might, you know, profit, particularly in cybersecurity.
You can clean up with cybersecurity.
Yep, I'm telling you, man.
I wonder why some subcode really fast and hack really quickly.
Pearl's your baby.
Plus it looks cool.
Hackers love it.
Maybe sticking to Pearl 5 plus instead of Recruity.
Yeah, absolutely.
I'm not, I personally, I personally, I'm not telling you what to do, but I personally am not ever going to use anything but Pearl 5.
Because the whole point of me using it is that it's everywhere and it has regular expression support for Unicode and that I just know how to write it really quickly.
I'm not going to use anything that, that, look, I'm not putting down the people who have made those projects.
I just, as I said before, if you are using, if you're reaching for something besides Pearl 5, you have a lot of other options in that field.
At that point, you need to compare your choice with a bunch of other things and not just, and not just, you know, a great, you know, the world's best shell scripting language.
Because that's what it is.
And, you know, so that's all I'm going to say about that.
I, I have, I have not even cracked open Recruity and the other ones we had.
Actually, we had one of the developers was on our stream some time ago, which you should really give it a try.
And I, she's very, very nice.
And, and I, I was, I was seriously thinking about looking at it, but I got to tell you, I mean, I like keeping my mind open on those kind of things.
But I, I can't imagine there being, I've been wrong before, but I can't imagine there being anything that I would ever want to code in besides, you know, because every, because Go covers all my other bases.
And the very few little edge cases that aren't covered by Go are covered by Rust or they're covered by Python or Bash or C.
There's no more room.
There's no more room in there.
You see what I'm saying?
I mean, it's like, if there's going to be other languages in NIM, for example, NIM is another one that's really, really cool, right?
Am I getting it right?
I think it's called NIM.
I mean, there's a lot of really cool languages.
Haskell, you know, any of the purely functional Erlang.
If I, you know, if I was going to go to plug in for Pandoc or something like that, then I could see doing, or if I was having a really, really, really, really highly concurrent system like Discord.
I would do Erlang for that.
But I don't see the sweet spot for anything outside of Pro 5, if that makes sense.
Because, you know what I mean?
Because all the other needs that I would have are well, well covered by other languages, sometimes redundantly well covered, and particularly Rust and C++.
They both cover and see, right?
All of them cover one area of high performance computing that is arguably harder to write, but more stable and more performant, but not the thing that you would grab for every day to make a microservice.
In fact, to write a microservice in Rust seems kind of silly, right?
It's particularly given all the libraries that exist in it for go and to do that very same thing.
You know, if you're doing machine learning, it's either Python, obviously, or R, or scientific computing, or Julia.
I just don't see there being a lot of space in the language realm for yet another multi-purpose offering.
That's not one of the ones that's already existed.
It's already been adopted by everybody.
And so that's my reason for not really caring about anything besides Pro 5.
And I apologize if that makes people sad, because there's probably people that have done a lot of really good work on that.
Pro 6 was a complete disaster.
And you guys, we just have to own it.
The reason you try to rebrand the whole thing is because Pro 6 was a freaking disaster.
You couldn't get it right.
You couldn't plan the thing.
You tried to spite up more than you could chew.
You basically tried to do all things for all people and you failed.
And maybe you finally came around and got it to being something better than it is, but at the time it failed.
I mean, I'm sad to say that, because I lived through that.
I was buying into the Pro 6 thing and I was sitting there waiting and waiting and waiting and waiting.
And meanwhile, Python was progressing and people were moving, porting from Pro to Python for enterprise solutions for all the right reasons.
And C++ was getting a lot of big leverage at that time.
It was coming into the enterprise, because it was easier to write than Bruno was taking over from Java.
And Java, of course, was dominant through the whole thing.
And then what?
Nothing.
And now, like 12 years after I gave up Pearl, someone tells me that there's a version of Pearl that's actually really awesome.
I'm like, I'm just sorry, you had your chance.
I'm not interested.
You know, I'm not saying I won't look, but, you know, pre-installed most of us.
Right.
Pearl is, but not Roku.
Yeah, Pearl 5 is pre-installed.
And one of the reasons I say that you should, you know, Pearl 4 is on everything.
And that's pretty much Ocon steroids.
So if you just keep yourself to writing basic Pearl 4 constructs and you don't do any of the other stuff,
you're totally fine.
Pearl will run anywhere except for BSD, apparently.
You know, some BSD stuff, in which case, you know, you have to decide why you're doing that in the first place.
So, yeah, I don't believe that I would ever deploy production software in Pearl today.
And I don't mean that to be, as an SRE, I would use it all the time.
As a cybersecurity person, I would use it all the time as a, you know, as a tool.
Anytime I would use Bash as a tool.
It's not like you're going to deploy a thousand lines of Bash in a production system.
If you're doing that, and I know Vera was talking about doing that, and he's porting that code to go right now,
picking on him a little bit.
You know, if you're doing that, that's fine, but it's arguably not the best way to do it.
Really, if you've got 10,000 lines of Bash code, you want to reconsider your life priorities.
You know, I actually refactored 9,000 lines of Pearl for a VMware integration layer at IBM.
Yeah, that was not fun.
You have to duck.
Love that someone else is loving Pearl the way I do.
Pearl was my second language after C.
Wow.
Yeah, and it does, it feels like C a little bit, you know, don't you?
I love Pearl for what Pearl is designed to be.
I'm wrapping up here, this is a long video, but I really want to hit that part home.
I love Pearl for what Pearl, and I suggest Pearl is cutting edge for what Pearl is intended to be,
the world's best shell scripting language.
It's not designed to be an enterprise language.
The prototype that I'm making in KN will eventually, many pieces of that will be rewritten in Go.
The core pieces of it will be rewritten in Go.
This scripting language, so people can write their own plugins,
will support anything that can run on the command line, including probably mostly Pearl.
So that's, you know, if you want to add expandability on a Unix or Linux system to something,
and you can say, well, you can write it in any scripting language, right?
Or you could, you know, make a compatible programming Go.
Back in the chat again.
Lots of great people here.
How's it going?
Infility?
BSC is moving to Subversion to get.
Are they?
Oh wait, I got some interesting stuff to read.
Yesterday was fun though.
Legacy, yeah.
BSC is moving from Subversion to get as soon as Pearl will be added back to, you think it's going to be?
I wonder what version it is.
That'd be interesting to know.
I bet it's 5.10.
That's the one I'm going to bet they're going to go with.
I think we should probably know.
I could have swore get Bundles Pearl with it.
You know, it makes sense that get has Pearl in it because of how fast it was turned around.
I mean, it was like he thought of it and then it was done.
So it's like, yeah, it looks like it's been installed with it.
Let's look at this one.
Let me check this.
There we go.
Get on the system which runs on the standard version is Pearl 5.8.
Oh my gosh, that is ancient.
What's important is that Pearl command keeps referring to Pearl 8.8 so that our script runs fine.
Let's see.
Get has a dependency on Pearl 5.28.
That's not true.
The docs doesn't even mention it requires Pearl though.
It does require Pearl though, we know for sure.
It doesn't say it get depends on if it says that package requires that.
It says that package requires 5.28.
No good answers there.
The proscripts that get runs on, beginning with the shebang lines.
In the get source, these lines are user bin pearl, which is what you should use instead of user bin ENV.
But as you build to get to install it, the source builder replaces these with the correct path,
which is also the right thing to do instead of using bin ENV.
So if you correct path for a correct version of Pearl, use it with a bin pearl.
Alright, fine.
What's the version? God damn it.
Anybody know?
Question, what does it matter so much whether something is installed by default?
Let's say a scripting language takes someone, package manager, away from being able,
it's really important that you have installed something from the Fisher Repositories.
Oh, Pearl 5 is greater than equal to 5.32.
Really?
Get has a 5.32 runtime dependency?
Holy cow.
So much for no pearl on BSD.
That's like the most recent version.
Wow.
Well, do I need to make my case further?
The most useful, powerful version management system in the world depends on Pearl 5.32.
There we go.
So, yeah, it is really important to have it on the remote system.
It depends on what you're making, right?
If you're a system administrator and you want your script to just be able to work,
you want to SCP the script over and be able to run it,
or you're a hacker and you want to be able to do that, that makes a lot of difference.
I'm going to be able to share your script with somebody else who also has a Linux machine.
You don't have to install anything.
Those small things make a difference.
There are less and less of a difference in a Docker world now, right?
Most people have Docker installed, but that's usually for larger applications.
So it's different in that space.
In that space of shell scripts on steroids, having Pearl everywhere is a plus.
But as soon as you go beyond that and as soon as you're making an application,
then it's not as big a deal, right?
Because you've got to already bundle.
And then the Python virtual environment makes sense, even though it's stupid.
But you have to bundle everything together.
You have all your dependencies matched.
At that point, you should just make a Docker container, by the way.
You're running 13 current, though.
Interesting.
There's a runtime dependency.
That's really interesting.
You have to report back on that.
That's a really interesting question.
Don't go to Pearl.com.
There are a bunch of...
It's apparently malware.
Which I didn't say that the Pearl community is on top of everything,
as well as some of our other communities.
They're just...
They're tired.
So they're forgetting to renew things.
They have really, really ancient websites.
I was on the Pearl Mager site the other day.
I was like, it needs a facelift so bad.
The whole initiative has lost a lot of its...
Because it's not sexy and cool anymore.
But it's still sexy and cool when it comes to being a powerful shell script.
Stop thinking of Pearl as more than that.
And frankly, a lot of the Pearl community,
the previous community and current community,
still is trying to push Pearl for large-scale applications development.
And I think that's a mistake.
It's a huge mistake.
But again, if you look at Pearl as a shell script language,
I'm just going to put it that way.
They're trying to change the version that required,
unless it's just looking if you're compliant,
when you're close to Pearl.
Yeah, that's probably what's going on with it.
Yeah, it really depends on the dependency there as well.
This particular video has generated a lot more interest than I would have thought.
So this has been really fun.
I'm going to have to go ahead and cut it short
if there's any more questions.
I have to duck down again.
Learning Pearl is one of the best programming books I've ever written.
I agree.
Yeah, Schwartz did a great job with it.
It's very, very easy to understand.
It's one of the greatest things about Pearl
is that all of the documentation has always been really easy to read.
And I told you all the man pages that are there, right?
There's literally a man page on everything.
You have to learn man to do Pearl really, to do it really well.
But if you're going to jump into it, do that.
Please don't go overboard though.
I'm going to just recommend that you not...
There are other very much more important languages for you to learn than Pearl.
Pearl is important if you want to do a lot of shell scripting.
You're going to live on the command line if you're going to be an SRE.
If you're going to be a hacker or if you just want to be a terminal power user.
Pearl is really good, but it wouldn't be the first thing I would learn, right?
I would have you learn JavaScript first in the web browser, by the way,
not on the command line.
And then I would learn Go as the first compiled language personally.
That's what I'd recommend.
And I would learn enough shell to be able to write shell scripts.
And then I would learn Pearl to help you out.
But it's a supplementary language that basically turns you into a terminal power user.
And that way, you won't get into the problem of...
It's more important that you learn Python than Pearl
unless you're going to live on the command line all the time.
So, but don't rule it out.
It does have a place that is not filled by any other language.
And that's the recent discovery.
And frankly, I thought Bash filled that spot and it doesn't.
It doesn't.
In fact, Bash and I, it was a fun year, but I think Bash and I are done for a while.
I'm going to be back to Dash and Pearl for everything.
And Python.
Because you have, you have like POSIX, right?
You have POSIX shell, which is compatible everywhere.
And then you have Pearl, which is everywhere when you need something more powerful.
You have Python for those enterprise...
Python and TypeScript for like those enterprisey kind of scale interpreted applications,
still interpreted language applications.
And then boom, you need some statically typed compilation stuff.
Go as your friend.
So that kind of go TypeScript and Python kind of all overlap.
And then you need like edgy, high-performance stuff, Rust and C, C++, right?
And you need stuff on the hardware assembly.
Yeah.
And that's, that's my spectrum of languages right now.
So, but the distinction between POSIX shell, Bash, you know, there might be a little bit
of...
I am still going to use the Bash interactive shell because I want to be able to export functions
that do things that I can't do with C shell.
So as a shell, it's still the best interactive shell if you ask me.
But, but, you know, so that's still, that's where I'll be, if I write any code in Bash,
that's where it will be.
Otherwise, it's going to be just in straight up POSIX dash or it's going to be in Pearl.
And that's, that's a position that I held or Python.
And that's a position I held back in 2007 and I'm just returning to it.
And if you read my blog, it's not a blog.
If you read my notes, if you go to github.com slash rdbxrob and you click on log,
you can read some of my laments about going through all of this and how it made me
to a very grumpy Gus yesterday, going through this, this, this process of discovery.
And to anyone that I may have offended yesterday, I'm sorry.
I'm just, I'm sorry.
That's all I'm going to say.
Probably time for me to go.
Can we, can we agree this topic is dead now?
Did we kill the camel or did we resurrect the camel?
I was actually really fun for me because I feel like I've given myself permission to use, to use it again.
Just like I gave myself permission in January to use bash.
So this is what happened.
I gave myself permission in January to use bash all the ways that I've been prohibited from using as a, as a system
and a developer at IBM for years because I was forced to use POSIX compliance.
So it would run on Solaris and AIX and all that stuff.
And, and then I'm going to, I'm going to go, but I'm going to just drop the stream.
I'll be back in a bit.
The stream script removed the R to let off steam.
It was all good.
And so all I want to say is that, you know, that was fun.
It was an experiment.
So I used bash.
All of bash is crazy, awesome things.
You know what?
I discovered about CD path, which nobody knows about, which is the same thing that you want out of your, your fish and your Z-shell
for automatic CD completion.
Lots of things I discovered about bash over the last year.
And, and I'm so, I don't look, I don't feel that was a bad thing, but I gave myself permission to use it after having been told
you can't, thou shall not use that cool bashism and that bashism and that bashism.
And, and I let myself do that.
And I had a lot of fun with it for about a year.
But, you know, this week I hit a two, those two significant blocks for bash.
No Unicode support for regular expressions, which Pearl does.
And no support for extensive documentation in a script, which Pearl does.
And those two things have caused me to abandon bash and relook at the whole thing.
And, and so I'm back to using basically Pausik's shell and Pearl for everything.
And you'll see me doing a lot of code doing that and go, of course.
So I think with that, I'm going to go ahead and put the, the, the dunes, the dunes back on, maybe turn them up a little bit.
Yeah, actually this terrifies my wife.
She's scared of the desert like this.
I'm like, this looks really fun to me.
I'll be back.
It'll probably be in about a half an hour or so.
I will be back when I come back.
I'll be doing a lot of Pearl coding actually on the knowledge node utility.
It's called KN.
It's a way of managing your notes and your schedule and everything.
And it's modular so you can expand it and customize it.
It's part of the associated federated knowledge workers.
Our efforts to create tools that are kind of come together on building for each other so we can manage our knowledge better and then share that knowledge over the knowledge exchange grid, which we call keg, which I'm going to put a plug in for that.
If you want to be involved with any of that conversation, that's always going to be on Friday.
But in my time as I do my daily routine, I'm going to be doing a lot of refactoring of all my scripts directory.
And it's going to be a lot of code in POSIX and in Pearl for the next week or two.
Take care.
Bye.
Thank you.
Thank you.
