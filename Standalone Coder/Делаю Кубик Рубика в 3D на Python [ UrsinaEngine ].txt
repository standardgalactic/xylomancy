Привет мир!
В 1974 году, венгерский архитектор Рубика изобретает игрушку-головоломку, которая становится всемирно известной под названием «Кубик Рубика».
Эта головоломка стала наиболее продаваемой игрушкой на планете.
Из момента изобретения разошлась по миру почти в полмиллиарда единиц.
И сегодня мы рассмотрим основные моменты по созданию этой головоломки,
а также разберем как создать Кубик Рубика при помощи языка Python,
и для этого главным инструментом станет функционал и возможности.
Очень простого 3D-движка – Урсина.
Итак, приступим.
И чтобы установить движок Урсина то в терминале запустим команду, представленную на экране.
После установки импортируем этот движок и напишем класс основного приложения,
точно так же как делали в сюжете про создание змейки на движке Урсина.
И пока что сделаем два метода для загрузки игры и для обработки событий нажатия клавиш,
ну и конечно же создадим экземпляр приложения запуск которого активируем через мететран.
А для лучшего восприятия информации, создадим объекты окружения,
сделаем плоскость которая будет расположена на 5 единиц ниже начала мировой системы координат,
а на эту плоскость наложим текстуру которая идет в комплекте движка.
Также в начале координат поместим большого размера сферу,
на которую наложим подобранную текстуру неба,
то есть мы будем находиться внутри сферы наблюдая небесный купол.
И для лучшей наглядности, поместим трехмерную модель левосторонне системы координат на то место,
где начинается мировая система счета для этого движка.
Ну и для полной свободы действий, задействуем камеру которая управляется при помощи мышки.
И если посмотреть на то что у нас вышло,
то мы видим что получился достаточно оживленный каркас приложения,
в котором при приятном окружении можем наблюдать начало мировой системы координат,
что в свою очередь поможет более лучше понять работу с трехмерным пространством.
Но чтобы двигаться дальше, то необходимо создать модель одного маленького кубика,
так сказать структурной единицы.
И проще всего будет работать с кубом, размеры сторон которого равны одному,
а его центр должен находиться в начале локальной системы координат.
Также нам важна карта текстура такого кубика,
которую мы самостоятельно разукрасим при помощи любого растрового редактора.
И при этом будем придерживаться классической раскраски грани для нашего кубика.
И тогда, отдельными атрибутами сделаем пути для новой модели куба его текстуры,
и чтобы проверить его отображение, то создадим один экземпляр объекта
используя созданную модель текстуру.
И как можно видеть, у нас появилась рукотворная структурная единица,
при помощи которой сделаем целый кубик рубика.
Но в начале координат мы поместим совершенно другой объект,
это будет так называемый родитель.
Он будет самым главным кубиком при помощи которого будет работать весь механизм кубика рубика.
Так вот, и нашему объекту укажем, что он будет потомком родительского кубика,
и расположим его слева от родителя.
А для более очевидной работы механизма наследования,
сделаем вращение родителя на 90 градусов вокруг оси X,
и вращаться родитель будет по нажатию левой клавиши мыши.
Теперь посмотрим как это работает.
И перед нами в центре мировой системы отчета находится родитель,
у него шахматная текстура, а сбоку от него, его потомок.
И при нажатии левой клавиши мыши происходит вращение родителя,
а если посмотреть на движение потомка, он полностью повторяет те же движения,
то есть так же вращается вокруг оси X,
и думает тут становится очевиден весь принцип работы механизма кубика рубика,
и этим механизмом будет управлять только один кубик родитель.
Но не все так просто как кажется, нам же надо крутить только определенную сторону кубика рубика,
и поэтому в зависимости от стороны вращения необходимо перекреплять потомков.
И давайте на этом же примере посмотрим что происходит во время смена родителя.
На клавишу W будем откреплять родителя, то есть родителем будет мировая сцена,
а на клавишу S, заново сделаем родителем центральный куб.
И если посмотреть на эту ситуацию, то вначале потомок вращается как и положено,
но когда производим смену родителя, то потомок возвращается в то место где было изначально.
А при назначении родителем снова центральный куб, то он перемещается в то место,
если бы он вращался все это время с прежним родителем.
Это неприятная вещь происходит потому, что координаты куба потомка относительно родителя не меняются,
а остаются всегда прежними, и поэтому при смене родителя он возвращается обратно.
И чтобы решить эту головоломку, то необходимо перед смены родителя
забрать мировые координаты потомка в отдельные переменные,
а после смены назначить эти координаты позиции потомка.
Но и в то же время нужно обнулить значение вращения центрального куба,
чтобы потомок начинал вращаться с ним с того же положения.
И теперь если посмотрим на процесс смены родителей,
то видим что потомок остается в том же положении куда и пришел,
а также впоследствии новой смены родителя,
он продолжает свое вращение как и предполагалось для него.
Итак, теперь можно продолжать создание кубика-рубика,
и создадим для начала его левую и нижнюю стороны.
Для этого уберем лишние элементы управления и создадим метод,
в котором определим позиции выбранных сторон.
Позиции кубика в каждой стороне очень легко создать при помощи циклов,
и наряду с этим координаты кубиков будут находиться в такой структуре данных как множество.
Вызывав этот метод, то вычислиться позиции кубиков для каждой из сторон,
и теперь можно пройтись по этим координатам и создать нужные нам объекты.
Ну и посмотрим, и сейчас можем наблюдать всего треть кубика,
но пока что оставим его в таком виде для лучшего понимания происходящего.
А для дальнейшей реализации понадобится словарь, ключами которого будут названия сторон куба,
а значениями станут очевидные оси вращения для каждой стороны.
Также нужен будет словарь для определения всех позиций кубиков по каждой стороне,
и в добавок введем переменные для обозначения времени анимации поворота сторон.
Далее напишем отдельный метод для смена родителя,
от центрального кубика к мировой сцене, здесь пройдемся по всем потомкам,
и у кого родитель является центральным кубиком, запишем их мировые координаты,
сменим родители на мировую сцену и присвоим позиции потомка его мировые координаты,
а в конце приравняем к нулю значения вращения центрального кубика.
А при помощи следующего метода будем осуществлять поворот необходимой стороны кубика-рубика,
в этом методе по передаваемому названию стороны,
определим координаты всех кубиков для данной стороны,
также получим значение оси вокруг которой надо сделать поворот.
Здесь же и будем вызывать метод по сменю предка на мировую сцену,
и проходясь по всем кубикам, нам нужны будут кубики для текущей стороны,
где назначим родителям центральный кубик и при помощи удобной функции.
Евал, вызовем код внутри себя по запуску анимации поворота вокруг нужной оси.
И добавим управление при котором при нажатии клавиши А,
будем поворачивать левую сторону, а при нажатии на С, повернем нижнюю.
Если мы посмотрим как в текущей ситуации работает механизм,
то очевидно что никаких проблем с правильной реализацией его работы нет.
И в данный момент это достаточно любопытный вид внутренностей кубика-рубика,
при котором можем наблюдать, как при каждом повороте центральный кубик моментально принимает начальное положение без вращения,
а также видно как составляющие кубики перемещаются по этим двум сторонам.
И теперь можно собрать полный кубик-рубика,
для этого добавим недостающие координаты кубиков для оставших со сторон,
при этом объединение множеств таких координат,
позволит избавиться от дублирующих позиций для маленьких кубиков.
А далее добавим, пока что экспериментальное управление,
для вращения всех сторон кубика при помощи шести и клавиш.
Также больше не понадобится модель системы координат,
а родителям будет пустый объект без модели,
так как он будет находиться в центре и не будет виден.
К тому же добавим недостающие стороны в словарь для определения координат кубиков для нужной стороны.
И в результате получаем кубик-рубика, в котором можно вращать любую сторону,
и выглядит все вполне достойно, но есть один существенный недостаток.
Если мы будем нажимать на клавишу быстрее, чем происходит анимация вращения стороны,
то кубик просто на просто весь сломается.
Чтобы исправить такое недоразумение, то создадим триггер для разрешения очередного поворота стороны.
Напишем метод при помощи которого будем менять логическое значение триггера.
И как только начинает вращаться какая-нибудь сторона, то присваиваем ему ложное значение,
и это значение станет истинным только в том случае, когда закончится вся анимация поворота.
Ну и конечно же, состояние этого триггера будем проверять при нажатии очередной клавиши.
И вот при таком раскладе, можно нажимать на клавиша с любой частоту и при этом с кубиком ничего странного не происходит.
И казалось бы на таком шаге можно завершать этот сюжет.
Но то управление которое реализовано в данный момент, мне крайне не нравится,
потому что при поворотах камеры, полностью теряешься в расположении сторон куба.
Поэтому сделаем более интуитивное управление, и управлять поворотами будем только при помощи мышки.
Сделаем два режима, режим обзора и режим взаимодействия,
а переключение между ними будет нажать и на колесика мыши.
Для этого создаем логическую переменную,
а также объект вывода текста на экран о том, какой сейчас режим,
и понадобится отдельный метод, в котором меняем логическое состояние переменной режима игры,
и на основании этого значения выводим сообщение.
Исследовательно в управлении, вызываем этот метод при нажатии средней клавиши мыши.
И как можете видеть внизу экрана, отображаемый текст изменяется при каждом нажатии на колесика мыши,
а теперь можно и переходить к дальнейшей разработке управления.
Итак, сделаем метод при помощи которого создадим так называемые сенсоры, это будут трехмерные модели,
покрывающие каждую сторону кубика-рубика.
Отличительной особенностью станет то, что у них будет активирован колайдер,
то есть движок будет их брать в расчет для вычисления столкновений по их форме.
А также у них будет задан параметры имени, в нашем случае он будет обозначать каждую сторону кубика-рубика.
И для примера, посмотрим как будет выглядеть сенсор для левой стороны.
Но такие сенсоры не будем отображать, так как у объектов есть такой параметр как видимость,
то есть движок производит все и расчеты с объектом, но в то же время объект не выводится на экран.
И чтобы создать адекватное управление, то такие объекты должны располагаться таким образом,
чтобы они не накладывались друг на друга, то есть надо сделать небольшой зазор в их расположении.
И важным шагом остается переделать управление.
Мы проверим что происходит на жате левой или правой клавиши мыши, при этом переменные режима игры.
Триггеры действий должны быть истинными.
Далее мы получим название у всех объектов, для которых задан параметр обработки коллизий,
и те названия которые совпадают с названиями сторон куба.
Будем передавать метод вращения сторон.
Для текущего случая боковые стороны будут поворачиваться по нажатию левой кнопки,
а верхняя или нижняя сторона, по нажатию правой кнопки мыши.
И теперь можно сказать что все готово.
Получили кубик рубика который можно управлять при помощи одной мышки.
Переключаясь между режимами, получили возможность вращаться стороны куба из нужного положения обзора.
А на самом деле управление, это выбор вкуса, так что реализовать свое видение управления не составит особого труда.
Но это еще не все.
Мне захотелось добавить немного интерактива.
И давайте сделаем так, чтобы изначально кубик рубика находился в другом исходном состоянии.
А для выполнения такой задачи, нам понадобится второй метод для вращения сторон,
но только в нем не будет анимации, и в котором для исполнения команды,
воспользуемся не менее удобной функцией, экзекьют.
И будет метод случайного исходного состояния,
в котором надо задать количество случайных вращений нашему кубу,
а стороны вращений будем случайно выбирать, из имеющихся ключей словаря для всей вращения.
И таким образом, получаем кубик рубика в котором стороны повернуты на указанное количество раз.
Так что кто увлекает с этой головоломкой, то можете усложнять себе задачу увеличивая такой параметр.
И в целом хочется отметить, что примененные здесь принцип родителя и потомка,
можно использовать в любом движке для работы с трехмерной графикой.
В общем пишите свои комментарии, и бейте в колокол чтобы не пропустить следующий выпуск.
А ваш палец век, как всегда, будет мотивацией на создание нового сюжета.
И всем успехов, всем пока!
Редактор субтитров И.Бойкова
