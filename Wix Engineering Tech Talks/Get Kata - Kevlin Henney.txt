Okay, you're all technologists. You know what this is? Yeah, it's an internet device. It
has a secondary use as a telephone. Actually, it might be a tertiary use these days. Apparently,
it makes noises when you do that. These have vibrate features. It's a really novel feature
that we have in the 21st century. So if you really are expecting that call, then that's
how you do it. Okay, that's the technology bit of the talk done. So what am I going to
talk about? So that's Michael Cain, 1971. What's that got to do with anything? Get Carter.
This is a film that he was in. It's kind of London gangster movie. There was apparently
a remake of Get Carter with Sylvester Stallone done in 2000. We do not speak of this. It's
a little bit like Sylvester Stallone and Judge Dredd in 1995. We do not speak of that
version. It does not exist. Dredd with Carl Urban is the only true canonical version.
So, good. So yeah, so this is what I'm talking about. I'm afraid you don't get me with a
shotgun. You get me with this, but it's not quite as cool, but Get Carter. And which came
first, the film title, did the title of the talk or the content of the talk? Well, obviously
the title of the talk came first. I sat there one day thinking of British movies and I thought,
you know what, there's something funny that could be done here. I wonder if there was
a talk. We now have an answer. Yes, there is. Okay, what am I going to talk about? What
am I going to talk about is Carter. Okay, now it turns out this is a word that has got
absorbed into the software craftsmanship community. I think it was originally introduced by Pragmatic
Dave, Pragmatic programmers, in trying to get this focus, get us to think about what
it is that we are doing and practice. Because one of the things that we lack in software
development is a sort of form of deliberate practice and focus. It's not that we don't
get much practice, but there is the old joke, you know, oh yeah, I've been in this industry
for ten years, oh, or is that one year ten times? Okay, we go round in circles. That's
a different form of iteration. Okay, it's not very helpful. But we also do not get the
opportunity to explore and learn. With most things, particularly in a sort of an educational
environment, in a practice environment, you get to repeat things. You get to try things
again. You get to perfect them. If you play a musical instrument or you undertake a sport,
you know that you do the same thing again to perfect it, to try it. So the idea of a
carter is the repetition. In software development, software development is filled with things
that are kind of like other things, but they're not identical. And once you've mastered them
or you think you're just about to master them, you move on to the next piece of software.
In other words, you try to think, I think I've got it! Oh, okay, we've shipped it and
now I've got to move on to something else. So the idea of the carter is actually to slow
you down, to make you focus on what you're doing and to choose something very small. Now
the term is Japanese and it has a couple of ways of being transcribed. So I clearly did
my homework and you've got the carter form, then you've got, it has two kanji forms, that
one and that one. I do not know enough Japanese, as in, I know this much Japanese. Actually,
I probably know more Japanese than I do Hebrew to be fair. But there are two forms. I'm
not entirely sure what the preferred one is. But in terms of pronunciation, there are
lots of different pronunciations people try to use. Cater. Actually, it does come out
as carter. Carter is closer to its supposedly true pronunciation. But there are various
translations. Form is one of them. It's about structure. It's about the form of what you're
doing. Structure in space and structure in time. It is applied in martial arts as a
practice form. So it covers both of these concepts. Pattern, which is very dear to my heart.
I've co-authored a couple of books on patterns. I find the pattern way of thinking is a very
profound way of approaching problems and solving them, reasoning through forces, thinking about
context. Unfortunately, that's not the bit that people normally associate with patterns
because it's hard. And like most things that are hard, people ignore the hard bit and go
for the easy bit. Style. There is this idea that a collection of patterns gives you a
style. Patterns originated in building architecture. We use the term architectural style and pattern
almost interchangeably. And there's an idea there that if you do something in a particular
way, you create a particular result. You cannot separate the way that you do something from
the thing that comes out at the other end. And then training exercise, which is the most
common idea from martial arts into the software craftsmanship community. It is normally associated
with really getting into test first programming. But I'm not really going to talk exactly about
that. What I want to talk about is a very sort of simple idea. First of all, the deliberate
practice approach. But then I want to go beyond the deliberate practice approach. So this
is a book I edited a few years ago. 97 things every programmer should know. My friend John
Jagger had this entry, do lots of deliberate practice. And this is the focus, deliberate
practice. This is what we're after. You do deliberate practice to improve your ability
to perform a task. It's about skill and technique. It means repetition. It is not about completing
the task. It is about mastering the task, which is different. Your daily work is about
completion. The goal here is mastery. It's fundamentally different. You have to slow
down and stop. But I'm also interested in something else. I'm interested in the idea
that a carter is almost a small laboratory. It is a laboratory which when you understand
it, what do you do in laboratories? You experiment. You try things out. Emile Auguste Artier is
a lovely quote. Probably one of my favorite all-purpose quotes. Nothing is more dangerous
than an idea when you have only one idea. You feel free to use this throughout your
whole life. You can leave now if this is the most important thing you're going to learn
this evening. But there is this. We normally, as developers, have a very bad habit of doing
a first fit. In other words, yep, I've got it. Okay, let's do it that way. It's just
like, oh, okay, that's the first idea you had. What about the second idea? No, no, no,
this is fine. How do you know? It turns out one of the things that humans are reasonably
good at, although apparently in the UK and in the US, we seem to be struggling with this
idea of comparing things. Normally, we're quite good when given two choices. Most humans,
who do the exemption of the UK and the US, when given two options, we're normally quite
good at comparing them. How do you know that's a good idea? Give me your second idea. What's
your third idea? The first idea is also something that may have just come out. It's clearing
your brain. The second idea might be better. It might be worse, but you won't know until
you get to compare them. Experiment. How do you experiment? I'm going to take our large
product and start experimenting on that. Oh, easy there. Maybe you don't want to do the
big experiment. Just try small things. A carter is an opportunity to experiment. The smallest
elements of style. This is really important. I think people often overlook this idea. Often
people talk about software. They look at coding practice and they say, oh, that's just a small
detail. I always come back to them and say, well, what do you think software is? That's
the whole point of software. Software is all about the details. All the rest is the stuff
that happens in meetings. It's the hand waving. Then you have detail. A working software system
is lots of details put together so they work. That is the whole point of software. Everything
else is just conversation. There is this idea. There is no such thing as a detail that is
too small. Particularly, one of the things you may observe is that as a software system
grows, as parts of it grow, we experience what is known as an inflationary phase. In
other words, those small little ripples in that tiny, tiny method that you once wrote,
that you didn't pay much attention to. When it got maintained and grown and extended and
grown, those little ripples suddenly became the galaxies of your system. You can normally
trace back the warts, the weird bits, the technical debt, locales to something that
somebody did and then somebody else followed through and then they followed through. They
normally grew out of a small detail. Details matter. We often find that the large-scale
architectures reflect ideas in the small. I want to just start off from somewhere completely
different and demonstrate the value of different ideas and lateral thinking. This is a right
angle triangle. Wow. Anybody want to take a guess at what dimensions I might have chosen?
345. We're going to be mathematical. We don't use numbers in maths. That's for arithmeticians.
Real mathematicians don't use numbers. Well, they do. Powers. There you go. We've got this
whole idea. Pythagoras. Brilliant. If you want to do it visually, you have this. There
is a thought here. Everybody learnt this at one point or another. You may also have learnt
a proof. I learnt a proof at school. I think the first proof I was shown was a proof by
similar triangles. No, he did a different one. He did do one. He did a dissection one.
The similar angles. He does the one line to get today. He does the shortest amplitude.
That's a different one. There are about 400, it turns out. This is what I discovered when
I started digging into this topic. Einstein does a slightly different approach, but it
wasn't that one that I was taught at school. There is an interesting question here. What
the hell did Pythagoras do? Very obvious thing. Pythagoras is not going to use the Roman alphabet.
That's the first observation. When did this notation come about? The equal sign is actually
quite young. It's a couple of centuries old. The squaring is really young. This whole algebra
concept, that's really, yeah. What did he do? He clearly didn't do it like this. This
is the basic approach. He did a proof by rearrangement. That you can do. Standing there with your stick
and the sand or tiles, you can do the proof by rearrangement, move it around, and then
logically you can say and you can call them whatever you like. This is the original proof.
It was a proof by rearrangement. We move things around. There are actually quite a few proofs
by rearrangement, it turns out. That all works. My favorite algebraic one, almost memorable
one, there's a number of variations, is this. The observation that if those are C, then
that's A, that's B. Therefore, this must be like that. You get C squared plus B squared.
Therefore, this is A plus B plus. Brilliant. We get this and you cancel things out. Magic
happens. Marvelous. That's the second way. It's completely different. But my recent
favorite I discovered this December last year is this one. The trapezoid one. This one was
proven by President Garfield of the United States. The 23rd president, I think he was
the president of the US. I just want you to compare that with number 45, the current
incumbent. President Garfield, well, actually just before he became president, he wasn't
president very long. It was back when assassinations were popular. But in the 1870s, when he was
a senator, I believe, he came up with an original proof. Yeah, standards have fallen. But yeah,
very, very simple idea. It's just like, well, if that, those are C on each side, then it's
just like, okay, this is really very elegant. It all works out beautifully. And boom, you've
got this. You have to know a little bit about areas, but that's fine. And the right things
happen. The halves disappear and you've got it. So three approaches. And as I said, it
was almost a writer passage. Everybody's got to have their own. Okay? So yeah, Einstein
did one. Everybody did one except, you know, every president after Garfield. But as I said,
there seemed to be nearly 400. There might be more, but apparently there was a book
published in the 1960s that had about 350. So I'm presuming somebody's come up with a
few since then. These are different ways of looking at the same thing. Now, what is interesting
about them is that they have different appeals to different people. A proof by rearrangement
is something that you can demonstrate just on a table. That's quite elegant from that
point of view. The previous algebraic proof, I managed to show to my younger son when he
was 10 and he got it. And it's just a case of like, what is it that appeals? Everybody
finds a different simplicity and a different way of looking at something. So what are we
going to do? We're going to look at a real enterprise problem here. Fizzbuzz. Okay? And
this is the heart of every major system, of course. So as a number of you have beer in
your hands, just check. Who is familiar with Fizzbuzz? Okay, let's try that one again.
Who's not familiar with Fizzbuzz? Okay, good. There are a few people. Okay. Fizzbuzz is
a counting game. Okay? It's relatively simple. You go group of friends, group of enemies.
It doesn't really matter. Actually, it might be a good way to settle international conflicts.
One, two, Fizz. Every number divisible by three is replaced by Fizz. Four, buzz. Every
number divisible by five is replaced by buzz. Fizz seven, eight, nine. I got it wrong. Take
a drink. Okay? If you do not have a drink, it is really not very exciting. Okay? Yeah.
My wife and my sons, we were on holiday last year and we were waiting for food in a restaurant.
They had not yet served us the wine. Both my boys, they are mathematically good. Both
the adults were sober and we played this game waiting for the food. It is really boring.
Everybody gets everything right. Okay? Because the only quirk is that every number divisible
by three and five, that was 15, is replaced by Fizzbuzz. 13, 14, Fizzbuzz. 16, 17, Fizz.
19, buzz. Okay. Somewhere along the line, somebody decided this would be a good interview
question for programmers. Actually, it is not a bad interview question. You might be surprised
how many people struggle with it. It has also become a kind of writer passage in the software
craftsmanship community. Can you write, can you TDD this? What I am going to do is we
just sort of pick on a relatively simple implementation, one that is very much structured
in terms of accumulator, the idea of accumulating. It is a fairly sequential approach, but people
normally eventually come across this and they are sort of happy at the basic elegance that
Fizzbuzzness is an emergent property. You only have to care about Fizz and Buzz and
the rest happens by magic. But you are dealing with accumulated state. Okay, so that works.
Alternatively, we have something that uses tail return. Everything has a mutually exclusive
path. Everything is handled. If your friend is kind of saying, hey, you should do more
functional, this is more functional. There is no kind of like state changes. There is
no variables. You can say, yeah, this is functional. Your friend comes along and goes, that is
not functional. Come on, man. Come on, that is functional. It has got to be an expression.
You are using statements. Yeah, you are right. I can see that. But then start thinking differently.
Okay? Because is it an arithmetic problem? Are we dividing things by three? Are we asking
the question, is it divisible by three? Can we invert that and say, actually, I have got
a set of numbers. By the way, just in case you are wondering about the upper limit, the
problem is normally specified over the domain of 1 to 100. Because people are either way
too drunk by that point or just bored out of their tiny minds. But from a programmer's
point of view, that is normally the way it is specified. You have got this. What we are
going to do here is turn it around. We are going to invert it. We are going to say, look,
I am going to have the set of numbers that are the 15s. 15, 30, 45. If this number is
in that set, then how? It is first plus. If it is in the set of threes, I am going to
turn the problem around. Instead of thinking of it as a problem of I am applying an operation,
a divisibility operation to something, I am going to turn it around into a set membership.
This changes the shape of the problem ever so slightly. Here is another one. What I am
going to do here is I am going to say, why don't we construct this and recover our emergent
property, which is quite nice before. Do something slightly different. The stopper at the beginning
and the end are just to align numbers and zero-based counting. I will count from one.
The other way of looking at it is to ask a very simple question. Show me all the fizzes.
Between here and 100, where did the fizzes occur? Well, the fizzes are every three. That
is blank, blank, fizz, blank, blank, fizz, blank, blank, fizz. Please generate that for
me. That is another way of doing it. I am going to do that. I am going to index that.
The fizzes, four blanks and a buzz. Repeat as necessary. Now what I am going to do is
what are all the numbers between one and 100, but as strings. Now I am going to stringify
all the numbers. I have got one, two, three. Now I have got all the resources I will ever
need. I have got numbers and I have got words. Then I compose them together. I take the fizz,
I take the buzz. I concatenate them. If there is something there, we either have fizz, buzz
or fizz, buzz. If there isn't, I have got to love Python for this. Python has a very
kind of loose relationship with the whole idea of booleanness. It is quite good. It is either
really good or you really hate it. It is something that lives at one of two extremes. It is a
case of if there was something there, then we are good with it. Otherwise, get one of
those numbers and we are good. That is a different way of looking at it. Then your friend comes
along and says, no, no, no. It has got to be about lambdas. You have got to have lambdas.
Python is one of those languages that could not come up with a short notation for lambdas.
They really struggled with the spelling of it, so they spelled it lambda. Every other
language that uses lambdas with possible exception of Lisp actually does not spell it out lambda.
They come up with some kind of crazy notation. It is like a competition between languages.
What are you going to do? I am going to use the leaky sign followed by an arrow. I am
going to use square brackets and an emoji. Cool. It is like a competition. Python was
terribly dull. It is called lambda. We are going to have lambdas for fizz, buzz, numbered.
This is probably enough to get you excommunicated from the Python community because it is not
very Pythonic. We are also going to mess about. Explore the languages a bit. Kick the tires
of it. Python is a language that has a very loose relationship with the concept of booleanness.
It also has some very interesting relationships with numbers. N mod 3 equals 0. That is going
to be either true or false. False times a string is empty string. True times a string
is the identity operation. It is the string. Brilliant. We can actually do boolean multiplication
of strings. Excellent. We have got that. That is fantastic. Now we have got all of this
stuff and then we just combine it. This is pure addition. It is just like, yeah, this
is really nice. Really nice that you really hate it. There is this one which combines
it all into one. Although it turns out when we realize we can do that. I like this one
because you can put it in a tweet with a comment. Just sort of say, yeah. Yes. This is here.
It is great. We can really mess about with this. But the question comes, yeah, Kevlin,
that is Python. These are all small examples. I work in an enterprise environment. There
is, of course, FizzBuzz Enterprise Edition. If you have not come across this, go and spend
some time looking at this and then run away very, very fast. I am of a particular generation
and inclination that I still cannot do this. It does not matter that the whole Java enterprise
thing kicked off 20 years ago. The word enterprise, I only think of one thing. I still, two decades
on, you say enterprise and captain Kirk pops into my head and I am thinking NCC 1701 or
my thinking NCC 1701A. Maybe B, maybe C, maybe D, maybe the reboot. I really love this. It
is beautiful. It is gorgeous. It is a lot better than most enterprise software I have
ever seen. But there is something here that is true and deep and profound and physically
possible that gives us a road into understanding this. It turns out that NASA have actually
been looking into warp drive. Although don't pack your bags for Proxima Centauri just yet.
There is actually a research group that looks into this. Naturally enough, they named this
as one of the artist mock-ups of what a craft would look like, Enterprise. It actually turns
out that there is a possibility of warp drive. Miguel Alcubier, Mexican physicist, 1994,
explored the equations of general relativity and came to the conclusion that it was actually
possible to warp space in a way that allowed you to travel faster. There is a basic Einstein
got to mention earlier on. He is probably not that well known for his Pythagorean proof.
He is probably a little better known for his theories of relativity. There is this solution
that allows you to get around or seemingly get around this whole issue of the speed of
light being a bit of a speed limit. It is the speed of light in a vacuum or to be precise
the speed of light in space-time. Now, you can't go faster than that. But here is the
clever bit. If you can make space-time move, then you still respect the law. In other words
if I say well I am still travelling less than speed of light in space-time but somebody
else is moving space-time for me and it is faster, notice it is a beautiful illusion.
We have warped reality. Now you understand the relationship to enterprise software. It
is a reality distortion field. There are a couple of small issues with Miguel Acubio's
theory when it comes to what they call an implementation detail. Remember I said there
are no details? The idea here is these are actually warp coils. There is an idea that
you hold this. This will warp the space around the craft. What are these filled with? They
are filled with exotic matter. We don't actually know that that stuff exists. If it does exist
we don't know how to make it. We are not entirely sure how much we would need. One estimate
says you might need to condense the mass of the moon into these warp coils. These are
small details. If you are a manager, this is it. It is just a detail. However, it does
return us to the reality or the distorted reality of enterprise software. I do strongly recommend
going and having a look at this thing. enterprise software marks a special high grade class
of software that makes careful use of relevant software architecture design principles to
build particularly customizable and extensible solutions to real problems. By the way, just
in case you have had a long day and your sense of humor is failing at this point, this is
a spoof site or rather it is intended as humor. I did have to clarify that to one person.
Perhaps they have just had a really hard time in the industry and this actually looks
quite plausible. Yeah, hire him. You have got a job. This project is an example of how
the popular FizzBuzz game might be built where it is subject to the high quality standards
of enterprise software. You can just wander through the Git repo. It has got all the really
good stuff. People are actually committed to this. You have got a FizzString return
a factory. You have got a printer return a factory. You have got a no FizzBuzz no
buzz strategy factory. As you can tell, this is just the factory stuff. There is a whole
code base out there of possibilities. Where is the open pull request from two months ago?
That is a very good question. This screen grab was a few months before that. It is absolutely
magnificent. You do not want this in your code base. I have yet to see any problem,
however complicated, which when you looked at it in the right way did not become still
more complicated. This is a really useful thing. I think secretly all programmers know
this. They just did not know that they knew this. This is kind of like there is a deep
belief. I see that problem that you have set me. I can make it more complex. Yeah? Oh,
yeah, that is a really easy requirement. But if I added this, it would make it interesting.
We are always play. There is a certain playfulness. I do want to channel the playfulness into
a different form of experimentation. You can do this with different models. This is an
orc solution. I quite like orc. It is a language that is much neglected these days. Partly
it had a bit of a fight with Pearl in the 1990s and lost. As a friend of mine described
Pearl as being executable line noise. I have never moved from that belief. But orc has
a very dedicated view. It is about pattern matching. It is structured around that. In
other words, you do not have a loop to loop over your input. There just is input. You
are part of a stream and this is invoked every single time. You do not need to repeat the
fact. It is a little more of an implicit invocation environment. It has got a slightly different
execution model to what you might find in other imperative languages. What I am doing
here is simply matching. It is divisible by three, by five, by not by three and by five.
Then for all cases, I will print out this matches. The last one always matches. We print
out a new line. How do we test this? How do we drive it? To drive it, it is fairly easy.
We use that old functional programming technique called the shell. People often overlook the
fact that a shell environment, a pipeline environment is actually a data flow architecture
which is a particular form of concatenative programming. This generates this quite nicely.
If you want to test it, we can just pump it into there. It turns out this problem is small
enough that we do not necessarily need to define all the properties. We are only doing
it up to 100. You can generate all the values by going round the table. We can actually
just cat the file and there it is. If you have a small enough set, this actually works
out fine. Why have I picked on orc? For a number of reasons. One, I think it is a much
neglected language. Two, there is an unusual solution for this. Three, it is the oldest
example of test first programming I have been able to find. Alfred Aho who is the A in orc,
Aho Weinberger-Kirningen, when he was interviewed and he made an observation about how they
developed this in the 1970s. We instituted a rigorous regression test for all the features
of orc. By the way, the lead up to this story is that it had a bug. There is a question
like, well, what do we do now? They decided that the only way to get complete coverage
and guarantee that you have the best coverage possible is to always have more coverage than
code. How is that possible? Well, you write your test first. Therefore, by definition,
you are covering things that you do not yet have. I know it is a normal football manager
thing to say. Our footballers gave it 110%. The guys gave it 110%. That is the whole point
of TDD. You give it 110%. What is your coverage? 110% at the moment. It is like, oh, okay.
It fails, doesn't it? That is a fancy way of saying it fails. Next time you have a red,
you can now translate that into 110%. You can give coverage figures that are higher than
reasonable. You can exceed the limits like the speed of light and so on. Any of the three
of us who put in a new feature into the language first had to write a test for the new feature.
This is test first programming, 1970s style. It turns out that test first programming, TDD,
all this stuff has a long prehistory. It was just very scattered. It started coming together
with XP and it became an entity in its own right. Up until that, it is not that it was
unknown. It was just edge cases. Here is how people normally present the test first cycle.
Red, green, refactor. A lot of people, when they arrive at this, they are not entirely
sure about it. They kind of go, well, I don't really see the point because write a failing
test. Anybody can do that. Where is the skill in that? I can write a failing test with my
eyes closed. There is no skill in that. The problem is I find when people run this stuff,
they often end up spending a lot of time on green. They are trying to get to green. You
need to show what you are going to do. The idea is to show what you are going to do. Red,
green, refactor. When people start getting the rhythm, red, green, red, green, they keep
forgetting about this bit below the line. You end up with the dumb down version. I got
a failing test. I write just enough code to make it pass. Then I write another test case.
Then I write another piece of code to make it pass. We miss out that bit. Then we end
up with some really crazy code. We say, this test first stuff, it doesn't really work.
Fortunately, that kind of view, although Uncle Bob didn't mean to put it like this,
his three laws of TDD, these are not laws that anybody is going to come around and knock
on your door and go, I'm afraid you've broken the law. These are not physics laws. You can
actually break them. It's quite easy. We do it every day. But three guidelines. One,
you are not allowed to write any production code unless it is to make a failing unit test
pass. Two, you are not allowed to write any more of a unit test than is sufficient to
fail and compilation failures are failures. Three, you are not allowed to write any more
production code than is sufficient to pass the one failing unit test. It turns out we
actually need four because this is not enough. What happens if I just follow these? Actually,
I get this. What does that look like in practice? Let's do FizzBuzz. We're going to build it
up this time. A FizzBuzz of one is one. Brilliant. How do I pass that? Brilliant. Done. A FizzBuzz
of two is two. How do I pass that? Copy, paste, copy, paste. This is the other kind of enterprise
programming. It's not the one that is architecturally complex. It is the one that is pure copy and
paste. It's brilliant because your productivity is awesome in one day. How are you doing?
Let's tidy it up so we feel there's an elegant regularity. Boom. Done. Go home. How are you
doing? 100 lines of code today? Does it work? 101. You're right. I get a free one as well.
That's great. 101 lines of code that works because we had tests. How many lines of test
did you have? 100. You wrote 201 lines of code that works today. Brilliant. Excellent. Have
you reviewed it? No. Has anybody else reviewed it? No. So then you go home. You think about
this and you think, you know what? I'm not using all my techniques. I'm not using all
my education. I'm not using all my brain power. You know what I need? I need landers. Yes.
Brilliant. I need landers and I need look-ups. This is how we do it. This is how we do it.
This is a dictionary. It's a look-up. I've been told to make my code more declarative.
I've been told that I need to get more functional. Magnificent. That's a work of art. Your colleague
comes along and says, yeah, actually. In fact, if we think about it, it's not really that
exciting. But that's a terrible solution. This is the point. This is the bit here. You're
supposed to bring your brain to the party. I don't actually like this as a way of describing
the test first approach or the philosophy of TDD. I prefer anchoring it in something
slightly different. I prefer the Deming Shoe Art Cycle, which people normally associate
with lean or agile thinking and at the large. PDSA originated with shoe arts popularized
by Deming. The variation is that Plan Do Check Act, but I find the study term is more important
because study sounds slow. Study has the same first two letters as stop. Coincidence? I
think not. The idea is slow down. Check is very cursory. It's just like, yeah, check
it. It's good. Study suggests you use your brain. This is very hard. Well, the evidence
suggests it's very hard. This is the bit that is below the waterline. Plan and do are highly
visible. Study and act. They don't have substance, so they're quite difficult to pin down. But
it turns out that if you want to run an experimental life cycle, if you want to experiment in the
large, this is the most important bit. People are always planning, doing, planning, doing,
planning, doing. But the reaction about, well, how did that work out? Why did it not work
out? Give me three theories. Don't just give me one. Give me three. Rule of three. Nothing
is more dangerous than an idea when you have only one. Two is a good start. Three, well,
now it becomes difficult to stop. Once you've got three, you'll get four. So the point here
is this is the hardest part to do. This is the bit we normally focus on, the plan and
the do, whether it is user stories, sprint velocities, or whatever it is, because it's
visible. This is hardly visible at all, but it's the bit that makes the difference. If
you're going to experiment and try new things, you need this lower part. So what does this
got to do with TDD? Why do I think there's a better way of describing the test first
cycle? Because if you can do it exactly the same way. Plan what you're going to do. Oh,
that's the tester. Here's the test for the code. This is the behavior that I want. This
is what I'm about to write. This is what it looks like, or at least what I think it looks
like. I would like this to work. It's a pull-driven approach. I'm going to pull from the ether,
or at least my brain. I'm going to pull out an idea. It should look like this. Let me
implement it. Let me do it. Let me reify it. Reify is to make real. Make it substance.
I sketch out a test or a spec, and then I make it real. Then I reflect on it. Then as necessary
I refactor. So there's this kind of idea of when you look at it like that, it's like,
oh, okay, that's why it makes sense. Red-green refactor, it sounds kind of catchy, but it's
actually, it doesn't quite get you thinking. This is about thinking. It turns out this
is mostly about slowing down. If software development were based on typing speed, we
would have solved that problem decades ago. It turns out this bit is the hard bit. It's
having solutions. It's the idea of being able to pause and think every now and then. Let's
try a different way of doing this. So I've got an actual, so here's a list of all the
fizz buzzes from one to 100. So I'm going to try a different way of testing it. There
are lots of different varieties of testing. One is obviously that you have a sample of
here are all the possible outcomes. It turns out for 100 values, that is certainly doable.
But when somebody says enterprise system, which can have trillions or quadrillions of
different states, it turns out this is less than practical. So therefore, you need a different
way of reasoning about it. So let's just try a different approach. Not example-based, I'm
going to take a property-based approach. I'm going to have an array or a list of truths.
There are things that must be true of the actual result for it to be a successful fizz buzz.
What I'm going to do is assert all truths. What are the truths look like? Well, every
result is fizz buzz, fizz buzz, or a decimal string. Every decimal result corresponds to
its ordinal position. Every third result contains fizz. Every fifth result contains buzz, and
every fifteenth result is fizz buzz. This is necessary, but it's not sufficient. It
turns out you need another three conditions. The ordinal position of every buzz, every
fizz result is divisible by three. The ordinal position of every buzz result, divisible by
five. Ordinal position of every fizz buzz, divisible by 15. And now we discover the reason
that I chose Python is because it turns out it's quite easy to convert into Python. Therefore,
we have a very simple concept of, here are all the truths that characterize this. So this
allows you to experiment in the small with, how good am I at discovering how to articulate
the truths? Now, you might want a framework at this point to make this a little easier,
but the basic mechanics, if you like this very raw approach, a lot of people assume
that TDD is about frameworks and things like that. It isn't. Framework extends the reach.
It extends the reach of your thinking, but if you don't have the thinking, then you're
a fool with the tool, unfortunately. And I don't want to say that of you. That's obviously
your colleagues, not you, because you turned up. Okay?
And your bosses, I, you know, so they were your colleagues, but they got promoted because
they weren't good enough, you know, so stuff like that. So the point here is that it's
the idea that there is, do I understand the idea? Do I understand what I want from the
framework? And then it's just like, yeah, yeah, I do. This is the philosophy of taking it
apart to understand how it works. And it's really good if you put it back together again,
but, you know, taking apart is fun. In fact, taking it apart is fundamental. Decomposition
is the basis. But there's another side of this composition. And one of the most composable
approaches that we tend to think of these days, people are focused very much on functional
programming as a model of composability. And I stumbled across this paper by Machi Pirog,
and apologies if I pronounced his name incorrectly. Fizzbar's in Haskell by embedding a domain
specific language. It's like, yeah, there's some really mental stuff in this paper. It's,
you know, yeah. However, I'm just going to extract a small observation here and then
take one of his results and do it slightly differently. The default action is executed
only if some previous actions were not executed. This is true of everything that we've done.
Okay, so we looked at some programming languages for a bit of variety. We're going to look
at JavaScript. Yes, I did say that. There we go. This is the first solution. Just done
again in JavaScript. And you can see we are doing default action, which is print a number
or generate a number, only if some previous actions were not generated. Okay, there's
our stop. That, so there's a kind of like, yeah, that's a shame. I can even get crazy
with it. Let's do this by look up. Okay. Yeah, so when you're bored in the office tomorrow,
you want to replace all those if statements. Yeah, you know, why not? You know, this is
a great way of doing it. That great was in quotes, by the way. I'm not recommending this.
However, we have a table look up approach. But again, the default action, end to string
is only executed if there's a branch here. It may look like a nearest piece of notation,
but there is a conditional branch. And he makes the observation, ask the question, can
we accomplish this without having to check conditions for previous actions twice? In
other words, can we make the control flow follow the information flow without losing
modularity? And he explores this in great depth. I'm not going to explore it in great
depth, but I'll give you, I did this in a few languages. I had some great, it was quite
good fun re-implementing this in different languages, seeing how easy it was in some
languages versus how hard. Curiously enough, Java was actually the hardest. The notation
was really simple for the landers, but it's an absolute nightmare to get the declarations
right. It's just that you sit in there and you've got the declarations and then somewhere
over on the right-hand side of the screen is the little lambda expression that is oh,
so tiny and short. Out to the left is this really long preamble that you're going to
ignore because it really isn't very interesting. What we're going to do is we're going to have
a lambda called test. It's going to take the divisor, it's going to take a string, and
it's going to take something we can execute. And what we're going to do is we're going
to have a fizz that takes something that it can execute. In other words, another function.
And we're going to test. And depending on whether or not the number n is divisible by
three, we're going to make a decision. And what we're going to do is we're going to
decide, we're going to compose with another lambda. So you end up with this beautiful
expression at the end, this is the identity operation, that all works. It's great. Anyway,
I recommend you go and look at the paper and have a go in your language of choice as
to this. Or drop me an email for this code. I might put it up on the slide share just
so you can have a bit of fun with it. But yeah, try it in different languages. Find out what
they feel like. For me, I think in terms of regular languages, Python and Groovy were
the easiest. I found most mainstream languages with an opinion on types were actually quite
difficult by comparison. Anyway, Oscar Wilde, I'm not recommending this as practical. This
is pure art. Except is it? I mean, there's a lot of ideas in here that are quite profound.
But let's look at another way. There is another way. Let's make a very simple observation.
Let's encode this. Okay? So let's encode this. Here we have a list. Zero means it's the
default. It's the number. One means fizz. Two means buzz. Three means fizz buzz. Okay?
That's what it looks like. And then it just repeats. Okay? So that's the basic model.
Okay. So we've encoded it. What I'm going to do is I'm going to shift it around one so
that all the indexing works from zero. And then, yeah, you could do this. So a little
bit of Ruby here. 100. We map i into that. And then we do this over here. A bit of modular
arithmetic and magic. This works. But here's the really crazy thing. If you ever want to
have a conversation with somebody about random numbers, and you say, you know, those random
numbers, they're not really random, you do this. So this blog, I came across somebody
recommended this to me because I talk about fizz buzz often enough that people send me
crazy solutions. Absolutely magnificent. This guy basically searched the ran space, basically
searched, you know, seeded and searched for that little sequence that I just showed there.
Where does this sequence occur? Okay? And there it is for round four. And that's the
sequence. So that's the magic number. Okay? At that point, you will get a nice, repeatable
implementation. As long as nobody changes the implementation of srand and ran. So, yeah.
So this is what we're talking about. You might think, wait a minute, wait a minute, that
Emil Auguste, I quote, maybe it is too dangerous to have more than one idea of this is the
kind of idea you're coming up with, Kevlin. I know, but it's fun. This is the whole point.
It's enjoyable. Then I guess we ought to have a look at Haskell. This is a variation of
a solution I originally saw from Dirk Koenig, who's responsible for the Frager language
on the JVM. And the way to introduce it is actually to return to one of the earlier observations
about one of the earlier examples I had in Python. But you know, originally the problem
was limited to a domain of 100. Why don't we just let go of the limits a little bit?
Fizzes. This is all the fizzes you will ever need. Blank blank fizz, blank blank fizz,
blank blank fizz, blank blank fizz, blank blank. How many of them? Infinite. You sit
and they go like, let's see, how much memory do I have on my laptop? Yeah, infinite, okay.
Here's all the buzzes you'll ever need. Okay, blank blank blank blank blank buzz. Repeat
until infinity. So this slide currently contains two infinities. Oh, this is great. This slide
has got a lot of capacity because here's the third infinity. I'm going to take those two
infinities and I'm going to merge them. Okay, I'm going to zip them together. So what I've
got now is blank blank fizz, blank buzz, fizz, blank blank fizz, buzz where it's necessary.
Okay, so these are all the words we will ever, ever need. Four infinities. These are all
the numbers, string of five we will ever need. One, two, three, four infinities. You know,
you have a new power point to take that. And now we have to make a decision. Number or
word. Number or word. And then we compose it so we get fizz buzz. What's interesting
here is we're not actually defining any new functions in this. This is actually, that
fizz buzz is an infinite sequence, okay, or semi-infinite because we know where it starts.
Okay, it starts at one. Then it goes two. Then it goes fizz. Then it goes four. And it just
goes on and on and on to infinity. Okay, what we do is we apply our choice to the words
and the numbers. We choose between them and then we just zip all the way down making that
choice. It's nice. Okay, here's how we get away with it because it turns out that the
best way to understand this, this infinitude, which normally has to be expressed using enumerators
or iterators in other languages, is that this is all about laziness. Or another way of putting
it is it's hypotheticals. I mean, clarify what I mean by that. Because what we're going
to do is blank blank fizz, we're going to cycle it from here to infinity. Buzzers. We're
going to cycle that from here to infinity. Words. It looks like we're actually going
to do some work, but this is the clever bit. This is how the lazy evaluation side of functional
programming works. It's so lazy it doesn't happen. It's kind of like a promise. It's
like an idea. It's just like, if I were, so this is the way you do it, this is how Haskell
gets around things like side effects and how functional programming gets around it. It's
a very clever way just for side effects, for IO, for example. The way to reason about it
is to say, in a pure functional language, you cannot have side effects because these
are pure functions. But let me describe to you how I would do IO. I'm not doing it. Oh,
no, no, no. Doing is an imperative thing. But if I were to do it, notice I'm being very
careful. There's an extra level of indirection in what I'm saying. If I were to do IO, it
would look like this, but I'm not doing IO. But it would look like this. Oh, clever. And
then you hand this off to the runtime. But you are still pure. Clever. It's an outsourcing
trick. Okay? You outsource the state changes. You just describe it as if you were going
to do it. If I were to have infinite sequences, this is how you would do it. Yeah. If I were
to calculate all the words, this is how I would do it. If I wanted all the numbers, I
would take them. This is stringifier. I'm going to apply the string operation from one
to infinity. If I were to do it, it would look like this. Are you going to do it? I never
said I was going to do it. I'm just telling you how I might do it. Classic mathematician
approach. Yeah? Choice is either profoundly elegant or a real hack, depending on your
point of view. I think it's really elegant. I was very pleased with this. It turns out
the numbers order perfectly with respect to the letters. Yeah? Or rather, so this actually
works out based on any character set you care to name on which there is a Haskell compiler.
Because I did have somebody say, yeah, but what if your character set doesn't do the
right thing? I will buy you a meal if you can find a Haskell implementation on a platform
that has a character set that disobeys this. Can they hack it for non-lixic bread ordering?
No, you can't hack it. No, it's good. Where's the sandwich?
Let's say sandwich, the meal. No, no, no. You're getting me the meal. Yeah, yeah, this
is it. I might give you an olive. Okay? Okay. Okay. So this is how we do it. This is all
hypothetical. Nothing's actually happened here. We just made a bunch of promises. At
this point, we actually do some work. Give me the first 100. At this point, we actually
have an imperative statement or Haskell programs will tell you, it's not imperative. Trust me,
I know language. Take is, and I've got kids. Take is a very strong, stateful operation.
Okay? Okay? At this point, we're going to make a commitment. Give me the first 100. At this
point, something actually happens. Up until this point, nothing has happened. Yeah? So
this is why it's called declarative. I do declare this. Have you done anything? Absolutely
nothing at all. Yeah? So, but it's a very elegant way of looking at the problem. And
this kind of stream-based thinking, this kind of infinite thinking, this kind of idea of
operations on things is both profound but also quite amusing. This quote from 2009, I love
functional programming. It takes smart people who would otherwise be competing with me and
turns them into unemployable crazies. Because you see that is the problem when you start
looking, you know, this is the kind of classic nature. If you look into the abyss, the abyss
will stare back at you. There are four infinities on this slide. No, I'm wrong. Five infinities.
I forgot this one. There are five infinities. You cannot look at infinity without having
some kind of reality distortion. You go crazy at this. Okay, I think I have just enough
time for a couple more things, haven't I? Yeah, so let's look at another carter. I'm
going to do something slightly different with that. I said I know a little bit about words
at Gesundheit. I know a little bit about words. And so therefore, one of the things I do is
I run a page, Word Friday, on Facebook. And every Friday, I present an unusual word and
a definition. The rest of the week is just language and linguistic stuff that I find
interesting, that I found on the web. The reason this is relevant is one of the words
I featured a couple of years ago is biquineric coded decimal. Okay, you get bonus points
if you can drop that into a conversation naturally tomorrow. Okay, I do actually know somebody
who always checks my Word Friday stuff and sees if he can get it into a conversation
over the weekend. You know, just get the word in. You know, sometimes it's quite a challenge.
Sometimes you can do it ordinarily. Yes. I learned a new word yesterday. It was biquineric
coded decimal. There you go. That's perfect. You know, but you need to be more discreet.
You need to somehow just slip it in as if they're... I learned a word. Oh yeah. Or do
it as a promise. Do it as a kind of like a declarative approach. We've learned all about
that. So here, biquineric coded decimal. Ask me about the words I learned yesterday.
Oh yeah. Which word was that? Biquineric coded decimal. There you go. So that was a message
based protocol. You can cover all paradigms with this. Okay, so a system of representing
numbers based on counting in fives. I have no idea where that idea came from. Okay. Right.
Counting in fives. With an additional indicator to show whether the count is in the first
or the second half of the decimal range. Whether the number represented in the range
0 to 4 or 5 to 9 or 1 to 5 and 6 to 10. Okay. So where do we see this? Well, you see this
in classic abacus systems, like the professional abacus systems. Not the ones you give to
your kids, which actually have 10 beads. You have a 2 and a 5 system. Okay. It was actually
used in the Colossus computer at Bletchley Park before they figured out that binary was
a lot easier to do. And perhaps one of the best known ones is the Roman numeral system,
one of the other classic cartas. Now there is a fabled tale, which I wish were true,
but I don't think it is, that actually the letters of the Roman numeral system came about
visually. In other words, they corresponded not originally to letters, but to indications
that you could do across a marketplace. So obviously one to, historically you would actually
do 4 rather than IV. But if I want to show that something is 5, then that's 5. Okay.
And then that's 10. Okay. And you see this all works beautifully. There's 50. There's 100.
I want this to be true. I don't think it is, but I want it to be true. Okay. However,
we don't have to worry about the truth of such things because we're going to do this
enterprise style. We're going to just do this one thing at a time. We're going to build
it up and we're going to do this. And yeah. Okay. Let's try that. Change font size. There
you go. Brilliant. Okay. If you're being paid by the line of code, this is magnificent.
Okay. This is how you earn your living. But it is entirely possible. You may spot some
regularity. I hope. Now, one of the things I find interesting is a very subtle observation.
And I noticed this when teaching my younger boy a little bit about programming, is that
if you ignore the else, then an if is just a single one time, is a limited form of while.
Normally, there's a lot of fun to be had trying to express one control flow mechanism in terms
of other control flow mechanisms. And an if is simply a while with a very limited range.
Okay. It'll execute zero or one times, whereas a while will be zero, one, to n. With that
regularity in mind, you can condense it down to a lookup. Okay. Now, what is interesting
about this is obviously the declarative approach. There's this very simple idea that if you
show me your data structures, then I can tell you what your program does. If you show me
your data, your control flow, I will struggle. It's kind of obvious what we're doing there.
We've actually separated this out. And what is interesting is this kind of separation
is actually quite fundamental in the large to a lot of software systems. I have a lookup
and I have a way of processing it. Processing? Thing to look up.
What's a double divisor?
That is proper division done the integer way. It's kind of like divide. No, I really mean it.
You know? Yeah? So, yeah, this is integer division. It turns out that the idea of polymorphic
division based on types in a dynamically typed language is fundamentally flawed. But it's taken
a few decades to discover that. So, here, we have a simple way of ripping through a lookup.
And now what we've got is two areas of focus, stability. Funny enough, this actually looks
like a message processing loop that I wrote many years ago. It was just like, yeah, I can do it
all through a table. And then suddenly we have a completely stable piece of code that is comprehensible
and then a tabular representation that is extensible. I don't expect to be extending the
domain of Roman numbers, but nonetheless, there is a fundamental idea here.
Now, this is all well and good, but I mentioned John Jagger before right at the beginning.
He came round to my house a couple of years back and we did some coding and he said, oh,
I came across a new solution, an alternative solution. It was an F-sharp solution to the
Deanwell's problem and I thought maybe we could try it out. So we tried it out in Ruby.
I'm not really a Ruby guy. No, I'm not a Ruby guy. There's no really about it. I'm not a Ruby guy.
I can read bits of it and then I look at the rest and go, you're kidding, right? So I translated
immediately to Python, but it's elegant because, again, we've got another problem here that looks
like an arithmetic problem, but actually it isn't. What we're going to do is if you thought
binary was the fundamental counting system because you think binary, that's it.
Unary. Unary is more fundamental. Unary is the base that the universe uses. It doesn't
have a condensed form. If I've got one thing, I've got one thing. If I've got two things,
it's two things. This is two in unary. This is three in unary. Four, five. You've got
a billion stars. Yes, there's a lot of them in unary. One thing at a time. So what I do
is I take the number and I convert it into unary. You give me the number 323. I multiply
i by i. I've got 323 i's. Unary is fundamental. Perhaps it's not very Roman though, so we
reduce it. It'll buy little. We condense it down. We pipeline it. We filter it. We cook
it down. No, I'm not making any claims for its efficiency, but I am making massive claims
for its elegance and, importantly, its explainability. Because, interestingly enough, good experiment,
I tried it with my kids. I said, I showed them this version and then I showed them this
version. The older one's 15. The younger one's 11. So they still have the desire to go and
look at something else that's got a screen and doesn't involve dad. So there's a patient's
limit, but you can actually show, it's just like, oh, okay, that makes sense. There's
an elegance here. It's just like, yeah, I quite like this. Johnny emailed me the other
day. He'd been messing about with it as well. He decided he wanted to try a different variation.
So he decided to just focus on i's, x's and c's. We could also factor that out. 10, 9,
5, 4, 10, 9, 5, 4, 10, 9, 5, 4. There's lots of different ways of showing the regularity.
There's a lot of elegance to be had here. Although the disappointment here is we've
reintroduced multiplication in lots of locations, but actually, no, that's good, because we've
got no division and it's string multiplication anyway. So there's a very simple idea here
about thinking this is not actually an arithmetic problem. It is a symbolic manipulation problem
and there's a different way of looking at it. So we may say, okay, well, yeah, Python,
but that's not really, you know, hell, you know, I need to do a proper functional programming.
So let's do this in Clojure. And this is why this is also talk about style, because it
turns out that not everything has a uniform, easy to access style. So if I do a straight
translation into a standard applicative language model, then I end up with this. Let's change
the font size on that. Yeah. It's got that kind of, I mean, it's got sort of, maybe it
looks like an airplane. I don't know. What do you think? Maybe it's geese migrating in
the winter. Yeah, there's lots of choices here. Comprehensible? Not so much. So this,
the straight applicative model is not the one we want. So we need to do some composition.
In other words, in other words, we're going to need to start thinking in terms of higher
order functions. So what we're going to do here is two changes. One is I'm going to use
anonymous functions, lambdas, but not spelled lambda. Okay, see, this is the creativity.
If you're going to invent a language, don't spell lambda, lambda, all right? Either let
your cat walk across the keyboard, you know, let your kids pick a random emoji or just
ripple the vowels out. It's a function. No, no, no, it's a funk. It's a funk. Ah, got it.
Brilliant. We'll do it. Feel free to use F next time because everybody will understand
what you mean. Okay. Okay, so now what we do is we've got a different model here. Okay,
so we've got comp, composition. Okay, so first of all, we join, this is our unary converter.
Then we successively, ah, there's a problem with this. The problem here is that we are
reading from the bottom to the top. Now, every now and then, a list program or a closure
program will come along and say, no, it's perfectly natural. No, it isn't. They are wrong. They
are trying to sell you something, okay? Because in the same code base, you'll have things
that read from top to bottom, and in other places, you'll read from bottom to top. I
don't mind which order. Just choose one. So here, there's a notion here of like, yeah,
I've got the elegance. I've got the power, but it's going against the grain of what
I want to do in terms of pipelining. So, okay, let's simplify it before we get there. Now
it's beginning to look much more like a table. So a little, few abbreviations we can throw.
Then I'm going to use a threading operator, and I'm actually going to go back and use
the member replace just to keep it simple here. And then we've recovered that, but we've
got a very different way of looking at it. And what is nice about this is I'm no closure
programmer, but it doesn't take a lot to explain this. What is interesting about a number of
these solutions is their explanatory power. It's the idea that it's not that you can read
it immediately, but it takes very little to unlock it. If you look at the if-else-if
versions, if you look at these complex control flow versions, they take a lot more deciphering.
Here, you can show somebody who doesn't even program what you're doing. You can just walk
them through it, and they go, aha, it's easily explainable. Explainability is a very often
overlooked power or quality of code. So there's a really important idea here. Richard Feynman.
We could, of course, use any notation we want. Do not laugh at notations. Invent them. They
are powerful. In fact, mathematics is, to a large extent, invention of better notations.
Okay? There is a very simple idea. Sometimes we go, oh, syntax sugaring. It doesn't really
change things. It changes things profoundly. Certain symbols, whether we are talking about
moving from Roman numerals, which really are quite difficult to work with. Okay? So the
Arabic model, which is positional and is much easier to work with, it makes things easier.
There are notations that allow us to stretch further. And what you're doing when you program
is inventing a language to talk about your problem domain. Okay? So feel free to push
out a little bit. Don't go too crazy, but if you're going to do it, do it in a carter.
It's a perfect place to experiment. It's a small, self-contained laboratory for techniques.
Now, if we're going to talk about notations, and I've been talking about pipelining and
things like that, I did think I would have a go at doing this on the command line. Just
for fun. Roman 42, Excel, aye, aye. There we go. There's my unary converter. I was very
pleased with this. This is hideously inefficient, so we can actually put it all in set. So there
it really is just text manipulation. It's a text manipulation problem. It is not an
arithmetic problem at all. You thought it was about numbers. It's not. So again, there
is something profound here that is basic to all programming. Will you convert a problem
that looks like this into a problem that looks like that? Oh, you told me it was a number
problem. Actually, it's not. Or rather, I can show you something else. Let me show it.
Let me take that problem, and now I understand it, turn it through 180 degrees and then an
imaginary amount, and I will give you something else that you did not think of before, and
it will provoke thinking. That's the whole point of these.
So I will end with Stuart Brand's quote. We talked about style. We talked about form.
Style is times full. Form is times student. Form is ultimately what you're after. Form
embodies understanding. When we use the term carto, it's not simply a training exercise
of repetition, which is good. That's the basis of it. It's practice, but it's also an opportunity
to experiment, and sometimes we overlook the second part of like, okay, I think I know
this. I showed this to a friend of mine who's a mathematician. She kind of came up to me
afterwards and said, okay, two things. One, I didn't know there were that many proofs
of Pythagoras. Two, I thought I knew the Roman numerals solution. Okay? There is always more,
and there always will be more. Thank you very much.
Okay. We're done? A couple of questions, maybe? Yeah? Yes?
10, 9, 5, 4. You saw that pattern? Yes.
Have you ever thought of writing in a zikata to extend Roman numerals?
That's really interesting. No. That's why I do this, because now you give me an idea.
That's great. I love it.
The letters are always coming through, right? IVX and X.
Yeah.
There's a regular patterning, and once you've seen it. Yeah. Sorry. 10, 9, 5, 4. There is
this recurring pattern. What about extending Roman numerals? Okay? Therefore, let's just
imagine, people love the alternative timelines. What if the Romans had kind of gone on for
a bit longer and decided that they'd keep the number system and decided that numbers
were not big enough? How would we extend this? You could make it regular. You could create
your own number system based on this bicoineric decimals system. I have an extension.
How about the bar of cocktails, if you're revolting against the Romans?
Oh, yes. Yes. But actually, I think I might go for the Eastern Empire, because the result
would be quite Byzantine. Okay. Right. Another question. I feel free to do an extended Roman
numerals card. I've never thought of that. I've seen extended fizzbuzz. I've not seen
extended Roman. That's great. Any other questions, thoughts, reflections, desires for beer?
Desires to play fizzbuzz? You've got to be practical, haven't you? I've just shown you
the theory of fizzbuzz. Can I share something now? I wanted to say afterwards, that's right,
so one of Tom Scott's language videos, and he talked about solving fizzbuzz. So I spent
a good couple of hours of sleep just writing other solutions for it. It is quite fun, because
it's a self-contained problem. You'd be surprised how much you can come out with, and occasionally,
a spark of inspiration comes along and goes, you know what? I think this could lead to
something else. It makes you look something else up. You learn more of the language. It
makes you say, what about this language? What about that language? It causes you to do things.
It creates a chain reaction. Occasionally, people say, but how can I use this in my everyday
code? My answer is, I don't know. You tell me. Okay. That's the idea of play. This is
a really important idea. So play is fundamental to this whole concept.
Change the context. Change things like the sizing of the domain. What if it's a thousand? What if it's a million? Okay?
Yes. There are fizzbuzz variations that do other things. In other words, there's lots of possibilities
of variation, and each one points in a different direction. It was actually a very interesting
example. I did it at a company. It was bigger than these ones. It was actually a programming
contest example. It was a phone number lookup approach, phone number prefix lookup approach.
It was interesting because four of us had an approach. We did it in Python, and it was for a workshop,
and we wanted to show four fundamentally different approaches. I went for an approach that was minimal,
Pythonic and functional. Somebody else went for an approach that was massively efficient,
used trees and all kinds of stuff. Somebody else decided to just do it in a scripting style.
In other words, I will do Python in the manner of a scripting language, just pure scripting
approach, sort of classic procedural scripting, and then somebody else did an in-memory approach.
It was interesting. If you change the parameters of the problem slightly, then it became completely
impractical. But memory is one of those things that we seem to be getting more of because it turns out
one of the things that we have learned is you can't beat the speed of light unless you have all that
exotic matter. If you have it, then what are you doing here on Earth?
It turns out that the network is always going to be slower than your local memory.
Therefore, if you have more local memory, it turns out you can do a lot more computation.
This idea is that his solution would scale given enough years. That's not a stupid idea,
because if we look at many of the solutions that we now adopt, if you go back 10 years,
go back 20 years, people would say, you'd never be able to run that in memory. That's impractical.
Oh, we're doing it all the time now. So these things change. Yes?
Sleepsort.
Oh, Sleepsort. I love Sleepsort. Sleepsort is one of the most counter-intuitive and yet profoundly
elegant ways of doing something. Has anybody come across Sleepsort? This is off. I'm going way off slide here.
Sleepsort is, I have an example. I think I have an example. It is beautiful in a way that is insane.
It will also scale up in a T-year with better resolution finders.
Yeah, there is something quite beautiful about it. Oh, yes, there we go. Here it is.
Okay. So here is my reduction of Sleepsort. Sleepsort was possibly the only good thing
to ever come out of 4chan. We don't know who invented it, because it was an anonymous poster.
They posted a much more complex version. I've reduced it down to actually straight born shell.
You don't even need bash. So we've got that. And then, okay, let's execute it.
And what we're going to do is we're going to Sleepsort the first few digits of Pi.
One, one, three, four, five. Wait for it.
This is the same as NoodleSort for quantum computers.
Do you know I'm going to have to look at that? Because this one has certain properties.
I guess one of the properties it shares with the quantum computation.
As you know, the quantum one should be 01. This is linear.
You know SpaghettiSort though, right? Yes.
Taking in for the SpaghettiSort.
Yeah. I've got lots of sorting algorithms on this particular slide deck.
If you're really interested in, you know, really bad sorting algorithms, I've got them, you know.
So here's a permutation based approach, which is factorial complexity.
I use this one when people say, oh yeah, we don't have any performance requirements.
You know the best way to find out people's requirements? You give them something like this.
And then suddenly they will discover they have requirements.
It's just like this has got factorial complexity.
Then we've got Bogosort. I didn't put any of the other ones in, which just uses random.
Take a sequence. Shuffle it. Is it sorted? No. Shuffle it again. Keep going.
The complexity of this is OMG.
So yeah, there's a whole host of these things, but they are all provocative.
They all do something. They get you thinking.
Sleepsort, I just love the nonsense or the insanity or the elegance of Sleepsort
because this whole idea of it's actually linear, but it shows you that you can now farm all of these processes out.
If you have all of the stuff available, then everything is a processing node.
You just have to scale the time appropriately because it turns out that the linearity logarithmicity
or quadrativeness is actually not your problem.
It turns out it's a different problem, but it makes you understand that performance is not simply a property of complexity.
There are some really insane things out there.
And on that note, we're done. Thank you.
