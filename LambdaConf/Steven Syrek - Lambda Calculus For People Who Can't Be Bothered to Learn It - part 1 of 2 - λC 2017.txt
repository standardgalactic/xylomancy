Rwy'n cael ei ddweud o'r ddweud o'r ddweud o'r ddweud o'r ddweud o'r ddweud o'r ddweud o'r ddweud o'r ddweud o'r ddweud o'r ddweud.
So, welcome everybody to this workshop, Lambda calculus for people who can't be bothered to learn it.
I was surprised to see on the schedule I think there are at least four lambda calculus related workshops and presentations at this conference,
that's a lot of lambda calculus, did any of you go to the six hour one yesterday?
Dana Scott.
Dana Scott? All day? How was that?
I'm sure way over my head.
This will not be a reprise of that at all.
For people who can't be bothered to learn it part,
that is because I'm not really going to teach you all of Lambda Calculus.
It is actually quite a deep subject. There's a lot to it.
There are many different Lambda Calculi.
I'm mostly going to be doing a little bit with the simply typed Lambda Calculus,
which I think is something anybody can learn pretty quickly.
It can actually be a little bit fun.
Also though, we're going to be implementing it
in America's favorite programming language, JavaScript.
Now, this is not because I recommend JavaScript for functional programming
or any practical purpose whatsoever.
It's because I don't want to have to ask everybody to install Haskell
or some other language.
You all have JavaScript on your machines already.
For those of you who don't know this, you may be slightly surprised by that fact.
But I assume all of you know this.
In your browsers, you have a console that runs JavaScript.
That's all you need, so easy for me.
I'm also not going to be using very much of the JavaScript syntax,
such as it is at all, just anonymous functions.
But we'll get to that.
Again, just to reiterate, please stop me and ask questions.
I don't generally like the Socratic method of teaching,
but let's see if you can read my mind.
What do you suppose is maybe the simplest,
what you might think of as the dumbest possible question
you might ask about Lambda Calculus?
Anyone want to take a guess?
I'll never do this again.
Why?
Why what?
Why do you need to bother?
Huh?
Why do you need to bother?
Why do you need to bother?
Why do you need to bother?
That's a smart question.
I'm looking for a dumb question.
What's a Lambda?
That's it.
Yeah, why is it called Lambda Calculus?
Does anyone actually know why it's called Lambda Calculus?
I know you know.
No, no, no, no.
I don't want you to...
Okay, good.
I'm glad very few people know.
This is an important point.
It seems like a trivial point.
This might be a little bit of mythology.
Very quickly.
I think it's kind of funny.
All right, people are afraid of this.
It's got a Greek letter.
It's called Calculus.
If you're not a math person,
I'm not a math person.
Sounds scary, right?
Forget the calculus part.
You know, we're going to count some things with it
or something like that.
So forget calculus.
But Lambda, what is this Lambda thing?
A little bit intimidating.
This is about lambdas, right?
It's lambda com.
Well, Alonso Church,
the person who developed, discovered, invented Lambda Calculus,
the story that I read in academic literature
was that he actually wanted to use some notation
from, I guess, the 18th century
that looks something like this.
It's actually like a little hat.
If he had gotten his way,
we'd be calling it hat calculus, I suppose.
I know that sounds funny,
but there actually is a hat calculus.
Look it up on Wikipedia.
It became a different thing.
Back then, professors had secretaries.
I'm actually a recovering English professor.
I never had a secretary.
But typewriters couldn't do that.
So his secretary ended up kind of doing that
to represent it.
He could do that with some slashes.
This could all be a myth.
I don't know.
What does that look like?
Yeah, capital Lambda, right?
That's it.
So they called it Lambda Calculus
and eventually went lowercase.
I suppose it looks nicer.
They use this for type systems now.
That's it.
So what is the point?
Okay, it's like a little bit of a factoid.
Completely arbitrary, right?
These are not things to be scared of.
All of the names that are used in Lambda Calculus
and much of functional programming,
they're just arbitrary names.
There's nothing to worry about.
They sound a little bit intimidating.
They certainly intimidated me.
I may be more easily intimidated than all of you.
But the point is, who cares?
It doesn't even matter.
These names are not important.
Okay.
I'm not going to do a lot of slides.
In fact, originally, I wasn't going to do any,
but I thought it's probably worthwhile to introduce
the syntax of Lambda Calculus a little bit
before going straight into JavaScript.
I need to ease you into JavaScript
because I know it's a little bit painful.
I should introduce myself.
This is my name, Stephen Syrac,
in case you're wondering about the pronunciation.
I'm SJ Syrac in all the places.
Like I said, I'm a recovering English professor.
I just want to point out to you that if I can do this,
you can do this.
I've not been doing this for very long.
I taught myself Lambda Calculus
while I was learning Haskell not very long ago.
I think I started a year and a half ago at the most.
I became very excited about it enough
that I was willing to do this right now.
I want to make that point not only because
I want to be encouraging to all of you,
but because there are two purposes to this talk in my mind.
One is that maybe I can communicate something
about Lambda Calculus to you
and why it's useful, why it's awesome,
why it's the foundation of everything
that this conference is about.
Also, and for me more importantly,
and for those of you who do have experience,
by the way, those of you who do have experience,
feel free at any time to tell me when I'm wrong.
I need that and I appreciate it.
Also, please help others around you.
I want everyone to be able to come away
from this presentation,
able to teach this material to somebody else.
The only way the functional programming world
is going to grow is if all of us become teachers.
Maybe that sounds like an extreme statement,
but we're a very small community.
For our own self-preservation,
we need to expand, like expand or die.
The other reason I'm using JavaScript
is precisely for this reason.
You can go back to your places of work
or to your friends if you can convince them
to learn something called Lambda Calculus.
Everybody has a web browser,
and you will be able to open that up and show them some things
without having them install a complicated programming language
or some software they don't understand.
Like I said, anybody can learn this.
If you already feel competent with this material,
then at the very least you can help me develop this
into a better presentation for teaching others
and then find a way to use this material
to teach your colleagues.
You may not get them to install Haskell,
but you can get them to open up a browser
and then you can immediately start writing functions
and show them how this stuff works.
Okay, so that's enough motivation, I think.
Are there any questions at this point?
I know that you wanted me to go over
purposes and aims or something.
Don't you?
That's very heavy, but it's a useful exercise
for the ultimate marathon.
Thank you for asking.
I think it's really useful for developing an intuition
for what functional programming is all about.
Raise your hand if you're really not sure
what functional programming is.
Yeah, honest people, yeah, exactly.
Raise your hand if you think that you would be able
to competently explain it to somebody else.
That's the other kind of question, yeah.
Functional programming is programming with functions.
So helpful.
I think actually this material will really show you
what functional programming is all about.
It's elementary particles, as it were.
What has learned Lambda Calculus itself
taught me about programming?
I think I only have a boring answer to that question.
Haskell is a Lambda Calculus.
I made this joke, don't we program with Lambda Calculus?
Yes, if you're using functional programming language
or using Lambda Calculus, you just may not know it.
So at the very least now you'll know it.
I never really thought about how Lambda Calculus
specifically...
I suppose I can look at a function and know
that I'm doing Ada reduction now,
or that maybe I should do Ada reduction.
I guess there are places in which it helps me
with refactoring or conceptualizing.
I'm not going to be talking specifically about that,
I don't think.
I guess I would maybe be able to talk about
how Lambda Calculus gives us for free
all of these features
that we hear about when we talk about
FP, right, like what?
Referential transparency, immutability,
curing.
What are some other good ones?
I don't know, fixed point recursion?
Anyway, that stuff all just sort of falls out
for free from Lambda Calculus.
Anyway, let's get to it.
This is the whole language, right? World's smallest programming language.
Maybe actually the first programming language
invented.
1933, anyone know the date?
1933?
You can look it up in Wikipedia.
Alonso Church, Lambda Calculus.
Before there were computers, right?
They got it right the first time.
This is the whole language
right here.
Concentrating first on the first line.
You have...
Anything in Lambda Calculus is an expression,
and there are three kinds
of expressions.
Names, functions, and applications,
and that's it.
A function can be
a name.
Lambda name dot, I'm going to explain all this a little bit
in more detail.
Lambda name dot expression,
and an application is just two expressions next to each other.
So you can see how this is a bit of a
recursively defined
language.
The Lambda in the second line,
that's the famous
Lambda that everybody wears. Does anyone have a Lambda
on their t-shirt right now?
I'd be surprised, actually, if nobody did.
You're probably all wearing one
on your lanyard thing.
It's just an abstraction operator.
If you're a programmer, you're used to abstraction,
even if you don't know functional programming.
All that is saying is create an abstraction
called name
and bind to that, this expression.
Whatever the expression is.
And then function application
is two expressions next to each other.
So if you're used to Haskell syntax,
the reason why we don't have parentheses in Haskell
is because function application is kind of the only operation we have.
So we keep it simple.
It's just two expressions next to each other.
I'm so happy to have a blackboard.
I don't do slides, so I'm more used to blackboards personally.
God, this is like very fat chalk.
I will be showing some expressions soon,
but I just want to make this point.
So you can have something like
Lambda X dot X.
We actually call this the identity function.
And this part here
we can call the head.
This part is the body.
This is an expression.
Obviously X has no meaning.
This is an abstract syntax.
Whatever you have here,
whatever the expression is,
it's just some stuff that we're going to
compute under
this thing, Lambda X.
You've heard anonymous function.
I don't like anonymous function.
It doesn't have a name. It doesn't matter.
This operator creates an abstraction
out of this expression.
And the X just means that
this X and this X are the same.
If you're used to functions that
look something like this,
right?
It's just text substitution, really.
I mean, really, it's just text substitution.
This was invented before there were computers.
In fact, with the Lambda calculus,
as simple as it is,
you can model any computation whatsoever.
That's what's really neat about it.
Maybe that's a good answer to your question.
You can compute anything that can be computed with this.
It doesn't seem like you should be able to.
I'll prove that.
I mean, there are things you can't compute.
That's just sort of a property of nature.
This sort of captures that
in the simplest possible way.
There's an expression, X.
It's just something, something X.
Lambda X.X, I just showed you that.
This is a function.
Body.
Body.
Sorry, head.body.
Lambda X.LambdaY.XY.
This is another expression.
You can think of this as a function
with two arguments, X and Y.
Lambda X.X
in parentheses applied to Y.
This is not terribly different
than if you had simply
X, Y.
This is also function
application.
Lambda X.XY is also function
application.
By function application, again,
I mean text substitution.
It's probably worth
not thinking too much about functions
as procedures
that we're used to in imperative
programming languages.
Lambda X.
Lambda X.XY.
Function
application means we're doing text substitution.
Y substitutes
for this X in the
expression.
This goes away
and we're just left with Y.
Y goes into the X.
Turns into Y.
This is also
a
function application
and it's not more complicated.
They get longer and more
they look trickier, but ultimately
the rules are the same.
Lambda X.X
Lambda Y.
Anybody want to guess what this turns into?
Yeah, right? Because this whole thing
goes into here and is substituted
for this X.
So we're just left with that.
This is
one of the operations, actually, beta reduction.
So again, anybody want to get another
guess for the audience? When we say
alpha substitution or alpha conversion,
where does the alpha come from?
Why alpha?
What's the dumbest possible
answer?
Yeah.
That's it.
I got to call it something.
I can go on to you.
On the last slide,
can you write the third
and the fifth one
in the new like alpha version?
Oh god, I can try.
The third one?
Okay.
Lambda X.Lambda Y.
XY.
Lambda X.
Write that using
like F.
Okay.
Well, does somebody else want to try?
I mean, I could do it,
but maybe someone else should do it.
I mean, I suppose you could have
F of XY
and then you could apply that
to
one and then two.
I mean, these don't do anything, right?
We don't know what X and Y mean.
Like it's just a function. It's just a pure.
Oh, there's the other one with a purity, right? Functional purity.
It's just a pure function. It has the same input.
For any given input, it has the same output, right?
Like anytime,
and whatever X you give it is always X.
It's always the same, right?
It's like mapping between sets.
Is that helpful?
Okay.
When we get to the JavaScript,
wow, I never thought I would say this sentence.
When we get to JavaScript, it'll make more sense.
Okay, so
here's alpha substitution.
Again, the variable names,
they don't mean anything.
You can use any variable that you want
and, yeah,
I'm being very funny about using poop emoji, but
the point is these are all the same.
I'm going to use this triple equals a lot
because this is not equality per se.
These are all actually identical.
Lambda A dot A, lambda Z dot Z, poop, whatever.
They're all the same.
All of these represent the exact same things.
You can substitute them one for the other.
And you sometimes need to do that
in complicated lambda reductions,
which we are not going to do, right?
Because you don't want to learn lambda calculus.
That's why you came here
when we get to the JavaScript. Sorry, yeah?
Do you remember the thing
after the dot?
Legibility?
But no.
You're separating the arguments
from the expression.
That's what the period is.
Yeah, yeah, yeah.
Lambda A is the argument
and the A after the dot
is the expression.
Otherwise, it doesn't matter.
It's just notation, right?
This is not a programming language.
This is not something you can run on a computer.
Here's a slightly more complicated.
That was alpha substitution.
This is beta reduction. I kind of did a few already,
so I hope this makes sense.
You have lambda X, lambda Y, X, Y applied
to P and Q.
First you apply the P, the X goes away.
Now you have lambda Y dot PY.
Then you apply the Q, the lambda Y goes away
and you end up with PQ.
Does that make sense?
It worries me sometimes
that this stuff doesn't actually make intuitive sense.
If it doesn't make sense, I will explain it
in more detail.
Again, I thought I was going to get 10 people.
Does it make sense to you?
I know.
We're going to get there.
This is just supposed to be a warm-up.
I actually don't want this to take that long.
This is kind of neat.
Lambda X dot XX applied
to lambda X dot XX.
When we reduce that, we get the same thing, right?
Because if you plug
this into this expression,
this X goes away
and you actually substitute this
for both of these Xs, right?
Then you get the same thing again.
Recursion.
You can do recursion with pencil and paper.
I thought that was pretty neat
when I first learned it.
Finally, eta conversion.
This is mostly for your information.
It's not going to be terribly important
for the talk today except the eta conversion
will come up in one very important place later.
What I'm saying here is that
maybe this is the math part that will help.
I don't know.
I can't really make it simpler than it is.
Lambda X dot XX is just the same thing as F.
The X is superfluous.
It's the same thing as a function F.
If you have a function F applied to an X,
you can put that into a lambda abstraction.
That is the same thing as F itself.
One thing that you still have
is that the first expression
would have your hacked bound
is no longer a free variable.
That's how useful you think about
my handing off a function
or my handing off a function.
Which one?
Lambda X dot F of X.
The first one is that your X is a bound variable.
The other one is not.
That's a good point.
That's a good point.
I wasn't going to talk about free variables.
The F is not bound in this expression.
If I were actually teaching you lambda calculus,
which I'm not supposed to be doing,
I would say that the F is a free variable.
It's F in some global state.
We don't like global state in functional programming.
Still, it represents some global binding F.
But these two things just happen to be
identical in meaning.
The F is the same in this case.
That's a good point.
Let's get right into combinators.
Another scary word.
A combinator is a function with no free variables.
I guess we can say that.
It's a function you can combine with other functions
to do some very neat things.
We've already seen this one.
Lambda X dot X.
We call this the identity function.
Whatever we give it, we get it back again.
This will prove to be useful and important
in many places in functional programming.
This is also, I guess you could say,
the universal fixed point combinator.
That sounds scary too.
A fixed point function is...
The fixed point of a function
is the value that when you give it to a function,
you get the same value back.
There are many examples of this in math.
I'm not going to go over them,
but I hope you can see that for this function.
Lambda X dot X.
Whatever you give it, you get back.
That's what I mean by universal fixed point combinator.
Fixed point combinators will also come up again later
in a much sexier way.
This is what
the identity function looks like in Haskell.
My favorite programming language.
And yours too, I assume.
It's not easy to type a lambda
on your computer, so we have a
a slash there instead.
That represents a lambda, essentially.
This is what we're going to use in JavaScript.
Assuming that your browsers are all up to date
and you have fat arrow functions.
Same thing, very simple, right?
This is the basic building block that we're going to use.
Anybody know what this is?
Python?
Yeah, Python.
Anyway, what about that?
Yeah, this is good for me to gauge the room.
Who knows what?
What about this weird looking one?
Not Ruby?
No?
Yeah, it's Rust.
Can you do this in Java?
I don't actually know Java.
I'm proud of the fact.
I've been programming as a hobby my whole life.
I lost interest in the 90s,
which is when Java started becoming popular,
and then I got back into it not very long ago.
I feel like my great pride in life
is I missed the Java period.
I hope.
I'm sorry if I'm moving too quickly.
I do want to get to JavaScript.
I can't believe I'm saying this stuff.
Now we have a very simple notation
for creating computations,
but it's a little bit clumsy.
We need to actually start creating
some primitive values.
We need to create true.
Again, this is not a binding
in the sense of a variable binding.
These two things are completely equivalent.
They are a substitutable one for another wherever you see them.
We're just going to say
lambda x dot lambda y dot x
means true.
This is simply a function that takes two values,
an x and a y,
and it returns the first one.
We're just going to say that that's true.
You could do it a different way if you want,
but we're going to use that as our convention.
We're going to encode false as the opposite.
It's a function that takes two values
and returns the second value.
That's it.
This is not like some standard
of lambda calculus.
This is totally a convention.
It's the convention that is typically used, so I'm using it,
but we're just making it up.
Did I see a hand somewhere?
Sorry, I was just going to interject.
If somebody is trying to use node
and you're using new language features,
it might not work.
I think actually,
Babel inspired me
to do this at some point.
Actually, I was very frustrated
with trying to learn lambda calculus.
I started messing around with it in JavaScript
because it was there,
and then eventually one thing led to another.
Here we are. We can make more complicated functions,
logic functions like and.
I hope that if you look at this
and you're a programmer, this makes sense.
Two values, you can determine
whether or not they are both true
by...
You look at the first one.
Is it true?
If it's true, you compare it to the second one.
Actually,
let me be clear here.
We have two functions, true and false.
True returns the first value,
false returns the second value.
If A
is a Boolean value,
true or false,
if it's true, it's going to return
whatever B is.
If it's false, it returns false right away
because it's in and.
If B is a true, then it's true.
If B is false, then the whole thing is false.
Does that make sense? That's why that looks like that.
I can do it on the board too.
I hate chalk.
The problem with lambda calculus is the notation.
From my understanding,
I see that basically,
when you see lambda x, it needs a function f.
In the first situation,
it picks two variables,
f of x, y.
In this case, it returns x.
In the second question, it picks f of x, y.
Then it returns y.
In the third case, it picks two arguments,
and it returns an and.
That's basically it.
Same thing.
It really isn't more complicated than that.
The notation is just
what is causing the confusion.
Here's the ultimate cop-out.
I didn't invent this notation.
It provides us a universal language
with which to speak about functions
and function application.
This is what functional programming is all about.
Literally, everything is a function.
You've heard everything is a function. What does that really mean?
Functions are values.
We're just saying lambda x dot lambda y to x
is true. It is the value true.
We're simply encoding truth
as that function.
Then we can do stuff with that function
to build up more complicated expressions.
There's an and, there's an or.
There's not.
Now we have booleans.
We're getting close to being able to do actual logic.
It's all functions.
I don't know how you feel about this inside your own head.
This was mind-blowing for me when I first learned about it.
Reducing expressions.
We can take an and and a true and a false.
If we put the lambdas back in, it looks like that.
Already it's starting to be headache-inducing.
I know.
The point is, and a true false is identical
to this expression.
It's easier for us as people to deal with and, true, false
than with all of this lambda stuff.
But you can actually still work this out on paper.
You can perform these reduction steps that I showed you.
Ultimately, there's the first step of the reduction.
Another step of the reduction.
Another step, another step.
By the way, the slides are all on GitHub,
so you can play with this later if you like.
Eventually, all of this reduces down to this function.
These are the reduction steps.
If you are plugging things in and replacing
your bound values in the expressions
at each step of the way,
finally you get to lambda x dot lambda y dot lambda y,
which we already know is false.
That's how it works. That's how you do a computation anyway
in lambda calculus. A very simple one.
I can, but why do you want me to?
I would just be writing.
I'm going to be honest with you.
I hate touching chalk and I am trying to avoid it.
But I would just be writing that again.
You want me to go through the whole thing?
No, that's not.
Totally, I will do it later.
Pen and paper, but it will take too long.
I only have two hours.
Yes. I'm just saying.
I'm just going to say that's true and that's false.
Just like truth and false in real life are arbitrary.
You came for the deep stuff today.
I know you want to look for some meaning,
but I showed you that first slide.
That's it. That's the whole language.
Those three things are the whole language.
I have to build the entire system of computation out of that,
out of just functions.
If I want to do Boolean operations,
I need some notion of truth and false.
If I want to do comparisons.
I just have to invent them.
I have to invent them in a way that they will work
and this happens to work.
It seems like a bit of magic and I guess it is.
You're saying that they're arbitrary,
but they're not arbitrary
in comparison to each other.
These are built up in such a way that
the system is logically consistent.
It developed out of the study of logic, in fact.
Formal logic.
Not stuff I know a whole lot about.
They're not random.
They're encodings that were decided upon
as part of a system that is internally coherent.
Wait till we get to numbers.
Now that we have some Booleans,
we can actually create useful functions.
Here's a function that determines whether or not a value is zero.
I've rearranged this presentation
since the last time I did some piece of it.
We don't have numbers yet.
Bear with me.
Let's say that x is a number.
This function will tell you whether or not
that number is zero.
This is maybe an easier way to look at it.
Is zero n.
Is zero n is going to return
a true or a false.
If it returns true,
I think I need to maybe explain this a little bit better.
This is zero n
is going to reduce down to a true or a false.
We know that true returns the first value
that it's given.
It's going to return true.
If it's not zero,
it will return false.
False returns the second value.
That's it.
We're applying true and false to this function
is zero n.
You're going to love it.
I think it's on the next slide.
I wanted to do predicates after a Boolean,
so the numbers are slightly out of order.
Bear with me.
Now we can have branching
in our lambda calculus.
An if statement is simply a function
that is a predicate.
A predicate is a function that returns true or false.
Then we apply to that two values
x and y.
If t is true, it will return the first value.
If it's false, it returns the second value.
What's the definition of zero?
You're saying is zero for a false.
What is the definition of zero?
We're going to get to that.
Very soon, imminently.
That would look like that.
If n is zero,
then you would do the value
in that then branch,
otherwise the else.
Actually, we can factor out
the p, the x, and the y.
We can just say that if it's the identity function.
It's the same thing, really,
because we're just dealing with predicates.
If you want to write it as a little law for yourself.
Expression one, expression two.
If p is true, then e1, else e2.
Everyone wants to do numbers.
I don't blame you because
how the heck do you do numbers with only functions?
This is really where the whole idea
of functions as values, I think,
is going to make sense.
I hope I'm going to drive this home for you.
Speaking of arbitrary,
we're going to call zero
a function that takes
an x and returns an x and does nothing to it.
Lambda f dot lambda x dot x.
We're just going to say that's zero.
That's a zero.
It's just an encoding, ultimately.
You can encode it in binary.
That's another way of encoding it.
Again, a convention.
This symbol represents some idea of zero.
We are so used to using it.
We think, well, that's zero.
That's five.
It's just a symbol.
There's one.
Lambda f dot lambda x dot f of x.
You're going to see a pattern very soon.
Now we're taking a function and a value,
and we're applying the function to the value one time.
There's two.
There's three.
You can probably guess what four looks like
and possibly 5,000 at this point.
Because what is a number?
If you're doing something with a number in computation,
you may just be storing a value,
but very likely you're probably going to be performing
some operation that number of times.
For any number n, you're going to do something n times.
That's all that this is doing.
Some number x,
if you want to do something
with the value three,
then you apply with a function.
You apply that function to the value three times.
Four, five.
It gets ridiculous.
By the way, again, this is not variable binding.
These are identical.
I'm just using this as a convenient symbol.
You could use poop emoji here too if you want.
I want you to be able to read this.
All of this stuff, I don't want to type that ever again.
Especially when they start to get really big.
I just attach convenient names to them
for my own benefit.
Enumeration, we can actually
work with these numbers and get somewhere with them.
There is a function that will tell you
what the next value is for a given value n.
This one is more complicated.
I don't want to divert too much into these things.
Again, I'm not meant to be teaching you a lambda calculus.
This is taking too long.
I just want to show you that you can do this kind of stuff
and that this is the basis of functional programming.
These are functional combinators
where all values are functions
and you can actually do computation
with just functions.
Pred is complicated
and it actually was kind of a discovery
at the time because they didn't know how to do it.
It will tell you the number.
Suck of two is one
and Pred of...
Suck of two is three and Pred of two is one.
That's what those are for.
There's a reduction.
You can write it out on paper if you don't believe me.
It totally works.
One is definitely two
and the number before one is definitely zero.
Those, they work. I tested these.
Now we can do some complicated arithmetic.
There's add and at this point
I'm going to start going a little faster
because the actual encodings don't particularly matter.
The fact that we can do them is what matters.
Different ways of doing add,
they both will give you the same result.
Subtract, multiplication,
exponent, which is delightfully simple.
Totally makes sense though
when you're doing a function
that gets applied a number of times
to another function that gets applied a number of times
now you have an exponent.
Here's a reduction.
If you add one and two together using functions
you get three.
You get a functional encoding of three.
Now if you're doing functional programming
you're not going to write all this lambda calculus garbage.
But this is the underlying
substrate you might say of the functional computation
and it ultimately gives you
the correct answer that you want.
Subtraction
is a little bit more tedious.
I mean tedious for me.
I'm so terrified of being wrong.
I sat down and wrote these out on paper.
I encourage you to do that
just to get an intuition for it.
Multiplication and exponentiation.
Look at that eight.
I think it's crazy.
All the parentheses.
This is really the hot stuff.
Raise your hand if you've heard of Y Combinator.
Like the company, right?
I hope you all end up.
Do I hope that you all know?
Anyway,
raise your hand if you've seen the Y Combinator.
This Y Combinator.
I don't know if you are aware of this
but the company Y Combinator
the name is based on this function.
This is how you perform recursion
in the untyped
lambda calculus.
I referred earlier to fixed point
combinators and this is a fixed point
combinator for functions.
For any function
that you give fixed
it will return that function again
and that is how you perform recursion.
For example,
everyone's favorite example, factorial.
Here's a function that will perform a factorial
but we need to do recursion to perform factorial.
We'll say factorial is
going to be a function
that is the fixed point of this function f.
We're going to pass f to our
fixed point comb. I didn't call it Y
because I want to be clear.
The fixed point combinator is a function
that when you give it a function
it will return that function again.
It actually embeds the function into the expression
in a way that you're going to see in a minute.
Honestly, the details aren't important
because you're not here to learn lambda calculus.
Honestly.
But I want you to get a sense for it, an intuition.
We're going to take the function f
and we're going to pass it to the fixed point combinator.
It looks like that.
That's what we get in the first reduction step
F is now embedded into the recursion
and that's how we can perform
a factorial operation.
That's again
and it looks like that and it will keep doing that
until we're done, until we reach our base case.
The base case
the is0
end part.
Without the base case it doesn't stop
and it lets a lot of writing.
I'm going to walk you
through the recursion step by step.
I don't expect you to
This is mostly for entertainment. This is what it looks like when you write this out, right?
So we're going to calculate now the factorial of two, step by step, and we're doing beta reduction right now.
It's just text substitution. We're putting values into functions. I'm actually cheating a little bit
because I'm not expanding all the lambda expressions, because I know that whether or not a number is zero,
so I'm just doing this in my own head, but this is an accurate representation of the reduction, right?
At each step, it's almost legible, right? Even if you don't know lambda calculus, you know a little bit of programming maybe.
You can see how this would work to calculate a factorial, and I end up with that, and I know that two times one is two.
I can do anything now, right?
I have numbers, I have recursion, I have branching. I can calculate anything.
You wouldn't want to calculate anything in lambda calculus like this, but you could, in principle, you could.
So is this driving one important thing? The first step of looking at the number of times it's getting substitutions in the building,
or the first step of getting substitutions to build this whole thing out, and then the next step of evaluation, trying to figure it all down?
Well, I mean, not exactly.
Okay, maybe the point is abstraction, right, because I don't want to write lambda expressions,
but I want to be able to trust that this stuff is going to work without worrying about the notation.
When you get to a real programming language, then obviously you're not worrying about this.
This is sort of how functional programming works at some very primitive level. You might think of it that way.
Like, when you write programs, you're not writing stuff like this, but if you're working with pure functions, right, you don't worry about state,
then you know that when I write fact, I'm writing all that lambda stuff, and it will work the same every single time.
I would rather work with named functions because they're easier for me and named values than with long lambda expressions.
Does this have a very concrete implication in terms of what curing and other expressions I've got, why it's underlit and why I don't have it comfortable?
It's a freebie, like referential transparency, and that just means that when I was showing you earlier that these expressions,
triple equal sign, or this name, triple equal sign, this expression, that those are completely identical, right,
and you can do equational reasoning with these things, and trust that it's always going to work,
because there's no such thing as global state when you're writing stuff down on a piece of paper, like, where's the global state?
There's no memory. This is not a curing machine. It's just symbolic manipulation.
Okay, so I told you I cheated a little bit with this example.
Here's what the real thing looks like if you're working with just lambdas.
Can you even read this?
Well, if I blew it up, you can't read it anyway.
So this is the whole thing, and if you sat down and you worked this out with a pen and a piece of paper, like I did,
so that in the event that someone was in the audience and did this and found that I was wrong, I wouldn't be embarrassed.
It works. These are the reduction steps.
This is just factorial of two. If you did factorial of a higher number,
you get to the point where it will take you until the heat death of the universe to compute, probably,
but you can see how the reduction steps ultimately get you to the same answer.
There it is.
lambdaf.lambdax.f.f of x is two.
So now you know the factorial of two is two.
That is the entirety of the syntax of lambda calculus I want to talk about.
Are there any questions?
That's more than I want it to do, in fact.
You mentioned a lot of different pens.
When you're learning lambda calculus, do you recommend paper and pen?
Yeah, yeah. No, paper and pen.
It's easier.
How do you check yourself because there's no complication?
It's a good question. How do you check yourself?
I just did.
This is a proof, right? It works.
You can do it and make sure I did it right.
In lambda calculus, you know what three plus zero is in real life.
So you don't take three plus zero in lambda calculus.
Right.
I mean, I'm establishing a principle, essentially.
So, basically, in the white code, the difference between function and function
is so successful to write off the formula into the base case?
Yes.
If you have a base case.
If you don't, then it diverges forever.
It never converges on an answer.
Is it similar to a for loop or an iteratory programming language?
Similar to what?
Like a for loop, like a loop.
I mean, yeah.
I love comparisons to imperative programming constructs.
This is what it is.
This predates for loops.
I think. Pretty sure.
All right. Enough lambda calculus.
Now we're going to do JavaScript. Thank God, right?
Something everybody is familiar with.
So I hope that everybody...
Can everyone see that? Is that big enough?
No, not. OK.
Oops.
Oh, great.
How about that?
Or that? Is that good?
Yeah, my normal background is even lower contrast.
I thought maybe this would be easier.
No, not so much.
I can do dark...
This is slightly different, but almost exactly identical.
Let me see.
Why am I using BB at it?
Do you like this better?
Yeah, OK.
Hi.
Bigger?
Whatever. I don't care.
At this point, I hope you can all open up the file
and open up your Java...
I'm doing this in Chrome, and I tested it in Safari and Firefox.
I don't know off the top of my head how you open a JavaScript console
in Safari or Firefox.
Command-option-j in Chrome,
if you have the lambda.html page open.
Sorry, question?
Question?
OK, so now we're going to move more into more of a workshop format
because that was a little bit more explanation than I had wanted to do.
You have all of the functions that I've shown you and a lot of other stuff,
and what I want you to be able to do with now is really play with them in your browsers.
The point is, I don't want to lecture at you.
Here's what functional programming is all about.
I actually want you to use these functions and build computations with them
so you learn not only what functional programming is,
you develop this intuition that will allow you to explain it to others.
This sense, what does it mean when we say functions are values?
That is the whole point of what I did this for.
So type stuff in as I go through these things.
I'm just going to go through the code, essentially,
and I just want you to play with it in your browsers, see what you can come up with.
There are a couple of little exercises that you can do if you want.
I actually have never given these kinds of exercises for a group before,
so I don't know how that will go over, so we'll just find out.
So now we're in JavaScript, maybe you'll see the magic for real.
We're only going to use the anonymous arrow function to do everything.
So starting with operations, this is what I showed you,
alpha, beta, and eta conversion.
If you type these in, these are like a little toy proofs.
You know, they work. There's true.
Oh, I should note also this file has a bunch of helper functions
because we need to translate between JavaScript and lambdas,
otherwise we can't read anything.
For example, I can type in one, but it looks like that.
What you know is lambda f, lambda x, f of x.
We know that that's one, but good point.
How about that? Okay.
So here's our identity combinator, id equals x, returning x.
Assuming everybody is either familiar with JavaScript arrows syntax
or this is trivial enough that you can pick it up.
Here's our true and false. We already saw that.
A function that takes two values, x and y, and returns x is true
and the opposite is false.
And again, you can cut and paste these things to test them.
I have a two-bool function that you can, and true, false,
and returns false.
They work, thankfully.
At some point, you will probably be able to break this
because JavaScript isn't designed for deeply nested function calls,
so I wouldn't try calculating the factorial of, like, 10.
So here we have and, we have or, we have not, and play with this stuff.
Type it in, see what you can do.
Just become comfortable with it.
That's all I want you to do right now.
And true and true returns true, right?
And false, false returns false.
Actually, this probably won't work because these are just functions.
Oh, look, it works. How about that?
If I type in plus, any plus function, it looks the same,
but then the true and true works.
What do you mean?
Type in one plus one five.
Oh, you did like that?
No, no, with the constant for the name.
You did this? One five?
Correct. Change the second over to three.
It's going to look the same.
Oh, that's, yeah, that's.
But your true and true function does work, in fact?
Yeah. I don't know, I don't know why it does that.
That's just, you know, the way the Chrome console works.
It's just a situation.
Yeah.
It's a function function, but it's not.
Chrome's like, what are you doing?
No, it wasn't.
Yeah, so we have to, you can look at the utility functions.
They're at the bottom of the file.
I'm just for convenience, I'm converting back and forth
between these lambda expressions and primitive values.
Okay, so a little exercise.
Try to implement XOR, right?
I've given you and or not.
See if you can come up with XOR and what that would look like.
And when someone comes up with it, you know, raise your hand.
We don't need to take all day.
Anyone have a good XOR implementation?
Brad, this is exclusive or?
It's not, no, this, I'm not trying to trick you.
I think that's what I got, right?
You can test it.
I don't know if I've actually typed this in XOR.
Yeah, so, yeah, I haven't actually typed it in yet, so.
Yeah, I encourage you to test these things, too.
Prove it to yourself, right?
Don't believe me.
Or find mistakes.
There are a couple of little weird bugs.
Well, there's one that I can think of
that you probably won't encounter.
By and large, this works about 99%,
which is pretty good for JavaScript, right?
Here's branching.
Remember before I said that in principle,
the if-then-else statement you can write
is this function that takes a predicate, right?
A function that returns true or false.
And then two values, X or Y.
And if P is true, it returns X.
If it's false, it returns Y.
You can do this in JavaScript.
You can factor out the X, factor out the Y,
factor out the P, and it's just the same function as ID.
And now you can write, I don't know, if-then-else.
So if this is true, return true, if not return...
Maybe that'll work.
Yeah, that works.
Here are the natural numbers.
Here are some enumeration functions.
I can explain a little bit how predecessor works.
It essentially will take a pair of values,
a pair of zeros, and it will increment one of them up to the point.
So if you give it, let's say, a predecessor of five,
it'll increment one of those values to five,
and it will like skip one of the incrementations.
It will skip one of the increments, right?
You get five and four, and then it selects for the four.
That's something I could probably demonstrate at great length,
but it would take too long, and so I won't.
But I do have a reduction to show you on that.
Because this talk is for people who don't want to learn Lambda Calculus,
I don't care if you learn Lambda Calculus,
I just want you to get comfortable working with functions
so that you can understand their expressive power
and why we do functional programming.
We're building actually an entire programming language
within your JavaScript console right now.
I don't know if that's apparent.
You can start putting more complicated things together
with these primitives,
and ultimately, in principle, you can do anything.
I'm not saying that you should write programs out of these Lambdas.
This is more of a...
I'm really nervous right now because John said earlier
at the end of the keynote that these workshops
are meant to be teaching skills.
Much from doing that, yeah.
No, yeah.
Yeah, I'll try.
Let's see.
We'll say A equals...
I can apply true to the and function,
and I'll just get another function back.
Yeah.
It's in there. I closed over it.
It is.
But I haven't evaluated the function.
If I too-booled my little A function,
it gives me...
It doesn't know what I'm trying to do.
No meaning.
I've actually partially applied the true to my and,
so now I can apply the false.
We'll say B is A applied to false.
Now B is fully applied.
Now I can too-bool on the B.
Is that meaningful,
as far as reduction steps are concerned?
Let's see.
OK. No problem.
You're making me think on my feet.
It's good.
I can just type it in.
Right?
It's just a function, after all.
That's not special.
So this is...
This is and, right?
So I want to apply...
In fact, I'll even replace the false with...
I don't know. I've not done this before,
so why not do it the hard way?
That's my motto in life.
OK.
I'm actually going to get rid of the too-bool,
because it's going to confuse me for a moment.
I think that looks right.
I think that's the end function.
Right?
So now I can apply
like a true to it, for example.
But instead of applying the true,
let's just kill off
the X
and put it in there.
Let me start over,
because I'm going to confuse myself.
I'm glad we're doing this.
This is the point.
I don't care. It's helpful for me.
This is about...
This talks about me. It's not about you.
OK.
I actually might leave the false in,
because you get the idea,
and I don't want to waste time being confused.
OK, so there's the true.
We're going to apply this to true.
But instead of doing that,
we'll kill off that X
and we'll just stick it there.
We need some other Boolean value,
because we need two branches.
So let's say the other branch is false.
Right.
So now I kill off the Y
and now I have false.
OK.
But remember, true is also just a function.
It's a function X,
Y that returns X.
Right?
So then we have this false.
We take that
and kill off this X
and
then it's there.
Then we have another false
and we
apply that to Y
and then we're left with false.
You know, it's tricky,
because I'm just branching using Booleans.
I'm not branching using real expressions.
Maybe if I say,
you know, is 0, 1
true, otherwise false,
something like that.
Remember, everything is a function.
They tell you this in FP, but you don't really know what it means.
Then you just walk around going, everything is a function.
Functional programming is programming with functions.
No, it's not intuitive at all.
I don't think it's intuitive,
but once it becomes intuitive,
it's awesome, right?
Right, no.
You think I'm trying to trick you, right?
Programming, I must have embedded primitive values
into this somewhere, right?
I have not.
They're all just functions.
They're simply encoding what, like I'm a human being.
I'm going to say this is true.
The computer or the notation doesn't know what true means.
You know what, true and false are really bad names.
Names are hard, right?
This is not philosophy, it's just computation.
So I'm just trying to make decisions.
Is zero false?
Why?
No, really, I want to know.
Does JavaScript think zero is false?
I don't even remember.
That's reassuring.
It's not reassuring
that that's not a type error.
Actually, it should return
something like that probably.
Anyway.
What does double equals do?
Oh, man.
I don't know.
I don't know.
I don't know.
I don't know.
I don't know.
I don't know.
I don't know.
I don't know.
I don't know.
I don't know.
I don't know.
I don't know.
I don't know.
