Hello, and welcome to the MIT System Design and Management
Program.
Oh, shoot.
I didn't even meet myself.
Hi.
Hi.
Hi again.
Good morning, afternoon, or evening, whatever the case may be.
Welcome to the MIT System Design and Management Program.
System Thinking Webinar Series, my name is Lois Slavin.
I'm the communications director and the host for this session.
It gives us great pleasure to host Doug Dory today, and with that, I will turn it over
to him with just one note.
There will be time for Q&A within this hour.
If you have any questions, please enter them directly into the chat window and address
them to everyone.
I will read them aloud, and Professor Dory will then answer them.
Also, you will be sent a link to the recording of the webinar and to the presentation slides,
and with that, Professor Doug Dory.
Hello, everybody.
I'm going to talk about the maturation of model-based systems engineering and the focus
on OPM and C-SML.
OPM is going to be the ESO Conceptual Modeling Language Standard, and the C-SML is already
a standard.
As engineers, we know that any engineering discipline has their own language which they
express themselves.
For example, mechanical engineers have machine drawings, civil engineers have floor maps,
electronics engineers have their own set of drawings, and software engineers have models
such as UML.
How about and what about systems engineers?
What language do they speak?
It turns out that what is required is a graphical, maybe also textual, formal language for conveying
systems, architectures, and designs in a conceptual, straightforward, and clear, and unambiguous
way.
It turns out that systems engineers, as of a few years back, do have a couple of languages.
One of them is C-SML, Systems Modeling Language, which has been the standard of OMG Object Management
Group since 2007, and there is also Object Process Methodology, OPM, which is in the process
of becoming ISO standard since 2009.
There is also a book that was published in 2002, previous publications date back to 1995.
Why do we need conceptual modeling to begin with?
There are several good reasons.
One is that we want to construct a mental picture of the system we are aiming to build,
design, architect.
We want to anchor one's understanding in formalisms that can be visual and or textual.
The two things are required for dual-channel processing, that is, the brain processes
information both visually and verbally, and if we can do it in parallel, that is even
better.
We want to design systems using non-verbal means, graphical, visual, convert asset knowledge
to explicit one, because many people have their knowledge, but they don't express it
explicitly.
Of course, we want to communicate the concepts that we have in mind to others very clearly
and unambiguously.
One key concept or term for our discussion is ontology.
Ontology, for our purpose, let's define it as a set of concepts for describing a domain.
Domain can be industry, banking, military, healthcare, and systems within this domain.
This has been in use for quite a long time.
We define a universal ontology as a set of concepts for describing the universal systems
within it, which is domain-independent.
It is not geared towards any specific domain, therefore it is called universal.
What we want to really do is have ontological grounding of model-based systems engineering.
We want to have a justification of what building blocks we are going to use in our modeling
language, not just start using anything.
To this end, we will try to determine the minimal set of concepts, which is required
to model the universe and systems in it, and this will be our ontology, a minimal ontology
that is required and sufficient to describe the universe and systems in it.
In order to do it in an appealing and engaging way, what I'm going to do is start with a
series of questions as Socrates used to do 2,500 years ago, but since it's a webinar
and unfortunately I can't get your immediate answers, I will just wait a while and then
give the answer myself.
Of course, you will be able to ask questions later on.
The first fundamental question is what are the things that exist in the universe?
What do we call them?
The answer is objects are the things that exist or might exist.
We can think of them as things that might exist or exist in fact.
The next one is what are the things that happen in the universe?
The answer is that processes happen or might happen, but we have to also remember that
processes cannot happen in vacuum, they happen to something.
The follow-up question is what are the things to which processes happen?
The answer is that processes happen to objects.
The things that happen happen to the things that exist.
If this is so, what do processes do to objects?
The answer is that they transform.
Processes transform objects.
Next we can ask what does it mean to transform?
What does it mean for a process to transform an object?
Transforming of an object by a process means one of three possible things.
The process can create an object, the process can destroy or consume an object, and the
process can affect an object.
Creating, which is equivalent to generating and destroying, are quite straightforward.
But what does affecting mean?
What does it mean for a process to affect an object?
A process affects an object by changing its state.
Here we introduce, in addition to objects and processes, a certain term, which is state,
and objects, therefore, must be stateful.
In other words, they must have states.
We are talking about not just objects, but stateful objects and processes that transform
them.
Let's shift gears for a while and ask another key question that we will need to use later
on.
The two complementary aspects from which any system can be viewed.
Two important, two key aspects.
So the two key aspects are structure and behavior.
Structure is a static aspect.
It answers the question, what is the system made of?
What are the parts?
How are they related?
The second aspect, the complementary aspect, is the behavior.
It's the dynamic aspect.
It answers the question, how does the system change over time?
What happens to the system and to the objects in it?
In addition, there is a third aspect that is only relevant to a man-made system.
What is it?
Well, the function, or the utilitarian, the subjective aspect, answers the question, why
is the system built?
For whom?
Who is the beneficiary?
Who benefits from operating the system?
This question has meaning only in the context of man-made systems, but much less so in natural
occurring systems.
So what is the basic idea behind conceptual modeling?
We have the conceived reality as we sense it, we engage with the world through our senses,
and we conceive some view of the reality.
We see things, we hear things.
So here is an aircraft, airplane, a bus.
Here is a person feeling gas.
So the airplane is modeled by a symbol, a rectangle in which airplane or aircraft is
written.
A bus similarly is modeled by a symbol for the bus, an object.
So these are two objects.
The third one, however, is different.
We see something happening, not just an object existing, but we see a process.
Before this, let us see what the common between aircraft and buses.
So aircraft is a vehicle and bus is also a vehicle.
So we see that we can start, see how we can generalize things which is part of the conceptual
modeling, generalization, specialization is an important relation, structural relation
between things, be they objects or processes.
So now looking at this process, this thing, this process is modeled by an ellipse because
it's a process and not an object.
We call it gas feeling and it's a process and it affects, as you should recall, an object.
Any process must transform an object.
In our case, the transformation is effect and the gas feeling affects the car.
How does it affect the car?
It changes its state from being empty of gasoline to being full with gasoline.
And just as we did with the objects, we can generalize gas feeling as being a special
case of energy replenishing process.
If this was an electric car, we would charge it with electricity rather than filling gas
and that would be another kind or type of energy replenishing.
So we see that there is quite an analogy between objects and processes.
So just as objects can be generalized, so can processes be generalized.
So using graphical symbols, the model expresses relations between things that are objects and
processes.
These are things in our model and the relations among them.
Currently, the relations are simply written along the arrows, but they have, as we will
see, certain better symbols.
So I'm now going to introduce something new, which I call the object process theorem.
And this theorem states the following.
Stateful objects, processes and relations among them constitute a necessary and sufficient
universal ontology.
In other words, or a corollary to this, is that using stateful objects, processes and
relations among them, it is possible to model systems in various domains and at any level
of complexity.
So it's a pretty ambitious statement or theorem and I want to try to prove it now with you.
So there are two parts.
We say that it's necessary and sufficient.
So we have to show that stateful objects and processes, first, are necessary to specify
the two system aspects, because as we said, these are the two aspects, the structural
and the procedural aspects.
We need to be able to specify them.
So specifying the structural static system aspect requires stateful objects and relations
among them, because we want to show what is out there, what the system is made of.
In order to specify the procedural or dynamic system aspect, we need processes and relations
between them and the objects that they transform.
So it's necessary to have both stateful objects and processes as well as relations among them.
So we have the proof of the necessity.
Now we want to prove that they are sufficient.
So stateful objects and processes are sufficient to specify anything in any system.
Why is that correct?
Anything that exists can be specified in terms of stateful objects and relations among them.
Anything that happens to an object can be specified in terms of processes and relations
between these processes and the objects that they transform.
So sufficiency is also proven, and this is actually the end of the proof.
So what we take of this is that it is enough to model any system at any level of complexity
and in any domain using stateful objects and processes that transform them along with relations
among them.
So what are the keys to good conceptual modeling?
First of all, because objects and processes are key to modeling, we have to be able to
tell them apart.
Telling processes and objects apart is the first key to good conceptual modeling.
Then we want to model the objects and processes concurrently because the world is really such
that or systems are such that structure and behavior are tightly intertwined and trying
to separate them does not make a lot of sense, at least not in the beginning.
We want to see how the structure and behavior are connected to each other.
Then we want to be able to manage the complexity of systems.
Systems are inherently complex, and we do this through abstraction and refinement mechanisms.
Finally, if possible, we want to utilize dual channel processing in order to take advantage
of our brain processing capabilities of both graphics and text concurrently.
Several years ago, Jeff Estefan in 2008 published as part of the InCoset Task Force a survey
of the leading model-based systems engineering methodologies, and there were six of them.
You can see the list here, two of them are from IBM, telelogic, rational, there is InCoset
object-oriented systems engineering method, Vitec, JPL state analysis, and OPM was also
one of them.
Some of you might wonder why SysML was not surveyed, and the answer is that SysML is
a language, but it is not a methodology, so it is not included in this survey.
In OPM, in object process methodology, we talk about things which are categorized into
objects, stateful objects, and processes that transform the objects.
These are the symbols, as we've seen them.
An object is defined as a thing that exists or might exist physically or informatically,
and the process is a thing that transforms one or more objects.
It transforms means either generates or consumes or affects, changes the state of an object.
Here is how this is expressed both graphically and textually.
Processes transform objects by one option is consuming them.
Here is an example of a process manufacturing, which consumes raw material as it operates.
The sentence that we see at the bottom is automatically generated by software called
OpCAD, which anyone can download for free.
I'm going to give you the link soon.
Sure.
They call it VRHouse.
It's clear in Python that type of thing.
What score do they usually want?
The second way.
Yes, VRHouse Python.
If I look at the rest, this is kind of your theory, but score.
Every floor has it, because they told me when I was a kid, we had some VRHouse items that
were interlocked.
Excuse me.
Please make sure you're muting yourselves.
We hear a woman.
Hello.
Okay.
Well, that's what you know.
I remember that the back of the window, like, you know, I wouldn't say it's a clean
air.
You have to step back two years or ladies, whatever.
Sorry about that.
The back of the window.
The window.
And I remember.
So what's on the edge more than, well, what are you labeled in any way?
So what's on the edge more than, well, what are you labeled in any score?
What does that mean?
What does that mean?
Okay.
I'll try to continue.
Okay.
Thank you, honey.
Right here.
Okay.
Hopefully this will not happen again.
So second way of transforming processes by objects is creating them.
So here we see manufacturing creating the product.
So, so you see another sentence was added here, manufacturing yields product.
And that's the same arrow, except it goes from the process to the object.
The previous one went from the object to the process.
And the third option for processes to transform objects is by changing the state.
So in this example, we have a process, a testing which changes products from a state of being
pre-tested to a state of being tested.
And that translates to a couple of sentences.
Product can be pre-tested or tested.
And testing, the process changes products.
The object from pre-tested to tested.
Again, all of these sentences are generated automatically on the fly in response to the
input by the modeler, by the system architect or designer.
So, again, the two things that OPM has or deals or uses for modeling are objects and
processes and all the rest are relations between things.
For example, these pair of arrows are called input output link pair from the input state
pre-tested, in this case, to the output state testing.
So I want to show you a more realistic system.
We all have experience with baggage handling, and sometimes it also gets lost.
So here is a model of baggage handling, which is the main process that you see in this diagram.
And we see the objects revolving around it, which are the passenger, the baggage,
the baggage location, which is an attribute of the baggage, the airport, and the airline.
These are the major objects that are involved in this process.
So the system's function is really this main process in the system diagram, the top-level
diagram, which is this one.
This, by the way, is the graphic user interface of OpCAD, the software that I mentioned.
And one of the guidelines in the OPM methodology is to start the modeling with depicting the
function of the system, what the system does to benefit one or more users, beneficiaries.
So in this case, it's baggage handling.
Processes should end with ING to give the feeling of something happening.
The beneficiary in this case is the passenger and the operand, the thing that the baggage
handling operates on is the baggage.
The attribute of the baggage is the location, which needs to be changed from origin, the
original, the initial state to the destination, the final state.
All this is expressed textually here at the bottom with what we call object process language
or OPL for short.
These are the attribute values origin and destination.
This whole thing is called the object process diagram, or OPD for short, and the text at
the bottom is object process language or OPL, which, as I said, is generated automatically
on the fly to interpret textually what is expressed by the model graphically at the top.
On the left, you can see a hierarchy of object process diagrams because now that we have
modeled the top level and we see what the system is all about and what its main function is,
we can elaborate by zooming into the baggage handling and show that it is comprised of lower
level processes.
I can show it to you later on as we go if we have time.
One thing that OPN does is to unify the three aspects that we mentioned, the functional
aspect, why the system is built, what is the utility who benefits from it, the structure
of the system, what is the system made of, and the behavior of the system, the dynamic
aspect talking about how the system changes over time.
These three aspects are expressed b-modally, that is, both in graphics and equivalent text,
that is generated automatically, all in a single model.
We don't need to have several types of diagrams.
It's always object process diagrams at different levels of depth.
Here we zoom into the baggage handling which was only a single ellipse in the previous
top level diagram.
Here we see sub-processes of these baggage handling processes which are origin, baggage
handling destination, baggage handling, baggage claiming, and lost and found baggage handling.
They are arranged from top to bottom vertically in the order that they happen.
This is the timeline which goes from the top of the in-zoom process ellipse to its bottom.
This is how time can be managed in an OPM model.
Again, around we see the objects that are involved.
Airports specializes into origin airport and destination airport.
The airline is comprised, among other things, of lost and found desk which is engaged in
the lost and found baggage handling.
The baggage has a location which, in addition to having the states of origin and destination,
now we can see that it also can be aboard the aircraft or someplace else which we don't
want to have, but this happened.
This is, for example, a condition for having the lost and found baggage handling sub-process
execute.
We've talked about the universality of the object process ontology, or in other words,
the claim which I hope proved that stateful objects and processes are sufficient for
modeling complex systems in any domain and at any level of complexity.
In order to support this empirically, I want to show you something from a totally different
domain which is molecular biology.
Baggage handling and molecular biology have in common the fact that they can both be
modeled using stateful objects and processes.
A little digression to molecular biology, we all know that biological systems or organisms
are highly complex.
They have organs that are made of cells and each cell has many, many thousands of biological
pathways, each comprised of many hundreds or thousands of biological reactions and all
this is happening in a tiny cell which is a whole world in its own.
Many, many thousands of researchers in biology are trying to unravel these mechanisms and
this is what molecular biology is all about.
We have a couple of years ago, actually more than that, some five years ago we started with
the idea that OPM can be very effective in modeling biological systems and collaborating
with Professor Mordechai Hoder from the Faculty of Medicine and Judith Somek who just finished
graduating and has a PhD around this subject.
We have developed conceptual model-based systems biology approach in which we use OPM to
model complex biological systems and what we did in this particular work is to look at
a set of about 40 papers related to the messenger RNA transcription cycle and we modeled it
in a very detailed level.
Excuse me.
Okay.
Oh, maybe I think I, by mistake I clicked, I clicked and I got to, yeah, this is the link
that's where I get, okay, I think I'm okay now.
Actually, click, okay, I know what I need to do, just go there.
Okay.
So in conceptual model-based systems biology, we start with research papers and experimental
findings that we can find in the literature which most of all of it is actually currently online
and we construct a conceptual model which looks something like this.
This is one of many, could be tens or hundreds of object process diagrams that are interrelated
and have the object which are molecules of various types and sizes and molecular complexes such as genes
and all kinds of hormones and anything that is involved in these processes.
And because the in silico computational model which represents the experimental knowledge
which is gathered from natural language papers that are available online.
We have the ability which I haven't mentioned yet to execute to stimulate the model.
So we don't only look at a static model of objects and processes and relations among them.
We have the ability and this is a screenshot of the simulation of this particular object process diagram.
What we see here is that the process called via denulation, the one at the top is currently executing
and is changing the states which are the brown ones of particular objects from one state to another.
The next process to be executed will be this one and then this one and then we will move to another.
On the left you can see some small part of the hierarchy of the object process diagrams that are part of this system.
And then having done the simulation, executing the simulation, we can compare the outcomes of this simulation
with the experimental findings that we can find in the literature.
Obviously there will be knowledge gaps because not everything is known at least in the system that we have been working on.
And so by modeling we stumble upon knowledge gaps that we can at least determine what they are.
And so we verify that the in silico computer simulations are compatible with the experimental results
and when they are not we define knowledge gaps and what needs to be done in order to close these gaps.
So this is a research cycle that goes on and the next stage is that we add new biological conjecture, one or more.
Maybe one at a time is a better approach.
And so we do some perturbation of the model according to what we think might be the case.
And again execute the model and check the results experimentally in vivo, in vitro, wet lab experiments.
This is the part of the biologists in order to verify that the result according to the conjecture really is in line with the findings in the lab.
If so, that is a very good indication that our conjecture is indeed true.
In reality what our experience has been that it is not enough to have just one...
It's a very long iterative process of refining the model further and further in order for it to meet when executed the biological findings.
But so it's an interplay between the in silico and the in vivo, in vitro experimentation in order to get them all in sync.
So we evaluate the conjecture, we find knowledge gap, we design and do new wet lab experiments and we iterate this until we have all of the facts in line.
And that's what there is another paper that has been accepted, will be published soon, which is a follow-up on the paper that I showed you.
So as I mentioned already, OPM has since 2009 been in the process of becoming an ISO standard.
So Paris, France in 2009 was the first meeting of the ISO group that in which the study group was established to explore OPM for modeling standards.
And then there was a meeting in Tokyo and in Florida in 2012 and in Israel in 2012 in Haifa, Frankfurt, Germany last year.
And this year, just last month, in Beijing, China, the resolution was to submit the draft as a PIS, publicly available specification.
And this is a major step toward becoming an ISO standard.
So it's now being voted.
Okay, I have mentioned CISML as the current standard of OMG and indeed a comparison of the key features of CISML and OPM is in order.
So one prominent difference is the number of diagram kinds.
I already mentioned that OPM has just one kind of diagram, which is object process diagram.
CISML has nine types of diagrams.
About half of them are structural and the other half is procedural.
CISML is graphical, so the modality is graphics.
OPM, as I have shown, has graphics and text modalities, so it's bimodal.
The theoretical foundation of CISML is UML.
In fact, CISML is defined as a profile of UML with some extensions.
And OPM is built on the foundations that I discussed earlier, which is a minimal universal ontology of stateful objects and processes that transform them.
However, we felt that it might be valuable to look for synergies and value of combining OPM and CISML.
So in a work done and published in 2011 in Systems Engineering Journal,
we developed an algorithm in supporting software to implement conversion or generation of CISML views of the different diagram types from the single OPM model.
And we evaluated the results through an experiment with students, 78 students,
the quality of the automatically generated diagrams, the CISML diagrams,
and how they impact the comprehension of the systems that are modeled with them.
So the result, which I will elaborate soon, is that the addition of certain auto-generated CISML views to the OPM system model
increased the comprehension of the system by the students.
There is a challenge of mapping OPM to CISML because the mapping is one-to-many.
So as a prominent example, a process in OPM can be mapped in CISML to a use case,
in a use case diagram to an operation of a block, in a block definition diagram,
to action in an activity diagram to state transition trigger or activity inside the state,
in state machine diagram, or as a message in a sequence diagram.
So all these concepts are actually some variation of a process with nuances,
and indeed the challenge is to make this transition to make sense as much as possible.
So we did this, and here is a couple of examples.
This is an object process diagram of some level at the ABS breaking system,
which is in zoomed, and we want to show a use case example.
So this is what we get from the conversion.
Here is the driver, which is here too, and there is an ABS breaking use case,
which includes the breaking, which you can see here.
Here is an example of converting another object process diagram from the same system
to an activity diagram. This is the resulting activity diagram.
Again, you can see signal converting is the sub-process here.
It is here, and signal processing is here, and so on.
Here you have a decision point, which is equivalent to what is happening here.
And finally, an example of a state machine from another OPD.
We have states of an order, which is ordered, paid, and supplied,
and you can see here the order is ordered, paid, and supplied.
So this is the focus on states, so obviously it has only states and some processes on the transitions.
So the evaluation of our experiment with the 78 students,
what we examined is the comprehension of the system modeled in OPM,
with and without the addition of the automatically generated system and diagrams,
and we also wanted to find whether there were any errors and inconsistency,
because this was the first time that we used this conversion system.
So we used two systems, divided the students into two groups.
There was a dishwasher system and a city scanner,
and you can see how the layout of the experiment was.
One group got OPM only of the dishwasher and OPM plus system of the city scanner and vice versa,
and this cancelled any possible biases and learning that might interfere with the results.
We asked them eight comprehension questions and we also asked them to find errors
and inconsistencies among the different diagrams.
And here you can see the results, which clearly and unambiguously in a significant way
show that there is an improvement between the scores for those who use the OPM only model
and those who got the enhancement with the system model,
the system model views that were automatically generated from the OPM.
So no human added information to the system model.
Still you see that there is a very significant improvement in the scores of the students
who had the opportunity or were provided with the system model interpretation of the OPM model.
The conversion was good because we didn't find true positive errors
or inconsistencies between the OPM model and the system model.
Moreover, we asked the students to say whether the system diagrams helped them
and indeed the 74%, 58 of those 78, indicated that it did help them
and we even have a breakdown by the types of diagrams.
So block definition diagram was the most helpful.
46, 47% and state machine and activity almost the same because it makes sense
because they're really pretty similar and the news case was the least helpful.
So to summarize the comparison, in this study we have seen that OPM and system model
take different approaches in realizing the goal of general purpose systems.
Conceptual modeling, OPM was especially good for idea generation
and rapid prototyping at the early architecting and design stages
whereas system is more appropriate when detailed views are required
and this happens usually during later stages of the detailed design.
So we see that each language has benefits and drawbacks
and neither is by all means better than the other.
So there is a large potential for synergy in using both a language in some combination
and this study can give hints or directions as to how this should be done.
Okay, so I'd like to go to the more general summary before we have the Q&A session
and so the takeouts that I would really be happy if you could take with you
are first of all the stateful objects, processes that transform them and relations among them.
These three things constitute a universal ontology
and that means that we can use them to model systems in a variety of domains
maybe even in any domain and OPM uses exactly this ontology
and therefore it is fit for modeling complex systems in a large variety of domains
and at any level of complexity.
Also using both graphics and text the B model presentation appeals
to what we call quote-unquote both sides of the brain.
The visual channel and the verbal auditory channel
they complement each other.
Some people are better than others in one and others are better in the other.
So each one can find whatever is best for him and complement with the other modality.
OPM is in the process of becoming ISO standard.
It's got a number, 19,450.
CISML has been the OMG standard for systems engineering since 2007
and what we saw an indication of in the experiment is that using OPM
in the early system architecting stages and CISML at later stages
can in a synergistic manner improve modeling quality and the comprehension of systems
and therefore this is something that should really be looked in very seriously.
Some resources, there is this book with a link to it
and it's also a website of our enterprise systems modeling laboratory
where you can find papers, software to download, presentations, projects and many other things
that are related to OPM.
Thank you very much.
We have a number of questions here.
The first is two part and it is by Sebastian Herzig.
The first part is you mentioned that stateful objects, processes and relations
are sufficient and necessary to describe systems.
Is there a base set of relationships such as some sort of a base vocabulary
or are these very much domain specific?
Okay, thank you. This is an excellent question.
Yes, there is a basic set of what we call fundamental structural relations
and procedural relations, the structural relations that are deemed fundamental
and this is also part of the standard that is found in the book.
Aggregation participation or in simpler words, whole part relation.
Then there is a generalization specialization or the easy relation
as it is perhaps more known for which is a relation between a general thing
and a specific thing that inherits from it.
And then there is a classification instantiation relation,
the relation between a class of things which can be an object or a process
and instances of that thing and exhibition characterization relation
which is a relation between a thing and its features.
Features are attributes and operations that characterize that thing.
So these are structural relations.
We also have a general relation which can be user defined.
As far as procedural relations go, we have, as you saw already,
we have seen generation or result link which is the graphical expression
of the result relation, the consumption relation between an object and a process
and there is a state transition relation.
These are the main ones.
We have also conditional and event relations
but these are more advanced concepts that I didn't have time to even mention here.
The next question from Sebastian is, can and if so, how are constraints
or generally requirements captured in OPM?
Yes. Okay. Again, a very good question.
One of the really nice features about OPM is that using this approach and methodology,
you can start with a requirements model that is not just a bunch of textual requirements
that have number and title and text but you can using either the requirement,
textual requirement document or starting right away by modeling hand with hand
or shoulder to shoulder width between the customer and the provider
to have a solution neutral requirements model of what the system is supposed to be doing.
And then that will be the basis for elaborating it by one or more options
which will be solution specific and then you can also compare the alternatives
by various means and select the best alternative and continue with detailed modeling
with that alternative.
The next questions are from John Clark.
First is a statement, function and behavior are the same thing.
Second is the baddest would enter the originating airport
and arrive at the destination airport correct.
And third, a human body is a non-man-made system, right?
Okay, so even though the first statement is declared as a statement,
I want to argue with it.
I know that many people confuse or mix behavior with function.
Function and behavior are not exactly the same.
They are similar because most of the time function is associated with behavior
but function, at least the way I view it and I define it,
is something that brings value to some user, to some beneficiary
whereas behavior is just a neutral concept of something changes being generated or consumed.
And this is how we define the difference between function and behavior.
Indeed, most of the functions entails some behavior of the system
but not any behavior as a functional objective.
What was the second one?
Okay, there was.
Sorry, one to the next question.
The baggage would enter the originating airport
and arrive at the destination airport correct.
And then the...
Yeah, well, the origin, the objective is to change the state of the location
baggage from the origin airport to the destination airport
but what we really are interested here is not just the sunny day scenario
but mostly what happens when things go wrong for some reason.
And we have a very detailed model of what happens to the baggage
when it is not routed the way it should be.
Sir?
A human body is a non-man-made system, correct?
Right.
Okay.
That's about it.
Is that a question or...?
Okay, what is the next one?
Okay, from Mark Ulié,
how would you handle the time aspect and description of concurrent,
i.e. non-sequential, processes?
So as I mentioned, the timeline in an OPM diagram
goes from the top of the diagram to the bottom
when you look inside an in-zoom process.
So if you want to express two or more processes or sub-processes
that have to start concurrently,
you simply draw them more or less at the same height
and the system, the software understands even with some leeway
that they should start concurrently.
Okay, next question from John Clark again.
OPM is an abstraction of cis-ML, correct?
Not quite.
What I've shown is that OPM has been...
First of all, the origins of OPM, as I mentioned, are in 1993
and the first paper was published in 1995.
That is at least a decade or more before cis-ML or even UML were conceived.
And an OPM is founded on ontological notions of stateful objects
and processes that transform them.
It comes from a different angle or train of thought than cis-ML.
Cis-ML is the way that cis-ML was conceived
is to build upon the achievement of UML as a software modeling language
and tweaking it and converting it into a language
that would be applicable and usable for general systems
rather than software systems.
So it's a totally different approach.
Okay, from Daniel Yao.
Did you also test the students on cis-ML diagrams with no OPM model?
That's exactly what my wife told me yesterday
that they should have done in this experiment.
We didn't do this.
This is something left to be done.
Okay.
From John Clark again, is cis-ML...
cis-ML helps the understanding of OPM.
Why do we need OPM?
What does OPM add?
Okay, so OPM, like I said, is very easy to learn.
It's very easy to understand.
You can start modeling within 30 minutes of being exposed to it.
Whereas in cis-ML and UML, for that matter,
you have to really spend a lot of time
and the learning curve is long and much more tedious
in order to start being able to produce a meaningful model.
Moreover, there are very little, if any, guidelines with cis-ML
and UML of what diagram to start with,
when to move to another type of diagram,
when to return to this,
what types of diagram to use for what purposes
and how they are interconnected.
It's a much more heavy overload on the modeler's mind
to be able to keep...
to juggle with the different types of diagrams
and get a clear and intact,
complete picture, coherent picture of the system
with these many types of diagrams.
With OPM, it is much easier.
From Lars Olaf Kielström,
having spent a significant amount of time
both using cis-ML as well as ontology development,
I feel that this approach has benefits.
Based on works with ontology,
I was wondering if you have looked at the ideas foundation ontology.
The reason for the ideas question
is that several concepts discussed in this presentation
also appear as part of the ideas foundation.
I'm not familiar with the ideas foundation.
I'll be happy to look at it.
As you indicated, there are synergies or commonalities,
and I guess that would be beneficial.
From Jose Luis Fernandez,
what about constraints?
How do you deal with something similar to a cis-ML parametric diagram?
I didn't have time to mention it,
but you can specify quantities and constraints,
again, by using objects with values,
objects which are attributes of other objects or processes
with values, and constrain the behavior such that
only if some parameter is within certain values,
a process will happen.
That is all done using objects and stateful objects
and processes and links between them.
Jim, is the converter from OPM to cis-ML available in OpCat?
It's a separate module,
but we can try to make it available.
It was part of a research project.
This would be the last question.
There are several more, and I'd like to inform the audience
that there will be a follow-up email with links
to the webinar recording and the slides,
as well as to Professor Dory's email.
You can feel free to contact him directly
if you'd like to discuss anything you've heard here.
The last question is from Oswaldo Arias.
This is the OPM book available in digital format,
if so, on which websites?
Thanks for the question.
This particular book, although I asked for it,
at that time, a decade ago, it wasn't very customary,
but there is hopefully the next book.
Well, not hopefully.
I know that the next book includes a digital form.
When will that be coming out?
Hopefully in six months.
Excellent.
We'll be happy to send you a link to the website
where you can get a digital version after the book is available.
I'd like to thank everyone for attending.
I'd like to thank Professor Dory as well.
I have to say this has been one of the more popular webinars
in terms of questions from the audience.
It's wonderful to see people so engaged.
Our next webinar will be two weeks from today.
We have Mona Vernon, an SDM alum who works at Thompson Reuters,
who will be speaking.
The topic will be announced later this week.
And with that, thank you again for attending,
and thank you again, Professor Dory.
Thank you very much for your attention and interest.
I look forward to interacting with you.
Bye-bye.
Thank you.
