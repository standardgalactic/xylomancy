Hej alla! Det här är Pontus.
I dag ska jag försöka tryka Kobel.
Och det är för att det är att jag har sett mycket om Kobel
att vara, vad det kallar,
att vara fördelad nu i New Jersey eller sånt här.
Låt oss se vad Twitter säger.
Jag tror att jag har sett Kobel trenden.
Där. Låt oss bara klicka en av dessa.
Och Kobel.
Så det ser ut som att världen är i en djur nivå för att folk inte förstår Kobel.
Så förstås jag ska försöka trycka att förstå Kobel.
Kobel är en av de länge som jag har hört om hela mitt liv.
Men jag vet inte vad det ser ut som tillbaka.
Så jag tänkte att jag ska försöka trycka och lära lite Kobel nu
från absolut skratts.
Så i den här episodeen kommer du att se mig svåra.
Jag vet inte om det kan röra på Windows. Jag vet inte vad det gör.
Jag har verkligen ingen erfarenhet med det.
Så jag tror att vi ska börja och se vad som händer
när jag lär Kobel.
Kanske kan jag göra mycket människa från att lära detta.
Vem vet det? Så låt oss skriva en blank slag här.
Och börja med Kobel Windows.
Microfokus.com har aldrig varit där.
Det här ser ut som en bra tutorial.
Låt oss gå in här och se vad som händer.
Okej.
Det här ser ut som en klassisk.
Kanske är det lite.
Okej. Common business-oriented language.
Bra från 1959. Older än mig.
Vad vill jag säga här på webbsiden?
För att hjälpa dig att lära Kobel. Microfokus för att lära en range.
Okej. Vem är mikrofokus?
Per standard lärningsprakt.
Jag ska inte investera för mycket tid i något.
Jag ska försöka hitta ett gist av allt.
Okej. Det här ser ut som en typisk person.
Jag har skrivit det här. Detta är mycket text.
Kanske är det useless.
Kalla en Kobel-program.
Det är bättre än att vara kallad. Vad är det här?
Okej. Låt oss gå till det.
Hallå Wolfing. Det här är vad jag talar om.
Okej.
Den här tutorialen går tillbaka till stället för att skriva den första
hello Kobel-applikationen. Och demonstreras de basic
effekter av Visual Studio. Integrera det.
Jag måste använda Visual Studio.
Det här ska vara en lång episode.
Det är faktiskt... Jag kanske har det installat.
Vi ses i Th bikes 2017.
Hej hej hej hej hej hej hej hej hej hej hej hej hej hej hej.
Välkomna alla de kl commenting-st�terna, hej hej.
Jag skulle ha lagt oss allt vad hon glucose
En familjeenvironment som är märkare.
Detta är generellt.
Jag kan inte skicka en kådbål här, okej?
Låt oss se den här igen.
Windows 10 och senare, det är jag.
Från min Windows-test-stopp, klick start.
Visual Studio 2007. Jag gjorde det.
Om det här är första gången du har startat Visual Studio på din machine,
Detta är generellt.
Det är där vi är, bra.
Windows är öppna.
Jag tror att jag ska fortsätta.
Klick start.
Visual Studio här.
Generellt.
Jag ska dubbla checken.
Okej, det är inte exakt samma, men det är det som det betyder.
Låt mig resa i denna Windows-kåd.
Okej, jag vill inte skicka en kådbål.
Min avdelning har endat.
Okej, jag tror att den har endat i 2017.
Vad ska jag göra nu?
Okej, vad finns det här?
Okej, vad är det här?
Okej, jag ska skicka en kådbål i VS-kåd.
Okej, jag ska skicka en kådbål i VS-kåd.
Okej.
Det ser ut som att det inte supporterar en kådbål.
I alla fall i alla fall.
Jag tror att det inte är coolt.
Varför har den här pageen blivit kvar?
Det är inte en bra design.
Kanske kommer det.
Men jag vill bara börja.
Varför måste du använda Wisha Studio normal?
Kådbål plus back.
De här sakerna är så alien till mig.
Det är faktiskt ganska intressant.
Är det kanske ett virus?
Det kan bli så virus.
Kådbål, akrådbål, kådbål.
Vänta en minut.
Kådbål på Linux.
Den här webben vet inte.
Nån vill inte höra historien av en länge när de vill testa det.
Det ser ut som om det är nånting kvar.
Kådbål.
Låt oss titta på den här.
Det ser ut som Obuntu-fing.
Låt oss ha Obuntu-kådbål här.
Jag tror att jag måste resa lite.
Det är lätt att se.
Låt oss installera det.
Hoppsan.
Ja.
Låt oss se hur det går.
Jag ska fortsätta att läsa det här.
Det här ser ut som en kväll.
Det är en packagel.
Det här ser ut som en kväll.
Jag tror att vi inte behöver Visua Studio.
Låt oss se hur det går.
Och öppna Visua Studio kod.
Låt oss ha Workspace-folder.
Och...
Jag ska ha en folder kväll.
Hello world.
Jag har ett kväll i det.
Låt oss kalla det.
Det är en bra folder.
Det är en update.
Jag vet inte vad det är.
Låt oss se vad som händer.
Kådbål.
Kådbål.
Jag har ett kväll som kallar test.cbl.
En ny kväll.
Jag sätter den in.
Jag ska säga att det är test.cbl.
Låt oss se hur det går.txt.
Nej, tack.
Aha!
Marknaden har ett kväll som kan hjälpa med CBL-kväll.
Låt oss se vad vi kan göra.
Okej, väldigt bra.
Det här är den som vi hade upp på pjällshållet.
Varför är pjällshållet så svårt?
Okej.
Låt oss inte använda den.
Det var en bra led, så tack på pjällshållet.
Men det här är vad vi vill pusha.
BAM, install.
Det här är bara en kvällshållare.
Låt oss se hur det går och se om det är något som vi vill.
Utan plötsligt och med diagnostisker.
Låt oss se vad som händer.
Okej, bra.
Vi har kvällshållare.
Varför är de här linjerna i mitten?
Okej.
Kan jag röra mitt kvällprogram nu?
Låt oss gå in här.
Vi har installat alla saker från kvällshållare.
Låt oss gå in till den här formen som vi har skrivit och testat på CBL.
Var har vi de här sakerna?
Development.
Method.
Kvällshållare.
Det är det här.
Låt oss gå och se vad den här kvällshållaren förberederar.
Det förberederar en kvällshållare.
Det ser ut som om vi kan skriva kvällshållare.
Och då får vi en executable kvällshållare eller ett kvällshållare som är executable.
Låt oss titta på det här.
Kvällshållare.
Inputsfilen. Det ser ut som om vi har denna kvällshållaren.
Och vi skriver kvällshållare.
Minus x hello.kvällshållare.
Men vår kvällshållare är kvällshållare testat på CBL.
Jag tror att det verkar.
Kvällshållare.
Kvällshållare.
Kvällshållare.
Låt oss se vad det ser ut här.
Wow, många av de optionerna.
Kvällshållare.
Kvällshållare.
Kvällshållare.
Kvällshållare.
Kvällshållare.
Minus x testat på CBL.
Kvällshållare.
Kvällshållare.
Det ser ut som att det kommer att kompila till
kvällshållare.
Hello, om det heter hello.
Så vår kvällshållare är kvällshållare kvällshållare.
Syntax är klar.
Okej, det är inte även
kolumns.
Ja, det är en del.
Kolumns 7.
Det här ser inte bra ut.
1, 2, 3, 4, 5, 7.
Åh!
Det är där jag hittar de linjer som jag inte vet vad de är.
Jag frågar vad det betyder.
Det här var intressant.
Så apparently
allt är okej upp till här.
Och det är...
Nej, jag kan inte skriva F där.
Intressant.
Jag vet inte, jag vet inte om det är...
Är det...
Är det en kompila, inte en kompatibel
med den här tutorialen?
Vad är det här?
Har ni...
Vänta, vad är...
Vad är den första linjen här?
Hello, Kobi, är det från editorn?
Eller vad?
Nej, det här är...
Det här är det fulla programmet, eller?
Okej, det ser inte bra ut.
Vi har skrivit test.cbl, eller?
Vi har skrivit ciao.
Okej.
Okej, det är lite intressant som jag ska lära dig.
Men det är inte bra att vi inte kan gå pass den här stepen.
Vad kan det vara?
Okej.
Vi kan googla det här också.
Okej.
Vi kan googla det här också.
Ah.
Okej, det ser ut som om någon hade samma problem.
Ska vi gå vidare?
Okej, det är en simpla kovoprogram
som inte är kompileringen.
Ska någon säga vad som är rätt?
Okej, det är mig.
Nej, det är mig.
Nej, det är mig.
Det är inte bra. Okej, det är mig.
Ah, vad?
Seriöst.
Jag äter webbplatsen.
Ska vi gå vidare?
Jag har en verksamhet, det är mig.
Jag har tagit och installerat en kovoprogram
och öppnade kovoprogram till nya effekter.
Även i Valenicus F, column 7.
Okej, det är mig.
Identifikation division.
Ska vi se om det är vad vi hade.
Ja.
Vad är det som betyder?
Vi får prova.
Tryck den liten moden
med syntax från limerik.
Okej, jag vet inte.
Det är helt...
alien till mig.
Okej, limerik.
Det är något du vet
om när du skriver kovoprogram.
Och vad är moden exakt?
Låt oss...
Jag kommer bara att copy och pasta den.
Jag ser vad som händer.
Oh, det är så bra att känna
som en kompletare.
Äh...
Nej, det är exakt samma problem.
Låt oss se om det här är faktiskt
det file som jag väckte att vara.
Okej, ja.
Det här är det.
Det här är det exakt samma problem.
Låt oss se om det här är faktiskt
det file som jag väckte att vara.
Okej, ja.
Det här var vad jag pastade.
Och det här är syntaxet här.
Det här är det.
Åh, det är jävla jävla jävla jävla jävla.
Det här är jävla jävla jävla jävla jävla.
Ska jag sätta den här också?
Sourceformat 3.
Det kanske är det.
Vad vet jag?
Jag vet inte.
Låt oss se vad som händer.
Okej, intressant.
Det händer.
Det händer.
Vi har en exakt här.
Varför inte testa det?
Vi ska exaktera testen.
Välkommen.
Välkommen.
Jag vet inte vad programet gör, men
jag kommer att veta den första.
Välkommen.
Välkommen.
Välkommen.
Välkommen.
Den här 02.
Okej.
crire.
Jag vet att entrepenterna inte finns.
Vad kan det kunna bli?
Vi intuitiverar det.
Trans zdjęret.
Vi önskar en multipla för att dra några șigrar
Sar några av så奈 muut bettingvarare.
Jaha?
Du har säkert gjort det.
Den utgången var lite för önskt.
Jag inte väckte den ledningen 0.
Men...
Låt oss försöka nåt annat.
Och första nr.
Vad ska vi skicka?
3.
Och första nr. 12.
Vi ska se...
36, rätt.
Åh, det kan vara bara en digit.
Okej.
Så 3.
Och 9.
Det ska vara 27, tror jag.
Ja.
Du går i program.
Du är en bra program.
Okej.
Så det här var intressant.
Det här är något...
Alla vet att det är nån som har en kogelvård.
Att du måste skicka det på toppen, så att du får en...
väldigt...
annorlunda error.
Det ser ut som...
Det här personen har gjort något som är simulant.
Okej.
Jag kommer inte igen.
Som jag har stoppat att göra en lång tid.
Vi kan complaina om nån som inte vet en specifikt ting i en länge.
Men det här var intressant.
Det här känns som när jag var mängder och jag bara...
Vad...
Var är det här för?
Jag vet inte vad det här är för.
Varför gjorde jag det så?
Wow!
Det här satsar!
Men nu satsar jag.
Det känns bra.
Okej.
Låt gå tillbaka till ett tutorial.
Och se om vi kan skicka det.
Gå tillbaka till det nu när vi vet att det är...
Det här magic trick av Koboldworld.
Ehm...
Så vi kan göra math.
Det var ganska intressant.
Och nu ska vi se om vi kan...
print.
Tjao!
Det här är fint.
Italien är en bra plats.
Vi vill gå tillbaka till det.
Låt gå tillbaka till det.
Det har jobbat.
Just...
Du vet vad?
Det här...
Source format 3 är min favoritfing i Kobold.
Men jag är här i den mikrofokusetutorialen.
Och...
Jag ska fortsätta med den här.
För jag vet att jag nu remerterat vad det var så fint.
Ehm...
Jag...
Är det inte suppose att det ska bli en historiemenu?
Jag äter dem här någonstans?
Eller har de just removed det för att jag inte vill?
Okej, det gör så mycket sänd.
Tack Google...
...för att vara annorlunda.
Okej.
Jag tror att jag inte kan hitta den här page.
Så låt oss fortsätta med den här produktionen här.
Vi har löpt en kompilingprogram.
Och här är det...
...remenets...
...remenets av vad jag gjorde...
...när tidigare.
Låt oss klara det ut så att det blir bra.
Okej.
Jag har en sourcefilen.
Vi kan göra det.
För vi vet hur vi kompilerar.
Så jag ska skriva en sourcefilen kallad...
...Hello World C-Belt.
Just...
...säkra in line med den här tutorialen.
Jag kopplar det.
Jag skriver en ny file här.
Säkra den här...
...Hello World...
....C-Belt.
Okej, blann.
Jag pastar den här in.
Nej, det är inte vad jag pastar in.
Du kan ha lite skäl som problem att skriva när du skadar projektet.
Vi behöver inte göra det.
Men i kodet, vid den nya file...
...säkra in line med procederdivision.
Så...
...så vi har skrivit det inte med Visual Studio...
...när vi inte fick nåt...
...när vi fick skäl.
Så jag kopplar det från vår testfilen...
...till Hello World C-Belt.
Och...
...säkra den här...
...procederdivision.
Ops.
Det är här.
Så det ser ut som...
...det är två delar av den här sourcefilen.
En är den här...
...statementen.
Det är... jag tror att det beror på...
...det compiler...
...vad sourcefilen är förmattad...
...därför.
Ehm...
Åh, sourceformat 3.
Är det...
...det samme...
...som att använda den här?
Ehm...
...säkra den här och se om vi kan skriva den här.
Om vi kompilerar den här med X...
...kompilerar den här...
...kan vi ta fram...
...att ta fram den här som vi hade i början?
Men om jag tar fram dash 3...
Åh...
...det görs det.
Ehm...
...så det ser ut som...
...det här...
...och den här är det samme.
Okej, det är bra att veta.
Ehm...
Okej, bra att veta.
Jag vet inte vad det är...
...och vad är en nonfri format?
Ehm...
Jag vet aldrig.
Kanske får vi se om det.
Men vi får se om det.
Vi får se om det är en procederdivision...
...och sen...
...när vi...
...när vi kompilerar den här med X...
...det görs det.
Där går vi.
Ehm...
...det sker en ny del i fileen...
...och den kursen på positionen...
...rätt efter den grön marginen.
Jag tror inte att vi har den grön...
...den grön marginen.
Ehm...
...och vad är A-B-nätet?
Ehm...
...jag vet inte.
Ehm...
...men anyways, let's gå ner till nummer 6 här.
Tyck på kodet...
...och skriva en text i konsol.
Koppla den ut...
...och boom!
Kompila...
...och skriva.
Det sker.
Fantastiskt.
Jag ska faktiskt kombinera den kompilen...
...och skriva en steg med dubbel-ampersanser.
Så kan jag...
...pressa upp...
...och skriva den.
...och kombinera den samtidigt.
Ehm...
...ok, bildapplikation.
Vi kan göra det.
Run hello world...
...hello cobal world.
Vi har gjort det.
Okej, vad är det nästa?
Kontinue med den nästa tutorial.
Configura den hello cobal world-applikationen.
Ehm, okej.
Copybooks.
Okej, let's se vad det är.
Tutorial configuring the hello cobal world-applikation.
Cobal application often consists of cobal source files and of copybooks.
Files that include code that is copied into other programs.
That's the new concept to me.
Eller, at least, the name copybooks.
Copybooks might not be stored in the same location as the source files.
This tutorial demonstrates how to configure a project to locate any copybooks that are not in the product directory.
This is strange to me.
Why would this be the first thing you want to learn about?
But let's just continue.
You're now going to modify and configure a hello cobal world-applikation,
which you created in the tutorial hello cobal world-applikation,
to use a copybook,
which is an external to the project.
It still feels very strange to me that this is the second thing you do when you're learning cobal,
but who am I to judge?
This is what you're going to do as part of this tutorial.
Create a project in the same solution that only contains a copybook.
Move a part of the code from the hello world cobal program in the hello world.
And replace the original code and hello world cobal with a copy statement.
The changes you make to your project will cause some build issues.
Modify the project properties to add a path to the copybook
in file in order to resolve these build issues.
Okay.
I wonder what this is if you're not the vicious studio code.
Let's just try to figure that out.
Okay.
They want to create a console application that probably doesn't apply to us.
Okay, create a copybook.
Copybook practice solution, add new item.
Click copybook.
What is a copybook?
Okay.
Gonna create a new file called hello.cpy and click add.
This crazy file in the project opens it in the editor.
You know, going to add some code to the file from the hello cobal world project.
Okay, copy the following line from the file, pass it to the hello cobal.
Okay.
Let's try this, I guess.
I think we have one thing missing here that hello.cpy probably requires some scaffolding
before we can make it work.
So by scaffolding, I mean this part, the identification division, the procedure division.
But let's follow it blindly and see what problems we get.
So they want us to call it hello.cpy.
I am going to create a new file.
The first copy is a new file, paste that in, call it hello.cpy.
And that seems to be a cobal thing that it recognizes with Visual Studio.
So I just have this literally in that file.
And then I'm supposed to, what was it?
Run this copy hello.cpy to here.
Is that supposed to be like that?
Okay, let's see what happens.
Save my changes, I did that.
Noted the line for the copy statement in no world.cbl.
It's now underlined with the red wave line in the editor.
No, it's not.
But that's just because we're not using Visual Studio.
Okay.
This looks boring, this is not programming, this is product setup.
Interesting tutorial.
I want to compile this to see what happens.
What? No.
Did that actually work?
Looks like it did, right?
Let's just write something else to make sure that we're actually running what we think we're running.
Here we are.
So I guess that whole part was useless for us.
And this looks like an import statement to me.
Looks like a very flaky way to import something.
But whatever.
Okay.
But so we know what copybooks are, they are pretty boring and shit.
So let's continue debugging the HelloCobal world application.
Come on.
This is not fun.
I want to create a function of something.
Maybe that doesn't even exist in Cobal.
What do I know?
So add the following code on a new line immediately at the line for the...
Okay, I don't want to do that.
I don't want to debug right now.
Creating a native Cobal application.
Let's start something else.
Running unitest.
What the hell is this tutorial?
Here's all the boring things that also make the program do what you want to that you need to learn first.
I understand why I hate taking programming classes in school because they were exactly like this.
First we need to do understand everything perfectly before the program does anything.
And I was more like...
I'd rather do something first.
What else could you do here?
Data file editor.
I want to do something fun.
What is a native Cobal application then?
Now this website starts to work.
No, it works again.
Okay, visual Cobal.
Okay, we're back in from start.
I'm going to have to find something more fun.
Okay, micro focus.
What's focus?
Two micro for me.
Let's dump this.
Okay, we know how to write a Cobal program.
So let's start something else.
Cobal tutorial.
Add tutorials point.
React all the cookies.
Overview.
What can we get there?
History and evolution of Cobal.
Okay, environment setup.
Not really interested in that right now.
Okay, I know how to compile it.
What else can we do?
Program structure.
Gave a program, division, sections, paragraph, sentence and statements and characters.
Nice.
Okay.
Interesting.
This part here looks a little bit like assembler to me.
Specially with this move 10 to WSID.
Okay.
You can tell that this tutorial is written by somebody that hates the world.
Is this the code?
Environment division, input, output, section, file control, select, file, organization, sequential access.
This is interesting.
Am I gonna write a program like this today?
We'll see.
Okay, let me just do something funny now.
Damn you tutorial, you suck.
Okay.
Basic syntax.
Who is gonna remember this when you start learning something?
This is such a strange way to teach something.
Okay, now I know where it is.
Continue.
This is like watching a movie and first looking through all the cost to know which people exist in it.
That's not how you present information.
Okay.
This is not a tutorial.
Sorry.
This is a technical data sheet.
Okay, let's go back.
I give up.
What else could you find?
Maybe we can make Kobold porn.
Let's look at this guy.
What is he on to?
No.
I want to know Kobold.
Yeah.
Tech Rose.
I was pointed to an article that talked about US banks still using Kobold and actually training new people to learn Kobold and maintain these old legacy systems.
And I frequently get asked this about if Kobold is a good niche or not and whether you should learn it.
Spellbulldog mindset.
So I thought I'd give my opinion on this.
I read the article.
There's definitely some interesting things specialized in Kobold.
But you've got two things I would say that are going to be going against you in this.
One of them is boring.
Let's see what this has to offer.
Actually, the most fun so far was that program that calculated the multiplication.
Let's take a look at this instead.
To analyze it.
I'm going to paste that in in my hello world program.
And I'm just going to compile it and see if it works.
Three two.
Result is zero six zero six.
Okay.
You have data division.
Working storage section.
Let's see what happens if we remove data division.
Will the program crash?
Ja.
So I guess the data division is needed.
So I guess this is what they call a section or what was it?
Didn't we have an overview like that somewhere?
Let's assume it was section or paragraph or something.
No, this was a division and this was a section.
So this is basically the closure or like section or say the header for this.
So I guess it means that this.
I know it won't work, but.
Okay, that makes sense.
So the working storage section is basically reserving the memory.
That makes sense.
So zero one num one pick nine.
I think this is how you reserve.
Memory.
So let's alter this program.
To.
To.
To add three numbers together.
Just do the logical interpretation here.
Copy that line, name it num three.
And the first number one did it with no advancing.
Okay.
Third number num three.
Multi by by by num three giving result result is result.
Let's see if this works.
Syntax error unexpected by.
Okay, I can't do that.
I guess that means that multiply can only multiply two numbers.
Let's see what happens if we Google.
Cobalt.
Cobalt.
Multiplier.
Wow, these websites.
Lovely.
Okay, multiply statement multiplies numeric items format.
One literal.
One data item by data item to.
And.
Okay.
Can we multiply three things?
Without having an extra in between variable.
Let's see if we can.
I'm gonna experiment a little bit here.
So let's have result.
Let's call this in between.
And instead of giving it to the result here, we give it to in between.
Remove that statement.
Then we multiply num three by in between.
And giving it to results.
Can we compile this?
Okay, it compiled at least.
So we multiply two by three by four.
Yeah, that worked.
But this was a little bit annoying.
What happens?
Can we multiply in to the number one here?
I wonder if this will work.
Two, three, four.
That worked.
That means I overwrote one by this.
This is interesting.
I'm gonna rewrite the program to see if I can get away with just having the result and an input.
And the idea is that I always multiply the next input with the result and put it in to the result.
So first here I'm gonna accept input.
Is this a reserved word maybe?
Because I'm asking that because it's not white.
So okay, I can't write input.
So I'm gonna write number.
Num, num, num.
So I always write the user's input into the number variable.
And then directly after, I multiply it with the result and put it in the result.
There we go, there we go.
And then we end with printer a result.
Let's see how that works.
Two, three, four.
Hah, no.
I wonder why.
Accept num, a result, giving result.
It might be.
I think that we had this switch before.
I wonder if that has an effect.
Let's see.
Two, three, four.
No.
Okay, that makes a little bit sense.
So what made it work before when we had all these numbers?
I thought that this was the equivalent of what we did in the beginning.
Maybe we did actually overwrite it here, but it just happened to have the same effect.
Because num one was two.
I'm not sure.
So here num one would be two.
Num two would be three.
And we put that.
And that would be six here.
And then we do that.
I'm not sure what this display in accept us exactly.
It might not be possible to do what I was doing there.
Okay.
Let's not try that again.
Or should we?
It is quite funny.
Let's remove the in-between.
I'm basically just poking at the language now trying to figure out what it is like.
So that works.
Two, three, four.
It's 24.
And can I get away with not using num three?
Let's see.
No, we can definitely do that.
But let's use that.
And then we can see if we can reuse one.
Num one.
No, we wrote it to there.
So I want to write it into the result there.
Okay, now I'm not writing ideal code.
I'm just basically fooling around a little bit.
I lost track of what I was thinking there.
But I wanted to get down.
I just want to have, since I take one input, I multiply it with the result.
Take one input again.
Oh!
Result starts with zero.
So I can't obviously just multiply it in there.
In the beginning I need at least two numbers to do that.
So let's see if I can get away with two and still have three.
So that makes sense.
So we have to have at least two numbers.
They are non-zero.
Before we multiply.
And if we multiply it with one of them, there is zero.
It will always be zero, obviously.
So let's see if we multiply this into results.
Wait a minute.
I feel like we should be able to do this in a smart, clever way.
If the first one we put into the result.
Or what is it called in multiplication, the product?
And let's look up with what are parts of multiplication called?
What are parts of multiplication called?
There are the multipliers.
Recall that.
They are called factors.
So I'm going to have a factor and I'm going to have a product.
And the product is actually this one.
And then on the first input, we input it into the product.
Because one multiplied by one is always one.
Or one multiplied by itself.
The first number is always, that's a product, if only one number.
Then the second number we put in the factor.
And then we multiply the factor with the product, giving it a new product.
Then we overwrite the factor and we do this thing again.
Now I think we can run a program.
At least that's what I'm hoping for.
Result undefined.
We need to print the product.
Two, three, four.
Yes, that worked.
So now I understand this a little bit better.
But I would like to have a loop here.
So that we can enter how many numbers we should multiply.
Let's see if there is such a thing as a loop in Koval.
Loop statements.
Nice.
Perform through.
Perform through is used to execute a series of paragraphs
by giving the first and last paragraph names in the sequence.
After executing the last paragraph, the control is returned back.
Inline perform.
Statements inside a perform will be executed till and perform is reached.
Syntax.
The following syntax is a syntax of inline perform.
Okay.
Out of line perform.
Here a statement is executed in one paragraph.
And then the control is transferred to other paragraph or section.
Okay.
Perform paragraph one through paragraph two.
Okay, interesting.
They have a really interesting way of giving away execution context in this language.
Okay.
Perform display and perform.
Okay, this looks a little bit like what we want to do.
I guess these are paragraphs.
No.
A para is the first paragraph, I guess.
Perform display in a para.
And perform.
Perform see para through e-para.
I guess it just runs this, this and that.
Okay, this is interesting.
Okay, this looks more like something we should want to be doing.
Inperform until a paragraph executed until a given condition becomes true.
Sounds like a while loop.
Or a for loop.
With test before is a default condition.
And it indicates that condition is checked before the execution of statements in a paragraph.
Okay.
I think that I want to have two variables here.
One called step.
And one called steps.
I'm writing zero one here without knowing why.
But the idea is that I won't have a number count up until another number.
So imagine a for loop where we have i and length.
So step is going to be this one, pick nine.
I think that is a single digit number.
And the value of that...
I don't know, but I want to set it to zero and increment it.
So zero one and it's step last.
Let's call it step current.
To be even more clear about what I want to be doing.
Pick nine value zeroes.
But I want this step last to be...
Contain nine.
I guess before we continue too long here, we should probably see if we can put a number in step current.
Or step last.
Oh, I could ask how many numbers I want to multiply.
So let's add a statement here.
And say how many numbers should be...
Let's just ask how many numbers.
That's easier.
And we accept that in the step last.
Then let's just write out display.
Will multiply.
Can I write that numbers.
And the step last will be here.
Is that how you concatenate things.
Oh, three.
Oh, we'll multiply four numbers, that works.
Nice.
Okay, and we know the rest of the program works, but now how to use the for loop.
I think let's output also a step.
So I'm going to say enter and then the step current.
Enter number.
Step current.
And then slash off step last.
One digit with no advancing.
And see what happens.
Okay, good.
We are at step one there, but we call it zero because it's zero based.
Okay, interesting.
We had an extra line here, we don't need.
And I guess can we concatenate this immediately.
Can we add one to the step current here, like this in COBOL?
Let's try it out.
No, I cannot.
So let's see what should I do here.
Should I, the cheap way of doing that is to start the step at one.
Okay, let's see how I assign a variable in COBOL.
Assign variable in COBOL.
Okay, this is going to be interesting.
Okay, this is not, this is going to be too long, declaring data.
Actually, let's see, war loop in COBOL.
How, what we will learn from this loop statement.
Okay, perform times looks interesting too.
Let's look at perform times.
So I guess if you write this, perform a paragraph five times.
If we can replace this with our step last.
Then we should be able to run this.
So I guess we need to first paragraph the multiplication part.
So let's create a paragraph here.
Is that supposed to be in the procedure division?
Yes.
Will it always start with the first one?
Actually, let's run add a paragraph here.
See what happens.
So I, what happens if we just do this?
Will that mean that program just stops immediately?
Yes.
So I guess it always starts.
This looks probably like a go to statement.
Might that be so.
I think it is.
So I was thinking if I put this in, in a paragraph.
So I say this.
Set up para.
And it displays how many numbers.
And it accepts the step last.
And it says how many numbers we're going to accept.
Could I end a paragraph two somehow?
Stop run stops the entire program.
So I want to look for something.
That goes to set up para.
Immediately here.
Not sure this is a good way to write it.
But my thinking is that I want to have the entry point in the top.
And I want to set up the structure of the program.
So basically something like this.
Run set up para.
Then I want to do that thing that's called.
Perform something para five times.
So if imagine that this was called the calculation para.
I could remove this.
That's the idea at least.
And then I would say perform calculation para.
And I would say step last times.
So if we run this as many times as you inputted here.
And then in the end I would just say display result is product.
So this way we will start here.
We will set it up asking for the number.
We run this five times.
And then if we display the product.
So it looks like we're definitely missing here.
We have the stop run.
Which I'm not sure how it works.
And let's look a little bit more here and see if we can have some hints.
What does the stop run seems to be stopping the program completely I think.
I would like to learn more.
Oh!
Here we go.
So this means go to set up para.
And I'm going to call this the init para.
Even though I probably don't need a name here.
I think before we continue too long.
Let's just see if we got anything there.
Calculation para undefined.
But it is here.
Maybe.
No, I don't know at all.
What's going on?
I didn't expect that.
That's interesting.
Line 27.
Oh, this is not the definition.
It complains.
What does that mean?
Do I need to define the paragraphs?
In some other way.
This looks like the just write.
The paragraph.
And then here they go to be para.
They do say with a dot.
But we do that too there.
I can't really see the difference.
I have here.
Go to set up para.
What does this mean?
In paragraph set up para.
We had these two errors.
Is that what it means?
I think I made too many differences there.
In the same time.
Let's scroll this back.
Let's get the program back into a working state.
Let's do one thing at a time.
Or a somewhat working state at least.
Or one, two, three.
The program works.
But we don't have that number thing.
So what if we add a stop run here?
Okay, that's good.
But before the stop run, I want to jump down here.
I'm actually gonna use the exact same context they use here.
So they have a para and b para.
Not sure. I thought I could name this anything I want.
But let's add a para in the top here.
See what happens.
Okay, that didn't destroy anything.
So let's call this the b para.
Let's see if it was destroyed.
No.
But in the end let's go to...
Was that how it's called?
Sju.
So unconditional go to.
So in the end here I want to go to b para.
Ja.
Can I choose any name I want here?
Because I want to do this b to calculation para.
Calc para, we call it.
Because I'm not sure I'm allowed to call this whatever I want to.
Even though I thought so.
Ja, that seemed to work.
Can I call this init para?
As I wanted to. Or main para maybe.
Without breaking.
That seemed to work.
So if I now...
If I now...
This is the thing that stops it.
If I don't have this...
Will I be able to display something else here?
Will it jump back up here when it's done?
Let's try this out.
Woo! We call it.
Two numbers, one, two, three.
No. It just went down here and stopped.
So I can't jump back up without explicitly
Telling it to I guess.
Does that go for the perform too?
This looks like something we want.
I'm sure we're doing too much in the same time now.
But perform calc para.
Väring.
One until, from one by one until...
Okay, this looks like a for loop.
So I guess this will be step current.
From one by one until step current
Equals step last.
Okay.
Let's remove a bunch of bullshit here.
And see what happens.
I'm going to move this up here too.
I have no idea. It's probably breaking so many ways.
How many numbers? Three.
And the number one out of three.
One, two, three, four.
Hmm.
There was something going on here that kind of worked to be honest.
We don't need a second number.
But we do have a problem here.
That the first result needs to be stored in the previous one.
Or in the factor.
So how can I do that in for loop? I don't think I ever did that.
I don't want to write this with an if statement to be honest.
What if I could push all these numbers to an array?
Is that even a thing in Cobol?
Cobol.
Array.
I don't want to write this with an if statement to be honest.
What if I could push all these numbers to an array?
Is that even a thing in Cobol?
Array table concept.
This looks hard.
Okej.
I think maybe not that hard.
I'm very unused to this syntax.
But...
I'm not sure if I can write this right now
without being completely confused on every step of the way.
Let's see what this says.
Cobol arrays or tables.
Single dimensional arrays.
Alla data structures are used to simplify coding and improve processing efficiency.
The primary uses of arrays are to define a series of similar looking format.
I put an output.
Declaring an array. Arrays assault Cobol data items.
Must be declared in a data division.
But are distinguished from scaler unsubscripted data items by use of the occurs class
in their data definition.
Arrays may be declared for elementary or group data items
0,2 to 49.
To declare an array of elementary data items
use the class occurs int num times.
In the data item definition int num is any positive integer
specifying the number of elements in the array.
Daily temp 0,5. Temp occurs 25 times.
Pick 999.
Okej, I don't know what this first number means
but I think that is how to define it.
This looks more like something I am interested in.
What is this number?
Just like in the order it executes or something.
Just like in basic.
Okej, this looks interesting too.
So I am thinking that I should be able to get away
on with this.
So instead of factor I am going to have
factors.
And what is temp?
So I am thinking that I should be able to get away
on with this.
So instead of factor I am going to have
and what is temp?
What does it mean, temp here?
It occurs 25 times.
So I guess this is, we have two instances of temp
but why do we need daily temp?
Okej, this example here is an array named temp
that contains 24 elements, data items, each of
pick 999. So pick 999 I think is a number that has
three spots
that can contain up to number 9 in each of them.
And it's referenced like this, temp 1,
temp 24, okej.
Daily temp is not itself an array but the group data item
72 characters long.
24 times 3, okej.
So that's 24 there and the 3 bytes are basic I guess.
And in 0, 2 to 49 level data frame
can contain an occurs clause.
Så I guess the daily temp
we probably don't need it.
But I'm going to call it factors
and there is a dot there, right?
And I'm going to call this factor
but I need to be able to say
I need this to be variable
because I input the number
dynamical in my program
and I don't know how to do that yet.
I guess I could just take a rare high number
and fill it with the ones
but it is a little bit
dumb.
But I am pretty dumb when I write code
but I must admit.
So I'm not sure how to do this
in a way that I'm not going to get too confused.
Before I do too much maybe I should just try this out.
So let's put a 9 here.
Should I do this?
And put values 1.
Can I do that?
I have a ton of factors in the program
basically multipliers
and the rest of them is 1.
It doesn't matter if I multiply them all
in the end of the program I know
it's really really bad
but I also want to see if this works.
Let's compile this and see what happens.
I don't even know
if this is at all going to work.
The set of the compilation seems to work.
Let's do something more then.
We can remove the factor.
So now the program should probably break I hope.
No.
I'm not using my factor right now.
I guess
what I should do here
is accept this number into the factor
step current.
Eh...
Not sure if this works.
Let's display what we did too.
Stored
and then factor
step current.
3.
We will multiply 3 numbers.
2.
3.
4.
Wow!
That was actually almost working.
We have some of by one error here.
I think
can we have
put this like this, the current is
until it's less or equal.
Okej, let's solve this later.
They were off by one error.
But in the end here
I want to multiply all the factors.
Can we do that here maybe?
Perform until this.
It looks like until your number data
it can be used as a subscript.
I don't know what the subscript did.
It looks like we can
multiply things here.
I'm not sure.
I'm ready to do this just yet.
I first want to get a good concept
what this program does.
So let's remove
Let's print something out there
in the product. No.
Maybe it was easy to do
the thing we did before.
I guess if the first number is one.
Okej, I guess I can cheat
a little bit here.
If I store the first result as one
I don't need this array.
So I'm going to scroll back a little bit here.
I fake it.
So here now we have the factor
and the product.
And the product
is going to start that
by being one.
I think that is possible.
Then every time we accept
the number into the factor
we multiply the factor
with the product.
I think that should work.
Where is the multiplication
step?
Let's scroll back.
It should be here somewhere.
There we go.
I accepted the factor
and then we add the factor to the product.
If the product starts at one
then we go down here
and we accept the factor.
Then we store the factor
we multiply the factor by the product
into the product.
Then we do that again and again
for all
until we reach the step last.
I think we have something going here.
How many digits?
Five.
Enter
nummer 1 och 4, 2.
Enter nummer 2 och 4, 3.
Enter nummer 3 out of 4, 4.
Result is 24.
Wow!
A program kind of works
but it has an off by one error.
Let's fix that.
Then I think the first course in Kobold
is complete.
Might be the world's shittiest Kobold program
to be honest, but I'm pretty proud of myself still.
I only took almost two hours
to make a shitt program.
How to solve this off by one error?
I guess we could have
we need a minus somewhere.
Or
the step last.
Why is the step current?
I guess
if this was while
now that doesn't work.
Let's see what options we have here for looping.
Loop statements.
We have the perform
until
wasn't there something else?
Perform times is pretty interesting.
Hmm.
Let's try this.
Perform calc
step last
times.
2, 1
and 2.
Okay, that worked.
But we have to update the step current.
And I guess
we could do that
by just adding to step current here.
Add
1, 2, step current.
Let's try that out.
3, 1, 2, 3.
Ah, look at that, that worked.
Cobble is really good.
I have some fluency in Cobble now.
That was pretty satisfying.
Even though this whole program is quite silly.
I like it.
I feel accomplished today.
Let's see if there is anything we should clean up.
Let's change the author.
This method.
Yeah.
Example program using
perform.
We are using
accept.
And we are using
times.
Collect
a number of user
the finable integers.
Finable integers.
And
multiply them
with
low memory
footprint.
I can't write.
I'm having so much fun.
Low memory footprint.
And return the result.
No display it.
And display the result.
Data division.
Step current, step last.
Fantastic.
Okay.
Pretty nice, I must say.
Wait.
I need to upload this to
GitHub.
Ist.
Wacka the whack.
My first Cobble program.
Da, da, da.
We call it.
Calculate.
Like a bank.cbl.
There we go.
We are public.
Gonna leave this link in the subscription.
I mean in the description.
I kinda like it.
I'm
happy that you took time
and looked at how to learn Cobble.
The world is our oyster now.
Let's go get those banks
and get a fat paycheck
for the summer.
Alright. Thanks. See you later.
