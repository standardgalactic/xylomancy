But till this point, we have seen the language fundamentals of Python, right?
We have seen variables, how to pass a variable to a function, we have seen function, right?
How to define function, how to call a function, and then we moved towards module and now we
know how to create different files.
Now once we have talked about the language fundamentals, let's move towards the concepts.
Now one of the concept which is very important is, oops, which is object-oriented programming.
Now one of the unique selling point of Python, you know, why Python is so famous because
of this thing, Python supports all different programming parameters, you know, it supports
functional programming, it supports object-oriented programming, and it also works with procedure
oriented programming.
Now we have talked about procedure, right?
What is procedure now is, whenever you work with Python, we define functions, right?
We call a function from a function, so if you want to create a software, you will break
down your project into small, small part, and those modules, small modules will be functions.
Now Python is also functional programming, so functional programming basically means
if you can achieve a certain task, implementing functions as a mathematical functions where
you will not manipulate a data, which is, instead of changing data, you will still accomplish
a task.
One of the ways is you can pass a function to a function, you know, we have seen this,
again, we have a very deep concept of functional programming, we will talk about that later,
but time being, procedures and functions, which is something we have already done, for
example, lambdas.
Now we are going for a concept of, oops, now which is very famous in the industry,
you know, so if you are working on big softwares, enterprise projects, you need to think everything
in the format of objects.
Now you might be thinking why objects, we were happy with functions, right?
Now see, even from start itself, I was talking about objects, right, maybe in some programming
I said, okay, this is an object, integer is an object.
But then we were skipping that part, what is object and why it's so important?
See, ultimately, if we talk about programming world, what we do is we try to solve a real
world issue with the help of virtual world solution, right?
So example, programming, softwares, everything is virtual world.
Now in real world, we all use objects, for example, if I want to record this video, I
need a camera, right?
If I want to call someone, I need a phone, if you want to type a code, you need a laptop,
right?
So for everything, you need object.
So in real world, everything is object, in fact, persons, right?
If I have a company, if I want some work to be done, of course, I need employees, right?
And for me, every employee is an object, right?
So an employee object is using a laptop object.
So some employee object needs a AC object, right?
That's how things work.
Everything is an object.
Even humans, we treat them as object.
Now what object will have?
Object will have two things.
Every object will have certain attributes and every object will have certain behavior.
Now when I say attribute, you can imagine them as data or you can say properties.
Example, my height is one attribute, my age is one attribute, my name is one attribute.
The company I work for is one attribute, right?
Everything is those things that attribute.
And then comes my behavior.
I'm talking, I'm walking, I'm dancing.
All these are behavior, right?
So our actions defines our behavior.
And then we have attributes which we know.
In other terms, you can say as an object, I know something.
As an object, I do something, right?
So I do something based on something which I know, right?
So this is object.
Object will have something where you can store data and object will have some behavior.
Now this data which we normally use, those are variables, right?
We have same variables.
So if you want to store something in object, we need to define variables.
If you want to define the behavior, we need to use methods.
Oh, that's something new now.
What is method?
We have done with functions, right?
So functions in object-oriented programming, they're called as methods.
Right?
So it's so simple.
We have done all those stuff.
The only change we have now is we need to think in an object term.
See, object-oriented programming is not just about different syntax.
It's also about the way you think.
So now if you want to achieve anything in programming, you need to think about objects.
So the moment you say you have a complex problem, think about the object.
Think about multiple objects and how can you connect them, right?
Because in UPS, we have so many concepts.
One of the concept is object, which we are going to see now.
We have a concept of classes.
We have a concept of encapsulation, abstraction, polymorphism.
I know weird words, right?
But don't worry.
We will be covering everything in detail in the subsequent tutorials.
So there's one thing which is important to discuss here about classes, because we have
an object and we have a concept of class.
It doesn't matter which language you work on, maybe Java, C++, or C sharp, whichever
whatever language which uses UPS concept, you know, we always use this thing which is
object and class together.
But why?
Why they are so important?
Of course, objects are important because whatever you want to do can be done with the help of
object.
But why class is important?
Now think about this.
When you see an object in real world, for example, this camera, a fan, or a clock, right?
All these things are manufactured, right?
So in some factory, they have been manufactured or maybe you can talk about a phone.
Now look at this phone.
This is Motorola G3, okay?
Now it's not the only phone available here, right?
So a lot of people, they have this phone.
So that means we don't have one object of Moto G3.
We have thousands or millions of objects.
I'm using any number here.
So imagine we have five million of this type of phones, which is Moto G3.
Now, of course, someone must have designed it, right?
And all these phones have been manufactured somewhere.
Maybe you can say all these phones are made in China, okay?
So we have a factory in China who is producing all this phone.
But then Motorola says it is their phone, right?
Of course, we don't say this is a China phone.
We say this is a Motorola phone.
Or we don't say, let's say the manufacturing is in India.
We don't say it's an Indian phone.
We say it's a Motorola phone.
Why?
Because manufacturing is not important.
You can manufacture stuff anywhere.
What is important is where it has been designed.
Okay?
So this is designed by Motorola.
So even if you talk about this phone, this has been designed once and then they have
manufactured multiple times.
And that design in programming or in, oops, we say class.
So in a class, you will write a design of the object.
Imagine there's some factory in your machine who will create these objects, okay?
So you have to provide a design so that you will get the object.
So that means class is a design and objects, they are real stuff, right?
They are real entities, you can say.
Or you can use another term called as instance.
So you can imagine this is an instance of a class.
That's awesome, right?
So point to remember, class is a design or you can call them as blueprint.
So if you have a class, you can manufacture thousands or billions of these devices.
So that's about class and object.
In the last video, we have talked about the theory of objects and a class, right?
So of course, before creating an object, you need to create a class, right?
Because class is a design for the object.
And if you don't have a design, how can you build something?
In fact, even before building a tower, you need to create a blueprint of it, right?
And that's the same case here.
So if you want an object, you need to create a class.
So what I'm talking about is, you know, let's say I want to work with computers.
So I'm a person, I want to work with a computer.
So of course, I want an object of a computer, right?
So let's say I'm a programmer, and of course, I want to work with a computer.
So I will say comp one.
So this is my computer.
But see, the thing is, till this point, we have worked with integers, we have worked
with float, string.
Now all those are inbuilt types, right?
We don't have any type as computer.
So of course, we need to create our own type.
So we have to create our own class for it.
So if you want to use a computer, you need to define a class here.
So how do we define a class?
The way we define a function is by saying def and function name.
The way we define a class is using a class keyword.
So we have to say class, and this class will of course have a name.
In this case, I will use a name as computer.
Okay, now this is how you define a class, you have to specify a colon.
Now after colon, this is your suite, right?
So this is where you will mention your stuff.
Now what stuff we can put in a class, two things.
The first thing is the attributes, the second one is the behavior.
Oh, now when you say attribute, it is your variables, okay, the way you create variables.
And the next thing we'll be having here is behavior, which is methods.
What is methods functions?
You know, the functions which we are using from a long time, but here we call them as
methods.
So next time when you are calling a function, but that function is a part of a class, instead
of calling them as functions, you have to say methods, right?
Okay, now let's define some methods here.
Now what I'm talking about, let me get a method here, I will say def.
I will say config, because every machine has a configuration, right?
So I will say config, we got that self keyword that that's weird, what is self?
Because here I'm not typing it, okay?
So I mean, the moment I say bracket, it says self, we'll talk about that self later.
But time being, let's keep it there.
You can imagine we don't have any self here, okay?
For time being, imagine we don't have anything like self.
Okay, and here we'll say we got a complete class and then we got a config method, or
you can say function, but try to move from that, that function term to method term, right?
So we got a method here, which is config, and here I'm printing the config of this
machine, and I want to say, hey, this is i5 machine with 16 GB RAM, and it has one
data byte hudder.
Now this is very common config now, which we find nowadays, right?
And that's what I'm doing here.
So we got a class computer, we got a method in that.
Example here, I'm saying comp1 is the object of computer, but we cannot simply do that, right?
We cannot simply say comp1, because no one will understand what this comp1 is.
Example, if I say there's a variable a, what is a type of this variable, right?
Now since in Python, we don't have to statically mention the type of it.
So what we can do is, when you say a equal to 5, now the type of a becomes integer, right?
If I say a is 5.5, the type of a becomes float.
If I assign a value of string type, if I say 8, even if that 8 is number, we are putting
that in single code, right?
That becomes a string.
What about comp1?
Comp1 here, don't have a type.
We have to mention, hey, this comp1 is an object of computer.
In that case, you will say equal to computer, and you have to give this round brackets.
Now if you are coming from another, you know, from different programming background like
Java, C sharp, we have a concept of constructor, right?
So these are constructed there.
So this will give you the object of computer.
Now how do I know that?
If you remember in one of the video, we have talked about a type function, right?
So you can use type function here.
So I will say print.
I will define type, print the type of comp1.
Let's see what happens, what it gives you.
So if another score, it says, hey, this is a class, okay?
Now we have a different keyword class, and this belongs to a computer.
That's important, okay?
So it gives you the module name.
The module name is main because we are running this code from here, and then we have a class
for this computer.
Now if you remember, when we worked with string as well, string gives the same thing.
So if I print the type of a, it also says the same thing.
Can you see that?
It says class str, right?
So we are using this concept from a long time, but this is where we are defining it now.
So string str is also a class, the same way computer is a class.
The difference is str is an in-built class.
Computer is our class, okay?
That's how you define it.
So you say class, computer, and then we have def, config.
In fact, there's one more thing.
So remember, when we worked with integers, we have also said that integers are also object.
Let's try it here.
X equal to 9, and let me print the type of X.
Can you see that?
When I print the type of X, it says class int.
So even this integer, this X, is an object of integer now, right?
So everything is object in Python, right?
So there are some in-built objects, and there are some objects which we create.
And the way you create your own class is by saying class, computer, whatever class name.
Make sure that you don't use in-built class name because it will give you error, right?
Or maybe you might face some bugs.
So in a class, we are defining a function, config, and then, oh, not function, method,
front, config, and then we are printing just a statement.
Now question arise, how will you call it?
So let me remove all this extra stuff which we are doing.
So we got a class, we got the object, I want to call that config.
Now what do you think?
How will you do it?
So normally, when you have a function, you mention the function name, right?
Here in this case, it is config, but you are getting an error.
Why error?
So if I go back here, it says unresolved reference, or that's weird.
Why it is giving you unresolved?
Because, of course, normally, till this point, we were mentioning the function as it is,
right?
Open.
But now we have written that function or a method inside a class.
So in order to access that, we have to mention the class name.
And the class name here is computer.
So we have to say computer.config, important.
So steps, remember the steps.
You have to mention the computer class, which is class name, and then you have to say config.
So let me repeat.
If you want to use a method, we have to mention a class name first, which is, I mean, it belongs
to computer, and then you have to mention config.
If I run this code, oh, we got an error.
But why?
So think about this.
One class can have multiple objects, right?
One object, two object, five objects, maybe billions of objects, right?
In this case, we are using only one object, which is comp1.
The thing is, this config function or a method will change its behavior based on the object,
right?
Because different objects have a different behavior, because depending upon what they
know, they have a different behavior.
So in this case, I'm not depending on any data, right?
But maybe there's a chance that this config will depend upon some data and every object
will have its own data.
Right?
Again, we'll talk about that later.
But every object is different, right?
If I'm calling config, for which object I'm doing that, so if I say, hey, walk, but whom
I'm supposed to say walk, so I have to mention, hey, Ravi, walk, hey, Mukesh, walk, hey, Kiran,
walk.
So I have to mention the names as well, right?
In the same way, when I say computer config, you have to also mention for which object
you're talking about.
And I'm talking about comp1.
So I'm saying, hey, I want the config for comp1.
Now, luckily, we have only one object here, so there's no confusion.
But let's say if you have thousands of objects, you have to mention the object name as well.
So we are doing comp1 here.
So if I run this code now, oh, it works, you can see that we got the output.
So we are calling config and we are passing comp1.
And this comp1 is a parameter, right?
It's an argument.
So when you call config, you're passing this comp1 as the argument and it is going in self.
So what is this self?
Self is the object which you're passing.
Again, this thing will get more clear once you see further videos, right?
So this is a complex concept if you're learning UPS for the first time.
But step by step, everything will go inside your brain, okay?
So this is the first layer.
Again, in the next video, we'll talk about some more layers to it, we'll add more layers
and then I will make sure that you'll get everything about it.
Okay, let's create some more objects, okay?
So I will say comp2 is equal to computer, right?
So we got comp1, we got comp2.
So in total, we have two objects, which is comp1 and comp2, but we have only one class
which is computer.
If I want to call config for comp2, what you will do?
You will say computer.config and this time you're saying, hey, I want to call config
for comp2.
So in the first instance, I'm saying Mukesh, walk, right?
Or I will say, hey, human, walk, in background, I'm passing Mukesh.
I will say hey, human, walk, in background, I'm passing Ravi, right?
In the same way here, I'm saying, hey, computer, show me your configuration and I'm talking
about comp1.
Hey, computer, I want your configuration for comp2.
So from this code, you can see we are getting same data because at this point, we are not
changing data for different objects.
We can do that later.
So this is one way, right?
If you want to call config, we have another way.
If you think about this, this looks good, right?
This looks clean because we are saying, hey, config method belongs to computer and then
we have to pass the object name which is comp1.
But there is one more way.
What you can do is you can mention comp1.config.
Now in this case, you are using the object itself to call the function.
So you are saying comp1.config.
But question is, we are not passing it, right?
Example, let's do it for comp2 as well.
I will say comp2.config and you can see this time, I'm not passing anything inside config
and still it works.
You can see the output.
It works.
We got four times the same data because the first two is because of these lines and
the second next two is because of this line, right?
But why is it working?
It's because this is another behavior of it.
So when you say comp1.config, you are calling config.
See, we are specifying which class it is, right?
So comp1 belongs to computer.
So now we know config belongs to computer.
The moment you say comp1.config, when you are calling it behind the scene, this config
will take comp1 as a parameter.
So behind the scene, config will take that comp1 as an argument and it will pass that
itself.
Okay?
So in most of the code, you will see this type of syntax, not this one.
But I have done this just to explain you how this syntax linked like, okay?
So how this exactly works.
But normally we use this syntax, the second one.
And that's why whatever we have done till now, example, if I work with a variable of
in size, if I say a equal to five, and if I say a dot.
So whatever function we use here, example, I want to know the bit length.
Now in this thing, you can see if I say control space, you know, you can actually see the
documentation by clicking on this, control and click on the function name.
So press control and click on the function name.
You can see it takes to the function, it says bit length self.
So as a definition, it is accepting self.
But when you're passing it, when you're calling bit length, we are not passing it.
So this a is an object, right?
It goes as a parameter.
So self is the object which you are passing.
We'll discuss more about that once we start with variables and then attributes, all the
stuff.
But time being, this is how you create a class and that's you create an object.
Now in the last video, we have talked about OOPS concept, right?
We have seen what is object and a class.
Let's explore it more.
Now if you remember, when we talked about objects, object will be having two stuff,
right?
One is it will be having some attributes and it will also have a behavior.
Now when you say attributes, those are variables, right?
We can create variables.
And behavior is your methods and then methods are almost same as functions.
But in OOPS, we call them as methods, right?
Now here, we have to work with methods, right?
We have not worked with variables yet.
So what I will do is just demonstrate that.
Let me just remove this thing here because we know that we can call config using the
object itself or we can call it with the help of class by passing the object.
Now syntactically, we normally go for the second one, which is calling the method from
the object.
It makes much more sense, right?
So we'll remove that part.
And so once we got the object, let's remove this a as well just to clean that stuff here.
Now what I will do is I want to have certain variables.
Now when I say variables, what I want to do is I want to have two variables, one which
defines the type of CPU I'm working with and the amount of RAM I have.
Example, if you talk about any computer, these two are very important, right?
The CPU which you are using and a RAM, maybe 8 GB RAM or 16 GB RAM.
And in terms of CPU, we have let's say I3, I5, I7 or maybe some AMD series.
Okay, we have different parameters as well, but just to keep it simple, let's only focus
on two things, CPU and RAM capacity.
Now when you say we have two variables, where to define that?
So we can use a special method, which is available in a class.
Now when I say special, you know, right?
So the moment you say special, we have talked about special variable, which is underscore
underscore name in the same way we have special method, which is in it.
And as a special, it will be having underscores as well.
So let's define that.
So we'll say def underscore underscore in it, you can see that we are getting suggestions
as well.
And the moment I say enter, you can see we have the function name or the method name
as in it, and we are passing self.
Now self is not something which I'm typing that is coming automatically.
So it's compulsory to have those argument, okay, which is self.
And in here, we can do something normally we use in it to initialize the variables.
Okay.
And that's what the name itself initialize, right?
Now if you are coming from CC++ or Java background, we use constructor, right?
So you can imagine this is our constructor, but then it is init method.
The advantage here is normally, see, if you want to work with config, you are supposed
to call config.
Okay.
So it's compulsory for you to call config, otherwise it will not get executed.
The idea behind init is it will be getting called automatically.
Example, if I go back here and let's say I want to print something and I will print
in init.
So you can see I have defined a function class init and not calling it.
Okay.
So anywhere in the code, I'm not calling init.
I'm calling config because I want to execute it.
The moment I run this code, you can see it prints in init.
And that way it prints two times.
Now why two times?
Because for every object, it will get called once.
So you can see in total, I'm getting two objects.
One is com one, one second is com two.
So we got two objects and it will call init two times.
So this is the object creation.
So when you say computer bracket, it will instantiate, it will call init for you.
Now I want to pass some arguments.
Okay.
I want to pass CPU and RAM.
So in the constructor itself, you can pass that.
So in the computer bracket itself, you can pass it.
So I can say I have a CPU here, which is, let's say, I5 and the amount of RAM we have
is 16 GB.
The second computer we have, let's say, reason three, and the amount of RAM we have, let's
say, 8 GB.
So we have two computers with two different CPUs, right?
And now how to accept these values?
So of course, you have to pass these values here, right?
So I have to say self, comma, you have to pass two values.
You have to accept these two values.
So you have to say CPU, comma, RAM.
Okay.
That's how you accept it.
Now I know your question.
Your question is, we are passing two parameters, right?
Or we are passing two arguments.
One is CPU and second is RAM, and we are accepting the arguments here.
So the thing is, you are actually passing three arguments here.
Remember, we are also passing comp one.
The moment you say computer in the bracket, you are passing that comp one by default.
The same thing happened with config, right?
When we call config, we are not passing self or the object itself, but it gets passed automatically.
The same way, when you say computer by passing two parameters, you are actually passing three.
The first one is the object itself.
The second one, the value, the first value here, and then RAM.
Okay.
That makes sense.
But will it work?
So the thing is, every object need to have a value because this is just an argument now.
So CPU and RAM is just an argument.
If you want it to be a part of your object, you need to say, because see, we have to assign
this value to an object, right?
And the object here is self, right?
So you have to say self dot.
That's right, right?
Comp one.
This is our object, right?
So we have to say self dot CPU is equal to CPU.
Again, there's no compulsion that you should be having same name.
You can have a different name.
That's fine.
So you will say self dot RAM is equal to RAM.
So whatever value you're passing here, which is I5 goes to the CPU as an argument, it will
be assigned to the object, which is self.
So the self, you can imagine now.
So in the background, you can see we have two objects here.
So in total, we got two objects.
Each object will have its own variables.
Okay.
It will have its own CPU.
It will have its own RAM.
And then whatever value you pass in the arguments, it will be assigned to those objects.
Okay.
So we have two objects, two different values.
And now in the config, instead of printing this stuff, I will say CPU comma RAM.
That's what we do.
Oh, we got an error.
What's wrong here?
So the thing is, this CPU is not a local variable, right?
This CPU belongs to an object.
And how do we refer to object?
It's very simple.
You have to use self, right?
That's why you are passing it.
You have to say self.CPU.
And here as well, you have to say self.RAM.
And that's the idea behind passing this self, right?
We are passing self so that you can use it to fetch the values.
So you can imagine your methods and your data works together and we have a name for this
concept.
Again, we'll talk about that name later.
It's a surprise.
But we are binding our data with every method.
So one object will have its own methods and its own variables, right?
So they are working together.
And now, let's run this code and let's see what happens.
So the moment you run this code, you can see it says config is i5-16 and config is raisin-3-8.
So that's the idea.
That's how you create a variable.
So every object will have its own values.
That's amazing.
In the last video, we have talked about OOPS concept, right?
We have talked about objects.
We have talked about classes.
And then somewhere we have talked about init, right?
In this video, we'll focus on two concepts.
One is constructor and self.
But hold on.
We have seen self before, right?
But let's try to expand more of it, okay?
Because self is something which is very easy to understand.
At the same time, it is a bit confusing, okay?
So we'll try to get that.
And then we also talk about constructor.
Now in the last video, we have talked about init, right?
Now init is actually a constructor.
But why this is called a constructor, we'll see that here.
And why this is so important.
So what we'll do is let's remove this thing and let's see a computer class again.
Let's go back to computer class.
So this is a class, right?
And of course, every class will have an object, right?
As we mentioned, we have a concept of a design, right?
So this computer class is a design and then we need to create an object of it.
So what I will do is I will say C1 is equal to computer.
Now this computer here is an object, right?
I mean, this C1 is an object or you can say C1 is referring to the object.
So what happens, you know, in your system, we have a special memory called as heap memory.
Now inside this heap memory, you will get all the objects, right?
For example, the moment you say you want an object now, if you remember, we have talked
about integers, string, everything is object in Python, right?
Now in this scenario, here this object will take some space in your heap memory.
Now every space will have some address, right?
We have talked about id function, remember?
So we can use an id function here and we can print the value of C1.
So we can print the address.
Of course, this object is created somewhere and we need to print the address as well.
And the way you can print the address is by saying, print, I want to print the address
of C1.
Let's do that.
Oh, we are getting an error.
Now if you remember, we have talked about this stuff.
So I'm keeping this class empty, right?
We cannot do that.
So let's write pass because I'm not mentioning anything in the class here.
So let's write pass.
Let's run this code now.
And you can see we got the output as 155 with the number, right?
Now this is an address, okay?
So this is the address of that memory.
Now what happens if I create another object?
Let's say if I say C2 equal to computer, now we are creating another object, right?
So in total, we got two objects.
So will it take different space or will it be accommodated in the same place?
Of course, we have talked about this before when we talked about integers, allocation.
If I run this code, you can see we got different addresses.
And again, every time you run this code, you will get different address, right?
Because every time you run this code, it will create a new object for you.
So this time we got two new objects.
Now if I run this again, we will get two different objects, not the same object again, right?
Because this is new execution.
So point to remember is every time you create the object, it will take two different spaces.
Now question arise, how much space it will take?
Maybe 1MB, maybe 1KB, maybe 5KB.
So who will decide and who will allocate the memory?
Now first of all, the size of the object is dependent upon number of variables we have
or the attributes, remember?
If this class has five variables of different type, it depends upon how much data you pass.
It will change the size of it, okay?
So the size of the object is dependent upon the size of the variables and number of variables.
But who is responsible to assign that memory or who is responsible to calculate the memory?
And that's your constructor.
Now this thing here, which is computer brackets, this is your constructor, right?
So whenever you write a constructor, it will call the init method for you.
Of course, you don't have to call it explicitly, it will be called internally.
Now let me define some variables here.
How do we create a variables, right?
So how do we define a variable for the object?
Now in this case, if you want to define a variable, we have one choice, which you can
define a function which is init.
Again, we have seen that.
So this is the init function, right?
Now it uses self, but as of now, we'll not talk about self, we'll continue here.
And I will use two variables again, we have talked about this, but let me just do it once
again.
I will say self.h, I want to have two attributes, one is name, I will say name is Navin and
age.
So let's say age is equal to 28.
So we got two things, we got name and we got age.
Now both the object will have the same values, right?
So you can imagine we have two objects and both the objects have the same value.
If I want to change it, if I want to change the value of one object, the way you can do
that is, in fact, instead of printing IDs, I want to change it now because of course
why IDs will print different now, we know that.
So we'll say c1. I want to print name of c1 and I want to print the name of c2 as well.
So what will happen?
Will it print the same data or different data?
That's a question.
So we have this code and you can see they are printing Navin.
Of course, right?
Because the moment you create the object, both will have the same value because that
is what by default you're getting.
If you want to assign your own values, you have two choices here.
What we can do is, before printing it, we can change the value for c1 because the c1.name
is equal to Rashi.
So we are changing the name, right?
And now if I run this code, you can see we got Rashi and we got Navin.
So of course c1 is different objects, c2 is different object and we got different names.
So that perfectly makes sense.
We can change the age of c1, we can say c1.age is less than 12, we got Rashi with age 12
and of course we are not printing age here but we can do that.
So we can change the value of one object from different objects and of course there are
two different entities.
So remember this, we got two different objects and both the objects will have different variables,
okay?
You can assign the values there, you can change it your wish.
Now question arises, why do we need this self?
So what I will do is just to explain that, let me take one more method here, we'll say
okay, so I'm changing the value of something and the moment I say update, I want to change
age, I will assign a new age and we'll say age is less than 30.
So we are changing the age now, right?
So we got a method which will change the age totally.
Now I want to call update, now how do you call update with the help of class name or
with the help of object name?
Let's try with objects, I will say c1.update, now see we have two different objects, right?
So what is program execution, right?
So execution will start from here, you got the object, you got the object, you are changing
the names and everything is fine.
The moment you say c1.update, your pointer which is your focus will move towards this
update function or update method, so it is executing it, right?
Update will say okay, I'm getting called, I belong to a class computer, my job is to
do something, my job is to change the value of age, but hold on, we got two objects.
Which value you want to change, right?
Because we are calling update and we are not mentioning which object I'm talking about
because when you call this update, we have not mentioned is it c1 or c2, we have mentioned
that by calling it, so we are saying c1.update, but we are not passing anything in the bracket.
So when you are calling it, when you are calling update, how your pointer will know which object
I'm talking about?
Is it the c1 age or is it the c2 age?
And that's where you need to use self.
So this self is a pointer or you can say self is directing to c1 or c2, so we have two objects,
this self will direct either on c1 or c2 based on what you are calling.
So if you are saying c1.update, then in the bracket, it is passing c1, so self will be
assigned to c1, okay?
So that's the importance of that self, it is very important because it is referring to
the object.
If you have ten objects and if you want to refer to one object, you can use self, so
it is the current instance you can say, even if you have ten objects, at one point you
are working with one object, that is self.
I hope that makes sense.
So that is self, right?
So we have talked about constructor and self here.
Let me show you one more thing.
What if I want to compare two objects here, okay?
So I want to compare, let's say we have c1, c2 and both have same names, right?
So they have same name and they have same age.
But let's say I want to compare the age, so I will say if c1 is equal to equal to c2,
so I want to compare two people based on their age, if their age is same, I want to
print their same.
So c1 is equal to equal to c2, print, they are the same.
So let's do this.
I want to check if both the objects are same, then I will print they are same.
But then I don't want to compare the object address, right?
I want to compare their values.
I want to compare their age.
Name doesn't matter, if name is different, what should be same is age.
Now in this case, we cannot simply say c1 equal to c2 because we don't know, your Python
don't know how to compare.
So in this case, what you will do is, you will use a separate function to do that.
I will say, hey, I want to compare c1 with c2, so I will say c1, compare, and you can
pass c2 because we are comparing it, right?
Again, this compare is not an inbuilt function.
So if I click on this, you can see it says, cannot find declaration to go to something.
The thing is, compare is not an inbuilt method we have.
So in order to work with compare, you have to define your function.
You have to say, compare, and in this compare, of course, you have to pass self, and then
you have to also pass one more object, which is of c2, right?
So we are comparing two objects, right?
So we have to pass self.
So what is self here?
So the c1 becomes self, and c2 becomes c2.
Again, you can change in the name, if it's your choice, right, you can say other, right?
So you are comparing self with other.
So c1 becomes self, and c2 becomes other.
Now why c1 becomes self is because c1 is calling it.
So c1 is comparing itself with c2.
You can reverse it, okay?
You can say c2.compare c1.
In that case, c2 becomes self, and c1 becomes other, right?
And now once you have this self and other, you can compare.
If self.h is equal to equal to other.h, you will return true, else return false.
In fact, you could have done that in one line, but just to make it look good, I'm doing this.
And now you can compare it, right?
So they don't have same age, because we are changing it after update.
Let's remove the update part here.
They have the same age, right?
Let's run this demo, and you can see, oh, we got an error.
We forgot to put a code in there.
My bad.
Let's run this code.
And so you can see, just printing, they are same.
So they are same, right?
Now what if they have different age?
So what I will do is, once I got c1, I will change this age of c1.
I will say age of c1 is 30.
Anyway, we are not using update here, and we can say run demo, and you can see it is not
printing, they are same.
We should print the lspot as well, so that we'll see.
Is it different?
Let's print.
They are different.
And let's run this code.
In case of that, we got they are different.
Now since their age is different, we are getting that different.
See, names are same.
What is different is age.
So we can compare two objects by defining our own function, which is compare in this
case, or method in this case.
But remember this thing, compare takes two parameters, the first one who is calling it,
and second one, whom to compare, right?
So here in this case, we are saying c1.compare with c2, so c1 becomes self, c2 becomes other.
This is very important.
I know it is a bit confusing at the start, but the moment you start working on it, it
becomes very easy.
Now we know how to work with class and object, right?
And we have also seen how can you create a variable inside an object.
Of course, right?
Every object should know something.
But when it comes to variable, in Ops, we have two different types of variable.
The first one is an instance variable, and the second one is a class variable, or you
can call them as static variables.
What is the difference between them?
Now think about this.
Let me just remove this code.
Okay, whatever we have done till now.
So let me just clean this up, okay?
So we will start from a plain slate.
So here, let's go with another very example.
Let's take a class called as car, okay?
We all love cars, right?
So let's say we have a class car, and of course, every car will have different variables, right?
Of course, you can mention the company name.
You can mention the type of engineer working with and the mileage, what it gives you.
So we have different variables, okay?
So what I will do is, if I want to use those variables here, we need to use a function
just in it.
So you will say init function, and in this, you can define those variables, right?
I can say self dot mileage, and I will say mileage is let's say 10.
And then I will say the company.
So company would be let's say BMW, any random company doesn't matter.
So we have these two values, right?
Now, these two variables are called as instance variables.
So we talk about mileage and com, these are instance.
Now why is our instance is because as your car changes, as the object changes, this value
also change.
By default, the value is 10 and BMW, but you can change it, right?
Example, we have done that before just to give you a glimpse.
I will say the first one is C1, and this is car.
That's my first object.
I got C2, which is again a car.
That is, we got C1, C2, now we got two different objects, and both the object will have different
variables, right?
So I will say the area for the variables, and now if I print the value, so I will say
C dot com, and I also want to print C1 dot mileage.
So I want to print both, for the both the variables.
So you can see we got C1 com, C1 mileage, C2 com, C2 mileage.
That's perfect.
And now if I run this code, of course it will print same values because they are same.
But can we change it?
Yes, we can.
So I will say, if I change for C1, so let's say C1 dot mileage, so let's say C1 mileage
changes from 10 to let's say 8.
This is what happens, you know, with some cars.
And let's run this code.
You can see the value is changing now.
So of course both the objects are different and they will have different values.
But what if I want to create a variable which is common for all the objects?
Of course, these variables, which are instance variable, they are different for different
objects, right?
If you change one object, it will not affect other objects.
What if you want to have a variable which will change, it will affect all other objects?
Example, the number of wheels in a car is 4, right?
By default is 4, right?
But what if in future we got a new concept and they are saying, hey, now this time we
will have five tires or five wheels.
I don't know why we will have five wheels, but let's imagine.
In this case, what you will do is you will define a variable outside in it, okay?
Because if you create or if you define the variable inside in it, it becomes an instance
variable.
If you define a variable outside in it and inside a class, of course, it becomes a class
variable.
Let's say wheels.
So let's say wheels are by default 4, of course, it will be 4, right?
But if I print the wheels as well, now how do you print wheels?
The way you can print is very simple.
You can say C1.wheels and here as well as C2.wheels and let's run this code now and you can see
we got the output.
We got 4 and 4.
So if you want to access wheels, you can use C1.wheels and C2.wheels.
See, instead of using the object name, we can also use class name because see, if you
talk about mill and com, it is specific to the object, right?
But that's not the case with wheels.
Wheels is common to all the objects.
So every object can share the same value of it.
So we can use object name or we can use class name, both works.
So you're getting value 4, right?
What if you want to change the value of it?
If you want to change the value, you can come here and you can change the value.
See what happens, you know, in your memory, you have different namespace.
Now what is namespace?
The place where you create an object or the variables that there was namespace.
So we have two types of namespace.
One is class namespace, where you will store all the class variables and then we have an
instance namespace where you will create all the instance variable.
So these variables, which is mill and com, they are instance, right?
So they will belong to instance namespace.
This wheel belongs to class namespace, right?
So if you want to work with wheels, if you want to modify it, you have to use a class
name.
You have to say car.wheels and you can assign the value to 5.
Now the moment you change the value of wheels, it will affect all the objects, right?
Because they are shared.
So this wheel is shared between all the objects and neither on this code, you can see the
output is 5 and 5.
So that's your class variable.
The point to remember is we have two types of variables, instance variables and class
variables or in fact class variables are also called as static variables.
Now till this point, we have talked about different types of variables, right?
We have seen instance variable and a class variable.
We can call them as static variables, right?
Now in this video, we will talk about methods and different types of methods.
Now we have seen that, right?
When we talk about objects, object will have two things, right?
The first one it will have is variables and second one is methods.
Now variable to store data and methods for the behavior, right?
So if you want to perform some operation, that's where methods comes into picture.
As human as well, we know something and we do something, right?
So those are your variables and methods, right?
Now here, when you talk about methods, we have different types of methods.
Now basically, we have three types of methods.
The first one is instance method.
The second one we have is class method and then we have static method.
Hold on.
When we talk about variables, we only have two, right?
Because class and static behave the same way in variables.
But hold on.
In variables, we have the same thing, right?
In variables, we have class variables and static variables which are same.
That's not the case with methods, okay?
So class methods and static methods are different in methods.
Okay, so let's get started.
So this time this concept, we'll take an example.
So let's take a class here and we'll name this class as student.
So in this student class, we'll be having multiple variables, right?
Now, of course, when we talk about student, we have names, we have roll number and then
we have marks.
At this point, let me only focus on marks, okay?
So what I will do is let me create a function which is your init function because I want
to declare some variables.
So it says self dot.
Now I want to go for three variables here.
One is marks one and marks one, I want to pass this value from the user, okay?
Of course, you can define your own values here, but I want to pass the value when I
create the object.
And the way you do that is by saying self comma, you will pass m1, m2, m3.
I want to pass three variables and m1 value will be assigned to the object by saying self
dot m1 equal to m1.
I will go to same thing for m2.
I will say m2 and the same thing for m3, right?
So we got m1, m2 and m3.
Now we got three variables.
I want to create certain objects here.
Okay, let's create objects for this.
I will go back here.
So let's create the object here.
I will say s1 is equal to and as usual, we can create multiple objects, but time it
will go for s1 equal to, I will say student.
That's my first object and if you get one more object, it will say s2 equal to student.
So basically, we got two objects here.
One is s1 and s2.
I also want to pass a value to it, right?
Because we are not passing it.
So let me pass any value, a random value.
I'm not actually saying what I'm typing here, but then we got three values there.
And here as well, I will go for a random value.
That doesn't make any sense to see that.
So we got these values, right?
So first student got 34, 67 and 32, second student got 87, 32 and 12.
Now what I want to do is, of course, this variable here m1, m2 and m3, those are instance
variables, right?
We have talked about that.
At this point, we have not created any methods.
Let me just do that.
Before going for methods, let me also create a variable, a static variable this time.
And the way you create a static or a class variable just by defining or declaring the
variable outside the constructor, right?
So here, I will say, I have a variable and we'll name this variable as school because
of course, right?
A student belongs to a school, right?
Or a college.
At this point, all the students belongs to the same school, which is the disco.
Imagine if we have the disco university, we'll be having a school.
So we got the school name as well, right?
So you can print those values by simply saying, in fact, you can print those values here as
well.
You can say x1.m1 and x2.m1, we can do that.
What I am concerned about here is, I want to know the average of marks, okay?
So I've got these three variables, right?
I want to perform some operation.
How do you find the average, right?
So you can, the logic of average you can define by yourself, you know, everyone has their
own way of doing it.
I will be doing a very simple calculation.
So let me create a method called as def method called average.
So when I say object dot average, it will give me average marks, okay?
So I want to return the average marks.
And the way you do that by saying return, you want to return the value.
And here, you will simply say m1, or not just m1, you have to say self dot m1 plus self
dot m3.
So we have to divide this number by three.
That's how you find the average, right?
And we know the stuff, right?
That's how you find the average of multiple numbers.
So we got the average and we are returning the value.
Okay, so now this, if you focus on this average, this is an instance method.
How do you know that's an instance method because we are passing self.
Now when you say self, it means it belongs to a particular object, right?
Of course, we are defining that in a class, but it works with the object.
And that's why you're passing self.
So if you want to call average, you have to say s1.average, or you have to say s2.average
because we are passing self.
We cannot simply say student.average because we are not using object there.
But in this case, we have to say s1.avg.
That's how you do it.
So I have to say s1.avg.
It will give you the values.
I will print the value here.
I would say print the average here.
So let's run this code and you can see it works.
We got the average of our student.
You can do the same thing for second student.
You can stop saying s1.average.
You can say s2.average.
And if you run this code, you can see we got the average for second student as well.
And they almost say, I don't know why.
Okay.
So after changing value, we got different average, you know.
So this was just for coincidence, you know, I've given some values and then they were
giving the same average, right?
So yeah, so you got different average for s1 and different average for s2.
That works.
Now what we're going to do is, so this method here, this average is an instance method because
it works with the object.
Now in instance itself, we have two different types, okay?
The first type of instance which we use is called as accesses.
And the second type we use is mutators.
So we have accesses and mutators.
Now what is accesses?
So if you are only fetching the value, see ultimately when you talk about this method,
they are only responsible to work with variables, right?
Which is your instance variables.
So if you want to just fetch the value of the instance variable, we will be using accesses.
If you want to modify the value, you will use mutators.
So the way you do that example, if you want to fetch the value of m1.
So if you want to know the value for m1, you can fetch directly, you can say print s1.m1.
You will get the value like this or instead of using the variables, we should actually
use methods.
So what we'll do here is we'll set def and we'll define the function as get m1.
So we'll say get m1 and which m1 you want.
So you will say return, I want to return the value for self.m1.
This is how you do it.
So if you want the value for m1, you will say get m1 and you've got the value.
Normally, it's not compulsory to have that get keyword there.
You can also say m1, that's fine.
But when you write a code conventionally, you simply specify get there.
So whenever you say get methods or in fact to set the value, we use set methods.
Example, if you want to set the value for m1, you will say set m1.
Of course, we are passing that from a constructor.
So we can say set m1 and you can pass some values here.
I would pass a value f.
I will say a value and this value will be assigned to m1.
So it will say self.m1 is equal to value.
So you can use constructed to pass the value or we can use setters.
So we have get methods and we have set methods.
Now for different variables, we'll be having different get and set methods.
So if you have three variables, you might be using three get methods and three set methods
and that's why they're called as getters and setters.
So getters get the value, set the value, getters only fetch the value.
It will not change the value.
That's why we say access.
Setters they change the value and that's why we say mutators.
So this makes sense whether you can call these methods, but this works.
Now once you talked about instance, the second type we have is a class method.
Now why we use class methods?
See, if you talk about these variables m1, m2, m3, those are your instance variable.
An instance variable can be used with instance methods.
What about this one?
This is cool, right?
Now school is basically your class variable.
And if you want to work with class variable, you need to use a class method.
And the way you do that, let's say I want to know the info of a student.
So I will set def info.
Info will print the name of the school.
Okay.
So let's say if you are studying for a telescope, you will be, it will print telescope.
And of course all the students belong to same school.
Right.
If you change school name for one student, it will affect all the student example.
This channel name earlier was nothing skills.
Right.
And we have changed it to telescope.
If the name changes for one subscriber, it will affect all the subscribers.
Right.
And that's what is happening here.
So if I want to print info and that to a school name, I don't want marks here.
Of course we don't want to work with self.
We want to work with class.
Right.
So if you are working with instance, you will use a self keyword.
If you're working with a class variables, you have to use class CLS.
Okay.
It should be CLS.
It should not be something else.
Now once you got that, you can simply print the value.
So you can say print or you can return the value, your choice.
You can say return CLS dot school.
That's how you do it.
So you have to say CLS dot school.
So whenever you want to work with class variable, you have to say CLS dot school.
Okay.
But then how do you call info?
It's very simple.
You will say print S1 dot info.
We can do that.
But there's only one problem.
Info should work with all the objects.
Right.
It's not specific to one object.
So instead of using S1, we can use a student dot info.
Now this should work.
Let's try.
I will say run.
Oh, we got an error.
It says inform is seeing one required potential argument, which is a position argument, which
is CLS.
Oh, we had to pass CLS.
That's weird.
I don't want to pass CLS.
Right.
In fact, we are not even doing that for average.
We are not passing S1.
Here also, I don't want to pass thing.
Normally what happens, you know, if you want to create a class method, we need to use a
special symbol or special way of doing that and we can use something called decorators.
So we have to say at the rate and you have to mention this as a class method.
Again, we'll talk about decoders later in detail.
But time being, we got a class method as a decorator.
So if you want to use info as a class method, you have to say at class method.
Okay.
That's how you define it.
So let's run this code now and it works.
You can see that we got the disco there quite simple, right?
So now we know about instance method because it works with instance variables.
Now we know about class method because it works with class variables.
How about static methods?
See, think about this.
Let's say if you want any method, it doesn't matter what method we want here.
If you want a method which has nothing to do with instance variable, which has nothing
to do with the class variables, we want to do something extra.
Okay.
So something different, which is not concerned with the variables at that time, you will
be using a static method because we are not concerned about instance variable.
We are not concerned about class variables.
Example, let's say I want to print the info about this class, okay, not about student
but the class.
So I will say def about, you know, in fact, instead of saying info for class, I would
say get school name that will make more sense.
So I'm changing the name from info to get school for class method, okay, not for this
and let me also change from here.
So we'll say get school.
Here, I will define a function and the function name will be info because when I say info,
I want to know the class name, okay?
So this is not related to the object.
This is not related to class as I will keep it blank, okay?
So if you don't want to read this to a class, keep it blank.
If you don't want to read this to an object, keep it blank, no self, no class, okay?
Static method.
And this will return, this will print.
In fact, not return, this will print.
We can do whatever you want.
So we can say this is student class.
You can do that, right?
So we are printing this is student class and in ABC module.
That's it.
You can print whatever you want.
As I mentioned, important is this method is nothing to do with the class variables and
the instance variable.
Now, it will be useful.
So let's say if you want to perform any operation which has something to do with the other object
or the class objects, we can use static methods here.
If you want to perform some operation like finding a factorial of a number, right?
Because the factorial has nothing to do with the class variables or instance variable.
Maybe you're passing a value.
You just want to know what's the factor of the number.
You can use static methods there.
Now, since we are using a static method, we need to use a special decorator here as well.
So we have to say any guess, we will be using static methods.
So for class method, we have to say class method and for static method, we have to use
static method.
Okay.
And then you can call it.
So you can say, so you have to use a class name.
So you will say student dot info, right?
So there's static.
So you don't have to pass anything, not even class and not even object, let's run this
code.
And it works.
Okay.
So basically, we have different types of methods.
We have instance method, which works with instance variable class method works with
class variable and static works with nothing.
It has, if you want to do something extra with your class, nothing to do with class variables
or instance variables, go with static.
Now, to this point, we have talked about different types of variables and we have talked about
different types of methods, right?
So we can write variable and methods instead of class, right?
So a class will have variables and methods.
The question is, can we have a class inside a class?
That sounds weird, right?
Why would anyone would have a class inside a class?
So let's try to understand that.
So let's say I have a class here and this class name is student as usual with the way we have
done earlier.
And when we talk about students, we have different types of variables, right?
Let me define that function first and the variables which I want here is self.
First I want a name.
Of course, in the last example, we have taken marks, but here let's take something different.
I would take a name of a person and that will be coming from a user, of course, or from
when you create an object.
We'll say name.
The second thing I want is roll number and I want these two details.
And then I will assign name here and I will say self.roll number.
Now we have used to it, right?
So I would say roll number, right?
Now once we got these two variables, what I want is I want to print them.
The way you print these values is by defining some functions, right?
Of course, you can do that directly, for example, if I create an object here.
So let's say the object is S1 and I will say student.
And when you create this object, you have to pass values as well, right?
The first one I want is navin and roll number is let's say 2.
The second object we want here is S2 and we'll say student in which we'll be having two things.
Of course, I would say this is Jenny and the roll number is let's say 3.
So I have navin and we have Jenny here, we got 2 and 3.
Okay, so let's say I want to print, I want to print S1.
So I want to print all the details about S1, okay?
I want to print the name and roll number.
So the way you do that is by saying S1.name and we can say S1.roll number.
So this is how you can print the values, right?
Let me run this code and you can say it works.
We got the details about S1.
Now what I want to do is I don't want to, see, this doesn't look good, right?
What you should be saying is you should say S1.show.
So when I say S1.show, it should print all the details about S1.
Maybe it has roll number, name, or different variables, right?
So of course, we need to define that function or method here.
So we'll set F, show.
So this will print self.name and we'll print self.roll number.
So we are printing these two data, right?
It should work.
Let's run this code and you can see we got the same data.
Now let's say student also has a laptop.
Of course, right?
When you say you are doing IT, in fact, we have done that, right?
So you are a student of Therisco.
You will be using a laptop to run your code or the extra doesn't matter.
And let's say we want laptop here.
So of course, I want to know which laptop we are using.
So I want to know your config.
Now in that case, I will also ask a user, hey, tell me which laptop you are using.
The problem is when you talk about laptop, there are different things important, right?
It's not just about brand.
You will not simply say, hey, I have HP laptop.
I have a Lenovo laptop.
You will also mention the configuration, maybe CPU and RAM.
That's very important.
Maybe any i5 CPU with, let's say, 8GB RAM is enough.
So I want to know your config.
So what you will do, will you pass three variables?
Like you will pass a brand, HP, and then you will also pass the CPU which you are using,
let's say i5, or you will also pass, let's say, RAM of 8GB.
Yes, you can do that.
So I have to accept this variable here.
I have to accept that here.
And we can do that.
The other option which we have is different.
So the other option which we can do here is, we can create a class.
We can create a supplier class as laptop, or instead of creating a class outside the student,
we can also create a laptop inside student.
So a laptop will be only used by student.
And in this case, so I will say a class and I will say laptop.
So we are creating a laptop class inside a student so that we can get that group.
So we have to also set depth here and we have to say init, right?
And then let's create a variable.
So the first variable we need here is brand.
And let's say the brand is HP.
That's the first thing we need.
Second thing we need is the CPU which you are working with.
I would say CPU is i5.
And the third one is RAM.
Let's say 8GB RAM.
So we got these three things, right?
Now we got these three variables.
And where to create the object of it?
So we can create the object here itself.
So we can create the object inside the init and normally that's what we do.
So if you want to create the object of laptop, we should be creating that object
inside the outer class, okay?
So the object of laptop will be the inside the student class.
The way you do that is very simple.
Here you will say self.lap.
You can create any variable you want and you will say laptop.
Or we are getting others, so you have to say self.laptop.
Okay, this works.
So you can see in the constructor itself, you can define a variable.
So in the outer class, you can define a variable lap and you can define the object.
So if you really want to use a laptop, you have to say the student object.lap.
For example, outside if I want to use it, I will say s1.lap.
Whatever brand you want to fetch.
So you cannot simply say lap.brand.
You have to say s1.lap.brand because the lab object is inside the student class.
This is one way.
What if you want to create another object of it?
Let's say I don't want lab, I want.
So you can simply say lap1 is equal to s1.lap.
You can get another object for s2.
You can say lap2 is equal to s2.lap because for every object you will get different laptop object.
Okay, trust me, this is how it works.
In fact, you can also check that we got two different laptop object here.
We will print lap1 and let's print lap2.
So let's print the ideas of lap1, lap2.
We got two different objects here.
So this works.
Okay, this is where you create inner class.
Okay, so we have a laptop as an inner class of a student, right?
You could have done the outer class as well.
I mean, you could have created two different classes that you want that works.
But sometime when you know that this class will be used only for student, nothing else,
then you don't have to create a separate file for that.
You can do that in student class itself.
Now, can I directly create the object outside?
Let's say I don't want to get object of laptop inside the student class.
Can we do it outside directly?
Let's try.
So I will say lap1 is equal to, I will say student.laptop.
Now, why shouldn't here?
Because you cannot simply access laptop directly, right?
Because laptop class belongs to a student class.
So we have to always say student.laptop constructor.
You cannot simply create laptop directly, okay?
So this is one thing you have to remember.
You can create the object of inner class inside outer class or you can do that outside the outer class provided.
You are using the outer class name.
So you have to say student.laptop.
Okay, this works.
In fact, just to enhance the example, what I will also do is we can create a show method for a laptop as well.
So we can say show for laptop and you can see we have two show methods.
One is student and one is laptop, okay?
So in such a student, we have show method inside laptop also.
We have show, but these are two different show methods.
The show method of student will print the data about a student and the show method of laptop will print the show method of student.
I know that makes, that's weird.
So let's do that.
So I will say print self.brand, self.cpu, and self.ram.
Okay, so we are printing this data.
So this show is different from this show.
Let me now print laptop here.
Let me on this quote and you can see it prints only the name and the roll number.
I also want to print the laptop.
Oh, you need the object, right?
We have removed that statement because if you want to access laptop, you have to say self.lap is equal to laptop, but you have to say self.
So this is important and after printing this will call laptop show because we also want to do that.
So you will say self.laptop show.
Okay, so we are printing data about a student and laptop as well.
So this should work.
Let's run this code and it worked.
You can see we got data about a student and laptop as well.
So this is how you create the class inside a class.
Now in this video, we'll talk about inheritance.
Now we talk about a concept of oops, you know, which is object oriented programming.
We have so many concepts to talk about and one of them is inheritance.
Now in real life, what we have is we have this parent and child relationship, right?
So whatever belongs to your parents belongs to you.
Example, if my father or mother has a phone, it's my phone, right?
By default, my phone would be my phone, but my father's phone would be my phone, right?
That's how it works.
So if your parents house, it's your house.
That's what we say inheritance, right?
They're the same concept you can implement in programming as well.
In fact, all the languages which follows oops concept, they do implement inheritance, right?
And the way you do that is with the help of classes, class inherit a class.
Let's try that.
What I'm talking about is let's say if you have a class and class is a, okay?
Again, it should be a logical name.
So you can go with employee class.
You can go with student class.
You can go with laptop class, whatever class you love.
But time being just for the example, we are going for class A and class B or class C.
In future, we'll try to implement some other examples using different names and
with proper example, but at this point, just to keep it simple, let's go for class A.
Now, if we talk about this class A, this class A will have multiple features, right?
Maybe we can define two methods here.
So we'll set definition there.
The first method which I'm going to go for is let's say feature one, okay?
So let's say we got this function, which is feature one, and
this function does provide you something, okay?
So time when we are printing feature one working, that's it, nothing much.
Of course, it can be a complex code, but make it simple.
Let's keep it that.
And then we can have another feature here.
Let me just copy paste this code.
So I will say copy and paste, and this will be my feature two.
So we got feature one and feature two, and this will point feature two is working.
So this class A has two features.
We got feature one, feature two, right?
And the way you can access them is with the help of object, right?
And the way you create an object is very simple.
You simply say A1 is equal to A, that's how you create the object, right?
Where A is your constructor.
Again, you can find that init method here, but not needed at this point.
So this will work.
And using this A1, you can call feature one, you can call feature two, right?
So you can say A1.feature one, and A1.feature two.
And this will work.
Let me just run this code, and you can see we got feature one working,
feature two working, so this code is working.
Now what I'm excited about is, let's say we have one more class.
Let's talk about class B.
So let me just create a class B here itself.
So here I will say class B, and class B will also have two features.
I will name this as feature three and feature four.
Instead of typing them, let me just copy this code here.
And we'll name this as feature three and feature four, right?
See, normally what happens, you know, when you work on a project,
of course, we have a very big team, right?
So example, if one person is defining a class, okay?
In that class, we provide you four features or four methods.
Maybe you want to define some other class in which you need some extra features,
and you also want the existing features.
You don't have to really find it, right?
You can use it.
And the way you do that, you're simply saying,
example, in this class B, we got two features, right?
We got feature three, we got feature four.
And of course, if I create the object of B one, so
if the B one is equal to B, and the functions which you can call using B one.
So if I say B one dot, you can see we got only two options.
We got feature three and feature four, of course, right?
Because in B class, we have only two features.
What if you want to get the features of A as well?
And that's where inheritance comes into picture.
So we can say, hey, this B is a child class of A, right?
And the moment you say child class, it will import all the features.
What I will say is this B is a child class, or you can say subclass.
We have different terminology we can use here.
And we can simply say in the bracket, you can say A.
So this class B is inheriting all the features from A, and we got it, right?
Just by writing that one thing, just bracket A, we are saying B is
inheriting the features from A, which means with the object of B, which is B one
in this case, the moment I say B one dot, see the options.
You can access feature one, feature two, feature three, and feature four.
And that's the importance of inheritance, which simply means if you already have
a class which provides you some feature, and in future, if you want to create your
own classes in which you want to use those features, you just need to inherit them, right?
So we can use some terminologies here.
We can say superclass, subclass, or we can say parent class or child class.
So timing will refer them as superclass and subclass.
So super is a class which is A and a class which inherits the class, we will
call them as subclass.
So B subclass and A is superclass.
So that's the concept about inheritance.
Now this is also called as a single level inheritance.
We have some other types as well.
We also have a multi-level inheritance.
Now what it means?
Example, let's say if I have another class here, let me get one more class here.
And this class is, let's say C.
So we'll call this class C, or this class C inherits B.
Now what will happen is whatever you do in this class, let's say timebin, I will
define only one feature here, we'll say feature five.
You can see how lazy I am.
So this is feature five working, right?
So we got C class which has only one feature.
But the moment you create an object for C1, so I will say C1 is equal to C.
The moment I say C1 dot, see the methods you can use.
So we can use feature one.
Now feature one, feature two are coming from A, right?
But C is only extending B.
So that's our relationship.
We have grandparent, we have parent, and then we have child, right?
So a child can access all the features from parent, grandparent, great grandparent,
right?
So that's how it works.
Okay, this is working, right?
So we got single where you have one superclass, one subclass, then we have multi-level where
you have superclass, subclass, and then I get subclass of that superclass.
Okay, this is working.
What if you go for multi-pull?
What is multi-pull here?
Let's say the C is not only taking from A and B.
We got some other class as well.
Just for time being, what I will do is I will say B is not inheriting A, okay?
So A and B, they are two different classes.
Nothing, they are not related to each other.
A provides two features, B provides two features, okay?
So there's no relationship between A and B.
They are two different classes.
C says I want to access features from both, from A and B.
So in this case, C will inherit from A and B both.
So you will say A, B.
So C will copy from both, or C will inherit from both.
So we will say C1.
The moment you say C1, you can see you can access all the features.
That's not the case with B1 now.
B1 can only access two features, feature three and feature four,
because B is not inheriting A, okay?
Point to remember, so we got A, we got B, and then we got C.
C is inheriting both the classes, A and B.
So this is called as multi-pull.
So this is your multi-pull, right?
So we have done with single, we have done with multi-level,
and then we have multi-pull.
So this is how we can work with inheritance.
Now to this point, we have talked about UPS concept, right?
In which we have seen inheritance, right?
Now what is inheritance?
If you already have some classes, and if you want to use the existing features,
you will simply say class B, which will take the features from A, right?
So class B inherits A, or you can go with a concept of multiple inheritance,
where one class will extend from two different classes,
or more than two classes, right?
So in this case, we have class A, class B, and then we have class C,
which has a feature five, but it is also inheriting A and B,
so we can say C has five features, right?
So that makes sense.
Now what we'll do in this video is we'll talk about two topics.
The first one is the constructor in inheritance, how it behaves,
and we'll also talk about method resolution order, or you can say MRO.
So let's start with the constructor.
Time bin, let's ignore C, okay?
So let's say we don't have this C, so we'll ignore that part,
and in fact, we'll delete that part from time bin.
And let's focus only on A and B, where B is inheriting A, okay?
So in total, in B, we have four features, right?
Now what happens is if I create an object of A, so let's say if I say A1
is equal to constructor of A, so this will work, right?
So when you say A bracket, that's a constructor, it will call a method which is in it.
Now, even if you don't define it, it is there somewhere, right?
But let me define my own constructor, own init here.
So I will set def, and we'll define the init method, and
this init method will print one stuff, so I will say print in A init.
Nothing much, we are not doing anything extra here,
we are just printing in A init, that's it.
Now what do you think, what it will print?
Of course, we are creating object of A, right?
So it will only execute A.
See, with the object of A, you cannot access features of B, okay?
So even if I try example, if I say A1.
You can only access feature one and feature two.
But yes, if you have an object of B, you can access all the features, right?
Features from A and B, because B is a subclass and A is superclass.
And as I mentioned, subclass can access all the features from superclass, but
that's not vice versa, right?
A superclass cannot access all the features of subclass, not even one feature of subclass.
Okay, this is fun.
Now, what if I create object of B?
So I'm not getting object of A here, I'm getting object of B.
Doesn't matter what is A1 or B1, important is if I create an object B,
create call the constructor, that's the question.
Because we are not getting object of A, we are getting object of B.
Will it call the constructor of A?
That's the question.
Let me just run this code and it works, okay?
So even if you have the object of B, it will still call the constructor of A, right?
That's how it works.
But what if you have your own constructor?
What if you have your own init method?
Example in B, see in B, we don't have that init, right?
And that's why it's going up.
So let me repeat, since we don't have init inside of B,
that's why it is going to A.
But what if you already have an init with you?
So I will simply copy paste here in B.
So both have init, but then in this, I will print in B init, right?
So in A, we are printing in A init, in B, we are printing in B init.
So this makes sense.
Now, if I run this code, what it will print?
It will print in A init or in B init.
Of course, if you are getting object of B, it should only call the init of B, right?
And let's see if that works.
And let me just run this code and we are right.
So when you run the code, you can see we only got in B init.
So that means if you create an object of B, first it will try to find the init of B.
If it is not there, then it will go for A.
Okay, that's the point you have to remember.
But what if you also want to call the init of A?
Is it possible?
I mean, if I create an object of B, can I call the init of both the classes?
I mean A and B.
See, by default, it will call only B, right?
What if I want to call A as well?
And that's where we have a very special keyword or a method you can say, and that is super.
So with the help of super, so you can say super and it's a method basically.
So you will say super dot.
The moment you say super, you can access all the features of the parent class.
So we can say super dot init.
So what we are doing is we are trying to call an init method of class A.
So the moment you say super, you are representing the super class, okay?
Which in this case, it is A.
So we are trying to call the init method of class A.
That's important.
And now let's run this code and you can see we got both the output.
We got in A int and we got in B int.
So point to remember is when you create an object of B, it will call the init of B first.
And then from the init of B, you're trying to call the init of A.
So it will jump up, it will execute the init of A first, which will print in A in it.
And then it will come back to print in B in it, okay?
That's why we got the output.
So this makes sense.
So we can work with constructor in inheritance, right?
Now let me add a twist here.
So what I will do is I will remove this super from here.
Let's clean it.
And I will not even say that this is B.
So class A and class B, two different things, okay?
They're not linked with each other.
But then we have class C.
As we have done earlier, we'll say class C.
And class C will inherit both the classes A and B, okay?
And now if I say def and init, you know, right?
What we are trying to do here, first of all, we'll print in C in it, okay?
And then I will create an object of C.
So there's no object of A and B, I'm trying to object of C.
Now what do you think?
Will it call the init of C or A or B?
Of course, right, when you say the object is of C, it will call the init of C only.
Let's run this code.
And that's right, we got the output as in C in it.
So this works perfectly.
But what if you want to call the init method of a superclass?
But there's a twist here.
Now C has two superclasses, right?
One is A and B.
The moment you say super, dot init.
Now what do you think?
Which init it will call?
Will it call the init of A or B?
That's a question.
Let's run this and let's see what happens.
The moment you send this, run this code, you can see it says in A init.
That means we are unfair here.
We are biased towards A.
We are not taking B here, right?
This is completely wrong.
But the thing is, we have a concept of MRO, which is method resolution order.
So what happens is, whenever you have this multiple inheritance,
it will always start from left to right.
Which means, so first, so the moment you say init,
it will try to find the init of itself.
So since we have init here, it will execute the init of C.
Then the moment you say super, dot init, now we have two classes, like A and B.
And on the left side, we have A and on the right side, we have B.
So it will prefer left one first.
So it goes from left to right.
And that's something you have to remember.
It's always from left to right, okay?
And that's why we got in A init.
The same thing can be done for methods.
Example, let's say, we have two methods which are same.
So in this case, you can see we have feature one in A and feature one in B.
Both are the same methods with the same name, of course.
And in this, I will print some different message.
Here I will print feature one A and here I will say feature one B.
That means the feature one is in A and feature one is in B.
And now, if I try to call, so I will say a one dot feature one.
Will it call from A or B?
That's a question and we know the answer, right?
It will always call from A because it goes from left to right.
And you can see the output.
So this is something you have to remember, which is a concept of method resolution order.
So basically, in this video, we have talked about three things.
The first one is how constructor behaves in inheritance.
The second one is how to use that super method.
And the third one is MRO, which is method resolution order.
Now, in fact, with the help of super method, it can be called function.
Let's see that.
So let's say from, we have a function here, which is def and I will say feature.
Feed, that's it.
And in this, I'm trying to call the method of super class, right?
So we can say super dot and we can use that thing, okay?
So you can say super dot feature two.
And let's see if it is working.
Let me call feature.
It should call the feature two.
So yes, it works.
So you can also use super method to call other methods as well, not just in it.
So to represent this super class, we use super method, okay?
Now, we have started talking about objects, right?
Then we move towards class and then we have discussed about inheritance.
Now, it's time to focus on one of the major concept in hopes, which is polymorphism.
Oh, that's a weird word, right?
Now, when you talk about polymorphism, it's break down this word poly and morphism.
So poly means many, right?
And when you say morph, it means forms.
So that means one thing can take multiple forms.
Example, like as human, we have different forms.
As the situation changes, we change ourselves, right?
Example, we behave differently, different location at office.
We behave differently when we are with our friends.
We behave differently.
So we are polymorphic.
In the same way, when we talk about object-oriented, objects will have multiple forms.
So this concept is very important when you talk about software development.
So we use this concept a lot when it comes to loose coupling, dependency injection.
We also have a concept of interfaces, which we'll see later.
There are four ways of implementing polymorphism.
The first one is duct typing in Python.
The second one is operator overloading.
Then we have method overloading and method overriding.
In the next few videos, we're going to talk about all these topics, okay?
And one of the interesting one is duct typing.
Especially if you're coming from different background, let's say,
if you have already seen Java or C++ or C sharp, this has been different for you.
Because in Java or in C sharp, we have to mention the type of the variable
which you work with, right?
We have to mention the type of object you work with.
But Python, we have something different, right?
In the last video, we have talked about polymorphism, right?
Which simply means you have one thing which will behave in a different way.
Or you can say one thing and multiple forms, right?
That is many forms.
Now, in this video, we'll talk about the first way of doing that.
And that is your duct typing.
I know that's a weird word, right?
Duck typing.
We have this famous line, which is, if there's a bird which is walking like a duck,
which is quacking like a duck, and which is swimming like a duck,
that bird is a duck, right?
Which simply means it doesn't matter if it's a duck or not.
What matters is the behavior of that bird.
If it is matching with duck, that's a duck, right?
Now, how do you implement that in programming?
So what we will do here is let's take an example.
Let's say if I have x equal to 5.
Now, we talk about a type.
Now, in Python, we have a concept of dynamic typing,
which simply means the type you can mention later.
Example, when you say x equal to 5, the type which we are representing now is integer.
But what if you say x equal to, let's say, Navin?
What if we're changing the type of x here?
See, that's not the case.
What is happening here is, when you say 5, in your memory,
you got a space which is of type integer.
When you say Navin, in your memory, you got a space which is of type string.
The x is just a name to it, okay?
So when you say x equal to 5, there is an object of type integer.
You are just naming it as x.
Later, when you say you got Navin, you got some space in your memory,
and you are representing that with x.
x is just a name to it, okay?
So we don't have specific type to x.
The moment you say type of x, you're actually getting the type of 5.
When you say the type of x, you are getting the type of Navin, right?
So that's one thing you have to remember.
The moment you give a variable name, that's just a name to a memory.
Now, to understand that typing what we'll do is, we'll take another example.
To explain this, what we'll do is, I will create a class and
we'll name this class as laptop.
And this laptop class will have a method which is, let's say, code.
So in this code, what I will do is, I want to execute my code, right?
So as a programmer, what we do is we write code, right?
We write code and we compile it, we run it, and we get the output at the end.
But then to do that, we also need an IDE, which is Integrated Development Environment.
And in this case, if you want to write a code, you need to pass an IDE.
So we are expecting in the arguments that someone will pass an IDE to us.
And using this IDE, I will say IDE.execute.
So the question is, the IDE is of what type?
Is it a type of integer?
Is it a type of float?
Is it a type of string?
Now, of course, when you say execute, that means there's something which is not there
in the existing classes which you have.
That means the type of IDE is something very unique and
something which is user is defining, right?
That means if you want to create this object IDE, you need to create your own class.
Let me get a class here and I will call this class as PyCharm.
Now, for different languages, we use different IDEs.
In fact, for one language, we have multiple options, right?
For example, when you work on Java, maybe you will be using NetBeans,
Eclipse, IntelliJ, for Python as well, we have different IDEs.
We are using PyCharm here because it works well.
Now, when you say PyCharm, of course, it will have a method, right?
So let me define a method which is def execute.
So you can see we have these two statements.
The moment you say execute, it will say compiling and running.
That's what you do, right?
Your code gets compiled and your code get run.
Now, will this work?
Of course not because we are not calling anything.
So when you run this code, you will not get any output.
Let me just try it out.
Right click and say run demo.
You can see there's no output because we are not calling methods.
Let me call code.
The way you call code is by creating the object of laptop first
because you cannot call code without laptop.
So I will say lap one is equal to laptop.
And with the help of lap one, now you can call code.
So you can say lap one dot code.
But there's one problem here, which is inside a code,
you have to pass an argument, which is of IDE.
That's a question now.
How do you pass an IDE here?
So what I will do is first you need to create an object of IDE.
You will say IDE, of course, you can have different names here,
but let me go with IDE.
So IDE equal to this will be of type pycharm.
So the type of IDE we are working with is pycharm, right?
Which is usually fine, of course.
And then when you are calling code, you have to pass IDE.
And now it should work.
You can see from this code you got compiling and running.
So the type of IDE here is pycharm.
But is it fixed?
Can we change the type of IDE later?
Maybe let's say we have one more IDE.
Let's say in future, I'm creating my own editor,
which is way better than pycharm, maybe.
And in that as well, we have the same method, let's say execute.
And in that, I'm doing some extra stuff.
So my IDE also does spell check.
Maybe pycharm does that.
My IDE also does what?
Convention checks, the name of the variable and different stuff.
And then it also does compiling and running.
So my IDE does extra stuff.
Now what if I want to change the type of IDE?
Is the IDE type fixed to pycharm?
Not exactly, because this is dynamic typing.
So you can replace this IDE type from pycharm to editor provided.
You have that method, which is execute.
It doesn't matter which class object you're passing.
What matters is that object should have the execute method.
Because in IDE, we are saying execute.
So now even if you change from myCharm to myEditor,
there is no problem.
The code will still work.
Provided you have that method.
So if you should be having this method, which is execute.
And that's the case.
If there's a bird, and if that bird behaves like a duck,
it walks like a duck, it quacks like a duck,
it swims like a duck, it should be a duck.
In the same way, if there is an object, which is IDE,
and it has a method execute, that's it.
We are not concerned about which class object it is.
What we are concerned about,
it should have that method, which is execute.
And that is called as duck typing.
And it is amazing.
And if you're coming from different background, like Java,
so we have a concept of interfaces, right?
So that's what we do.
We create interface, and we have this myEditor
and pyCharm as a class, which will implement that interface.
But if you are new to this programming, don't worry.
That's the other part, right?
This is simple.
We have started talking about polymorphism, right?
And in that, we have seen one example of duck typing.
Now in this video, we'll talk about operator overloading.
So what is operator overloading?
So we know the concept of operators, right?
So we have two operands.
Example, if you want to add two numbers,
you can say five plus six,
where five and six are your operands,
and plus is the operator.
So we know that, right?
And then we have a concept of polymorphism.
So it simply means you have one thing
which has multiple forms, right?
Now if you can think about this,
we have two integers, and then we are trying to add them.
We can also add an integer and a float, right?
So in different programming language, it does support.
What about two strings?
So if you say you have two strings,
let's say hello plus world, will it work?
And the answer is yes, right?
So plus works with the strings as well.
But what if you want to say you have a number five?
So let's say we got a and a is five, right?
And then we got b and b is let's say world.
Now can I print by saying a plus b?
The moment you try to run this code,
you can see we got an error.
It says unsupported operand types for plus.
So we cannot use int and string for plus, right?
So all these things are predefined.
All these things they are called as a synthetic sugar,
which simply means it is trying to simplify
the code for the user.
See, behind the same things are a bit different.
Imagine this one.
Example if I say a is five and b is six.
Now what do you think?
What is happening behind the scene?
Now trust me, whatever happens in Python
happens with the help of object, right?
And here as well, when we talk about a and b,
the type of it is int, right?
So int is a class here.
And when you say class, of course,
class will have certain methods, right?
So behind the scene, what is happening is
when you say a plus b, which is of type integer,
it is calling something.
So behind the same, it is calling int dot.
The moment you say int dot, int is a class, right?
Then you can see we have a method called as init.
We have a method called as abs
and we also have a method called as add,
which is very important here.
The moment you say int dot add,
this is taking two parameters, okay?
The first one is a comma b.
So what we are doing here in print a plus b,
the same thing can be done here.
Let me just run this code here.
You can see we got the same output.
So both are printing 11.
So you can say a plus b or you can say int dot add
by passing two parameters a comma b.
And of course, the first one looks cool, right?
You're simply saying a plus b
because from our childhood we are doing that.
We are trying to add numbers using plus operator.
But the moment you come to programming
whatever you want to do,
you will be doing that with the help of methods.
And add is a method which belongs to the int class, right?
If I jump to integer,
so you can press on the control button
and click on the method which you want to see
or the class which you want to see.
You can see it's a class
and this class has multiple methods.
In the same way, the moment you say int dot,
you can access a method called as add
and you're calling a comma b.
So even if you say a plus b behind the scene,
this is getting called, right?
So this is one thing you have to remember, okay?
So we'll talk about operator overloading later
but this is something you have to remember.
So whenever you add two numbers,
this is what is getting called behind the scene.
Now if these two things are strings,
so if I make a string here,
now this is not integers, right?
They are strings, so I have to say str dot add.
Now when you say str dot add,
in fact str also has an add method
which takes two parameters
and both should be of the same type,
which is string type and then it will work, right?
So if I run this code and you can see it is working.
So we got five and six as a string.
So they got concatenated here.
So this works.
The moment you change the type of it, it will not work
because the inbuilt class doesn't have two things
which is integer and string together, right?
So this thing you have to remember.
Now once we know the moment you add a plus operator,
it calls the add method.
The moment you put a minus operator,
it will call a submeter.
The moment you use a star symbol
which is multiplication, it will call mul method.
So we have different methods for different operators, right?
And normally those things are called as magic methods
but that's what they say magic methods, right?
So all these operators behind the scene,
they work as methods.
Now to understand the concept of operator overloading,
what I will do is I will say class
and let's say we have a student class
and every student will have let's say two variables
and that will be marks one and marks two
just to keep it simple.
So what I will do here is I will set def and init
and here I will say self dot m one is equal to oh,
now we want the value from the user, right?
So, or maybe I want to pass the value.
So I will pass it from here m one comma m two
and let's specify self dot m two is equal to m two.
So we got these two values, right?
Now what I want to do is I want to create two objects, okay?
Two students object, one is let's say s one
is equal to student and this will take two values.
I would say 58 comma 69, that's the value here
and then s two is equal to student
and this student will have let's say 60 comma 65.
So we got two marks here, right?
We got two student and each student have two marks.
Now I want to apply the operator here
which is plus operator.
So I want to add these two students.
So the moment I say s one plus s two,
I want a different student object, right?
Is it possible to do that?
Let's try.
So I will say s three is equal to s one plus s two
because now we know that plus operator means
it will add two values
but it is possible with the help of integer.
It is possible with the help of string.
Is it possible to use plus operator with student class?
That's a question.
So let's run this code.
Let's see what happens.
Okay, we are not printing the value of s three
but let's run this code.
The moment you try to run this code, you will get an error.
Oh, okay.
We got different error here.
It says student takes no argument
but it is taking arguments, right?
What's wrong?
Oh, we have written the wrong name, my bad.
Let's run this code once again.
So I was expecting this error, not the first one.
And the error is it says unsupported operant type plus.
We cannot use plus between student and student
because we have not defined it, right?
If you remember behind the scene,
even if you use plus with integers,
it will be calling an add method.
But if you see our class,
we don't have that add method, right?
Because if you say s one plus s two,
how your compiler, how your Python will know what to do?
And that's where you have to define it.
Yeah, that's where you have to say,
hey, the moment anyone says plus of a student,
you need to call this method called as add.
Okay, so you can overload the operator
and you can change definition for it.
You can define anything you want, right?
So I can say add.
And this add will take two parameters.
The first one is self comma other.
And you can see it takes two parameters, self and other.
Okay, guess what is happening?
So behind the scene, this code is getting converted
into it is student dot add,
which takes two parameters, s one comma s two.
So what is self and what is other here?
So the first parameter is self
and s two is the other parameter.
You can change the variable name, that's fine, okay?
You can say this is O and it should work.
It's a variable name, right?
So this is what is getting called behind the scene, right?
So here what I will do is I will say,
let's take two variables, m one,
m one is equal to self dot m one,
and m two is equal to self dot m two.
So we got two variables, right?
Oh, not just self m one plus,
it is other dot m one plus other dot m two.
So this is how you add values, right?
So self m one and other m one,
and then m two will have the addition
of self m two and other m two.
So this works.
And once you've got these two values,
what you will be doing is you will be getting
a new student object, we'll call it s three,
you can have any name as a matter.
So s three is equal to student
by passing these two values, m one comma m two.
And now once you've got this student,
you will return s three here, right?
That is what you're expecting.
So the moment you say s one plus s two,
it will return the value,
it will return a new object of student
and you will assign that to s three, okay?
So this is what will happen.
Now if I print the value for s three,
I will let me print s three dot m one.
And the moment you run this code, run,
and you can see it works, we've got one, one, eight.
Is it right?
Of course it should be, right?
So it is 58 plus 60 and that's right.
We got one, one, eight.
This thing is working, right?
Perfect.
So if you want to add two students,
you need to overload the operator of plus
because integer knows what is plus,
string knows what is plus.
Your student class don't know what is that plus means.
So plus means call the add method,
but we don't have an add method here.
So we have to define our own method.
The same thing can be done with subtraction,
which is minus.
The same thing can be done with multiplication.
So I would recommend you to explore more on this, you know?
So the moment you say def underscore underscore,
you can see we have so many methods.
We also have greater than, we also have equal to symbol.
We can compare two objects.
We can say the different methods are available here, okay?
So try it out.
We also have multiplication somewhere.
So you can see we also have mull.
So everything is predefined, you can just use them.
In fact, for this example, I will take one more.
I want to compare if two objects are getting all equal.
To example, if I say if S1 is greater than S2,
this is the horrible way of comparing students
because marks is not a criteria
where you can compare students.
But just for the example, I will say S1 wins.
So whoever has maximum marks, I will say they win.
I will say else, print S2 wins.
So what we're trying to do here
is whoever has maximum marks, they will win.
But when you say maximum marks, how do you check it?
Because we are not defining it, right?
So maybe I want to check only first marks, which is m1,
or maybe I want to check m2,
or maybe the addition of both.
We can try it out.
So what I will do here is, this will work, of course not,
because the moment you try to run this code,
it will give you an error by saying
the greater than symbol not supported
between two instances of student.
It is supported for integers because it is predefined.
So here as well, if you want to make it work,
you have to define a function of method, which is gt.
gt is greater than, ge is greater than equal to.
So you want to check only greater than.
And then here you'll be using self and other as usual,
because behind the scene, that is what is happening.
It is saying student.gt, and it's passing two variables,
s1, s2.
So s1 goes to self, s2 goes to other.
And now, how do I compare?
So we'll say s1 doesn't matter, is it s1 or something?
So we'll say s1 is equal to self.m1 plus self.m2.
And we'll say s2 is equal to other.m1 plus other.m2.
So we are adding their marks basically.
You can compare.
If s1 is greater than s2, now this time s1, s2,
they're not objects, okay?
They are simple variables of integer.
Okay, if I get confused with this, let me just make it r.
That should make sense.
So let's compare r1 and r2.
Now those are just marks, right?
If r1 is greater than r2, we will say return true,
else return false.
Simple.
Now if you're on this code, we are comparing it, right?
Let's compare and let's run and it worked.
You can see s1 wins, right?
Because s1 values are higher.
So 58 plus 69 is higher than 60 plus 65.
But what if I change the value for s2?
Let's say there's 69 and you can see, of course,
now s2 is bigger, so let's run this code.
And you can see it says s2 wins, so that's right.
So what we are doing is we are adding those values
and then we are comparing it.
So if you want to perform any operation on the objects
which I usually find, you have to define all these methods.
Okay, there's one more.
What if you have a variable, let's say a is equal to nine?
The moment you say print a, and you can see
it will print the value of a, there's nothing wrong with that.
You can see it is printing the value of a.
Now is it printing the address of it?
That's not the case.
Why it is not printing the address of a?
It is printing the value of a.
But what happens, the moment you try to print s1,
it will not print the values of s1.
It will try to print the address of s1.
Okay, so you can see that it says it's a student object
at the address at this position.
Okay, we don't want that address, right?
We want values.
What is happening?
So when you try to print the object,
doesn't matter is it integer or your class,
behind the scene, it is calling a method called as str.
It is happening behind the scene, okay?
Even if you don't call it, it is happening behind the scene.
So the moment you say print a,
it will try to call a.str.
And that's why you're getting the output, right?
You're getting nine because it is calling str.
In the same way, the moment you say s1,
even this is calling str, right?
And now if you run this code,
you can see it is still giving the same output.
That means it is calling str.
What is this str?
So if I click on this, you can see it is in built-in.
So even if you don't define str function
or method in your own class,
it is getting defined somewhere.
And that definition, what is printing?
It is printing the module name.
It is printing the name of the class
and it is printing the object address.
We don't want that, we want values, right?
That means we need to override this method.
So what I will do is I will say def
and the method name is str,
so you have to define this by yourself.
So we want to return the value of m1 and m2, right?
So you will say self.m1, self.m2.
And now if I run this code,
it will return a tuple, of course.
Let's run this code and you got it.
Can you see that we got 58 and 69.
So now if you want to print the object,
it will not print the address,
it will print the values, right?
Because we are overriding the str.
So if you remove str,
if you run this code, you got an error.
So it is returning a non-string value.
We have to return a string value.
How do we do that?
Because by default, when you say print,
you want to print a string, right?
So what you will do is you will use a format here.
So you can say curly packets,
curly packets, you're printing two stuff, dot, format.
And inside this format, you can pass this to value.
So what will happen is those curly packets
will be replaced by these values.
So you are returning a string now.
And we have seen that before, right?
So let's run this code and it worked.
You can see it got 58 and 69.
So even if you say print S1, it does work.
You can also print S2 if you want.
And let's run this code.
And you can see we got 69 and 65.
So that's perfect.
So this is how you work with operator over-loading.
Okay, so point to remember is,
whenever you perform any operator-like addition,
subtraction, deletion,
behind this scene, we are calling methods, okay?
So for plus, we use add method,
for minus, we use sub-method.
And for star, we use multi-method.
In fact, we have a list of methods there.
In the last video, we have talked about
operator over-loading, right?
Which simply means you have operator-like plus,
minus, or division, or multiplication.
So the operator will remain same,
but the operands will change, right?
The type of parameters we are passing, it will change.
Example, when you say plus,
we are calling the add method, right?
And add method takes different types of parameters
or different types of arguments.
So that is over-loading.
So it simply means you have the same method name,
but the arguments are different.
Or maybe the number of arguments
or the type of arguments are different.
In the same way, we have two more types in polymorphism.
One is method over-loading and method over-writing.
So what it means?
Let's start with the first one,
which is method over-loading.
Now languages like Java, C sharp,
or any other oops language,
they have this concept of method over-loading,
which is not there in Python.
But what exactly it is?
So it simply means if you have a class,
and in that class if you have, let's say,
two methods with the same name,
but different parameters or arguments,
it is called as method over-loading.
Example, let's say if you have student class,
and in student class if you have two methods,
let's say average.
So we have two methods with the same name, average.
One takes two parameters, one takes three parameters.
This is called as method over-loading.
But in Python, we don't have this concept.
So we cannot create two methods with the same name.
The next one is method over-writing,
which simply means you have two methods
with the same name and same number of parameters or arguments.
Okay, so that means can we create two methods
with the same name and same parameter in the same class?
Of course not, not in the same class.
But let's say if you have a concept of inheritance,
we have class A and class B,
and both the class have the same method
with the same name, same parameter,
this is called as over-writing.
Again, we'll see the impact of that.
Let's start with the method over-loading first.
So if you want to achieve method over-loading,
what I will do is I will just remove this methods from here.
Just to keep it simple, right?
So we got a init method and it is working perfectly.
Let's remove all the extra stuff from here.
We just want to create one object, not even two.
I want to add two numbers.
So I have to create a method, let's say sum,
and this sum will take two arguments.
We'll say A and B.
So I want to add two values, that's it.
Nothing complex, I want to add two numbers.
Now if you want to add two numbers,
I will say S is equal to A plus B,
and at the end, we'll return S.
That's what we want to do here.
We just want to return the value of S.
And if you want to work with that, you will say S1.
In fact, you will print the value, you will say S1 dot sum,
and you want to add two numbers here.
I will say five and nine, and let's see if it is working.
Let's run this code and it works.
You can see we got 14.
So yes, we can create a method in set a class
which takes two parameters
and we can pass two parameters, it works.
What if, if you want to pass three values,
you want to pass five, nine, and six.
Now this is not possible, right?
The moment you run this code, you will get an error
because you are passing three parameters
or you're passing three arguments
and you're accepting only two.
So this will not work.
That means you need to create another method called a sum
which will take three arguments.
That's what we do in other languages.
But here we'll not do that.
Here what you can do is you can also use third variable.
You will say C, you got A, B, and C,
and you will simply say A plus B plus C, right?
So this will work.
So if I run this code and you can see you got 20
and this is what I do, you will get 20.
So we are passing three arguments
and we are accepting three arguments, it will work.
But what if I'm not passing third argument,
I'm passing only two arguments?
And now the problem starts, right?
Because you are expected to pass the third argument as well.
How do we solve this?
To solve this thing, we can use a concept
where you will say A is equal to none.
So this is one option,
the other option we can use the variable length arguments.
If you remember, we have done that before,
the star and variable name.
But this is another option.
You can say all the values are by default none,
which means even if you don't pass the value,
this is default arguments, right?
So even if you don't pass the value,
the default value will be none.
So that means even if you don't pass any value,
example, even if you don't pass five and nine, it will work.
All the values will become none.
I want to pass some values, I will say five comma nine.
I'm passing with two values, right?
Let's start with third one.
Let's say I want to pass three values,
five comma nine comma six.
All these values will be assigned to A, B and C,
respectively, right?
So if I will go to A, nine will go to B,
and six will go to C.
So these values will be replaced by none.
So none will be replaced by these values, right?
So now, once I know this, so we can simply add it.
But what if you're passing two?
So in this case, you will check.
So before adding, you will check.
You will check if A is not equal to none,
B is not equal to none,
and C is not equal to none.
So if none of them are none,
that simply means you're passing three arguments, right?
And if you're passing three arguments,
this is the calculation we have to go for.
You will say S is equal to A plus B plus C,
and you want to declare S outside
so that you can use it from anywhere.
So you will say S is by default zero, and you got this.
Otherwise, if let's say if I'm passing only two arguments,
I'm not passing the third argument,
in that case, it will go to LF.
And inside LF, I will check.
I forgot a colon here.
So inside LF, I will check A if A is not equal to none.
So I'm concerned about A and B.
If they are not none, in that case,
I will say S is equal to A plus B
because we're not concerned about C, right?
And then we can go for one more condition.
What if you pass only one parameter or one argument?
In that case, you will say L's,
and you will say S equal to A.
So when you say only one parameter,
let's say if I'm not passing nine and six,
I'm passing only five.
So it will return five, right?
That's what we want.
So we can do that.
L's part is not required here,
but just to make it more effective,
we can pass one argument, we can pass two arguments,
we can pass three arguments.
That's perfect.
Let's run this code and it worked.
You can see we got 20.
Now, if I pass only five and nine,
even this will work because if you pass only five and nine,
C will get none and it will execute LF.
And you can see we got 14.
Now, if you pass only one value, let's say five.
In this case, if you run this code, you got five, right?
That's how it works.
So this is your method overloading.
So we are overloading methods,
but then we are not doing directly
because it doesn't support in Python,
so we are doing some trick.
The next one is method overriding.
So let's go with that.
Let me just remove this code.
And let's once again take a simple example.
And this time we'll go for A and B.
I love these classes.
So what I'll do is let's say we have a class A, okay?
And in this class A, we have a function.
I will say function name is, or the method name is show.
And in this method, I will simply print in a show.
Now, first of all, before going ahead,
this concept is method overriding.
This is very famous in software industry, you know?
So in future videos, we'll also talk about this thing.
When we talk about interfaces and abstract classes,
this concept is used very heavily, okay?
So make sure that you understand this concept properly.
Maybe with simple example like A and B,
but understanding the concept is important here.
We can go with complex example as well.
Concept is important.
So let's say we got class A, which has a method we just show,
and we are printing in a show.
That's it, nothing fancy.
Now, if I create an object of A here,
so if I go back and if I say A1 is equal to A,
so we are creating object of A, right?
And with the help of this, we can call show.
If you have this code, you can see we got in A show.
That perfectly worked.
Now, what if you create another class?
Let's say class B, okay?
And now imagine this class A is a parent
and class B is a child.
Example, let's say this is my dad and this me.
So we have B here.
And time in, I'm not writing anything here.
We say pass.
I just want to keep it empty.
Okay, so we are keeping it empty.
Let me create object of B, not A,
but let me get object of B.
And let's run this code.
And you can see we got an error.
It says B object has no attribute as show.
Of course, in B, we don't have anything.
At this point, you will use a concept of inheritance
and you will say, hey, B inherits A.
So when you say B inherits A,
it means you will get all the features of A to B.
And let's run this code and you can see if we got in A show.
Because of course, in B, we don't have show.
The moment you run this code,
it will first search for the method show inside B.
Now, since we don't have that,
it will go to A to search it.
And that's how it works.
So before going ahead, let me tell you one story.
A small story.
I've used this story in multiple examples
when I was teaching Java as well.
So the concept is, when I was in my 11th standard,
when I've just joined my college,
I was not having any phone, okay?
So a lot of people used to ask me which phone you have.
So I used to say I don't have any phone, okay?
Because I was not having a phone.
But then this question got repeated multiple times.
Then I realized, okay, I have to say something.
Now, at that point, my father was having a phone
which is Nokia double one, double zero.
I was not having any phone.
So whenever someone used to ask me which phone you have,
I used to say I got Nokia double one, double zero.
I don't have a phone, right?
But my father says a phone.
So father's phone is my phone.
That's how I think it works, right?
So since B and B, my father is A.
So B in hates A, so I got all the features.
In this case, show is in A, right?
In B, we don't have show.
After some time, you know, after a few months,
I got a new phone and that is Motorola phone.
So my father has a Nokia phone and I got Motorola phone.
Now, if you ask me which phone I have,
of course I would say Motorola, right?
I would not say Nokia, right?
Because my phone overwrites my father's phone.
That's what happened here.
The moment you create a show method inside B as well,
and if you try to print in B show,
because when we were not having show inside B,
it was going to A.
Now, since we have show inside B,
it will print the show of B, right?
So if you ask me which phone I have now,
so I will say Motorola, not Nokia, right?
So my phone overwrites my father's phone in the same way.
This show overwrites the earlier show method.
So this is how you work with method overriding.
Again, we'll be doing this concept more in the next tutorials
when we talked about abstract classes or interfaces.
But this is awesome, right?
Remember this point, when you call show,
it will call the show method of this subclass
if you have it, okay?
So that's it, everyone.
I hope you enjoyed this session.
Let me know in the comment section
and do subscribe for the videos.
