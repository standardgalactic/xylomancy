Good afternoon everyone and welcome to MIT Success 191.
My name is Alexander Amini and I'll be one of your instructors for the course this year
along with Ava.
And together we're really excited to welcome you to this really incredible course.
This is a very fast paced and very intense one week that we're about to go through together.
So we're going to cover the foundations of a also very fast paced moving field and a
field that has been rapidly changing over the past eight years that we have taught this
course at MIT.
Now over the past decade in fact, even before we started teaching this course, AI and deep
learning has really been revolutionizing so many different advances and so many different
areas of science, mathematics, physics and so on.
And not that long ago, we were having challenges and problems that we did not think were necessarily
solvable in our lifetimes that AI is now actually solving beyond human performance today.
And each year that we teach this course, this lecture in particular is getting harder
and harder to teach because for an introductory level course, this lecture, lecture number
one, is the lecture that's supposed to cover the foundations and if you think to any other
introductory course like an introductory course 101 on mathematics or biology, those
lecture ones don't really change that much over time.
So we're in a rapidly changing field of AI and deep learning where even these types
of lectures are rapidly changing.
So let me give you an example of how we introduced this course only a few years ago.
Hi everybody and welcome to MIT 6S191, the official introductory course on deep learning
taught here at MIT.
Deep learning is revolutionizing so many fields from robotics to medicine and everything
in between.
You'll learn the fundamentals of this field and how you can build some of these incredible
algorithms.
In fact, this entire speech and video are not real and were created using deep learning
and artificial intelligence.
And in this class, you'll learn how.
It has been an honor to speak with you today and I hope you enjoy the course.
The really surprising thing about that video to me when we first did it was how viral it
went a few years ago.
So just in a couple months of us teaching this course a few years ago, that video went
very viral.
It got over a million views within only a few months.
People were shocked with a few things but the main one was the realism of AI to be able
to generate content that looks and sounds extremely hyper realistic.
And when we did this video, when we created this for the class only a few years ago, this
video took us about $10,000 in compute to generate just about a minute long video.
If you think about it, I would say it's extremely expensive to compute something what we look
at like that.
And maybe a lot of you are not really even impressed by the technology today because
you see all of the amazing things that AI and deep learning are producing.
Now fast forward today, the progress in deep learning and people were making all kinds
of exciting remarks about it when it came out a few years ago.
Now this is common stuff because AI is really doing much more powerful things than this
fun little introductory video.
So today fast forward four years, about four years to today.
Now where are we?
AI is now generating content with deep learning being so commoditized.
Deep learning is in all of our fingertips now online in our smartphones and so on.
In fact, we can use deep learning to generate these types of hyper realistic pieces of media
and content entirely from English language without even coding anymore.
So before we had to actually go in, train these models and really code them to be able
to create that one minute long video.
Today we have models that will do that for us end to end directly from English language.
So we can prompt these models to create something that the world has never seen before, a photo
of an astronaut riding a horse and these models can imagine those pieces of content entirely
from scratch.
My personal favorite is actually how we can now ask these deep learning models to create
new types of software, even themselves being software to ask them to create, for example,
to write this piece of TensorFlow code to train a neural network, right?
We're asking a neural network to write TensorFlow code to train another neural network and our
model can produce examples of functional and usable pieces of code that satisfy this English
prompt while walking through each part of the code independently.
So not even just producing it, but actually educating and teaching the user on what each
part of these code blocks are actually doing.
You can see an example here.
And really what I'm trying to show you with all of this is that this is just highlighting
how far deep learning has gone even in a couple years since we've started teaching this course.
I mean, going back even from before that to eight years ago.
And the most amazing thing that you'll see in this course, in my opinion, is that what
we try to do here is to teach you the foundations of all of this, how all of these different
types of models are created from the ground up and how we can make all of these amazing
advances possible so that you can also do it on your own as well.
And like I mentioned in the beginning, this introduction course is getting harder and
harder to do and to make every year.
I don't know where the field is going to be next year.
And I mean, that's my honest truth.
Or even honestly, in even one or two months time from now, just because it's moving so
incredibly fast.
But what I do know is that what we will share with you in the course as part of this one
week is going to be the foundations of all of the technologies that we have seen up until
this point that will allow you to create that future for yourselves and to design brand new
types of deep learning models using those fundamentals and those foundations.
So let's get started with all of that and start to figure out how we can actually achieve
all of these different pieces and learn all of these different components.
And we should start this by really tackling the foundations from the very beginning and
asking ourselves, you know, we've heard this term, I think all of you, obviously before
you've come to this class today, you've heard the term deep learning, but it's important
for you to really understand how this concept of deep learning relates to all of the other
pieces of science that you've learned about so far.
So to do that, we have to start from the very beginning and start by thinking about what
is intelligence at its core.
Not even artificial intelligence, but just intelligence, right?
So the way I like to think about this is that I like to think that intelligence is the ability
to process information which will inform your future decision-making abilities.
Now that's something that we as humans do every single day.
Now artificial intelligence is simply the ability for us to give computers that same
ability to process information and inform future decisions.
Now machine learning is simply a subset of artificial intelligence.
The way you should think of machine learning is just as the programming ability, or let's
say even simpler than that, machine learning is the science of trying to teach computers
how to do that processing of information and decision-making from data.
So instead of hard coding some of these rules into machines and programming them like we
used to do in software engineering classes, now we're going to try and do that processing
of information and informing a future decision-making abilities directly from data.
And then going one step deeper, deep learning is simply the subset of machine learning which
uses neural networks to do that.
It uses neural networks to process raw pieces of data, now unprocessed data, and allows
them to ingest all of those very large data sets and inform future decisions.
Now that's exactly what this class is really all about.
If you think of, if I had to summarize this class in just one line, it's all about teaching
machines how to process data, process information, and inform decision-making abilities from
that data, and learn it from that data.
Now this program is split between really two different parts.
So you should think of this class as being captured with both technical lectures, which
for example this is one part of, as well as software labs.
We'll have several new updates this year, as I mentioned earlier, just covering the rapid
changing of advances in AI, and especially in some of the later lectures you're going
to see those.
The first lecture today is going to cover the foundations of neural networks themselves,
starting with really the building blocks of every single neural network, which is called
the perceptron.
And finally we'll go through the week, and we'll conclude with a series of exciting
guest lectures from industry leading sponsors of the course.
And finally on the software side, after every lecture you'll also get software experience
and project building experience to be able to take what we teach in lectures, and actually
deploy them in real code, and actually produce based on the learnings that you find in this
lecture, and at the very end of the class from the software side, you'll have the ability
to participate in a really fun day at the very end, which is the project pitch competition.
It's kind of like a shark tank style competition of all of the different projects from all
of you, and win some really awesome prizes.
So let's step through that a little bit briefly.
This is the syllabus part of the lecture.
So each day we'll have dedicated software labs that will basically mirror all of the
technical lectures that we go through, just helping you reinforce your learnings.
And these are coupled with, each day again, coupled with prizes for the top performing
software solutions that are come up in the class.
This is going to start with today with Lab 1, and it's going to be on Music Generation,
so you're going to learn how to build a neural network that can learn from a bunch of musical
songs, listen to them, and then learn to compose brand new songs in that same genre.
Tomorrow, Lab 2, on Computer Vision, you're going to learn about facial detection systems.
You'll build a facial detection system from scratch using convolutional neural networks.
You'll learn what that means tomorrow.
And you'll also learn how to actually de-bias, remove the biases that exist in some of these
facial detection systems, which is a huge problem for the state-of-the-art solutions
that exist today.
And finally, a brand new lab at the end of the course will focus on large language models,
where you're actually going to take a multi-billion parameter large language model and fine-tune
it to build an assistive chatbot and evaluate a set of cognitive abilities, ranging from
mathematics abilities to scientific reasoning to logical abilities and so on.
And finally, at the very, very end, there will be a final project pitch competition
for up to five minutes per team.
And all of these are accompanied with great prizes.
So definitely there will be a lot of fun to be had throughout the week.
There are many resources to help with this class.
You'll see them posted here.
You don't need to write them down, because all of the slides are already posted online.
Please post to Piazza if you have any questions.
And of course, we have an amazing team that is helping teach this course this year.
And you can reach out to any of us if you have any questions.
So Piazza is a great place to start.
Myself and Ava will be the two main lectures for this course, Monday through Wednesday especially,
and we'll also be hearing some amazing guest lectures on the second half of the course,
which definitely you would want to attend, because they really cover the really state-of-the-art
sides of deep learning that's going on in industry outside of academia.
And very briefly, just want to give a huge thanks to all of our sponsors who, without
their support, this course like every year would not be possible.
Okay, so now let's start with the fun stuff, and my favorite part of the course, which
is the technical parts.
And let's start by just asking ourselves a question, which is, why do we care about
all of this?
Why do we care about deep learning?
Why did you all come here today to learn and to listen to this course?
So to understand, I think we, again, need to go back a little bit to understand how machine
learning used to be performed, right?
So machine learning typically would define a set of features, or you can think of these
as kind of a set of things to look for in an image or in a piece of data.
Usually these are hand engineered, so humans would have to define these themselves, and
the problem with these is that they tend to be very brittle in practice, just by nature
of a human defining them.
So the key idea of deep learning and what you're going to learn throughout this entire
week is this paradigm shift of trying to move away from hand engineering features and
rules that computers should look for, and instead trying to learn them directly from
raw pieces of data.
So what are the patterns that we need to look at in data sets, such that if we look at those
patterns, we can make some interesting decisions and interesting actions can come out.
So for example, if we wanted to learn how to detect faces, we might, if you think even
how you would detect faces, if you look at a picture, what are you looking for to detect
a face?
You're looking for some particular patterns, you're looking for eyes and noses and ears,
and when those things are all composed in a certain way, you would probably deduce that
that's a face, right?
Computers do something very similar, so they have to understand what are the patterns that
they look for, what are the eyes and noses and ears of those pieces of data, and then
from there actually detect and predict from them.
So the really interesting thing I think about deep learning is that these foundations for
doing exactly what I just mentioned, picking out the building blocks, picking out the features
from raw pieces of data, and the underlying algorithms themselves have existed for many,
many decades.
Now the question I would ask at this point is, so why are we studying this now, and why
is all of this really blowing up right now and exploding with so many great advances?
Well for one, there's three things, right?
Number one is that the data that is available to us today is significantly more pervasive.
These models are hungry for data, you're going to learn about this more in detail, but these
models are extremely hungry for data, and we're living in a world right now, quite frankly,
where data is more abundant than it has ever been in our history.
Now secondly, these algorithms are massively compute hungry, and they're massively parallelizable,
which means that they have greatly benefited from compute hardware, which is also capable
of being parallelized.
The particular name of that hardware is called a GPU, GPUs can run parallel processing streams
of information, and are particularly amenable to deep learning algorithms, and the abundance
of GPUs and that compute hardware has also pushed forward what we can do in deep learning.
And finally, the last piece is the software, right?
It's the open source tools that are really used as the foundational building blocks of
deploying and building all of these underlying models that you're going to learn about in
this course, and those open source tools have just become extremely streamlined, making
this extremely easy for all of us to learn about these technologies within an amazing
one week course like this.
So let's start now with understanding, now that we have some of the background, let's
start with understanding exactly what is the fundamental building block of a neural network.
Now that building block is called a perceptron, right?
Every single percept, every single neural network is built up of multiple perceptrons,
and you're going to learn how those perceptrons, number one, compute information themselves
and how they connect to these much larger billion parameter neural networks.
So the key idea of a perceptron, or even simpler, think of this as a single neuron, right?
So a neural network is composed of many, many neurons, and a perceptron is just one neuron.
So that idea of a perceptron is actually extremely simple, and I hope that by the end of today,
this idea and this processing of a perceptron becomes extremely clear to you.
So let's start by talking about just the forward propagation of information through a single
neuron.
Now, single neurons ingest information, they can actually ingest multiple pieces of information.
So here you can see this neuron taking as input three pieces of information, x1, x2,
and xm, right?
So we define this set of inputs called x1 through m, and each of these inputs, each
of these numbers, is going to be element-wise multiplied by a particular weight.
So this is going to be denoted here by w1 through wm.
So this is a corresponding weight for every single input, and you should think of this
as really, you know, every weight being assigned to that input, right?
The weights are part of the neuron itself.
Now you multiply all of these inputs with their weights together, and then you add them
up.
We take this single number after that addition, and you pass it through what's called a non-linear
activation function to produce your final output, which here we're calling y.
Now, what I just said is not entirely correct, right?
So I missed out one critical piece of information.
That piece of information is that we also have what you can see here is called this bias
term.
That bias term is actually what allows your neuron to shift its activation function horizontally
on that x-axis, if you think of it, right?
So on the right side, you can now see this diagram illustrating mathematically that single
equation that I talked through kind of conceptually.
Now you can see it mathematically written down as one single equation, and we can actually
rewrite this using linear algebra using vectors and dot products.
So let's do that, right?
So now our inputs are going to be described by a capital X, which is simply a vector of
all of our inputs, x1 through xm, and then our weights are going to be described by a
capital W, which is going to be w1 through wm.
The input is obtained by taking the dot product of x and w, right?
That dot product does that element-wise multiplication and then adds, sums, all of the element-wise
multiplications, and then here's the missing piece, is that we're now going to add that
bias term.
Here we're calling the bias term w0, right?
And then we're going to apply the non-linearity, which here denoted is g, excuse me.
So I've mentioned this non-linearity a few times, this activation function.
Let's dig into it a little bit more so we can understand what is actually this activation
function doing.
Well, I said a couple things about it.
I said it's a non-linear function, right?
Here you can see one example of an activation function.
One common, one commonly used activation function is called the sigmoid function, which you
can actually see here on the bottom right-hand side of the screen.
The sigmoid function is very commonly used because its outputs, right, so it takes as
input any real number, the x-axis is infinite plus or minus, but on the y-axis it basically
squashes every input x into a number between 0 and 1.
So it's actually a very common choice for things like probability distributions if you
want to convert your answers into probabilities or learn or teach a neuron to learn a probability
distribution.
But in fact, there are actually many different types of non-linear activation functions that
are used in neural networks.
And here are some common ones.
And again, throughout this presentation, you'll see these little TensorFlow icons actually
throughout the entire course.
You'll see these TensorFlow icons on the bottom, which basically just allow you to relate
some of the foundational knowledge that we're teaching in the lectures to some of the software
labs, and this might provide a good starting point for a lot of the pieces that you have
to do later on in the software parts of the class.
So the sigmoid activation, which we talked about in the last slide, here it's shown on
the left-hand side, right?
This is very popular because of the probability distributions, right?
It squashes everything between 0 and 1.
But you see two other very common types of activation functions in the middle and the
right-hand side as well.
So the other very, very common one, probably this is the one now that's the most popular
activation function, is now on the far right-hand side.
It's called the relu activation function, or also called the rectified linear unit.
So basically, it's linear everywhere except there's a non-linearity at x equals 0.
So there's a kind of a step or a great discontinuity, right?
So the benefit of this, very easy to compute.
It still has the non-linearity, which we kind of need, and we'll talk about why we need
it in one second, but it's very fast, right?
Just two linear functions piecewise combined with each other.
Okay, so now let's talk about why we need a non-linearity in the first place.
Why not just deal with a linear function that we pass all of these inputs through?
So the point of the activation function, even at all, why do we have this, is to introduce
non-linearities in of itself.
So what we want to do is to allow our neural network to deal with non-linear data, right?
Our neural networks need the ability to deal with non-linear data because the world is
extremely non-linear, right?
This is important because if you think of the real world, real data sets, this is just
the way they are, right?
If you look at data sets like this one, green and red points, right?
And I ask you to build a neural network that can separate the green and the red points.
This means that we actually need a non-linear function to do that.
We cannot solve this problem with a single line, right?
In fact, if we used linear functions as your activation function, no matter how big your
neural network is, it's still a linear function because linear functions combined with linear
functions are still linear.
So no matter how deep or how many parameters your neural network has, the best they would
be able to do to separate these green and red points would look like this.
But adding non-linearities allows our neural networks to be smaller by allowing them to
be more expressive and capture more complexities in the data sets.
And this allows them to be much more powerful in the end.
So let's understand this with a simple example.
Imagine I give you now this trained neural network.
So what does it mean trained neural network?
It means now I'm giving you the weights, right?
Not only the inputs, but I'm going to tell you what the weights of this neural network
are.
So here, let's say the bias term w0 is going to be 1 and our w vector is going to be 3 and
negative 2, right?
These are just the weights of your trained neural network.
Let's worry about how we got those weights in a second.
But this network has two inputs, x1 and x2.
Now if we want to get the output of this neural network, all we have to do simply is to do
the same story that we talked about before, right?
It's dot product, inputs with weights, add the bias, and apply the non-linearity, right?
And those are the three components that you really have to remember as part of this class,
right?
Dot product, add the bias, and apply a non-linearity.
That's going to be the process that keeps repeating over and over and over again for
every single neuron.
After that happens, that neuron is going to output a single number, right?
Now let's take a look at what's inside of that non-linearity.
It's simply a weighted combination of those inputs with those weights, right?
So if we look at what's inside of g, right?
Inside of g is a weighted combination of x and w, right?
Added with a bias, right?
That's going to produce a single number, right?
But in reality, for any input that this model could see, what this really is is a two-dimensional
line because we have two parameters in this model.
So we can actually plot that line.
We can see exactly how this neuron separates points on these axes between x1 and x2, right?
These are the two inputs of this model.
We can see exactly and interpret exactly what this neuron is doing, right?
We can visualize its entire space because we can plot the line that defines this neuron,
right?
So here we're plotting when that line equals zero.
And in fact, if I give you, if I give that neuron, in fact, a new data point, here the
new data point is x1 equals negative one and x2 equals two, just an arbitrary point in
this two-dimensional space.
We can plot that point in the two-dimensional space and depending on which side of the line
it falls on, it tells us what the answer is going to be, what the sign of the answer
is going to be, and also what the answer itself is going to be, right?
So if we follow that equation written on the top here and plug in negative one and two,
we're going to get one minus three minus four, which equals minus six, right?
And when I put that into my non-linearity, g, I'm going to get a final output of 0.002,
right?
So that, that don't worry about the final output, that's just going to be the output
for that sigmoid function.
But the important point to remember here is that the sigmoid function actually divides
the space into these two parts, right?
It squashes everything between zero and one, but it defines it implicitly by everything
less than 0.5 and greater than 0.5, depending on if it's on, if x is less than zero or greater
than zero.
So depending on which side of the line that you fall on, remember the line is when x equals
zero, the input to the sigmoid is zero.
If you fall on the left side of the line, your output will be less than 0.5 because you're
falling on the negative side of the line.
If your output, if your input is on the right side of the line, now your output is going
to be greater than 0.5, right?
So here we can actually visualize this space, this is called the feature space of a neural
network.
We can visualize it in its completion, right?
We can totally visualize and interpret this neural network.
We can understand exactly what it's going to do for any input that it sees, right?
But of course, this is a very simple neuron, right?
It's not a neural network, it's just one neuron.
And even more than that, it's even a very simple neuron.
It only has two inputs, right?
So in reality, the types of neurons that you're going to be dealing with in this course are
going to be neurons and neural networks with millions or even billions of these parameters,
right?
Of these inputs, right?
So here we only have two weights, w1, w2, but today's neural networks have billions
of these parameters.
So drawing these types of plots that you see here obviously becomes a lot more challenging.
It's actually not possible.
But now that we have some of the intuition behind a perceptron, let's start now by building
neural networks and seeing how all of this comes together.
So let's revisit that previous diagram of a perceptron.
Now again, if there's only one thing to take away from this lecture right now, it's to
remember how a perceptron works.
That equation of a perceptron is extremely important for every single class that comes
after today.
And there's only three steps.
It's dot product with the inputs, add a bias, and apply your nonlinearity.
Let's simplify the diagram a little bit.
I'll remove the weight labels from this picture.
And now you can assume that if I show a line, every single line has an associated weight
that comes with that line, right?
I'll also remove the bias term for simplicity.
Assume that every neuron has that bias term.
I don't need to show it.
And now note that the result here now calling it Z, which is just the dot product plus
bias before the nonlinearity, is the output is going to be linear.
First of all, it's just a weighted sum of all those pieces.
We have not applied the nonlinearity yet.
But our final output is just going to be G of Z.
It's the activation function, or nonlinear activation function applied to Z.
Now, if we want to step this up a little bit more and say, what if we had a multi-output
function?
Now we don't just have one output, but let's say we want to have two outputs.
Well, now we can just have two neurons in this network, right?
Every neuron sees all of the inputs that came before it.
But now you see the top neuron is going to be predicting an answer, and
the bottom neuron will predict its own answer.
Now, importantly, one thing you should really notice here is that each neuron
has its own weights, right?
Each neuron has its own lines that are coming into just that neuron, right?
So they're acting independently, but
they can later on communicate if you have another layer, right?
So let's start now by initializing this process a bit further and
thinking about it more programmatically, right?
What if we wanted to program this neural network ourselves from scratch, right?
Remember that equation I told you didn't sound very complex.
Let's take a dot product, add a bias, which is a single number, and apply a non-linearity.
Let's see how we would actually implement something like that.
So to define the layer, right, we're now going to call this a layer,
which is a collection of neurons, right?
We have to first define how that information propagates through the network.
So we can do that by creating a call function here.
First, we're going to actually define the weights for that network, right?
So remember every network, every neuron, I should say,
every neuron has weights and a bias, right?
So let's define those first.
We're going to create the call function to actually see how we can pass
information through that layer, right?
So this is going to take as input an inputs, right?
This is like what we previously called x.
And it's the same story that we've been seeing this whole class, right?
We're going to matrix multiply or take a dot product of our inputs with our weights.
We're going to add a bias, and then we're going to apply a non-linearity.
It's really that simple, right?
We've now created a single layer neural network, right?
So this line in particular, this is the part that allows us to be
a powerful neural network maintaining that non-linearity.
And the important thing here is to note that modern deep learning
toolboxes and libraries already implement a lot of these for you, right?
So it's important for you to understand the foundations.
But in practice, all of that layer or architecture and
all of that layer logic is actually implemented in tools like TensorFlow and
PyTorch through a dense layer, right?
So here you can see an example of calling or creating, initializing
a dense layer with two neurons, right?
Allowing it to feed in an arbitrary set of inputs.
Here we're seeing these two neurons in a layer being fed three inputs, right?
And in code, it's only reduced down to this one line of TensorFlow code,
making it extremely easy and convenient for us to use these functions and call them.
So now let's look at our single layered neural network.
This is where we have now one layer between our input and our outputs, right?
So we're slowly and progressively increasing the complexity of our neural
network so that we can build up all of these building blocks, right?
This layer in the middle is called a hidden layer, right?
Obviously because you don't directly observe it, you don't directly supervise it, right?
You do observe the two input and output layers, but
your hidden layer is just kind of a neuron layer that you don't directly observe, right?
It just gives your network more capacity, more learning complexity.
And since we now have a transformation function from inputs to hidden layers and
hidden layers to output, we now have a two layered neural network, right?
Which means that we also have two weight matrices, right?
We don't have just the W1, which we previously had to create this hidden layer,
but now we also have W2, which does the transformation from hidden layer to output layer.
Yes?
What happens with the non-linearity of hidden?
You have just linear, so there's no, is it a perceptron or not?
Yes, so every hidden layer also has a non-linearity accompanied with it, right?
And that's a very important point because if you don't have that perceptron,
then it's just a very large linear function followed by a final non-linearity at
the very end, right?
So you need that cascading and, you know,
overlapping application of non-linearities that occur throughout the network.
Awesome.
Okay, so now let's zoom in, look at a single unit in the hidden layer.
Take this one, for example, let's call it Z2, right?
It's the second neuron in the first layer, right?
It's the same perception that we saw before.
We compute its answer by taking a dot product of its weights with its inputs,
adding a bias, and then applying a non-linearity.
If we took a different hidden node, like Z3, the one right below it,
we would compute its answer exactly the same way that we computed Z2,
except its weights would be different than the weights of Z2.
Everything else stays exactly the same, it sees the same inputs.
But of course, you know, I'm not going to actually show Z3 in this picture.
And now this picture is getting a little bit messy.
So let's clean things up a little bit more.
I'm going to remove all the lines now and replace them just with these boxes,
these symbols that will denote what we call a fully connected layer, right?
So these layers now denote that everything in our input is connected to everything
in our output, and the transformation is exactly as we saw it before,
dot product, bias, and non-linearity.
And again, in code, to do this is extremely straightforward with the
foundations that we've built up from the beginning of the class.
We can now just define two of these dense layers, right?
Our hidden layer on line one with n hidden units, and
then our output layer with two hidden output units.
Does that mean the non-linearity function must be the same for layers?
Non-linearity function does not need to be the same through each layer.
Oftentimes it is because of convenience.
There are some cases where you would want it to be different as well,
especially in lecture two, you're going to see non-linearity is be different,
even within the same layer, let alone different layers.
But unless for a particular reason, generally convention is there's
no need to keep them differently.
Now, let's keep expanding our knowledge a little bit more.
If we now want to make a deep neural network, not just a neural network like
we saw in the previous slide, now it's deep.
All that means is that we're now going to stack these layers on top of each other,
one by one, more and more creating a hierarchical model, right?
The ones where the final output is now going to be computed by going deeper and
deeper and deeper into the neural network.
And again, doing this in code again follows the exact same story as before.
Just cascading these TensorFlow layers on top of each other and
just going deeper into the network.
Okay, so now this is great because now we have at least a solid foundational
understanding of how to not only define a single neuron, but
how to define an entire neural network.
And you should be able to actually explain at this point or understand how
information goes from input through an entire neural network to compute an output.
So now let's look at how we can apply these neural networks to solve a very
real problem that I'm sure all of you care about.
So here's a problem on how we want to build an AI system to learn to answer
the following question, which is, will I pass this class, right?
I'm sure all of you are really worried about this question.
So to do this, let's start with a simple input feature model.
The feature, the two features that let's concern ourselves with are going to be
number one, how many lectures you attend.
And number two, how many hours you spend on your final project.
So let's look at some of the past years of this class, right?
We can actually observe how different people have lived in this space, right?
Between how many lectures and how much time you've spent on your final project.
And you can actually see every point is a person.
The color of that point is going to be if they passed or failed the class.
And you can see and visualize kind of this feature space, if you will,
that we talked about before.
And then we have you.
You follow right here.
You're the point four or five right in between this feature space.
You've attended four lectures and you will spend five hours on the final project.
And you want to build a neural network to determine, given everyone else in the
class, right, that I've seen from all of the previous years, you want to help,
you want to have your neural network help you to understand what is your
likelihood that you will pass or fail this class.
So let's do it.
We now have all of the building blocks to solve this problem using a neural network.
Let's do it.
So we have two inputs.
Those inputs are the number of lectures you attend and
number of hours you spend on your final project.
It's four and five.
We can pass those two inputs to our two X1 and X2 variables.
These are fed into this single hidden layered neural network.
It has three hidden units in the middle.
And we can see that the final predicted output probability for
you to pass this class is 0.1 or 10%, right?
So very bleak outcome, it's not a good outcome.
The actual probability is one, right?
So attending four out of the five lectures and spending five hours on your final project,
you actually lived in a part of the feature space which was actually very positive, right?
It looked like you were going to pass the class.
So what happened here?
Anyone have any ideas?
So why did the neural network get this so terribly wrong, right?
Exactly.
So this neural network is not trained.
We haven't shown it any of that data, the green and red data, right?
So you should really think of neural networks like babies, right?
Before they see data, they haven't learned anything.
There's no expectation that we should have for
them to be able to solve any of these types of problems before we teach them
something about the world.
So let's teach this neural network something about the problem first, right?
And to train it, we first need to tell our neural network when it's making bad
decisions, right?
So we need to teach it, right?
Really train it to learn exactly like how we as humans learn in some ways, right?
So we have to inform the neural network when it gets the answer incorrect so
that it can learn how to get the answer correct, right?
So the closer the answer is to the ground truth, so right?
So for example, the actual value for you passing this class was probability 100%.
But it predicted a probability of 0.1.
We compute what's called a loss, right?
So the closer these two things are together, the smaller your loss should be,
and the more accurate your model should be.
So let's assume that we have data not just from one student, but
now we have data from many students.
Many students have taken this class before, and we can plug all of them into
the neural network and show them all to this system.
Now we care not only about how the neural network did on just this one prediction,
but we care about how it predicted on all of these different people that
the neural network has shown in the past as well during this training and
learning process.
So when training the neural network, we want to find a network that minimizes
the empirical loss between our predictions and those ground truth outputs.
And we're going to do this on average across all of the different inputs
that the model has seen.
If we look at this problem of binary classification, right?
Between yeses and nos, right?
Will I pass the class or will I not pass the class?
It's a zero or one probability.
And we can use what is called the softmax function or
the softmax cross entropy function to be able to inform if this network is
getting the answer correct or incorrect, right?
The softmax cross, or the cross entropy function,
think of this as an objective function.
It's a loss function that tells our neural network how far away
these two probability distributions are, right?
So the output is a probability distribution.
We're trying to determine how bad of an answer the neural network is predicting so
that we can give it feedback to get a better answer.
Now let's suppose instead of training or predicting a binary output,
we want to predict a real valued output like any number.
It can take any number plus or minus infinity.
So for example, if you want to predict the grade that you get in a class, right?
It doesn't necessarily need to be between zero and one or zero and 100 even, right?
You could now use a different loss in order to produce that value because
our outputs are no longer a probability distribution, right?
So for example, what you might do here is compute a mean squared error,
mean squared error loss function between your true value or
your true grade of the class and the predicted grade, right?
These are two numbers.
They're not probabilities necessarily.
You compute their difference.
You square it to look at a distance between the two, an absolute distance, right?
Sign doesn't matter.
And then you can minimize this thing, right?
Okay, great, so let's put all of this loss information with this problem of finding
our network weights into a unified problem and
a unified solution to actually train our neural network.
So we know that we want to find a neural network that will solve this problem on
all this data on average, right?
That's how we contextualize this problem earlier in the lectures.
This means effectively that we're trying to solve or
we're trying to find what are the weights for our neural network?
What are this big vector w that we talked about earlier in the lecture?
What is this vector w?
Compute this vector w for me based on all of the data that we have seen, right?
Now, the vector w is also going to determine what is the loss, right?
So given a single vector w, we can compute how bad is this neural network
performing on our data, right?
So what is the loss?
What is this deviation from the ground truth of our network based on where it
should be?
Now, remember that w is just a group of a bunch of numbers, right?
It's a very big list of numbers, a list of weights for
every single layer and every single neuron in our neural network, right?
So it's just a very big list or a vector of weights.
We want to find that vector.
What is that vector based on a lot of data?
That's the problem of training a neural network.
And remember, our loss function is just a simple function of our weights.
If we have only two weights in our neural network, like we saw earlier in the slide,
then we can plot the loss landscape over this two dimensional space, right?
So we have two weights, w1 and w2, and for every single configuration or
setting of those two weights, our loss will have a particular value,
which here we're showing is the height of this graph, right?
So for any w1 and w2, what is the loss?
And what we want to do is find the lowest point.
What is the best loss?
Where, what are the weights such that our loss will be as good as possible?
So the smaller the loss, the better.
So we want to find the lowest point in this graph.
Now, how do we do that, right?
So the way this works is we start somewhere in this space.
We don't know where to start, so let's pick a random place to start, right?
Now, from that place, let's compute what's called the gradient of the landscape
at that particular point.
This is a very local estimate of where is going up, basically.
Where is the slope increasing at my current location, right?
That informs us not only where the slope is increasing, but
more importantly, where the slope is decreasing.
If I negate the direction, if I go in the opposite direction,
I can actually step down into the landscape and change my weights such
that I lower my loss.
So let's take a small step, just a small step in the opposite direction of the part
that's going up.
Let's take a small step going down, and we'll keep repeating this process.
We'll compute a new gradient at that new point, and
it will take another small step, and we'll keep doing this over and over and over
again until we converge at what's called a local minimum, right?
So based on where we started, it may not be a global minimum of everywhere in
this lost landscape, but let's find ourselves now in a local minimum.
And we're guaranteed to actually converge by following this very simple
algorithm at a local minimum.
So let's summarize now this algorithm.
This algorithm is called gradient descent.
Let's summarize it first in pseudo code, and then we'll look at it in actual code
in a second.
So there's a few steps.
The first step is we initialize our location somewhere randomly in this weight space,
right?
We compute the gradient of our loss with respect to our weights, okay?
And then we take a small step in the opposite direction, and
we keep repeating this in a loop over and over and over again.
And we say we'll keep doing this until convergence, right?
Until we stop moving, basically, and
our network basically finds where it's supposed to end up.
We'll talk about this small step, right?
So we're multiplying our gradient by what I keep calling as a small step.
We'll talk about that a bit more, a bit more later part of this lecture.
But for now, let's also very quickly show the analogous part in code as well.
And it mirrors very nicely, right?
So we'll randomly initialize our weights.
This happens every time you train a neural network.
You have to randomly initialize the weights, and then you have a loop, right?
You're showing it without even convergence, right?
We're just going to keep looping forever.
Where we say, okay, we're going to compute the loss at that location.
Compute the gradient, so which way is up?
And then we just negate that gradient, multiply it by some,
what's called learning rate, LR, denote it here.
It's a small step.
And then we take a direction in that small step.
So let's take a deeper look at this term here.
This is called the gradient, right?
This tells us which way is up in that landscape.
And this, again, it tells us even more than that.
It tells us how is our landscape, how is our loss changing as a function of all
of our weights?
But I actually have not told you how to compute this.
So let's talk about that process.
That process is called back propagation.
We'll go through this very, very briefly.
And we'll start with the simplest neural network that's possible, right?
So we already saw the simplest building block, which is a single neuron.
Now let's build the simplest neural network, which is just a one neuron neural
network, right?
So it has one hidden neuron.
It goes from input to hidden neuron to output.
And we want to compute the gradient of our loss with respect to this weight, W2.
Okay, so I'm highlighting it here.
So we have two weights.
Let's compute the gradient first with respect to W2.
And that tells us how much does a small change in W2 affect our loss?
Does our loss go up or down if we move our W2 a little bit in one direction or another?
So let's write out this derivative.
We can start by applying the chain rule backwards from the loss through the output.
And specifically, we can actually decompose this law,
this derivative, this gradient, into two parts, right?
So the first part, we're decomposing it from dj, dW2,
into dj, dY, right, which is our output, multiplied by dY, dW2, right?
This is all possible, right?
It's a chain rule, so I'm just reciting a chain rule here from calculus.
This is possible because Y is only dependent on the previous layer.
And now let's suppose we don't want to do this for W2, but
we want to do it for W1.
We can use the exact same process, right?
But now it's one step further, right?
We'll now replace W2 with W1.
We need to apply the chain rule yet again, once again to decompose the problem further.
And now we propagate our old gradient that we computed for W2,
all the way back one more step to the weight that we're interested in,
which in this case is W1.
And we keep repeating this process over and over again,
propagating these gradients backwards from output to input to compute.
Ultimately, what we want in the end is this derivative of every weight,
so the derivative of our loss with respect to every weight in our neural network.
This tells us how much does a small change in every single weight in our network
affect the loss?
Does our loss go up or down if we change this weight a little bit in this direction
or a little bit in that direction?
Yes?
I think when you use the term neuron, is there a function of the same?
Neuron and perceptron are the same, so typically people say neural network,
which is why a single neuron, it's also gotten popularity.
But originally, a perceptron is the formal term.
The two terms are identical.
Okay, so now we've covered a lot.
So we've covered the forward propagation of information through a neuron,
and through a neural network all the way through.
And we've covered now the back propagation of information to understand how we
should change every single one of those weights in our neural network to improve
our loss.
So that was the back prop algorithm.
In theory, it's actually pretty simple.
It's just a chain rule, right?
There's actually nothing more than just the chain rule.
And the nice part is that deep learning libraries actually do this for you.
So they compute back prop for you.
You don't actually have to implement it yourself, which is very convenient.
But now it's important to touch on, even though the theory is actually not that
complicated for back propagation, let's touch on it now from practice.
Now, thinking a little bit towards your own implementations when you want to
implement these neural networks, what are some insights?
So optimization of neural networks in practice is a completely different story.
It's not straightforward at all.
And in practice, it's very difficult and usually very computationally
intensive to do this back prop algorithm.
So here's an illustration from a paper that came out a few years ago that
actually attempted to visualize a very deep neural network's loss landscape.
So previously, we had that other depiction,
visualization of how a neural network would look in a two dimensional landscape.
Real neural networks are not two dimensional.
There are hundreds or millions or billions of dimensions.
And now, what would those loss landscapes look like?
You can actually try some clever techniques to actually visualize them.
This is one paper that attempted to do that.
And it turns out that they look extremely messy, right?
The important thing is that if you do this algorithm and
you start in a bad place, depending on your neural network,
you may not actually end up in the global solution, right?
So your initialization matters a lot and you need to kind of traverse these local
minimum to try and help you find the global minima.
Or even more than that, you need to construct neural networks that have
lost landscapes that are much more amenable to optimization than this one, right?
So this is a very bad lost landscape.
There are some techniques that we can apply to our neural networks that smooth
out their lost landscape and make them easier to optimize.
So recall that update equation that we talked about earlier with gradient descent, right?
So there is this parameter here that we didn't talk about.
We described this as the little step that you could take, right?
So it's a small number that you multiply with the direction which is your gradient.
It just tells you, okay, I'm not gonna just go all the way in this direction.
I'll just take a small step in this direction.
So in practice, even setting this value, right, it's just one number.
Setting this one number can be rather difficult, right?
If we set the learning rate too small, then the model can get stuck in these local minima, right?
So here it starts and it kind of gets stuck in this local minima.
It converges very slowly even if it doesn't get stuck.
If the learning rate is too large, it can kind of overshoot and
practice it even diverges and explodes and you don't actually ever find any minima.
Now, ideally what we want is to use learning rates that are not too small and not too large.
So they're large enough to basically avoid those local minima, but small enough such
that they won't diverge and they will actually still find their way into the global minima.
So something like this is what you should intuitively have in mind, right?
So something that can overshoot the local minimas but find itself into a better minima
and then finally stabilize itself there.
So how do we actually set these learning rates, right, in practice?
What does that process look like?
Now, idea number one is very basic, right?
It's try a bunch of different learning rates and see what works.
And that's actually not a bad process in practice.
It's one of the processes that people use.
So that's interesting.
But let's see if we can do something smarter than this and
let's see how we can design algorithms that can adapt to the landscapes, right?
So in practice, there's no reason why there should be a single number, right?
Can we have learning rates that adapt to the model, to the data,
to the landscapes, to the gradients that it's seeing around?
So this means that the learning rate may actually increase or
decrease as a function of the gradients in the loss function, right?
How fast we're learning or many other options, right?
There are many different ideas that could be done here.
And in fact, there are many widely used different procedures or
methodologies for setting the learning rate.
And during your labs, we actually encourage you to try out some of these
different ideas for different types of learning rates.
And even play around with what's the effect of increasing or
decreasing your learning rate, you'll see very striking differences.
So a few things, what number one is that it's not a closed space, right?
So there's an infinite, every weight can be plus or minus up to infinity, right?
So even if it was a one dimensional neural network with just one weight,
it's not a closed space.
In practice, it's even worse than that because you have billions of dimensions,
right?
So not only is your space, your support system in one dimension, is it infinite?
But you now have billions of infinite dimensions, right?
Or billions of infinite support spaces.
So it's not something that you can just search every weight, every possible weight
in your configuration, or what is every possible weight that this neural
network could take, and let me test them out.
Because it's not practical to do even for a very small neural network in practice.
So in your labs, you can really try to put all of this information in this picture
into practice, which defines your model, number one, right here.
Defines your optimizer, which previously we denoted as this gradient descent
optimizer here, we're calling it stochastic gradient center SGD.
We'll talk about that more in a second.
And then also note that your optimizer, which here we're calling SGD,
could be any of these adaptive optimizers.
You can swap them out, and you should swap them out.
You should test different things here to see the impact of these different
methods on your training procedure.
And you'll gain very valuable intuition for
the different insights that will come with that as well.
So I want to continue very briefly just for the end of this lecture to talk
about tips for training neural networks in practice, and how we can focus on
this powerful idea of really what's called batching data, right?
Not seeing all of your data, but now talking about a topic called batching.
So to do this, let's very briefly revisit this gradient descent algorithm.
The gradient is actually compute, this gradient computation,
the back prop algorithm.
I mentioned this earlier, it's a very computationally expensive operation.
And it's even worse because we now are, we previously described it in a way where
we would have to compute it over a summation,
over every single data point in our entire data set, right?
That's how we defined it with the loss function.
It's an average over all of our data points,
which means that we're summing over all of our data points, the gradients.
So in most real life problems, this would be completely infeasible to do.
Because our data sets are simply too big, and
the models are too big to compute those gradients on every single iteration.
Remember, this isn't just a one-time thing, right?
It's every single step that you do, you keep taking small steps.
So you keep needing to repeat this process.
So instead, let's define a new gradient descent algorithm called SGD,
stochastic gradient descent.
Instead of computing the gradient over the entire data set,
now let's just pick a single training point and
compute that one training point gradient, right?
The nice thing about that is that it's much easier to compute that gradient, right?
It only needs one point.
And the downside is that it's very noisy.
It's very stochastic since it was computed using just that one example, right?
So you have that trade-off that exists.
So what's the middle ground, right?
The middle ground is to take not one data point and not the full data set,
but a batch of data, right?
So take what's called a mini batch, right?
This could be something in practice like 32 pieces of data as a common batch size.
And this gives us an estimate of the true gradient, right?
So you approximate the gradient by averaging the gradient of these 32 samples.
It's still fast because 32 is much smaller than the size of your entire data set.
But it's pretty quick now, right?
It's still noisy, but it's okay usually in practice because you can still iterate
much faster.
And since B is normally not that large, again,
think of something like in the tens or the hundreds of samples.
It's very fast to compute this in practice compared to regular gradient descent.
And it's also much more accurate compared to stochastic gradient descent.
And the increase in accuracy of this gradient estimation allows us to
converge to our solution significantly faster as well, right?
It's not only about the speed, it's just about the increase in accuracy of those
gradients allows us to get to our solution much faster.
Which ultimately means that we can train much faster as well and we can save compute.
And the other really nice thing about mini batches is that they allow for
parallelizing our computation, right?
And that was a concept that we had talked about earlier in the class as well.
And here's where it's coming in.
We can split up those batches, right?
So those 32 pieces of data, let's say, if our batch size is 32,
we can split them up onto different workers, right?
Different parts of the GPU can tackle those different parts of our data points.
This can allow us to basically achieve even more significant speed ups using
GPU architectures and GPU hardware.
Okay, finally, last topic I wanna talk about before we end this lecture and
move on to lecture number two is overfitting, right?
So overfitting is this idea that is actually not a deep learning
centric problem at all.
It's a problem that exists in all of machine learning, right?
The key problem is that, and the key problem is actually one that
addresses how you can accurately define if your model is
actually capturing your true data set, right?
Or if it's just learning kind of the subtle details that are kind of
spuriously correlating to your data set.
So set differently, let me say it a bit differently now.
So let's say we want to build models that can learn representations, okay?
From our training data that still generalize to brand new unseen test points, right?
That's the real goal here is we wanna teach our model something based on a lot
of training data, but then we don't want it to do well in the training day.
We want it to do well when we deploy it into the real world and
it's seeing things that it has never seen during training.
So the concept of overfitting is exactly addressing that problem.
Overfitting means if your model is doing very well on your training data but
very badly in testing, that means it's overfitting.
It's overfitting to the training data that it saw.
On the other hand, there's also underfitting, right?
On the left hand side, you can see basically not fitting the data enough.
Which means that you're going to achieve very similar performance on your testing
distribution, but both are underperforming the actual capabilities of your system.
Now ideally, you wanna end up somewhere in the middle, which is not too complex,
where you're memorizing all of the nuances in your training data, like on the right.
But you still want to continue to perform well, even based on the brand new data.
So you're not underfitting as well.
So to actually address this problem in neural networks and
the machine learning in general,
there's a few different ways that you should be aware of and how to do it.
Because you'll need to apply them as part of your solutions and
your software labs as well.
So the key concept here is called regularization, right?
Regularization is a technique that you can introduce and
said very simply, all regularization is, is a way to discourage your model from,
from these nuances in your training data from being learned.
That's all it is.
And as we've seen before, it's actually critical for
our models to be able to generalize, you know, not just on training data, but
really what we care about is the testing data.
So the most popular regularization technique,
that's important for you to understand is this very simple idea called dropout.
Let's revisit this picture of a deep neural network that we've been seeing all
lecture, right?
In dropout, our training, during training, what we're going to do is randomly set
some of the activations, right?
These outputs of every single neuron to zero,
which is randomly going to set them to zero with some probability, right?
So let's say 50% is our probability.
That means that we're going to take all of the activation in our neural network.
And with a probability of 50%, before we pass that activation on to the next neuron,
we're just going to set it to zero and not pass on anything.
So effectively, 50% of the neurons are going to be kind of shut down or
killed in a forward pass.
And you're only going to forward pass information with the other 50% of your
neurons.
So this idea is extremely powerful, actually,
because it lowers the capacity of our neural network.
It not only lowers the capacity of our neural network, but
it's dynamically lowering it, because on the next iteration,
we're going to pick a different 50% of neurons that we drop out.
So constantly, the network is going to have to learn to build pathways,
different pathways from input to output, and that it can't rely on any small,
any small part of the features that are present in any part of the training
data set too extensively, right, because it's constantly being forced
to find these different pathways with random probabilities.
So let's drop out.
The second regularization technique is going to be this notion called early
stopping, which is actually something that is model agnostic.
You can apply this to any type of model as long as you have a testing set that you
can play around with.
So the idea here is that we have already a pretty formal mathematical
definition of what it means to overfit, right?
Overfitting is just when our model starts to perform worse on our test set.
That's really all it is, right?
So what if we plot over the course of training?
So x-axis is as we're training the model.
Let's look at the performance on both the training set and the test set.
So in the beginning, you can see that the training set and
the test set are both going down, and they continue to go down.
Which is excellent because it means that our model is getting stronger.
Eventually though, what you'll notice is that the test loss plateaus and
starts to increase.
On the other hand, the training loss,
there's no reason why the training loss should ever need to stop going down, right?
Training losses generally always continue to decay as long as there is
capacity in the neural network to learn those differences, right?
But the important point is that this continues for the rest of training.
And we want to basically, we care about this point right here, right?
This is the really important point because this is where we need to stop training, right?
After this point, this is the happy medium because after this point,
we start to overfit on parts of the data where our training accuracy becomes
actually better than our testing accuracy.
So our testing accuracy is going bad, it's getting worse, but
our training accuracy is still improving, so it means overfitting.
On the other hand, on the left hand side, this is the opposite problem, right?
We have not fully utilized the capacity of our model, and
the testing accuracy can still improve further, right?
This is a very powerful idea, but it's actually extremely easy to implement in
practice because all you really have to do is just monitor the loss of,
over the course of training, right?
And you just have to pick the model where the testing accuracy starts to get worse.
So I'll conclude this lecture by just summarizing three key points that we've
covered in the class so far.
And this is a very jam-packed class, so the entire week is going to be like this.
And today is just the start.
So so far, we've learned the fundamental building blocks of neural networks,
starting all the way from just one neuron, also called a perceptron.
We learned that we can stack these systems on top of each other to create a
hierarchical network.
And how we can mathematically optimize those types of systems.
And then finally, in the very last part of the class, we talked about just
techniques, tips and techniques for actually training and
applying these systems into practice.
Now in the next lecture, we're going to hear from Aava on deep sequence modeling
using RNNs and also a really new and exciting algorithm and
type of model called the transformer, which is built off of this principle of
attention.
You're going to learn about it in the next class.
But let's, for now, just take a brief pause and
let's resume in about five minutes just so we can switch speakers and
Aava can start her presentation.
Okay, thank you.
Thank you.
Thank you.
Thank you.
Thank you.
