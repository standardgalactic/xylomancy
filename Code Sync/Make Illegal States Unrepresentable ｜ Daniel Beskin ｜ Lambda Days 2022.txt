We're here to talk about this great quote up there by Euron Minsky, make illegal states
unrepresentable. And although it sounds quite simple, I find that the consequences of it
are quite profound. But before we actually begin and dive in, let's start with kind of a short
story as an introduction. So it's the middle of the night and you're sleeping peacefully and
suddenly you get a call and you're being informed that the production system is crashing. And after
a few minutes of furious debugging, you find this exception that happens. Someone accessed an empty
optional value. And how can that be? You ask yourself. And so you dig a little deeper and you
find this wonderful code. Someone unwrapped an empty option value. And you read this comment.
This is safe. Registered users always have email. And it's a very nice comment. And the old caps
are stressing the right points. And it's a very reasonable assumption because registered users
should have emails. And the product manager also required that as well. So what went wrong? And
basically what happened is that we entered an illegal state of our system. And it doesn't really
matter how we got there. But these sorts of situations happen all the time. I'm sure most
of you had some experience seeing some error of this kind happening to you. And those things can
be avoided. And I would say they must be avoided because all would like to have a good night's
sleep. But this is what we're here to talk about. How to make these illegal states
unrepresentable. How to make it impossible to create software that enters those illegal states.
So today we're going to discuss this quote. What it actually means. We'll break it down into
smaller parts. Then I'll show some simple techniques to achieve this ideal of making
illegal states unrepresentable. And we'll conclude with seeing what are the sort of benefits that
you might expect to reap in case you actually follow this principle. So this is mostly a beginner
friendly talk. So don't expect some mind-blowing techniques. But I do hope that the perspective
I am about to show is useful even for more experienced developers. So as far as I know,
this quote was created in the context of working on a financial system. So Jaron Minsky
is working on Jane Street. And I can imagine that making illegal states unrepresentable
in a financial system is very, very important because you probably don't want to lose transactions
or money or whatever. So let's dive in and figure out what it means that an illegal state is
unrepresentable and how do we define it. So we'll start with the state. So what is the state of
a program? So imagine your whole application running and take like a single snapshot in time
with all the variables and all your variables, threads, function calls, whatever. So a single
snapshot of your program. So this is an example of such a state. So you have some variable
assignments. You have maybe registers, heap allocations, whatever. Threads are running.
Functions are about to be called. So this is a single state of the system. So obviously,
a real system will have many, many, many states. But for the purposes of this talk,
we're going to kind of zoom out and from the details of registers and threads and like,
and just have like a conceptual picture of the different states of the system. So this is our
program's state space. All the different states, it can find itself in. So but some states are
illegal. That means that if you enter that state, something bad will happen. The program will crash,
an exception will be thrown, maybe a business rule will be violated. But something, whatever it is,
it's something that's bad for your system and something that you would like to avoid.
So of course, what's considered illegal is very context dependent and it depends on
what you care about at the moment and various trade-offs. But let's assume that we can
recognize an illegal state once we see it. And so the picture I'm showing here is that we have
like a huge state space and we have a few legal states. But usually the reality is much worse.
Usually we have a lot of states that are actually illegal. And so hitting them and usually by accident
is just a matter of time. You walk around your kind of state space and just accidentally stumble on
something illegal. And that's quite likely to happen, just like the registered user in the previous
example. So let's zoom in a bit and enter this diagram. So a typical program will probably
be moving between lots of states. Hopefully, and we can assume usually between legal states,
which are okay for a system. But sometimes you'll probably by accident hit an illegal state and
your system might crash or violate some rule or do something bad. And usually if you got
one illegal state, you probably will get another illegal state. And this is not good. And this is
what the sort of things that we would like to avoid in the context of this quote and probably just
in general in programming. So let's zoom in a little more. So as high-level programmers,
we typically don't think about registers and threads and the heap and the like. And as
functional programmers, we typically want to represent as much as possible of our application
as functions. So imagine that this function signature here is some part of your system. You
have some inputs, you have some output, and you would like to analyze what's possible and
impossible here. So what do I mean that an illegal state is representable? It's that there is some
combination of the inputs A, B, C that would get you into an illegal state. Okay? That would mean
that the state is representable. You can find such inputs and you'll get an illegal state
directly in your system. And what we want, what we strive to achieve is to make it impossible
for to find such inputs that would get us into this illegal state. So imagine that it's literally
impossible to write down such inputs that would get you into illegal state that you cannot get
there at all. And all you can do is kind of walk around illegal states and just never worry about
entering the illegal red dots here. And so this should be possible not because you checked and
double-checked your inputs and not because you covered everything with tests, but because you
make it strictly impossible to write down those inputs that would get you into an illegal state.
So that's at least the ideal that we want to reach. And question is whether it's a reachable
idea. Ideal, can you actually do that? And probably the answer is generally no. You probably
can't avoid all illegal states. But I would claim that every step you make in that direction is
a good step and probably is improving your software in some way or dimension.
Also, question is whether it's worth it. I'm going to show you some techniques that you have to
apply to your code. And then maybe there's some costs that might not be worth it. And that's,
again, it can be true that it may be too expensive. But the sort of techniques I'm about to show you
now are quite lightweight. And hopefully the cost-benefit ratio would make them worth it.
And although it's possible to avoid illegal states in pretty much every
paradigm and language, but strongly-typed functional programming is very good at it.
So because types makes it easier to define our state space and functional techniques makes it,
once you define and recognize an illegal state, they make it easier to avoid various illegal states.
Okay. So now that we know what are illegal states, so slide the aggression into something else.
So I'm not sure why this is so, but empirical evidence shows that people really, really like coffee.
I myself don't drink coffee, so I can't really relate. But apparently making coffee is very,
very complicated. And here's a diagram that obviously has lots of different states, and I'm
sure some of them are illegal. And since I don't know much about coffee, I thought maybe it will
be a good idea to use it as kind of an example domain for this talk that we can explore and try
to kind of make more legible for our purposes. So imagine that you're tasked with programming
coffee-making robot. So lots of things can go wrong when you program a robot, I imagine,
especially one that does something as complicated as creating coffee, because coffee drinkers are
very specific about what and how they are willing to drink. So there's a huge state space here,
and lots of things that can go wrong. And we'll just try to tackle small sub-problems
from this domain and see how we can improve what we see. So we start with the simplest part I
could possibly imagine here, ordering coffee. So again, imagine that you are doing this kind of
proof of concept of your robot. You want to show that it can actually do something useful, so
you want to specify how to order a cappuccino, which is, so I hear, a popular drink. So your
users have to specify what kind of milk they want in the cappuccino. And apparently, milk choice is
also a complicated topic, so milk is not some trivial type, but an enumeration of various
options. So after successfully making cappuccino, you think, okay, let's see, it kind of works,
let's add something to our repertoire to make it more interesting. So since you already know
how to do cappuccino, espresso, apparently, according to this picture there, is pretty much
the same thing, but minus the milk. So you make your milk an optional argument in this case,
so that you don't require it anymore, and now if you don't have milk, you make an espresso.
Espresso, if you have milk, you do a cappuccino. And now let's add another one,
latte. So latte is basically, apparently, again, by this diagram, it's just the same as cappuccino,
but with more milk. And so we have a problem. We have an ambiguity. Both cappuccino and latte
require milk. So we have to somehow tell them apart which order are we talking about. So in
order to make it easier to figure out what's going on, we're going to add another enumeration,
the drink type, which will actually tell us what kind of order are we dealing with here. And so we
have kind of three cases for cappuccino, espresso, and latte. And that's a nice way to kind of future
prove ourselves from future drinks that we might want to add, because now we could easily add them
to our enumeration. So that's a nice bonus. And so now that you have some basic drinks and you
know how to make them, you want to show off how your robot can actually do something more complicated.
So you want to do two fancy drinks in this case. So I want to try and do affogato and Irish coffee.
Fortunately, botanary require more ingredients. So we need to add gelato for the affogato and
cream and whisky for Irish coffee. And that's a good place to stop for a moment and take a look
at what we have. So we support five different types of drinks, which is nice. But we have
lots of various optional values. It's completely non-obvious which combinations are actually
legal here. So can I mix milk into my Irish coffee or some such? It's not obvious from the types.
And it's easy to get confused. So let's try to step back for a moment. So what is the issue here?
So this is again kind of a simplified state diagram of what we want to achieve. So we have five legal
states, five states that we actually want to support. So each one corresponding to some drink
that we have in our system. But we also have various combinations that are illegal in some
sense. So for example, espresso with gelato is just redundant because we're just rediscovered
affogato. But some drinkers might be offended. But Irish coffee without whisky is obviously
an illegal state if I ever seen one. So it makes no sense at all. And there are many other states
here that many combinations of various inputs that we can get here that are completely illegal
and make no sense. So let's think more concretely why this is a problem. So suppose we have some
low-level function that actually tells the robot how to prepare the Irish coffee. It has to take
two arguments, cream and whisky, because those are the parameters that we need to specify
for this drink. And imagine that you are trying to actually take an order and prepare the Irish
coffee. So in case you are in the Irish coffee order, you access the cream and whisky and then
prepare Irish coffee. Now, notice that we are accessing optional values. And we are very careful
here. We have a comment that says this is safe. That's probably okay, right? I mean, what could
possibly go wrong? So because it makes no sense to have empty values of cream and whisky in case
someone ordered an Irish coffee. So maybe just in case, because we don't want to be too troubled
with debugging late at night, we'll make it even more explicit. So we will throw a nice exception
that has more information. So it might be nicer to debug. But it's really, really
is impossible. I mean, you can't have Irish coffee without cream and whisky.
And this is sort of an invariant that we are assuming over our code. In this case,
the invariant is quite simple. Irish coffee always has cream and whisky. But nothing is enforcing
this invariant. We're kind of writing comment and have suffered from a wishful thinking that
hopefully nobody will ever break this thing apart. But imagine that in the future, you're
supporting reading orders from JSON files and someone messed up the format and then
something is missing. Who knows? Something can happen. And you can't write tests to cover all
of your flows in your system probably. And even less so, you can't write tests for future flows
that someone might define, that are not defined right now. How can you protect against something
that you don't even know that will exist in your system? And so, and you might be actually
thinking that, okay, I'm very bad at designing data types. And that's why I have this kind of
bad definition of an order. But that may be so. But the thing I'm trying to assert here is not
something that happens in a single step. Usually, it kind of creeps up on you. You start with something
small and gradually it increases, grows, and then becomes this huge thing full of illegal
states that you can really depend on and can't really disentangle from your system. And then
you again enter this space where you have lots of illegal states and nothing to do about it.
But we can do better, a lot better. So,
sorry. So, our problem here is that our type is in a sense too big for our problem. We have,
we define some schema for possible combinations of inputs and it's too big. Our state space
contains lots of things that shouldn't be there. And the algebraic data types are a really good
way and methodology to create types of the right size. Types that can actually fit our domain
in a way that really is exactly what we want and nothing else. So, let's rewrite our data type
as an algebraic data type in this case and some type or an enumeration in Scala syntax now.
So, we're going, instead of writing coffee order where everything is placed in the top level
with all the options, everything possible, we're going to split it up into various cases.
So, we have a first case with Cappuccino. Cappuccino requires milk so it's no longer optional.
We have a case for Espresso which doesn't have any requirements. So, it's just Espresso. We have
the case of Latte which also requires milk but there's no ambiguity anymore because now it's a
separate case and there's no way to confuse one Cappuccino with the other. So, and again,
the argument is no longer optional. And Afogato requires Gelato so this is, again,
a required dependency and we cannot avoid it. And Irish coffee which was our stumbling block
now has a required dependency on Cream and Whiskey and there's no ambiguity anymore.
So, not only that it's now much, much clearer what is going on and what sort of states are
legal here and what is the actionable data that we have and how to access it, it's literally
now impossible to express the legal state I just described previously. So, the legal states in
the previous slide are literally unrepresentable. You can't write down the code that actually
enters those states. So, now we can, for example, when preparing the Irish coffee, we can now safely
pattern match on our order and if it's Irish coffee, we know and the compiler provides us
with access to both Cream and Whiskey and it's definitely there and can be gone and can be missing.
So, we don't need to assume any invariant about our code or code don't have to lie about it in
comments and no exceptions can be thrown here or any other legal states. And if we got to this
point where it better matched than we have Irish coffee, we know for a fact that all requirements
were met and nothing can go wrong in this respect. And this is enforced by the compiler
for every possible floor of our program. So, we don't have to try to cover everything with tests
and it's also enforced there for the future as well because the compiler does the same thing for
all future flows as well. So, we don't have to worry about it again with tests that we cannot
write even. So, the illegal state that I showed before is truly unrepresentable now. You cannot
write it down. It cannot exist in the system. So, algebraic data types are a great tool you can
use to reduce the state space of your problem domain. So, leading to fewer legal states and
making the code generally more comprehensible. And this is done by making every assumption about
your inputs completely explicit. So, in our case, we made every case to correspond to the assumptions
about coffee orders that we have at the moment. And the values are now correct by construction. So,
you cannot build an illegal order anymore because you made it impossible in the type to represent
what is not supposed to be there. And so, once you do that, you're basically turning your flow
into data. So, notice how we no longer have any conditionals. After better matching and figuring
out that we are in the Irish coffee case, that's it. We don't have to do anything else. We don't
have to ask and be hopeful that the cream whiskey are present. It's there. It's accessible. And so,
you don't have to worry about defensively programming against it. And nice bonus in
statically type programming language is where you, for pattern matches, you also have
exhaustivity checking. So, in case someone adds another case or something else is changing,
the compiler will have your back and help you figure out what's missing and what you have to
add there to be able to handle everything correctly. So, you can't forget anything that you need
and can't forget to handle everything. And what's important, the compiler is not providing you with
safe access to all the data that you need. You don't have to assume that it will be present when
it might be not. It will definitely be there and you can't work around it. So, now that you're
basically free from thinking about illegal states and you don't have to engage in defensive
programming all throughout your application. It's not a magical solution. You still have
to kind of get the size of your algebraic data type, right? Because my initial example, the first
coffee order is also an algebraic data type. But that one was too big for our state space. So,
you still have to think. Nobody is getting away from thinking. But still, having this perspective
and having algebraic data types as a tool that you can use to shape your state space is very,
very useful. And so, this is, I think that algebraic data types of all the features of
functional programming is probably the best cost-benefit ratio out there. And if you're using
them consistently all over your system, I think that will be a great improvement to the possible
illegal states that you can or cannot represent. And if I were to start on a deserted island or
something or programming Java, that probably would be the one feature that I would like to have from
functional programming. They're that useful. So, now we're back to our robot. So, let's try to
tackle another scenario. So, successfully defeated the issue of coffee ordering. So, again, apparently
that coffee drinkers have lots and lots of neat picks. For example, you can't just pour any amount
of water on any amount of coffee. Apparently. I don't know why. That would be wrong. So, imagine
that you have some function that does the pouring. So, take some waters, take some grounds and pours
water over the grounds. So, this function can easily lead us to an illegal state. So, you can
just choose the wrong ratio of water and grounds. And there you go. You have a wrong state and a
coffee that was spoiled by too much water or too little water or whatever. So, we can do something
like this. So, we define a new type called tasty ratio. And we only want to allow tasty ratios
in our function. And this seems like that would be kind of better because here we're explicit
about what we actually want to achieve. But not really. Because the definition of tasty ratio is
pretty much the same thing. You just moved, sorry, you just shuffled around your problem into another
place. You still can create tasty ratio instances with the wrong proportion of water and grounds.
And so, although we claim that tasty ratio is a valid input, we do not enforce it in any way. So,
it's again another illegal state that's waiting to happen. And since it can be represented in
our system, most likely someone at some point will create an illegal instance of tasty ratio and
something will be broken. And so, in this case, though, we have so many illegal states because
most combinations of water and grounds will probably be illegal. So, our state space is just
full of illegal states. And just a few small number of possible, comparatively small number of
combinations of water and grounds are actually legal. And what we want to achieve is to only
be able to write down the legal combinations and writing all other combinations completely
impossible. That's our goal. So, basically, what we want is some kind of invariant on tasty ratio
and invariant that tells us that water and grounds are in the right proportion. And we don't want
to be checking it all over the place. We don't want to do defensive programming and kind of
sprinkle our code with e-falses and exceptions and the like. So, ideally, whenever we have an
instance of tasty ratio, it has to be correct and nothing else should be impossible. But unlike
the invariant of the coffee order, which was kind of simple, is that Irish coffee must have cream
and whiskey, this invariant is a bit trickier to get right. And just using algebraic data types,
you probably won't be able to easily enforce it in the types. Correct me if I'm wrong if
you have a way of doing that, but probably not likely and won't be worth it. So, instead,
we're going to use smart constructor. So, smart constructor basically limits the way we can build
instances of our values. So, this is the scholar specific way, but most languages have some
equivalent of this. So, first of all, we mark our constructor as private so we can no longer
instantiate instances of tasty ratio without directly from the constructor. And then we create our own
legal, our own smart constructor that requires that everything is legal. So, the contract of the
make function is that it can take any inputs, but it will only produce a tasty ratio only if the
inputs are actually valid. And nothing else is possible. And this will be the only way to construct
tasty ratios in our program. And so, the logic itself is probably not that complicated. So,
we just verified the right amounts. But this is crucial to get this right. So, this is kind of
the safe kernel that you have in your program that users will now assume is correct and can
rely on in all other places. So, if you got this right, people can rely on this invariant now for
every place where they stumble upon tasty ratio. So, now, after making the smart constructor and
forbidding the creation of tasty ratio without calling the smart constructor, now this function
is safe. It actually does what it promises. You cannot call it with an illegal tasty ratio
because there are no tasty ratios that are illegal in our system. It's just not possible anymore.
So, more generally, smart constructors are a great way of enforcing diverse invariants. So,
we can find many examples. So, in this case, our signature is, again, we have a wishful comment
about something about age and alcohol restrictions. But it's not really an invariant that's enforced
anywhere. Just wishful thinking. But if you apply the correct smart constructor, you can
probably get this type that will enforce it. It's not possible anymore to do the illegal
action of, in this case, pouring whiskey into Irish coffee. And you can have more examples. So,
again, the top signature is always some wishful thinking and a type that doesn't really
represent what we want. And the second is a corrected version where we enforce
something on our type and usually we close it off with a smart constructor so that nobody can access
the illegal states. And notice that we didn't make tasty ratio any smaller by creating the smart
constructor. But we can, we have an illusion that tasty ratio is now a smaller value that doesn't
have illegal states just because we made it impossible to create them. So, we can program as
if the state space really is now smaller and illegal states are unrepresentable. And, again,
it's very important to get the smart constructors right. So, it's a one-time effort which is probably
worth it because you just cover it in one place and then all of your flows can rely on the fact
that the invariant, all the invariants you want are actually enforced. So, smart constructors
are a great way to enforce diverse invariants and with compiler assistance. So, assistance. So,
the moment you got it right, from there on, you know that the compiler won't let anyone bypass
this invariant that you're trying to enforce. And as a bonus, our type signatures are becoming
kind of self-documenting because our types are now representing actual invariants that we care
directly in our code and it's better than comments because they will never go out of date. The
compiler is there to keep everything in check. But we do have to be careful when defining
smart constructors because, as I said, you have to get that function right. And so, unlike algebraic
data types where you are kind of correct by construction, smart constructors are usually
have to do some unsafe work to make sure that everything else is safe. And so, when possible,
if you can represent something with an algebraic data type, that's probably the preferred way.
But when they work, smart constructors are a great tool for excluding illegal states.
So, one last problem to tackle with a robot. So, brewing coffee is, again, no surprise,
a complicated process as well. And let's try to model a small part of brewing coffee. So,
here's one way to kind of model this process. So, we have this kind of imperative interface
that you might expect for operating a robot with a bunch of kind of low-level commands
that can be used for the brewing stage. And assuming that someone actually implemented
this at the robot level, we can write the code for preparing for brewing, not the actual brewing,
but just the preparation. And so, this looks pretty informative. We just call the various
actions in order. Anyone see the bug here? So, disgustingly, we forgot to rinse the filter,
and now our users are going to drink this paper-tasting coffee, and probably we'll just
throw our, quit our robot, and we will lose customers. So, the reputation of the robot depends
on it, and we just messed up a good cup of coffee. But more seriously, this code is very,
very open to potential bugs, that is, illegal states. So, you can forget action just like I
did right now with the filter-insuring. You can mix up the order. You can duplicate actions.
Everything can happen here. It's full of possible illegal states. And if it's possible, we're
most likely to hit it at some point. Maybe a refactoring gone wrong or something else will
can go wrong. And the problem is here that even if we do mix something up, the compiler won't
help us. It doesn't know anything about it. So, just compile fine and just be wrong. So, again,
this is our desired state space. It's quite simple. It doesn't really have many, many things that it
has to do. But, again, our actual code is open to various illegal state transitions that we can
make that we would like to avoid and make them compile time impossible to actually write down.
So, we can improve as well. So, a big part of the problem here of the issue is the imperative
interface. It just tells us the actions we want to perform doesn't have any information, very little
information about the intent of the sanction and the consequences of it. So, if we have a unit return
time of something, it doesn't really tell us much about what did we want to achieve or what
actually happened. So, since so little is reflected in the types, it's not a surprise that the
compiler can't really help us because the compiler works usually with types and that's its way to
support us. And so, the solution will be to become more declarative. So, leaving the imperative
interface behind and trying to make it more declarative. So, we start by just adding expectations.
So, what we aim to achieve on every action. So, for example, the place filter function now
once invoked will return a filter placed value which will correspond to the fact that the filter
was indeed placed. And so on for all the other functions. And we're not done yet. So, we have
another, we do have some various prerequisites. So, there's some ordering that has to go on
here that is otherwise illegal. And so, we're going to define prerequisites as function arguments.
So, placing a filter cannot occur unless the filter was folded before. So, we make the explicit
in our function by requiring an argument that the filter was actually folded. And the same thing
goes for rinsing the filter which can't happen unless the filter was placed and the water was
heated. And the same thing for grounds that if you want to add them, they must be actually ground
and the filter must be rinsed to prevent the bug from before. And so, basically what we were doing
here is we're encoding kind of business rules directly in our signatures. And once we do that,
in turn, it means that code that violates those rules won't even compile. It becomes literally
unrepresentable. And so, we can now implement our prep flow from before. So, instead of having
our implementation returning unit, we now have a more informative, more informative
signature that tells us what actually was achieved during that process. So, after we finished the
prep, water was heated and grounds were actually added. So, there's no avoiding that now. Every
implementation of this code has to do something about it. And so, since our types are so descriptive,
now we gain this ability to kind of follow the types to implement our flow. So, this is very
similar to the code that we had before. But now, we have to press around various outputs from our
actions. So, this code is still incomplete. But the nice thing here is that the compiler now helps
as it tells us, well, you forgot to make sure that you followed the filter before you placed it.
And so, we can fix that. And now, the compiler tells us, okay, but if you want to add grounds,
you have to, you have some prerequisites. So, let's fix that. We have to have coffee ground and
the coffee ground and filter placed. And now, we still have the same bug from before. We still
forgot to rinse the filter. But this time, the compiler will tell us, you forgot to rinse the
filter. So, you have to do that before you can actually add your grounds. And so, we fix that.
And now, the compiler is happy. And we are happy because our clients are happy. So, because we
shared our business rules, business knowledge with the compiler, the compiler was very helpful in
actually enforcing this for us and making it impossible to stray from the right path.
And also notice, so, by making everything more declarative, it's now much easier to figure out
what flows where and what goes in which way. And so, in essence, our function dependencies are
defining requirements and making the flow much more limited in what can or can't happen. And so,
this, for example, opens up opportunities for parallelization. So, if you see that
two functions are independent, you might be able to parallelize them. And the nice thing here is
that the compiler will help you get it right because it knows what can or cannot be parallelized.
But there is something that I didn't specify for the moment. And what are those types? The
water heated and grounds added types and all the rest I just used here. So, I just assumed that
they are there, but I didn't actually specify them. And the answer is I don't care. I literally
don't care about those types. So much so that I can actually represent it in our type signature.
So, brewing prep doesn't really depend on the specific values of all the types of coffee ground
water heated and the like. Why? Because it just passes them around. It doesn't inspect them in
any way. It just passes them around as kind of tokens of security, but it doesn't do anything
else with them. And to make this explicit, we made our brewing prep function parametric. So,
now it takes six type arguments, although sounds scary. But since we don't care about the actual
values, we can do that and everything will just work the same way as before. So, we explicitly
declare the fact that we are invariant and don't care about how those types are specified.
Now, in order for this to work out, the brewing actions interface has to be adapted as well. It
has to be parametric in the same way. But because slide space is kind of limited, I'll abbreviate
for a moment. And so, now brewing actions is going to take the same six type parameters.
And so, now we are kind of consistent. The code looks exactly the same, but now we have type
parameters. You might ask, why would you do that? And the answer is, if you don't care about the
inputs and outputs, if you make them parametric, it leaves you very little space to actually cheat.
So, in case I want to pass the water heated value and have to return it for my signature,
there's no way to obtain a water heated value because from anywhere else other than calling
heat water because I have no idea what the type really is. It's parametric, so I have no information
on how to obtain it. I don't know what it is. So, it's just impossible. And so, in this case,
we're just forced kind of to do the right thing because there's no way to cheat. If it was a
unit or some other kind of simple value, we just could return that. But in this case, we can't
because it's type parameter. And as a nice bonus, this project actually gives us, although it limits
the implementation, which is a good thing, it does give us various flexibility degrees of freedom
when creating brewing actions because the type parameters can be set to whatever we actually
want in brewing actions and still use unit. And maybe we can use something more informative
in tests. And so, this gives us actual, the limitation on this side actually gives us more
flexibility in other places, which is a nice bonus, but it's not directly related to what we're
doing here. But the point is that the brewing prep doesn't care about how those inputs work,
and so we can limit it completely to using them correctly. And so, I will point out that this
code doesn't prevent every legal state possible. So, for example, nothing stops us from calling
fault filter twice. That might be illegal. And in general, it's not always possible to limit
every possible legal state, but it's better to get something right than nothing. So, I do think
it's an improvement. So, being declarative is a great way to encode your business rules
directly in your types. That way, the compiler can help you enforce those rules and making every
breakage of the encoded rules impossible at compile time, and thus, it's unrepresentable.
And the good first step when trying to do things more declaratively is figure out where you have
those redundant units that don't communicate any information about what the function does,
and then try to see how you can solve it. And by making everything parametric,
our code is becoming ignorant of the actual types that we use, which limits the number of
possible illegal states that we can enter. So, the less the code can do, the more we know about
what it actually does. So, ignorance is strength, like the famous quote. Okay. So, we're done kind
of with the various techniques. It might not be obvious from those two examples, like why would
that be useful? Because they're all small examples and kind of hard to see how they work out in a
large code base that you have to maintain for a long time. My point is that all of this kind of
adds up, and eventually, it does make your code better in the long run, even if it's not obvious
from the first small steps. But in this section, we'll just kind of quickly review what sort of
benefits you can expect to reap from being consistent and making illegal states as unrepresentable
as you can in your code base. So, the first point is that code becomes easier to comprehend. So,
as I just mentioned, the fewer things the code can do, the easier it is to understand what it
actually does. But more concretely, for example, if you use algebraic data types consistently
across your code base, the compiler can help you figure out what's happening now. You do
a better match. Some editors would actually autocomplete all the cases, and you can now
figure out what's going on, what information you have, what can you use and the like, and the
compiler got your back. Not only that, it can also, as I mentioned, automatically do
accessibility checking, so you're sure to not forget anything in case anything changes.
And so, this is definitely an improvement on your ability to figure out what's going on.
And also, a common theme throughout the examples is that our type signatures are becoming more
and more informative. They encode more and more information about what's going on. So,
just by reading the signatures, it becomes easier to figure out what are the limitations,
what is allowed, what is disallowed, and the like. Fewer bugs. So, every legal state that you
precluded and made an unrepresentable is a potential bug that you avoided. So, for example,
creating an Irish coffee order without whiskey is no longer possible. It's not a state that you
can write. This is a compilation error. Nor this, like serving coffee and to an empty list of cups.
Again, this is no longer possible because you enforced it at compile time, and this is a bug,
again, that cannot happen anymore. And since they're unrepresentable, you don't have to test
for them a lot. So, this is our next point, is that you can do fewer, if you make as many
legal states unrepresentable as possible, this leads to fewer tests that you actually have to
write. For example, this test can't be expressed. Again, testing whether our Irish coffee order
has whiskey is no longer relevant because, again, even the test can't even compile. So, that's a
test that you don't have to write. And some tests, for example, are still possible to write, but
maybe more redundant because you don't really need, if your interface is sufficiently declarative,
it might be kind of obvious on its own that you don't have to check whether water was heated or not
when you done the brewing prep because the types are requiring that. And the last point is safer
refactoring. So, your code becomes much easier to refactor. For example, this code, the get calls
on the optional values are only safe somewhat in the case that you're ordering Irish coffee. But
imagine that you're doing refactor and now the prepare Irish coffee call moves to another place.
Now it's in some other place and nothing is actually checking whether we're in the right
case. So, this is no longer safe. On the other hand, this code with the pattern match is safe by
construction. If you try to move the call to prepare Irish coffee, the code will fail to compile
because it will no longer have the references to the right information that it needs. And another
refactoring is if you add something, for example, again, the compiler will verify that you matched
all the various types, all the various cases that you have and will enforce again that you don't
forget anything. Another example of refactoring is I mentioned in the previous section that we can
paralyze some actions here. So, we can, for example, heat water, grind coffee and the rest
are, can be paralyzed because they have no dependencies. So, this is a refactoring that
is easy to get wrong because if you mess something up, things will run in parallel when they shouldn't
and in the bad example, that would be just broken. But here we can write this code and if we mess
something up, the compiler will tell us, you're missing some dependencies. You can't run this
in parallel. So, as people work and maintain large code bases, I think those benefits kind of add
up and the investment that you're making on making legal states unrepresentable is definitely,
definitely worth the effort. So, to conclude, almost done. So, whenever you tackle a new domain,
try to think about the state space of your problem, the various states that the system can arrive at
and what can happen. Find the legal states in your system and define them to match your
requirements or whatever other error conditions that you might care about. And all the other states
are illegal. Now, if all you do is just think, just sit there and think about your state space
in the legal and illegal state, that's already a great first step. You don't have to do anything
else. That's already a good way of getting your code to be better just by knowing what's possible
and impossible. But if you actually want to reap the benefits from this talk, make those states
unrepresentable. And the benefits are fewer bugs, fewer tests, easier to comprehend code,
and you don't have to worry anymore about states that are illegal because you made them unrepresentable,
so you don't have to think about them anymore. And that's a great thing to do. When you don't
have to think about something, you can think about something else, which might be useful.
And so we saw a number of techniques to achieve this goal, so algebraic data types help us
reduce the state space into something smaller and more manageable. Smart constructors let
us enforce diverse invariants and declarative signatures make various business rules kind
of apparent in our code. And parametric polymphism is like a nice cherry on top if you want to really
kind of go at it even more limited. So there's a slide about where to go next. So I covered some
very basic techniques. There are other approaches that you can take, which probably have a steeper
cost-benefit ratio, so it might be not worth it. But these are some ideas of what you can think of,
especially various type systems. So a lot of the things we've done are kind of bound by the type
system that we're using. And so maybe trying other more advanced type systems or type system
features can help you make things easier if you're taking it. I'll post the link to the
slides so everything is there. And there's some inspiration for various resources that I think
are kind of useful in thinking about problems. And again, I'll post the link for the presentation.
All the links will be available. So it's my time to wrap up. So remember our poor little user that
was trying to register and didn't have an email. So somewhere someone is trying to introduce another
bug in our system. But luckily we applied all the techniques that we studied right now and it no
longer compiles. The illegal states is unrepresentable. The compiler still tells us that and we can
sleep quietly tonight. So hopefully I managed to convince you that making legal states unrepresentable
is actually worth the effort. And this is linked to the presentation. And if I have time for questions,
I'm not sure. Yes, we can try to take one online question first, maybe.
Can you please read it out for our audience? I guess you're in favor of using something like
refined to express even more constraints in types instead of custom smart constructors. Yes,
one of the last slides I used refined as there's a link to the refined library here in the end. So
yes, refined is a nice library that can help you automate the process of creating smart constructors
instead of writing them manually by hand. You can use a library that helps with that.
All right. Thank you. We have also one question here on site.
Hi. So thanks for the great talk. In the example about algebraic data types.
It was with the example of ordering different types of coffee, but what happens if the coffee
shop owners have a business requirement that at any point of time she wants to be able to add a
new type of the coffee? So what happens to our algebraic data types with such a requirement?
So there's often kind of people debating whether types are useful or not or kind of this conception
that you have to go all in or nothing. So either you specify everything and everything is fixed
in types or not. This is not the case. If you want some flexibility, you can live that measure
of flexibility as your requirements desire. So in the case of maybe having another case which is
more dynamically defined, maybe have another case which is dynamic. And then you'll be extra
careful around that case. But still you now have a small island of sanity where you know what's
going on and another section of the code which is not as pleasant and safe. But still you can
separate the parts. What you know you can encode. What you don't, leave it as an unknown and handle
it appropriately. Okay. Thank you. We have one more online question. If you could again please read
it out. So only recently I started learning Haskell and Idris from the perspective of making
illegal states not representable. It seems to me that type-driven development
advocated by Idris is more suitable. Then again, I'm a beginner. So yes, Haskell and Idris both
have various advanced type-level features and things you can do that make it possible to exclude
even more illegal states. And as I mentioned, using more advanced type systems is a good way
to enforce more invariance. But the question is kind of the cost, whether it's worth it,
especially as a beginner, because if you play something very, very kind of a heavy tool that
does something very sophisticated, it might be more difficult to maintain. So I think you
should kind of gradually ramp up there and eventually maybe use it, but have a good way
to judge whether it's worth it or not. So start simple and then gradually improve.
All the things I did mention now are available in both Haskell and Idris. So that's not actually
a problem and you can start there and move on to something more advanced. Okay. We have time for
one last onsite question here. Thanks for a great talk. I'm wondering if any of the techniques that
you mentioned are applicable in dynamically checked languages and if you have an experience in doing
so, maybe? So in dynamically typed languages, everything is applicable. You can write anything.
The question is whether who enforces things for you. So in a statically typed language,
the compiler is much more your friend than people usually think. And then in dynamically typed
language, first of all, just thinking about the state space, you can do it in any language on a
piece of paper. It doesn't really matter and it's already an improvement. And then if you are explicit
about what's illegal, at least you can force your invariance even in a dynamic context. For
example, your smart constructor won't return an optional value but will throw an exception. But
at least you limited the scope of where things can go wrong, for example. And pattern matching
is available in various languages. Although there are no, the guarantees might be somewhat looser,
but still it's better than nothing. So those approaches can help you, but they won't gain
you as much benefit as they are in a statically typed language, I think.
All right. Thank you very much, Daniel. Please help me thank him.
